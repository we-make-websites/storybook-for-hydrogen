diff --git a/dist/dist/esnext/FileSessionStorage.d.ts b/dist/dist/esnext/FileSessionStorage.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7841fb64efe07de29a381a176aa39cbafc15a457
--- /dev/null
+++ b/dist/dist/esnext/FileSessionStorage.d.ts
@@ -0,0 +1 @@
+export { FileSessionStorage } from './foundation/FileSessionStorage/FileSessionStorage.js';
diff --git a/dist/dist/esnext/FileSessionStorage.js b/dist/dist/esnext/FileSessionStorage.js
new file mode 100644
index 0000000000000000000000000000000000000000..7841fb64efe07de29a381a176aa39cbafc15a457
--- /dev/null
+++ b/dist/dist/esnext/FileSessionStorage.js
@@ -0,0 +1 @@
+export { FileSessionStorage } from './foundation/FileSessionStorage/FileSessionStorage.js';
diff --git a/dist/dist/esnext/client.d.ts b/dist/dist/esnext/client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fc43880b6e4389b4469e71b4ec299df27adc79a2
--- /dev/null
+++ b/dist/dist/esnext/client.d.ts
@@ -0,0 +1,16 @@
+export * from './components/index.js';
+export * from './hooks/index.js';
+export { useServerProps } from './foundation/useServerProps/index.js';
+export { useShop } from './foundation/useShop/index.js';
+export { ServerPropsProvider, ServerPropsContext, type ServerProps, type ServerPropsContextValue, } from './foundation/ServerPropsProvider/index.js';
+export { useUrl } from './foundation/useUrl/index.js';
+export { Head } from './foundation/Head/index.js';
+export * from './utilities/index.js';
+export { gql } from './utilities/graphql-tag.js';
+export { ClientAnalytics } from './foundation/Analytics/index.js';
+export { useRouteParams } from './foundation/useRouteParams/useRouteParams.js';
+export { useNavigate } from './foundation/useNavigate/useNavigate.js';
+export { fetchSync } from './foundation/fetchSync/client/fetchSync.js';
+export { suspendFunction, preloadFunction } from './utilities/suspense.js';
+export { PerformanceMetrics } from './foundation/Analytics/connectors/PerformanceMetrics/PerformanceMetrics.client.js';
+export { PerformanceMetricsDebug } from './foundation/Analytics/connectors/PerformanceMetrics/PerformanceMetricsDebug.client.js';
diff --git a/dist/dist/esnext/client.js b/dist/dist/esnext/client.js
new file mode 100644
index 0000000000000000000000000000000000000000..5038be5a3bfa91ebf5292dfa5efa26372edc5f25
--- /dev/null
+++ b/dist/dist/esnext/client.js
@@ -0,0 +1,16 @@
+export * from './components/index.js';
+export * from './hooks/index.js';
+export { useServerProps } from './foundation/useServerProps/index.js';
+export { useShop } from './foundation/useShop/index.js';
+export { ServerPropsProvider, ServerPropsContext, } from './foundation/ServerPropsProvider/index.js';
+export { useUrl } from './foundation/useUrl/index.js';
+export { Head } from './foundation/Head/index.js';
+export * from './utilities/index.js';
+export { gql } from './utilities/graphql-tag.js';
+export { ClientAnalytics } from './foundation/Analytics/index.js';
+export { useRouteParams } from './foundation/useRouteParams/useRouteParams.js';
+export { useNavigate } from './foundation/useNavigate/useNavigate.js';
+export { fetchSync } from './foundation/fetchSync/client/fetchSync.js';
+export { suspendFunction, preloadFunction } from './utilities/suspense.js';
+export { PerformanceMetrics } from './foundation/Analytics/connectors/PerformanceMetrics/PerformanceMetrics.client.js';
+export { PerformanceMetricsDebug } from './foundation/Analytics/connectors/PerformanceMetrics/PerformanceMetricsDebug.client.js';
diff --git a/dist/dist/esnext/components/AddToCartButton/AddToCartButton.client.d.ts b/dist/dist/esnext/components/AddToCartButton/AddToCartButton.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ad894998ff44c0a0f28393a3c70580c63d9059ef
--- /dev/null
+++ b/dist/dist/esnext/components/AddToCartButton/AddToCartButton.client.d.ts
@@ -0,0 +1,23 @@
+import React from 'react';
+import { BaseButtonProps } from '../BaseButton/index.js';
+interface AddToCartButtonProps {
+    /** An array of cart line attributes that belong to the item being added to the cart. */
+    attributes?: {
+        key: string;
+        value: string;
+    }[];
+    /** The ID of the variant. */
+    variantId?: string | null;
+    /** The item quantity. */
+    quantity?: number;
+    /** The text that is announced by the screen reader when the item is being added to the cart. Used for accessibility purposes only and not displayed on the page. */
+    accessibleAddingToCartLabel?: string;
+    /** The selling plan ID of the subscription variant */
+    sellingPlanId?: string;
+}
+/**
+ * The `AddToCartButton` component renders a button that adds an item to the cart when pressed.
+ * It must be a descendent of the `CartProvider` component.
+ */
+export declare function AddToCartButton<AsType extends React.ElementType = 'button'>(props: AddToCartButtonProps & BaseButtonProps<AsType>): JSX.Element;
+export {};
diff --git a/dist/dist/esnext/components/AddToCartButton/AddToCartButton.client.js b/dist/dist/esnext/components/AddToCartButton/AddToCartButton.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..908f45cd281a5e95ffa9e491afe6ac50926ccb6b
--- /dev/null
+++ b/dist/dist/esnext/components/AddToCartButton/AddToCartButton.client.js
@@ -0,0 +1,49 @@
+import React, { useCallback, useEffect, useState } from 'react';
+import { useCart } from '../CartProvider/index.js';
+import { useProductOptions } from '../../hooks/useProductOptions/index.js';
+import { BaseButton } from '../BaseButton/index.js';
+/**
+ * The `AddToCartButton` component renders a button that adds an item to the cart when pressed.
+ * It must be a descendent of the `CartProvider` component.
+ */
+export function AddToCartButton(props) {
+    const [addingItem, setAddingItem] = useState(false);
+    const { variantId: explicitVariantId, quantity = 1, attributes, sellingPlanId, onClick, children, accessibleAddingToCartLabel, ...passthroughProps } = props;
+    const { status, linesAdd } = useCart();
+    const { selectedVariant } = useProductOptions();
+    const variantId = explicitVariantId ?? selectedVariant?.id ?? '';
+    const disabled = explicitVariantId === null ||
+        variantId === '' ||
+        selectedVariant === null ||
+        addingItem ||
+        passthroughProps.disabled;
+    useEffect(() => {
+        if (addingItem && status === 'idle') {
+            setAddingItem(false);
+        }
+    }, [status, addingItem]);
+    const handleAddItem = useCallback(() => {
+        setAddingItem(true);
+        linesAdd([
+            {
+                quantity,
+                merchandiseId: variantId,
+                attributes,
+                sellingPlanId,
+            },
+        ]);
+    }, [linesAdd, quantity, variantId, attributes, sellingPlanId]);
+    return (React.createElement(React.Fragment, null,
+        React.createElement(BaseButton, { ...passthroughProps, disabled: disabled, onClick: onClick, defaultOnClick: handleAddItem }, children),
+        accessibleAddingToCartLabel ? (React.createElement("p", { style: {
+                position: 'absolute',
+                width: '1px',
+                height: '1px',
+                padding: '0',
+                margin: '-1px',
+                overflow: 'hidden',
+                clip: 'rect(0, 0, 0, 0)',
+                whiteSpace: 'nowrap',
+                borderWidth: '0',
+            }, role: "alert", "aria-live": "assertive" }, addingItem ? accessibleAddingToCartLabel : null)) : null));
+}
diff --git a/dist/dist/esnext/components/AddToCartButton/index.d.ts b/dist/dist/esnext/components/AddToCartButton/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e0bf95cf75d8010ec92d786fa65508d47f4fe5b7
--- /dev/null
+++ b/dist/dist/esnext/components/AddToCartButton/index.d.ts
@@ -0,0 +1 @@
+export { AddToCartButton } from './AddToCartButton.client.js';
diff --git a/dist/dist/esnext/components/AddToCartButton/index.js b/dist/dist/esnext/components/AddToCartButton/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..e0bf95cf75d8010ec92d786fa65508d47f4fe5b7
--- /dev/null
+++ b/dist/dist/esnext/components/AddToCartButton/index.js
@@ -0,0 +1 @@
+export { AddToCartButton } from './AddToCartButton.client.js';
diff --git a/dist/dist/esnext/components/BaseButton/BaseButton.client.d.ts b/dist/dist/esnext/components/BaseButton/BaseButton.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b4da476dd4fda878889b918444fe566fddbf5406
--- /dev/null
+++ b/dist/dist/esnext/components/BaseButton/BaseButton.client.d.ts
@@ -0,0 +1,16 @@
+import React, { ReactNode, Ref } from 'react';
+export interface CustomBaseButtonProps<AsType> {
+    /** Provide a React element or component to render as the underlying button. Note: for accessibility compliance, almost always you should use a `button` element, or a component that renders an underlying button. */
+    as?: AsType;
+    /** Any ReactNode elements. */
+    children: ReactNode;
+    /** Click event handler. Default behaviour triggers unless prevented */
+    onClick?: (event?: React.MouseEvent<HTMLButtonElement, MouseEvent>) => void | boolean;
+    /** A default onClick behavior */
+    defaultOnClick?: (event?: React.MouseEvent<HTMLButtonElement, MouseEvent>) => void | boolean;
+    /** A ref to the underlying button */
+    buttonRef?: Ref<HTMLButtonElement>;
+    disabled?: boolean;
+}
+export declare type BaseButtonProps<AsType extends React.ElementType> = CustomBaseButtonProps<AsType> & Omit<React.ComponentPropsWithoutRef<AsType>, keyof CustomBaseButtonProps<AsType>>;
+export declare function BaseButton<AsType extends React.ElementType = 'button'>(props: BaseButtonProps<AsType>): JSX.Element;
diff --git a/dist/dist/esnext/components/BaseButton/BaseButton.client.js b/dist/dist/esnext/components/BaseButton/BaseButton.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..0644196310a0052abcb6deffbb0acdb98122dc3f
--- /dev/null
+++ b/dist/dist/esnext/components/BaseButton/BaseButton.client.js
@@ -0,0 +1,16 @@
+import React, { useCallback } from 'react';
+export function BaseButton(props) {
+    const { as, onClick, defaultOnClick, children, buttonRef, ...passthroughProps } = props;
+    const handleOnClick = useCallback((event) => {
+        if (onClick) {
+            const clickShouldContinue = onClick(event);
+            if ((typeof clickShouldContinue === 'boolean' &&
+                clickShouldContinue === false) ||
+                event?.defaultPrevented)
+                return;
+        }
+        defaultOnClick?.(event);
+    }, [defaultOnClick, onClick]);
+    const Component = as || 'button';
+    return (React.createElement(Component, { ref: buttonRef, onClick: handleOnClick, ...passthroughProps }, children));
+}
diff --git a/dist/dist/esnext/components/BaseButton/index.d.ts b/dist/dist/esnext/components/BaseButton/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..49ba9eb816a921e9f1ab40385872115773090923
--- /dev/null
+++ b/dist/dist/esnext/components/BaseButton/index.d.ts
@@ -0,0 +1 @@
+export { BaseButton, BaseButtonProps } from './BaseButton.client.js';
diff --git a/dist/dist/esnext/components/BaseButton/index.js b/dist/dist/esnext/components/BaseButton/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..f9a5873c3b7066318fd7793e7297a31247b612d5
--- /dev/null
+++ b/dist/dist/esnext/components/BaseButton/index.js
@@ -0,0 +1 @@
+export { BaseButton } from './BaseButton.client.js';
diff --git a/dist/dist/esnext/components/BuyNowButton/BuyNowButton.client.d.ts b/dist/dist/esnext/components/BuyNowButton/BuyNowButton.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b29fd3966ca32fe1317e047836a4c94976dbeced
--- /dev/null
+++ b/dist/dist/esnext/components/BuyNowButton/BuyNowButton.client.d.ts
@@ -0,0 +1,16 @@
+import React from 'react';
+import { BaseButtonProps } from '../BaseButton/index.js';
+interface BuyNowButtonProps {
+    /** The item quantity. Defaults to 1. */
+    quantity?: number;
+    /** The ID of the variant. */
+    variantId: string;
+    /** An array of cart line attributes that belong to the item being added to the cart. */
+    attributes?: {
+        key: string;
+        value: string;
+    }[];
+}
+/** The `BuyNowButton` component renders a button that adds an item to the cart and redirects the customer to checkout. */
+export declare function BuyNowButton<AsType extends React.ElementType = 'button'>(props: BuyNowButtonProps & BaseButtonProps<AsType>): JSX.Element;
+export {};
diff --git a/dist/dist/esnext/components/BuyNowButton/BuyNowButton.client.js b/dist/dist/esnext/components/BuyNowButton/BuyNowButton.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..f0fae52835c239d5ee3568892c09940dd3dc1c7f
--- /dev/null
+++ b/dist/dist/esnext/components/BuyNowButton/BuyNowButton.client.js
@@ -0,0 +1,27 @@
+import React, { useEffect, useState, useCallback } from 'react';
+import { useInstantCheckout } from '../CartProvider/index.js';
+import { BaseButton } from '../BaseButton/index.js';
+/** The `BuyNowButton` component renders a button that adds an item to the cart and redirects the customer to checkout. */
+export function BuyNowButton(props) {
+    const { createInstantCheckout, checkoutUrl } = useInstantCheckout();
+    const [loading, setLoading] = useState(false);
+    const { quantity, variantId, onClick, attributes, children, ...passthroughProps } = props;
+    useEffect(() => {
+        if (checkoutUrl) {
+            window.location.href = checkoutUrl;
+        }
+    }, [checkoutUrl]);
+    const handleBuyNow = useCallback(() => {
+        setLoading(true);
+        createInstantCheckout({
+            lines: [
+                {
+                    quantity: quantity ?? 1,
+                    merchandiseId: variantId,
+                    attributes,
+                },
+            ],
+        });
+    }, [createInstantCheckout, quantity, variantId, attributes]);
+    return (React.createElement(BaseButton, { disabled: loading ?? passthroughProps.disabled, ...passthroughProps, onClick: onClick, defaultOnClick: handleBuyNow }, children));
+}
diff --git a/dist/dist/esnext/components/BuyNowButton/index.d.ts b/dist/dist/esnext/components/BuyNowButton/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a979364f08ec31bd61b6415b7703eed8205d1834
--- /dev/null
+++ b/dist/dist/esnext/components/BuyNowButton/index.d.ts
@@ -0,0 +1 @@
+export { BuyNowButton } from './BuyNowButton.client.js';
diff --git a/dist/dist/esnext/components/BuyNowButton/index.js b/dist/dist/esnext/components/BuyNowButton/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..a979364f08ec31bd61b6415b7703eed8205d1834
--- /dev/null
+++ b/dist/dist/esnext/components/BuyNowButton/index.js
@@ -0,0 +1 @@
+export { BuyNowButton } from './BuyNowButton.client.js';
diff --git a/dist/dist/esnext/components/CartCheckoutButton/CartCheckoutButton.client.d.ts b/dist/dist/esnext/components/CartCheckoutButton/CartCheckoutButton.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..056445c1bdcfa42f8c47c20e61a2bd707f40b8b6
--- /dev/null
+++ b/dist/dist/esnext/components/CartCheckoutButton/CartCheckoutButton.client.d.ts
@@ -0,0 +1,11 @@
+import { ReactNode } from 'react';
+declare type PropsWeControl = 'onClick';
+/**
+ * The `CartCheckoutButton` component renders a button that redirects to the checkout URL for the cart.
+ * It must be a descendent of a `CartProvider` component.
+ */
+export declare function CartCheckoutButton(props: Omit<JSX.IntrinsicElements['button'], PropsWeControl> & {
+    /** A `ReactNode` element. */
+    children: ReactNode;
+}): JSX.Element;
+export {};
diff --git a/dist/dist/esnext/components/CartCheckoutButton/CartCheckoutButton.client.js b/dist/dist/esnext/components/CartCheckoutButton/CartCheckoutButton.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..b57ebf297175d230f8dd1cedc3ebe7bf4137e371
--- /dev/null
+++ b/dist/dist/esnext/components/CartCheckoutButton/CartCheckoutButton.client.js
@@ -0,0 +1,17 @@
+import React, { useEffect, useState } from 'react';
+import { useCart } from '../CartProvider/index.js';
+/**
+ * The `CartCheckoutButton` component renders a button that redirects to the checkout URL for the cart.
+ * It must be a descendent of a `CartProvider` component.
+ */
+export function CartCheckoutButton(props) {
+    const [requestedCheckout, setRequestedCheckout] = useState(false);
+    const { status, checkoutUrl } = useCart();
+    const { children, ...passthroughProps } = props;
+    useEffect(() => {
+        if (requestedCheckout && checkoutUrl && status === 'idle') {
+            window.location.href = checkoutUrl;
+        }
+    }, [requestedCheckout, status, checkoutUrl]);
+    return (React.createElement("button", { ...passthroughProps, disabled: requestedCheckout || passthroughProps.disabled, onClick: () => setRequestedCheckout(true) }, children));
+}
diff --git a/dist/dist/esnext/components/CartCheckoutButton/index.d.ts b/dist/dist/esnext/components/CartCheckoutButton/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b704901db57536b2af18020d6e49e8fe096b5ced
--- /dev/null
+++ b/dist/dist/esnext/components/CartCheckoutButton/index.d.ts
@@ -0,0 +1 @@
+export { CartCheckoutButton } from './CartCheckoutButton.client.js';
diff --git a/dist/dist/esnext/components/CartCheckoutButton/index.js b/dist/dist/esnext/components/CartCheckoutButton/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..b704901db57536b2af18020d6e49e8fe096b5ced
--- /dev/null
+++ b/dist/dist/esnext/components/CartCheckoutButton/index.js
@@ -0,0 +1 @@
+export { CartCheckoutButton } from './CartCheckoutButton.client.js';
diff --git a/dist/dist/esnext/components/CartCost/CartCost.client.d.ts b/dist/dist/esnext/components/CartCost/CartCost.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dfb0ddc330279a7f495a06ddf7c35fccd96363fc
--- /dev/null
+++ b/dist/dist/esnext/components/CartCost/CartCost.client.d.ts
@@ -0,0 +1,14 @@
+import React from 'react';
+import { Money } from '../Money/index.js';
+export interface CartCostProps {
+    /** A string type that defines the type of cost needed. Valid values: `total`, `subtotal`, `tax`, or `duty`. */
+    amountType?: 'total' | 'subtotal' | 'tax' | 'duty';
+    /** A function that takes an object return by the `useMoney` hook and returns a `ReactNode`. */
+    children?: React.ReactNode;
+}
+/**
+ * The `CartCost` component renders a `Money` component with the
+ * cost associated with the `amountType` prop. If no `amountType` prop is specified, then it defaults to `totalAmount`.
+ * If `children` is a function, then it will pass down the render props provided by the parent component.
+ */
+export declare function CartCost(props: Omit<React.ComponentProps<typeof Money>, 'data'> & CartCostProps): JSX.Element | null;
diff --git a/dist/dist/esnext/components/CartCost/CartCost.client.js b/dist/dist/esnext/components/CartCost/CartCost.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..96246ecb3ea1132b7dbc2d346019fcc477084530
--- /dev/null
+++ b/dist/dist/esnext/components/CartCost/CartCost.client.js
@@ -0,0 +1,29 @@
+import React from 'react';
+import { useCart } from '../CartProvider/index.js';
+import { Money } from '../Money/index.js';
+/**
+ * The `CartCost` component renders a `Money` component with the
+ * cost associated with the `amountType` prop. If no `amountType` prop is specified, then it defaults to `totalAmount`.
+ * If `children` is a function, then it will pass down the render props provided by the parent component.
+ */
+export function CartCost(props) {
+    const { cost } = useCart();
+    const { amountType = 'total', children, ...passthroughProps } = props;
+    let amount;
+    if (amountType == 'total') {
+        amount = cost?.totalAmount;
+    }
+    else if (amountType == 'subtotal') {
+        amount = cost?.subtotalAmount;
+    }
+    else if (amountType == 'tax') {
+        amount = cost?.totalTaxAmount;
+    }
+    else if (amountType == 'duty') {
+        amount = cost?.totalDutyAmount;
+    }
+    if (amount == null) {
+        return null;
+    }
+    return (React.createElement(Money, { ...passthroughProps, data: amount }, children));
+}
diff --git a/dist/dist/esnext/components/CartCost/index.d.ts b/dist/dist/esnext/components/CartCost/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fe26e4c64853f456c89c8ecc87265ba737f220c0
--- /dev/null
+++ b/dist/dist/esnext/components/CartCost/index.d.ts
@@ -0,0 +1 @@
+export { CartCost } from './CartCost.client.js';
diff --git a/dist/dist/esnext/components/CartCost/index.js b/dist/dist/esnext/components/CartCost/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..fe26e4c64853f456c89c8ecc87265ba737f220c0
--- /dev/null
+++ b/dist/dist/esnext/components/CartCost/index.js
@@ -0,0 +1 @@
+export { CartCost } from './CartCost.client.js';
diff --git a/dist/dist/esnext/components/CartLineImage/CartLineImage.client.d.ts b/dist/dist/esnext/components/CartLineImage/CartLineImage.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c803870cdaac0e2f8a946bc740e74563b4b8a139
--- /dev/null
+++ b/dist/dist/esnext/components/CartLineImage/CartLineImage.client.d.ts
@@ -0,0 +1,9 @@
+import { type ShopifyImageProps } from '../Image/index.js';
+import type { Simplify } from 'type-fest';
+declare type PropsWeControl = 'data';
+/**
+ * The `CartLineImage` component renders an `Image` component for the cart line merchandise's image.
+ * It must be a descendent of a `CartLineProvider` component.
+ */
+export declare function CartLineImage(props: Simplify<Omit<ShopifyImageProps, PropsWeControl>>): JSX.Element | null;
+export {};
diff --git a/dist/dist/esnext/components/CartLineImage/CartLineImage.client.js b/dist/dist/esnext/components/CartLineImage/CartLineImage.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..a756eb127a104c463ff975ffc534d038679a27b6
--- /dev/null
+++ b/dist/dist/esnext/components/CartLineImage/CartLineImage.client.js
@@ -0,0 +1,11 @@
+import React from 'react';
+import { useCartLine } from '../CartLineProvider/index.js';
+import { Image } from '../Image/index.js';
+/**
+ * The `CartLineImage` component renders an `Image` component for the cart line merchandise's image.
+ * It must be a descendent of a `CartLineProvider` component.
+ */
+export function CartLineImage(props) {
+    const cartLine = useCartLine();
+    return cartLine.merchandise.image ? (React.createElement(Image, { ...props, data: cartLine.merchandise.image })) : null;
+}
diff --git a/dist/dist/esnext/components/CartLineImage/index.d.ts b/dist/dist/esnext/components/CartLineImage/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..62493cbe09f74de4c33e21765aaef8a79f3e9dc1
--- /dev/null
+++ b/dist/dist/esnext/components/CartLineImage/index.d.ts
@@ -0,0 +1 @@
+export { CartLineImage } from './CartLineImage.client.js';
diff --git a/dist/dist/esnext/components/CartLineImage/index.js b/dist/dist/esnext/components/CartLineImage/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..62493cbe09f74de4c33e21765aaef8a79f3e9dc1
--- /dev/null
+++ b/dist/dist/esnext/components/CartLineImage/index.js
@@ -0,0 +1 @@
+export { CartLineImage } from './CartLineImage.client.js';
diff --git a/dist/dist/esnext/components/CartLinePrice/CartLinePrice.client.d.ts b/dist/dist/esnext/components/CartLinePrice/CartLinePrice.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..eac19b68eb0a8f515863b239ec23404c871c7196
--- /dev/null
+++ b/dist/dist/esnext/components/CartLinePrice/CartLinePrice.client.d.ts
@@ -0,0 +1,12 @@
+import React from 'react';
+import { Money } from '../Money/index.js';
+interface CartLinePriceProps {
+    /** The type of price. Valid values:`regular` (default) or `compareAt`. */
+    priceType?: 'regular' | 'compareAt';
+}
+/**
+ * The `CartLinePrice` component renders a `Money` component for the cart line merchandise's price or
+ * compare at price. It must be a descendent of a `CartLineProvider` component.
+ */
+export declare function CartLinePrice(props: Omit<React.ComponentProps<typeof Money>, 'data'> & CartLinePriceProps): JSX.Element | null;
+export {};
diff --git a/dist/dist/esnext/components/CartLinePrice/CartLinePrice.client.js b/dist/dist/esnext/components/CartLinePrice/CartLinePrice.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..46b37d58a824bd1729812ab0e627a2acea97b46f
--- /dev/null
+++ b/dist/dist/esnext/components/CartLinePrice/CartLinePrice.client.js
@@ -0,0 +1,18 @@
+import React from 'react';
+import { useCartLine } from '../CartLineProvider/index.js';
+import { Money } from '../Money/index.js';
+/**
+ * The `CartLinePrice` component renders a `Money` component for the cart line merchandise's price or
+ * compare at price. It must be a descendent of a `CartLineProvider` component.
+ */
+export function CartLinePrice(props) {
+    const cartLine = useCartLine();
+    const { priceType = 'regular', ...passthroughProps } = props;
+    const moneyV2 = priceType === 'regular'
+        ? cartLine.cost.totalAmount
+        : cartLine.cost.compareAtAmountPerQuantity;
+    if (moneyV2 == null) {
+        return null;
+    }
+    return React.createElement(Money, { ...passthroughProps, data: moneyV2 });
+}
diff --git a/dist/dist/esnext/components/CartLinePrice/index.d.ts b/dist/dist/esnext/components/CartLinePrice/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4f47c8db3c9a2d0c0f687e155ea05ead354f2aa8
--- /dev/null
+++ b/dist/dist/esnext/components/CartLinePrice/index.d.ts
@@ -0,0 +1 @@
+export { CartLinePrice } from './CartLinePrice.client.js';
diff --git a/dist/dist/esnext/components/CartLinePrice/index.js b/dist/dist/esnext/components/CartLinePrice/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..4f47c8db3c9a2d0c0f687e155ea05ead354f2aa8
--- /dev/null
+++ b/dist/dist/esnext/components/CartLinePrice/index.js
@@ -0,0 +1 @@
+export { CartLinePrice } from './CartLinePrice.client.js';
diff --git a/dist/dist/esnext/components/CartLineProductTitle/CartLineProductTitle.client.d.ts b/dist/dist/esnext/components/CartLineProductTitle/CartLineProductTitle.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6c6d94dba37929f83513b530e1ee1b81bf1de377
--- /dev/null
+++ b/dist/dist/esnext/components/CartLineProductTitle/CartLineProductTitle.client.d.ts
@@ -0,0 +1,8 @@
+/**
+ * The `CartLineProductTitle` component renders a `span` element (or the type of HTML element specified by
+ * the `as` prop) with the cart line merchandise's title. It must be a descendent of a `CartLineProvider` component.
+ */
+export declare function CartLineProductTitle<TTag extends keyof JSX.IntrinsicElements = 'span'>(props: JSX.IntrinsicElements[TTag] & {
+    /** An HTML tag to be rendered as the base element wrapper. The default is `span`.  */
+    as?: TTag;
+}): JSX.Element;
diff --git a/dist/dist/esnext/components/CartLineProductTitle/CartLineProductTitle.client.js b/dist/dist/esnext/components/CartLineProductTitle/CartLineProductTitle.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..46ffa1946ee935d6ad868f73aa08bea7245e0ac1
--- /dev/null
+++ b/dist/dist/esnext/components/CartLineProductTitle/CartLineProductTitle.client.js
@@ -0,0 +1,12 @@
+import React from 'react';
+import { useCartLine } from '../CartLineProvider/index.js';
+/**
+ * The `CartLineProductTitle` component renders a `span` element (or the type of HTML element specified by
+ * the `as` prop) with the cart line merchandise's title. It must be a descendent of a `CartLineProvider` component.
+ */
+export function CartLineProductTitle(props) {
+    const cartLine = useCartLine();
+    const { as, ...passthroughProps } = props;
+    const Wrapper = as ? as : 'span';
+    return (React.createElement(Wrapper, { ...passthroughProps }, cartLine.merchandise.product.title));
+}
diff --git a/dist/dist/esnext/components/CartLineProductTitle/index.d.ts b/dist/dist/esnext/components/CartLineProductTitle/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3d38583190df204f63b994979e0694b6c0da8f6c
--- /dev/null
+++ b/dist/dist/esnext/components/CartLineProductTitle/index.d.ts
@@ -0,0 +1 @@
+export { CartLineProductTitle } from './CartLineProductTitle.client.js';
diff --git a/dist/dist/esnext/components/CartLineProductTitle/index.js b/dist/dist/esnext/components/CartLineProductTitle/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..3d38583190df204f63b994979e0694b6c0da8f6c
--- /dev/null
+++ b/dist/dist/esnext/components/CartLineProductTitle/index.js
@@ -0,0 +1 @@
+export { CartLineProductTitle } from './CartLineProductTitle.client.js';
diff --git a/dist/dist/esnext/components/CartLineProvider/CartLineProvider.client.d.ts b/dist/dist/esnext/components/CartLineProvider/CartLineProvider.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5744f5bbcc559f2e86485c7ab4a16d7ec6f6818f
--- /dev/null
+++ b/dist/dist/esnext/components/CartLineProvider/CartLineProvider.client.d.ts
@@ -0,0 +1,11 @@
+import { ReactNode } from 'react';
+import { Cart } from '../CartProvider/index.js';
+/**
+ * The `CartLineProvider` component creates a context for using a cart line.
+ */
+export declare function CartLineProvider({ children, line, }: {
+    /** Any `ReactNode` elements. */
+    children: ReactNode;
+    /** A cart line object. */
+    line: Cart['lines'][1];
+}): JSX.Element;
diff --git a/dist/dist/esnext/components/CartLineProvider/CartLineProvider.client.js b/dist/dist/esnext/components/CartLineProvider/CartLineProvider.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..ce9d53fa8fca722967af215bbafb6619db5dd62f
--- /dev/null
+++ b/dist/dist/esnext/components/CartLineProvider/CartLineProvider.client.js
@@ -0,0 +1,8 @@
+import React from 'react';
+import { CartLineContext } from './context.js';
+/**
+ * The `CartLineProvider` component creates a context for using a cart line.
+ */
+export function CartLineProvider({ children, line, }) {
+    return (React.createElement(CartLineContext.Provider, { value: line }, children));
+}
diff --git a/dist/dist/esnext/components/CartLineProvider/context.d.ts b/dist/dist/esnext/components/CartLineProvider/context.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6b5ccd5b5adcc16303d5b59b5351e060422ba4cd
--- /dev/null
+++ b/dist/dist/esnext/components/CartLineProvider/context.d.ts
@@ -0,0 +1,36 @@
+export declare const CartLineContext: import("react").Context<({
+    __typename?: "CartLine" | undefined;
+} & Pick<import("../../storefront-api-types.js").CartLine, "id" | "quantity"> & {
+    attributes: ({
+        __typename?: "Attribute" | undefined;
+    } & Pick<import("../../storefront-api-types.js").Attribute, "key" | "value">)[];
+    cost: {
+        __typename?: "CartLineCost" | undefined;
+    } & {
+        totalAmount: {
+            __typename?: "MoneyV2" | undefined;
+        } & Pick<import("../../storefront-api-types.js").MoneyV2, "currencyCode" | "amount">;
+        compareAtAmountPerQuantity?: import("../../storefront-api-types.js").Maybe<{
+            __typename?: "MoneyV2" | undefined;
+        } & Pick<import("../../storefront-api-types.js").MoneyV2, "currencyCode" | "amount">> | undefined;
+    };
+    merchandise: {
+        __typename?: "ProductVariant" | undefined;
+    } & Pick<import("../../storefront-api-types.js").ProductVariant, "id" | "title" | "availableForSale" | "requiresShipping"> & {
+        compareAtPriceV2?: import("../../storefront-api-types.js").Maybe<{
+            __typename?: "MoneyV2" | undefined;
+        } & Pick<import("../../storefront-api-types.js").MoneyV2, "currencyCode" | "amount">> | undefined;
+        priceV2: {
+            __typename?: "MoneyV2" | undefined;
+        } & Pick<import("../../storefront-api-types.js").MoneyV2, "currencyCode" | "amount">;
+        image?: import("../../storefront-api-types.js").Maybe<{
+            __typename?: "Image" | undefined;
+        } & Pick<import("../../storefront-api-types.js").Image, "id" | "height" | "width" | "url" | "altText">> | undefined;
+        product: {
+            __typename?: "Product" | undefined;
+        } & Pick<import("../../storefront-api-types.js").Product, "title" | "handle">;
+        selectedOptions: ({
+            __typename?: "SelectedOption" | undefined;
+        } & Pick<import("../../storefront-api-types.js").SelectedOption, "name" | "value">)[];
+    };
+}) | null>;
diff --git a/dist/dist/esnext/components/CartLineProvider/context.js b/dist/dist/esnext/components/CartLineProvider/context.js
new file mode 100644
index 0000000000000000000000000000000000000000..69ddbe3e8bd839ca3008836308fc46f9be38296a
--- /dev/null
+++ b/dist/dist/esnext/components/CartLineProvider/context.js
@@ -0,0 +1,2 @@
+import { createContext } from 'react';
+export const CartLineContext = createContext(null);
diff --git a/dist/dist/esnext/components/CartLineProvider/index.d.ts b/dist/dist/esnext/components/CartLineProvider/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..81fc032f0f7ca80980b388d28ee739f870bd4bcb
--- /dev/null
+++ b/dist/dist/esnext/components/CartLineProvider/index.d.ts
@@ -0,0 +1,2 @@
+export { CartLineProvider } from './CartLineProvider.client.js';
+export { useCartLine } from '../../hooks/useCartLine/index.js';
diff --git a/dist/dist/esnext/components/CartLineProvider/index.js b/dist/dist/esnext/components/CartLineProvider/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..81fc032f0f7ca80980b388d28ee739f870bd4bcb
--- /dev/null
+++ b/dist/dist/esnext/components/CartLineProvider/index.js
@@ -0,0 +1,2 @@
+export { CartLineProvider } from './CartLineProvider.client.js';
+export { useCartLine } from '../../hooks/useCartLine/index.js';
diff --git a/dist/dist/esnext/components/CartLineProvider/tests/fixtures.d.ts b/dist/dist/esnext/components/CartLineProvider/tests/fixtures.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ed3d5357d8980a34bb2ea96d1178c45ceb1ca980
--- /dev/null
+++ b/dist/dist/esnext/components/CartLineProvider/tests/fixtures.d.ts
@@ -0,0 +1,86 @@
+import { CurrencyCode } from '../../../storefront-api-types.js';
+import { CartFragmentFragment } from '../../CartProvider/graphql/CartFragment.js';
+export declare const CART_LINE: {
+    attributes: {
+        key: string;
+        value: string;
+    }[];
+    quantity: number;
+    id: string;
+    merchandise: {
+        id: string;
+        availableForSale: boolean;
+        priceV2: {
+            amount: string;
+            currencyCode: CurrencyCode;
+        };
+        product: {
+            handle: string;
+            title: string;
+        };
+        requiresShipping: boolean;
+        selectedOptions: {
+            name: string;
+            value: string;
+        }[];
+        title: string;
+    };
+    cost: {
+        totalAmount: {
+            amount: string;
+            currencyCode: CurrencyCode;
+        };
+        compareAtAmount: {
+            amount: string;
+            currencyCode: CurrencyCode;
+        };
+    };
+};
+export declare function getCartLineMock(options?: Partial<CartFragmentFragment['lines']['edges'][0]['node']>): {
+    __typename?: "CartLine" | undefined;
+    id: string;
+    quantity: number;
+    attributes: ({
+        __typename?: "Attribute" | undefined;
+    } & Pick<import("../../../storefront-api-types.js").Attribute, "key" | "value">)[] | {
+        key: string;
+        value: string;
+    }[];
+    cost: ({
+        __typename?: "CartLineCost" | undefined;
+    } & {
+        totalAmount: {
+            __typename?: "MoneyV2" | undefined;
+        } & Pick<import("../../../storefront-api-types.js").MoneyV2, "currencyCode" | "amount">;
+        compareAtAmountPerQuantity?: import("../../../storefront-api-types.js").Maybe<{
+            __typename?: "MoneyV2" | undefined;
+        } & Pick<import("../../../storefront-api-types.js").MoneyV2, "currencyCode" | "amount">> | undefined;
+    }) | {
+        totalAmount: {
+            amount: string;
+            currencyCode: CurrencyCode;
+        };
+        compareAtAmount: {
+            amount: string;
+            currencyCode: CurrencyCode;
+        };
+    };
+    merchandise: {
+        id: string;
+        availableForSale: boolean;
+        priceV2: {
+            amount: string;
+            currencyCode: CurrencyCode;
+        };
+        product: {
+            handle: string;
+            title: string;
+        };
+        requiresShipping: boolean;
+        selectedOptions: {
+            name: string;
+            value: string;
+        }[];
+        title: string;
+    };
+};
diff --git a/dist/dist/esnext/components/CartLineProvider/tests/fixtures.js b/dist/dist/esnext/components/CartLineProvider/tests/fixtures.js
new file mode 100644
index 0000000000000000000000000000000000000000..25abd346ddd80e58f7cdd7a1a3a1a77ee7536c30
--- /dev/null
+++ b/dist/dist/esnext/components/CartLineProvider/tests/fixtures.js
@@ -0,0 +1,34 @@
+import { CurrencyCode } from '../../../storefront-api-types.js';
+export const CART_LINE = {
+    attributes: [{ key: 'color', value: 'red' }],
+    quantity: 1,
+    id: 'abc',
+    merchandise: {
+        id: 'def',
+        availableForSale: true,
+        priceV2: {
+            amount: '123',
+            currencyCode: CurrencyCode.Usd,
+        },
+        product: {
+            handle: 'foo',
+            title: 'Product Name',
+        },
+        requiresShipping: true,
+        selectedOptions: [{ name: 'size', value: 'large' }],
+        title: 'Product Name - Large',
+    },
+    cost: {
+        totalAmount: {
+            amount: '123',
+            currencyCode: CurrencyCode.Usd,
+        },
+        compareAtAmount: {
+            amount: '125',
+            currencyCode: CurrencyCode.Usd,
+        },
+    },
+};
+export function getCartLineMock(options) {
+    return { ...CART_LINE, ...options };
+}
diff --git a/dist/dist/esnext/components/CartLineQuantity/CartLineQuantity.client.d.ts b/dist/dist/esnext/components/CartLineQuantity/CartLineQuantity.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..513eade24d5b35830f39fc1823beb9398c5d3be1
--- /dev/null
+++ b/dist/dist/esnext/components/CartLineQuantity/CartLineQuantity.client.d.ts
@@ -0,0 +1,8 @@
+/**
+ * The `CartLineQuantity` component renders a `span` element (or the type of HTML element
+ * specified by the `as` prop) with the cart line's quantity. It must be a descendent of a `CartLineProvider` component.
+ */
+export declare function CartLineQuantity<TTag extends keyof JSX.IntrinsicElements = 'span'>(props: JSX.IntrinsicElements[TTag] & {
+    /** An HTML tag to be rendered as the base element wrapper. The default is `div`. */
+    as?: TTag;
+}): JSX.Element;
diff --git a/dist/dist/esnext/components/CartLineQuantity/CartLineQuantity.client.js b/dist/dist/esnext/components/CartLineQuantity/CartLineQuantity.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..e2c3c716b260d6d000b5122f222c982544a5dff4
--- /dev/null
+++ b/dist/dist/esnext/components/CartLineQuantity/CartLineQuantity.client.js
@@ -0,0 +1,12 @@
+import React from 'react';
+import { useCartLine } from '../CartLineProvider/index.js';
+/**
+ * The `CartLineQuantity` component renders a `span` element (or the type of HTML element
+ * specified by the `as` prop) with the cart line's quantity. It must be a descendent of a `CartLineProvider` component.
+ */
+export function CartLineQuantity(props) {
+    const cartLine = useCartLine();
+    const { as, ...passthroughProps } = props;
+    const Wrapper = as ? as : 'span';
+    return React.createElement(Wrapper, { ...passthroughProps }, cartLine.quantity);
+}
diff --git a/dist/dist/esnext/components/CartLineQuantity/index.d.ts b/dist/dist/esnext/components/CartLineQuantity/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7b1ccd6cf0813e62dd064b5ed79e1e9c39651a8c
--- /dev/null
+++ b/dist/dist/esnext/components/CartLineQuantity/index.d.ts
@@ -0,0 +1 @@
+export { CartLineQuantity } from './CartLineQuantity.client.js';
diff --git a/dist/dist/esnext/components/CartLineQuantity/index.js b/dist/dist/esnext/components/CartLineQuantity/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..7b1ccd6cf0813e62dd064b5ed79e1e9c39651a8c
--- /dev/null
+++ b/dist/dist/esnext/components/CartLineQuantity/index.js
@@ -0,0 +1 @@
+export { CartLineQuantity } from './CartLineQuantity.client.js';
diff --git a/dist/dist/esnext/components/CartLineQuantityAdjustButton/CartLineQuantityAdjustButton.d.ts b/dist/dist/esnext/components/CartLineQuantityAdjustButton/CartLineQuantityAdjustButton.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b1d782ac4aa661e81c41d4ba2556cdb2ef7df978
--- /dev/null
+++ b/dist/dist/esnext/components/CartLineQuantityAdjustButton/CartLineQuantityAdjustButton.d.ts
@@ -0,0 +1,12 @@
+import React from 'react';
+import { BaseButtonProps } from '../BaseButton/index.js';
+interface CartLineQuantityAdjustButtonProps {
+    /** The adjustment for a cart line's quantity. Valid values: `increase` (default), `decrease`, or `remove`. */
+    adjust?: 'increase' | 'decrease' | 'remove';
+}
+/**
+ * The `CartLineQuantityAdjustButton` component renders a button that adjusts the cart line's quantity when pressed.
+ * It must be a descendent of a `CartLineProvider` component.
+ */
+export declare function CartLineQuantityAdjustButton<AsType extends React.ElementType = 'button'>(props: CartLineQuantityAdjustButtonProps & BaseButtonProps<AsType>): JSX.Element;
+export {};
diff --git a/dist/dist/esnext/components/CartLineQuantityAdjustButton/CartLineQuantityAdjustButton.js b/dist/dist/esnext/components/CartLineQuantityAdjustButton/CartLineQuantityAdjustButton.js
new file mode 100644
index 0000000000000000000000000000000000000000..788e2d83e63bb71a76cbff8bb9c1960d6eb20975
--- /dev/null
+++ b/dist/dist/esnext/components/CartLineQuantityAdjustButton/CartLineQuantityAdjustButton.js
@@ -0,0 +1,26 @@
+import React, { useCallback } from 'react';
+import { useCart } from '../CartProvider/index.js';
+import { useCartLine } from '../CartLineProvider/index.js';
+import { BaseButton } from '../BaseButton/index.js';
+/**
+ * The `CartLineQuantityAdjustButton` component renders a button that adjusts the cart line's quantity when pressed.
+ * It must be a descendent of a `CartLineProvider` component.
+ */
+export function CartLineQuantityAdjustButton(props) {
+    const { status, linesRemove, linesUpdate } = useCart();
+    const cartLine = useCartLine();
+    const { children, adjust, onClick, ...passthroughProps } = props;
+    const handleAdjust = useCallback(() => {
+        if (adjust === 'remove') {
+            linesRemove([cartLine.id]);
+            return;
+        }
+        const quantity = adjust === 'decrease' ? cartLine.quantity - 1 : cartLine.quantity + 1;
+        if (quantity <= 0) {
+            linesRemove([cartLine.id]);
+            return;
+        }
+        linesUpdate([{ id: cartLine.id, quantity }]);
+    }, [adjust, cartLine.id, cartLine.quantity, linesRemove, linesUpdate]);
+    return (React.createElement(BaseButton, { disabled: status !== 'idle', onClick: onClick, defaultOnClick: handleAdjust, ...passthroughProps }, children));
+}
diff --git a/dist/dist/esnext/components/CartLineQuantityAdjustButton/index.d.ts b/dist/dist/esnext/components/CartLineQuantityAdjustButton/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..92a74652784091951abf66d62258db092b4869a3
--- /dev/null
+++ b/dist/dist/esnext/components/CartLineQuantityAdjustButton/index.d.ts
@@ -0,0 +1 @@
+export { CartLineQuantityAdjustButton } from './CartLineQuantityAdjustButton.js';
diff --git a/dist/dist/esnext/components/CartLineQuantityAdjustButton/index.js b/dist/dist/esnext/components/CartLineQuantityAdjustButton/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..92a74652784091951abf66d62258db092b4869a3
--- /dev/null
+++ b/dist/dist/esnext/components/CartLineQuantityAdjustButton/index.js
@@ -0,0 +1 @@
+export { CartLineQuantityAdjustButton } from './CartLineQuantityAdjustButton.js';
diff --git a/dist/dist/esnext/components/CartLines/CartLines.client.d.ts b/dist/dist/esnext/components/CartLines/CartLines.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e9d7f83ec0ff4a4fcac937f2aa42cddcde9465e4
--- /dev/null
+++ b/dist/dist/esnext/components/CartLines/CartLines.client.d.ts
@@ -0,0 +1,15 @@
+import { ReactNode, ElementType } from 'react';
+import { Props } from '../types.js';
+export interface CartLinesProps {
+    /** A `ReactNode` element. Valid values: `ul` or `undefined`. If `ul`, then each child will
+     * be wrapped with a `li` element.
+     */
+    as?: 'ul';
+    /** A `ReactNode` element */
+    children: ReactNode;
+}
+/**
+ * The `CartLines` component iterates over each cart line and renders its `children` within
+ * a `CartLineProvider` for each cart line.
+ */
+export declare function CartLines<TTag extends ElementType>(props: Props<TTag> & CartLinesProps): JSX.Element;
diff --git a/dist/dist/esnext/components/CartLines/CartLines.client.js b/dist/dist/esnext/components/CartLines/CartLines.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..c6741fb740a78d48b9896f258250bd6de84f8b64
--- /dev/null
+++ b/dist/dist/esnext/components/CartLines/CartLines.client.js
@@ -0,0 +1,17 @@
+import React, { Fragment } from 'react';
+import { useCart } from '../CartProvider/index.js';
+import { CartLineProvider } from '../CartLineProvider/index.js';
+/**
+ * The `CartLines` component iterates over each cart line and renders its `children` within
+ * a `CartLineProvider` for each cart line.
+ */
+export function CartLines(props) {
+    const { lines } = useCart();
+    const { as, children, ...passthroughProps } = props;
+    const Wrapper = as ?? Fragment;
+    const ChildWrapper = Wrapper === 'ul' ? 'li' : Fragment;
+    return (React.createElement(Wrapper, { ...passthroughProps }, lines.map((line) => {
+        return (React.createElement(ChildWrapper, { key: line.id },
+            React.createElement(CartLineProvider, { line: line }, children)));
+    })));
+}
diff --git a/dist/dist/esnext/components/CartLines/index.d.ts b/dist/dist/esnext/components/CartLines/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b6ad5944db793f8a6179bdb0b12d2acc363523b7
--- /dev/null
+++ b/dist/dist/esnext/components/CartLines/index.d.ts
@@ -0,0 +1 @@
+export { CartLines } from './CartLines.client.js';
diff --git a/dist/dist/esnext/components/CartLines/index.js b/dist/dist/esnext/components/CartLines/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..b6ad5944db793f8a6179bdb0b12d2acc363523b7
--- /dev/null
+++ b/dist/dist/esnext/components/CartLines/index.js
@@ -0,0 +1 @@
+export { CartLines } from './CartLines.client.js';
diff --git a/dist/dist/esnext/components/CartProvider/CartActions.client.d.ts b/dist/dist/esnext/components/CartProvider/CartActions.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..adde163f9b2e7f73ac3a11e12a38d843041fc15f
--- /dev/null
+++ b/dist/dist/esnext/components/CartProvider/CartActions.client.d.ts
@@ -0,0 +1,61 @@
+import { AttributeInput, CartBuyerIdentityInput, CartInput, CartLineInput, CartLineUpdateInput, CountryCode } from '../../storefront-api-types.js';
+import { CartAttributesUpdateMutation } from './graphql/CartAttributesUpdateMutation.js';
+import { CartBuyerIdentityUpdateMutation } from './graphql/CartBuyerIdentityUpdateMutation.js';
+import { CartCreateMutation } from './graphql/CartCreateMutation.js';
+import { CartDiscountCodesUpdateMutation, CartDiscountCodesUpdateMutationVariables } from './graphql/CartDiscountCodesUpdateMutation.js';
+import { CartLineAddMutation } from './graphql/CartLineAddMutation.js';
+import { CartLineRemoveMutation } from './graphql/CartLineRemoveMutation.js';
+import { CartLineUpdateMutation } from './graphql/CartLineUpdateMutation.js';
+import { CartNoteUpdateMutation, CartNoteUpdateMutationVariables } from './graphql/CartNoteUpdateMutation.js';
+import { CartQueryQuery } from './graphql/CartQuery.js';
+/**
+ * The `useCartActions` hook returns helper graphql functions for Storefront Cart API
+ *
+ * See [cart API graphql mutations](https://shopify.dev/api/storefront/2022-07/objects/Cart)
+ */
+export declare function useCartActions({ numCartLines, cartFragment, countryCode, }: {
+    /**  Maximum number of cart lines to fetch. Defaults to 250 cart lines. */
+    numCartLines?: number;
+    /** A fragment used to query the Storefront API's [Cart object](https://shopify.dev/api/storefront/latest/objects/cart) for all queries and mutations. A default value is used if no argument is provided. */
+    cartFragment: string;
+    /** The ISO country code for i18n. */
+    countryCode?: CountryCode;
+}): {
+    cartFetch: (cartId: string) => Promise<{
+        data: CartQueryQuery | undefined;
+        errors: any;
+    }>;
+    cartCreate: (cart: CartInput) => Promise<{
+        data: CartCreateMutation | undefined;
+        errors: any;
+    }>;
+    cartLineAdd: (cartId: string, lines: CartLineInput[]) => Promise<{
+        data: CartLineAddMutation | undefined;
+        errors: any;
+    }>;
+    cartLineUpdate: (cartId: string, lines: CartLineUpdateInput[]) => Promise<{
+        data: CartLineUpdateMutation | undefined;
+        errors: any;
+    }>;
+    cartLineRemove: (cartId: string, lines: string[]) => Promise<{
+        data: CartLineRemoveMutation | undefined;
+        errors: any;
+    }>;
+    noteUpdate: (cartId: string, note: CartNoteUpdateMutationVariables['note']) => Promise<{
+        data: CartNoteUpdateMutation | undefined;
+        errors: any;
+    }>;
+    buyerIdentityUpdate: (cartId: string, buyerIdentity: CartBuyerIdentityInput) => Promise<{
+        data: CartBuyerIdentityUpdateMutation | undefined;
+        errors: any;
+    }>;
+    cartAttributesUpdate: (cartId: string, attributes: AttributeInput[]) => Promise<{
+        data: CartAttributesUpdateMutation | undefined;
+        errors: any;
+    }>;
+    discountCodesUpdate: (cartId: string, discountCodes: CartDiscountCodesUpdateMutationVariables['discountCodes']) => Promise<{
+        data: CartDiscountCodesUpdateMutation | undefined;
+        errors: any;
+    }>;
+    cartFragment: string;
+};
diff --git a/dist/dist/esnext/components/CartProvider/CartActions.client.js b/dist/dist/esnext/components/CartProvider/CartActions.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3b11474d788687af3e48b96c9c08e12766fd03d
--- /dev/null
+++ b/dist/dist/esnext/components/CartProvider/CartActions.client.js
@@ -0,0 +1,132 @@
+import { useCallback, useMemo } from 'react';
+import { CountryCode, } from '../../storefront-api-types.js';
+import { CartAttributesUpdate, CartBuyerIdentityUpdate, CartCreate, CartDiscountCodesUpdate, CartLineAdd, CartLineRemove, CartLineUpdate, CartNoteUpdate, CartQuery, } from './cart-queries.js';
+import { useCartFetch } from './hooks.client.js';
+/**
+ * The `useCartActions` hook returns helper graphql functions for Storefront Cart API
+ *
+ * See [cart API graphql mutations](https://shopify.dev/api/storefront/2022-07/objects/Cart)
+ */
+export function useCartActions({ numCartLines, cartFragment, countryCode = CountryCode.Us, }) {
+    const fetchCart = useCartFetch();
+    const cartFetch = useCallback((cartId) => {
+        return fetchCart({
+            query: CartQuery(cartFragment),
+            variables: {
+                id: cartId,
+                numCartLines,
+                country: countryCode,
+            },
+        });
+    }, [fetchCart, cartFragment, numCartLines, countryCode]);
+    const cartCreate = useCallback((cart) => {
+        return fetchCart({
+            query: CartCreate(cartFragment),
+            variables: {
+                input: cart,
+                numCartLines,
+                country: countryCode,
+            },
+        });
+    }, [cartFragment, countryCode, fetchCart, numCartLines]);
+    const cartLineAdd = useCallback((cartId, lines) => {
+        return fetchCart({
+            query: CartLineAdd(cartFragment),
+            variables: {
+                cartId,
+                lines,
+                numCartLines,
+                country: countryCode,
+            },
+        });
+    }, [cartFragment, countryCode, fetchCart, numCartLines]);
+    const cartLineUpdate = useCallback((cartId, lines) => {
+        return fetchCart({
+            query: CartLineUpdate(cartFragment),
+            variables: {
+                cartId,
+                lines,
+                numCartLines,
+                country: countryCode,
+            },
+        });
+    }, [cartFragment, countryCode, fetchCart, numCartLines]);
+    const cartLineRemove = useCallback((cartId, lines) => {
+        return fetchCart({
+            query: CartLineRemove(cartFragment),
+            variables: {
+                cartId,
+                lines,
+                numCartLines,
+                country: countryCode,
+            },
+        });
+    }, [cartFragment, countryCode, fetchCart, numCartLines]);
+    const noteUpdate = useCallback((cartId, note) => {
+        return fetchCart({
+            query: CartNoteUpdate(cartFragment),
+            variables: {
+                cartId,
+                note,
+                numCartLines,
+                country: countryCode,
+            },
+        });
+    }, [fetchCart, cartFragment, numCartLines, countryCode]);
+    const buyerIdentityUpdate = useCallback((cartId, buyerIdentity) => {
+        return fetchCart({
+            query: CartBuyerIdentityUpdate(cartFragment),
+            variables: {
+                cartId,
+                buyerIdentity,
+                numCartLines,
+                country: countryCode,
+            },
+        });
+    }, [cartFragment, countryCode, fetchCart, numCartLines]);
+    const cartAttributesUpdate = useCallback((cartId, attributes) => {
+        return fetchCart({
+            query: CartAttributesUpdate(cartFragment),
+            variables: {
+                cartId,
+                attributes,
+                numCartLines,
+                country: countryCode,
+            },
+        });
+    }, [cartFragment, countryCode, fetchCart, numCartLines]);
+    const discountCodesUpdate = useCallback((cartId, discountCodes) => {
+        return fetchCart({
+            query: CartDiscountCodesUpdate(cartFragment),
+            variables: {
+                cartId,
+                discountCodes,
+                numCartLines,
+                country: countryCode,
+            },
+        });
+    }, [cartFragment, countryCode, fetchCart, numCartLines]);
+    return useMemo(() => ({
+        cartFetch,
+        cartCreate,
+        cartLineAdd,
+        cartLineUpdate,
+        cartLineRemove,
+        noteUpdate,
+        buyerIdentityUpdate,
+        cartAttributesUpdate,
+        discountCodesUpdate,
+        cartFragment,
+    }), [
+        cartFetch,
+        cartCreate,
+        cartLineAdd,
+        cartLineUpdate,
+        cartLineRemove,
+        noteUpdate,
+        buyerIdentityUpdate,
+        cartAttributesUpdate,
+        discountCodesUpdate,
+        cartFragment,
+    ]);
+}
diff --git a/dist/dist/esnext/components/CartProvider/CartProvider.client.d.ts b/dist/dist/esnext/components/CartProvider/CartProvider.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..60a4d34dc4a0c8b8276f3feb46d4f6cd7970d3e5
--- /dev/null
+++ b/dist/dist/esnext/components/CartProvider/CartProvider.client.d.ts
@@ -0,0 +1,41 @@
+import React from 'react';
+import { CartBuyerIdentityInput, CountryCode } from '../../storefront-api-types.js';
+import { CartFragmentFragment } from './graphql/CartFragment.js';
+/**
+ * The `CartProvider` component creates a context for using a cart. It creates a cart object and callbacks
+ * that can be accessed by any descendent component using the `useCart` hook and related hooks. It also carries out
+ * any callback props when a relevant action is performed. For example, if a `onLineAdd` callback is provided,
+ * then the callback will be called when a new line item is successfully added to the cart.
+ *
+ * The `CartProvider` component must be a descendent of the `ShopifyProvider` component.
+ * You must use this component if you want to use the `useCart` hook or related hooks, or if you would like to use the `AddToCartButton` component.
+ */
+export declare function CartProvider({ children, numCartLines, onCreate, onLineAdd, onLineRemove, onLineUpdate, onNoteUpdate, onBuyerIdentityUpdate, onAttributesUpdate, onDiscountCodesUpdate, data: cart, cartFragment, customerAccessToken, countryCode, }: {
+    /** Any `ReactNode` elements. */
+    children: React.ReactNode;
+    numCartLines?: number;
+    /** A callback that is invoked when the process to create a cart begins, but before the cart is created in the Storefront API. */
+    onCreate?: () => void;
+    /** A callback that is invoked when the process to add a line item to the cart begins, but before the line item is added to the Storefront API. */
+    onLineAdd?: () => void;
+    /** A callback that is invoked when the process to remove a line item to the cart begins, but before the line item is removed from the Storefront API. */
+    onLineRemove?: () => void;
+    /** A callback that is invoked when the process to update a line item in the cart begins, but before the line item is updated in the Storefront API. */
+    onLineUpdate?: () => void;
+    /** A callback that is invoked when the process to add or update a note in the cart begins, but before the note is added or updated in the Storefront API. */
+    onNoteUpdate?: () => void;
+    /** A callback that is invoked when the process to update the buyer identity begins, but before the buyer identity is updated in the Storefront API. */
+    onBuyerIdentityUpdate?: () => void;
+    /** A callback that is invoked when the process to update the cart attributes begins, but before the attributes are updated in the Storefront API. */
+    onAttributesUpdate?: () => void;
+    /** A callback that is invoked when the process to update the cart discount codes begins, but before the discount codes are updated in the Storefront API. */
+    onDiscountCodesUpdate?: () => void;
+    /** An object with fields that correspond to the Storefront API's [Cart object](https://shopify.dev/api/storefront/latest/objects/cart). */
+    data?: CartFragmentFragment;
+    /** A fragment used to query the Storefront API's [Cart object](https://shopify.dev/api/storefront/latest/objects/cart) for all queries and mutations. A default value is used if no argument is provided. */
+    cartFragment?: string;
+    /** A customer access token that's accessible on the server if there's a customer login. */
+    customerAccessToken?: CartBuyerIdentityInput['customerAccessToken'];
+    /** The ISO country code for i18n. */
+    countryCode?: CountryCode;
+}): JSX.Element;
diff --git a/dist/dist/esnext/components/CartProvider/CartProvider.client.js b/dist/dist/esnext/components/CartProvider/CartProvider.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..b304e627358afbad3102d87f865ac36782b45519
--- /dev/null
+++ b/dist/dist/esnext/components/CartProvider/CartProvider.client.js
@@ -0,0 +1,554 @@
+import React, { useEffect, useCallback, useReducer, useMemo, useRef, } from 'react';
+import { flattenConnection } from '../../utilities/flattenConnection/index.js';
+import { CartLineAdd, CartCreate, CartLineRemove, CartLineUpdate, CartNoteUpdate, CartBuyerIdentityUpdate, CartAttributesUpdate, CartDiscountCodesUpdate, CartQuery, defaultCartFragment, } from './cart-queries.js';
+import { CountryCode, } from '../../storefront-api-types.js';
+import { useCartFetch } from './hooks.client.js';
+import { CartContext } from './context.js';
+import { CART_ID_STORAGE_KEY } from './constants.js';
+import { ClientAnalytics } from '../../foundation/Analytics/ClientAnalytics.js';
+function getLocalStoragePolyfill() {
+    const storage = {};
+    return {
+        removeItem(key) {
+            delete storage[key];
+        },
+        setItem(key, value) {
+            storage[key] = value;
+        },
+        getItem(key) {
+            return storage[key];
+        },
+    };
+}
+const localStorage = (function () {
+    try {
+        return window.localStorage || getLocalStoragePolyfill();
+    }
+    catch (e) {
+        return getLocalStoragePolyfill();
+    }
+})();
+function cartReducer(state, action) {
+    switch (action.type) {
+        case 'cartFetch': {
+            if (state.status === 'uninitialized') {
+                return {
+                    status: 'fetching',
+                };
+            }
+            break;
+        }
+        case 'cartCreate': {
+            if (state.status === 'uninitialized') {
+                return {
+                    status: 'creating',
+                };
+            }
+            break;
+        }
+        case 'resolve': {
+            const resolvableStatuses = ['updating', 'fetching', 'creating'];
+            if (resolvableStatuses.includes(state.status)) {
+                return {
+                    status: 'idle',
+                    cart: action.cart,
+                };
+            }
+            break;
+        }
+        case 'reject': {
+            if (action.errors) {
+                console.group('%cCart Error:', 'color:red');
+                for (const [i, error] of action.errors.entries()) {
+                    console.log(`%c${i + 1}. ` + error.message, 'color:red');
+                }
+                console.groupEnd();
+            }
+            if (state.status === 'fetching' || state.status === 'creating') {
+                return { status: 'uninitialized', error: action.errors };
+            }
+            else if (state.status === 'updating') {
+                return {
+                    status: 'idle',
+                    cart: state.lastValidCart,
+                    error: action.errors,
+                };
+            }
+            break;
+        }
+        case 'resetCart': {
+            if (state.status === 'fetching') {
+                return { status: 'uninitialized' };
+            }
+            break;
+        }
+        case 'addLineItem': {
+            if (state.status === 'idle') {
+                return {
+                    status: 'updating',
+                    cart: state.cart,
+                    lastValidCart: state.cart,
+                };
+            }
+            break;
+        }
+        case 'removeLineItem': {
+            if (state.status === 'idle') {
+                return {
+                    status: 'updating',
+                    cart: {
+                        ...state.cart,
+                        lines: state.cart.lines.filter(({ id }) => !action.lines.includes(id)),
+                    },
+                    lastValidCart: state.cart,
+                };
+            }
+            break;
+        }
+        case 'updateLineItem': {
+            if (state.status === 'idle') {
+                return {
+                    status: 'updating',
+                    cart: {
+                        ...state.cart,
+                        lines: state.cart.lines.map((line) => {
+                            const updatedLine = action.lines.find(({ id }) => id === line.id);
+                            if (updatedLine && updatedLine.quantity) {
+                                return {
+                                    ...line,
+                                    quantity: updatedLine.quantity,
+                                };
+                            }
+                            return line;
+                        }),
+                    },
+                    lastValidCart: state.cart,
+                };
+            }
+            break;
+        }
+        case 'noteUpdate': {
+            if (state.status === 'idle') {
+                return {
+                    status: 'updating',
+                    cart: state.cart,
+                    lastValidCart: state.cart,
+                };
+            }
+            break;
+        }
+        case 'buyerIdentityUpdate': {
+            if (state.status === 'idle') {
+                return {
+                    status: 'updating',
+                    cart: state.cart,
+                    lastValidCart: state.cart,
+                };
+            }
+            break;
+        }
+        case 'cartAttributesUpdate': {
+            if (state.status === 'idle') {
+                return {
+                    status: 'updating',
+                    cart: state.cart,
+                    lastValidCart: state.cart,
+                };
+            }
+            break;
+        }
+        case 'discountCodesUpdate': {
+            if (state.status === 'idle') {
+                return {
+                    status: 'updating',
+                    cart: state.cart,
+                    lastValidCart: state.cart,
+                };
+            }
+            break;
+        }
+    }
+    throw new Error(`Cannot dispatch event (${action.type}) for current cart state (${state.status})`);
+}
+/**
+ * The `CartProvider` component creates a context for using a cart. It creates a cart object and callbacks
+ * that can be accessed by any descendent component using the `useCart` hook and related hooks. It also carries out
+ * any callback props when a relevant action is performed. For example, if a `onLineAdd` callback is provided,
+ * then the callback will be called when a new line item is successfully added to the cart.
+ *
+ * The `CartProvider` component must be a descendent of the `ShopifyProvider` component.
+ * You must use this component if you want to use the `useCart` hook or related hooks, or if you would like to use the `AddToCartButton` component.
+ */
+export function CartProvider({ children, numCartLines, onCreate, onLineAdd, onLineRemove, onLineUpdate, onNoteUpdate, onBuyerIdentityUpdate, onAttributesUpdate, onDiscountCodesUpdate, data: cart, cartFragment = defaultCartFragment, customerAccessToken, countryCode = CountryCode.Us, }) {
+    if (countryCode)
+        countryCode = countryCode.toUpperCase();
+    const initialStatus = cart
+        ? { status: 'idle', cart: cartFromGraphQL(cart) }
+        : { status: 'uninitialized' };
+    const [state, dispatch] = useReducer((state, dispatch) => cartReducer(state, dispatch), initialStatus);
+    const fetchCart = useCartFetch();
+    const countryChanged = state.status === 'idle' &&
+        countryCode !== state?.cart?.buyerIdentity?.countryCode &&
+        !state.error;
+    const cartFetch = useCallback(async (cartId) => {
+        dispatch({ type: 'cartFetch' });
+        const { data } = await fetchCart({
+            query: CartQuery(cartFragment),
+            variables: {
+                id: cartId,
+                numCartLines,
+                country: countryCode,
+            },
+        });
+        if (!data?.cart) {
+            localStorage.removeItem(CART_ID_STORAGE_KEY);
+            dispatch({ type: 'resetCart' });
+            return;
+        }
+        dispatch({ type: 'resolve', cart: cartFromGraphQL(data.cart) });
+    }, [fetchCart, cartFragment, numCartLines, countryCode]);
+    const cartCreate = useCallback(async (cart) => {
+        dispatch({ type: 'cartCreate' });
+        onCreate?.();
+        if (countryCode && !cart.buyerIdentity?.countryCode) {
+            if (cart.buyerIdentity == null) {
+                cart.buyerIdentity = {};
+            }
+            cart.buyerIdentity.countryCode = countryCode;
+        }
+        if (customerAccessToken && !cart.buyerIdentity?.customerAccessToken) {
+            if (cart.buyerIdentity == null) {
+                cart.buyerIdentity = {};
+            }
+            cart.buyerIdentity.customerAccessToken = customerAccessToken;
+        }
+        const { data, errors } = await fetchCart({
+            query: CartCreate(cartFragment),
+            variables: {
+                input: cart,
+                numCartLines,
+                country: countryCode,
+            },
+        });
+        if (errors) {
+            dispatch({
+                type: 'reject',
+                errors,
+            });
+        }
+        if (data?.cartCreate?.cart) {
+            if (cart.lines) {
+                ClientAnalytics.publish(ClientAnalytics.eventNames.ADD_TO_CART, true, {
+                    addedCartLines: cart.lines,
+                    cart: data.cartCreate.cart,
+                    prevCart: null,
+                });
+            }
+            dispatch({
+                type: 'resolve',
+                cart: cartFromGraphQL(data.cartCreate.cart),
+            });
+            localStorage.setItem(CART_ID_STORAGE_KEY, data.cartCreate.cart.id);
+        }
+    }, [
+        onCreate,
+        countryCode,
+        fetchCart,
+        cartFragment,
+        numCartLines,
+        customerAccessToken,
+    ]);
+    const addLineItem = useCallback(async (lines, state) => {
+        if (state.status === 'idle') {
+            dispatch({ type: 'addLineItem' });
+            onLineAdd?.();
+            const { data, errors } = await fetchCart({
+                query: CartLineAdd(cartFragment),
+                variables: {
+                    cartId: state.cart.id,
+                    lines,
+                    numCartLines,
+                    country: countryCode,
+                },
+            });
+            if (errors) {
+                dispatch({
+                    type: 'reject',
+                    errors,
+                });
+            }
+            if (data?.cartLinesAdd?.cart) {
+                ClientAnalytics.publish(ClientAnalytics.eventNames.ADD_TO_CART, true, {
+                    addedCartLines: lines,
+                    cart: data.cartLinesAdd.cart,
+                    prevCart: state.cart,
+                });
+                dispatch({
+                    type: 'resolve',
+                    cart: cartFromGraphQL(data.cartLinesAdd.cart),
+                });
+            }
+        }
+    }, [onLineAdd, fetchCart, cartFragment, numCartLines, countryCode]);
+    const removeLineItem = useCallback(async (lines, state) => {
+        if (state.status === 'idle') {
+            dispatch({ type: 'removeLineItem', lines });
+            onLineRemove?.();
+            const { data, errors } = await fetchCart({
+                query: CartLineRemove(cartFragment),
+                variables: {
+                    cartId: state.cart.id,
+                    lines,
+                    numCartLines,
+                    country: countryCode,
+                },
+            });
+            if (errors) {
+                dispatch({
+                    type: 'reject',
+                    errors,
+                });
+            }
+            if (data?.cartLinesRemove?.cart) {
+                ClientAnalytics.publish(ClientAnalytics.eventNames.REMOVE_FROM_CART, true, {
+                    removedCartLines: lines,
+                    cart: data.cartLinesRemove.cart,
+                    prevCart: state.cart,
+                });
+                dispatch({
+                    type: 'resolve',
+                    cart: cartFromGraphQL(data.cartLinesRemove.cart),
+                });
+            }
+        }
+    }, [onLineRemove, fetchCart, cartFragment, numCartLines, countryCode]);
+    const updateLineItem = useCallback(async (lines, state) => {
+        if (state.status === 'idle') {
+            dispatch({ type: 'updateLineItem', lines });
+            onLineUpdate?.();
+            const { data, errors } = await fetchCart({
+                query: CartLineUpdate(cartFragment),
+                variables: {
+                    cartId: state.cart.id,
+                    lines,
+                    numCartLines,
+                    country: countryCode,
+                },
+            });
+            if (errors) {
+                dispatch({
+                    type: 'reject',
+                    errors,
+                });
+            }
+            if (data?.cartLinesUpdate?.cart) {
+                ClientAnalytics.publish(ClientAnalytics.eventNames.UPDATE_CART, true, {
+                    updatedCartLines: lines,
+                    oldCart: state.cart,
+                    cart: data.cartLinesUpdate.cart,
+                    prevCart: state.cart,
+                });
+                dispatch({
+                    type: 'resolve',
+                    cart: cartFromGraphQL(data.cartLinesUpdate.cart),
+                });
+            }
+        }
+    }, [onLineUpdate, fetchCart, cartFragment, numCartLines, countryCode]);
+    const noteUpdate = useCallback(async (note, state) => {
+        if (state.status === 'idle') {
+            dispatch({ type: 'noteUpdate' });
+            onNoteUpdate?.();
+            const { data, errors } = await fetchCart({
+                query: CartNoteUpdate(cartFragment),
+                variables: {
+                    cartId: state.cart.id,
+                    note,
+                    numCartLines,
+                    country: countryCode,
+                },
+            });
+            if (errors) {
+                dispatch({
+                    type: 'reject',
+                    errors,
+                });
+            }
+            if (data?.cartNoteUpdate?.cart) {
+                dispatch({
+                    type: 'resolve',
+                    cart: cartFromGraphQL(data.cartNoteUpdate.cart),
+                });
+            }
+        }
+    }, [onNoteUpdate, fetchCart, cartFragment, numCartLines, countryCode]);
+    const buyerIdentityUpdate = useCallback(async (buyerIdentity, state) => {
+        if (state.status === 'idle') {
+            dispatch({ type: 'buyerIdentityUpdate' });
+            onBuyerIdentityUpdate?.();
+            const { data, errors } = await fetchCart({
+                query: CartBuyerIdentityUpdate(cartFragment),
+                variables: {
+                    cartId: state.cart.id,
+                    buyerIdentity,
+                    numCartLines,
+                    country: countryCode,
+                },
+            });
+            if (errors) {
+                dispatch({
+                    type: 'reject',
+                    errors,
+                });
+            }
+            if (data?.cartBuyerIdentityUpdate?.cart) {
+                dispatch({
+                    type: 'resolve',
+                    cart: cartFromGraphQL(data.cartBuyerIdentityUpdate.cart),
+                });
+            }
+        }
+    }, [onBuyerIdentityUpdate, fetchCart, cartFragment, numCartLines, countryCode]);
+    const cartAttributesUpdate = useCallback(async (attributes, state) => {
+        if (state.status === 'idle') {
+            dispatch({ type: 'cartAttributesUpdate' });
+            onAttributesUpdate?.();
+            const { data, errors } = await fetchCart({
+                query: CartAttributesUpdate(cartFragment),
+                variables: {
+                    cartId: state.cart.id,
+                    attributes,
+                    numCartLines,
+                    country: countryCode,
+                },
+            });
+            if (errors) {
+                dispatch({
+                    type: 'reject',
+                    errors,
+                });
+            }
+            if (data?.cartAttributesUpdate?.cart) {
+                dispatch({
+                    type: 'resolve',
+                    cart: cartFromGraphQL(data.cartAttributesUpdate.cart),
+                });
+            }
+        }
+    }, [onAttributesUpdate, fetchCart, cartFragment, numCartLines, countryCode]);
+    const discountCodesUpdate = useCallback(async (discountCodes, state) => {
+        if (state.status === 'idle') {
+            dispatch({ type: 'discountCodesUpdate' });
+            onDiscountCodesUpdate?.();
+            const { data, errors } = await fetchCart({
+                query: CartDiscountCodesUpdate(cartFragment),
+                variables: {
+                    cartId: state.cart.id,
+                    discountCodes,
+                    numCartLines,
+                    country: countryCode,
+                },
+            });
+            if (errors) {
+                dispatch({
+                    type: 'reject',
+                    errors,
+                });
+            }
+            if (data?.cartDiscountCodesUpdate?.cart) {
+                ClientAnalytics.publish(ClientAnalytics.eventNames.DISCOUNT_CODE_UPDATED, true, {
+                    updatedDiscountCodes: discountCodes,
+                    cart: data.cartDiscountCodesUpdate.cart,
+                    prevCart: state.cart,
+                });
+                dispatch({
+                    type: 'resolve',
+                    cart: cartFromGraphQL(data.cartDiscountCodesUpdate.cart),
+                });
+            }
+        }
+    }, [onDiscountCodesUpdate, fetchCart, cartFragment, numCartLines, countryCode]);
+    const didFetchCart = useRef(false);
+    useEffect(() => {
+        if (localStorage.getItem(CART_ID_STORAGE_KEY) &&
+            state.status === 'uninitialized' &&
+            !didFetchCart.current) {
+            didFetchCart.current = true;
+            cartFetch(localStorage.getItem(CART_ID_STORAGE_KEY));
+        }
+    }, [cartFetch, state]);
+    useEffect(() => {
+        if (!countryChanged)
+            return;
+        buyerIdentityUpdate({ countryCode, customerAccessToken }, state);
+    }, [
+        state,
+        buyerIdentityUpdate,
+        countryCode,
+        customerAccessToken,
+        countryChanged,
+    ]);
+    const cartContextValue = useMemo(() => {
+        return {
+            ...('cart' in state
+                ? state.cart
+                : {
+                    lines: [],
+                    attributes: [],
+                    ...(cart ? cartFromGraphQL(cart) : {}),
+                }),
+            status: state.status,
+            error: 'error' in state ? state.error : undefined,
+            totalQuantity: 'cart' in state ? state?.cart?.totalQuantity ?? 0 : 0,
+            cartCreate,
+            linesAdd(lines) {
+                if ('cart' in state && state.cart.id) {
+                    addLineItem(lines, state);
+                }
+                else {
+                    cartCreate({ lines });
+                }
+            },
+            linesRemove(lines) {
+                removeLineItem(lines, state);
+            },
+            linesUpdate(lines) {
+                updateLineItem(lines, state);
+            },
+            noteUpdate(note) {
+                noteUpdate(note, state);
+            },
+            buyerIdentityUpdate(buyerIdentity) {
+                buyerIdentityUpdate(buyerIdentity, state);
+            },
+            cartAttributesUpdate(attributes) {
+                cartAttributesUpdate(attributes, state);
+            },
+            discountCodesUpdate(discountCodes) {
+                discountCodesUpdate(discountCodes, state);
+            },
+            cartFragment,
+        };
+    }, [
+        state,
+        cart,
+        cartCreate,
+        cartFragment,
+        addLineItem,
+        removeLineItem,
+        updateLineItem,
+        noteUpdate,
+        buyerIdentityUpdate,
+        cartAttributesUpdate,
+        discountCodesUpdate,
+    ]);
+    return (React.createElement(CartContext.Provider, { value: cartContextValue }, children));
+}
+function cartFromGraphQL(cart) {
+    return {
+        ...cart,
+        // @ts-expect-error While the cart still uses fragments, there will be a TS error here until we remove those fragments and get the type in-line
+        lines: flattenConnection(cart.lines),
+        note: cart.note ?? undefined,
+    };
+}
diff --git a/dist/dist/esnext/components/CartProvider/CartProviderV2.client.d.ts b/dist/dist/esnext/components/CartProvider/CartProviderV2.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b733d234e9fd83929fde6623e8e4647d764ff260
--- /dev/null
+++ b/dist/dist/esnext/components/CartProvider/CartProviderV2.client.d.ts
@@ -0,0 +1,50 @@
+import React from 'react';
+import { CartFragmentFragment } from './graphql/CartFragment.js';
+import { CartBuyerIdentityInput, CountryCode } from '../../storefront-api-types.js';
+export declare function CartProviderV2({ children, numCartLines, onCreate, onLineAdd, onLineRemove, onLineUpdate, onNoteUpdate, onBuyerIdentityUpdate, onAttributesUpdate, onDiscountCodesUpdate, onCreateComplete, onLineAddComplete, onLineRemoveComplete, onLineUpdateComplete, onNoteUpdateComplete, onBuyerIdentityUpdateComplete, onAttributesUpdateComplete, onDiscountCodesUpdateComplete, data: cart, cartFragment, customerAccessToken, countryCode, }: {
+    /** Any `ReactNode` elements. */
+    children: React.ReactNode;
+    /**  Maximum number of cart lines to fetch. Defaults to 250 cart lines. */
+    numCartLines?: number;
+    /** A callback that is invoked when the process to create a cart begins, but before the cart is created in the Storefront API. */
+    onCreate?: () => void;
+    /** A callback that is invoked when the process to add a line item to the cart begins, but before the line item is added to the Storefront API. */
+    onLineAdd?: () => void;
+    /** A callback that is invoked when the process to remove a line item to the cart begins, but before the line item is removed from the Storefront API. */
+    onLineRemove?: () => void;
+    /** A callback that is invoked when the process to update a line item in the cart begins, but before the line item is updated in the Storefront API. */
+    onLineUpdate?: () => void;
+    /** A callback that is invoked when the process to add or update a note in the cart begins, but before the note is added or updated in the Storefront API. */
+    onNoteUpdate?: () => void;
+    /** A callback that is invoked when the process to update the buyer identity begins, but before the buyer identity is updated in the Storefront API. */
+    onBuyerIdentityUpdate?: () => void;
+    /** A callback that is invoked when the process to update the cart attributes begins, but before the attributes are updated in the Storefront API. */
+    onAttributesUpdate?: () => void;
+    /** A callback that is invoked when the process to update the cart discount codes begins, but before the discount codes are updated in the Storefront API. */
+    onDiscountCodesUpdate?: () => void;
+    /** A callback that is invoked when the process to create a cart completes */
+    onCreateComplete?: () => void;
+    /** A callback that is invoked when the process to add a line item to the cart completes */
+    onLineAddComplete?: () => void;
+    /** A callback that is invoked when the process to remove a line item to the cart completes */
+    onLineRemoveComplete?: () => void;
+    /** A callback that is invoked when the process to update a line item in the cart completes */
+    onLineUpdateComplete?: () => void;
+    /** A callback that is invoked when the process to add or update a note in the cart completes */
+    onNoteUpdateComplete?: () => void;
+    /** A callback that is invoked when the process to update the buyer identity completes */
+    onBuyerIdentityUpdateComplete?: () => void;
+    /** A callback that is invoked when the process to update the cart attributes completes */
+    onAttributesUpdateComplete?: () => void;
+    /** A callback that is invoked when the process to update the cart discount codes completes */
+    onDiscountCodesUpdateComplete?: () => void;
+    /** An object with fields that correspond to the Storefront API's [Cart object](https://shopify.dev/api/storefront/latest/objects/cart). */
+    data?: CartFragmentFragment;
+    /** A fragment used to query the Storefront API's [Cart object](https://shopify.dev/api/storefront/latest/objects/cart) for all queries and mutations. A default value is used if no argument is provided. */
+    cartFragment?: string;
+    /** A customer access token that's accessible on the server if there's a customer login. */
+    customerAccessToken?: CartBuyerIdentityInput['customerAccessToken'];
+    /** The ISO country code for i18n. */
+    countryCode?: CountryCode;
+}): JSX.Element;
+export declare const defaultCartFragment = "\nfragment CartFragment on Cart {\n  id\n  checkoutUrl\n  totalQuantity\n  buyerIdentity {\n    countryCode\n    customer {\n      id\n      email\n      firstName\n      lastName\n      displayName\n    }\n    email\n    phone\n  }\n  lines(first: $numCartLines) {\n    edges {\n      node {\n        id\n        quantity\n        attributes {\n          key\n          value\n        }\n        cost {\n          totalAmount {\n            amount\n            currencyCode\n          }\n          compareAtAmountPerQuantity {\n            amount\n            currencyCode\n          }\n        }\n        merchandise {\n          ... on ProductVariant {\n            id\n            availableForSale\n            compareAtPriceV2 {\n              ...MoneyFragment\n            }\n            priceV2 {\n              ...MoneyFragment\n            }\n            requiresShipping\n            title\n            image {\n              ...ImageFragment\n            }\n            product {\n              handle\n              title\n            }\n            selectedOptions {\n              name\n              value\n            }\n          }\n        }\n      }\n    }\n  }\n  cost {\n    subtotalAmount {\n      ...MoneyFragment\n    }\n    totalAmount {\n      ...MoneyFragment\n    }\n    totalDutyAmount {\n      ...MoneyFragment\n    }\n    totalTaxAmount {\n      ...MoneyFragment\n    }\n  }\n  note\n  attributes {\n    key\n    value\n  }\n  discountCodes {\n    code\n  }\n}\n\nfragment MoneyFragment on MoneyV2 {\n  currencyCode\n  amount\n}\nfragment ImageFragment on Image {\n  id\n  url\n  altText\n  width\n  height\n}\n";
diff --git a/dist/dist/esnext/components/CartProvider/CartProviderV2.client.js b/dist/dist/esnext/components/CartProvider/CartProviderV2.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..5abacc28a5443b5f3eefc97d5a212a14ff6a8f12
--- /dev/null
+++ b/dist/dist/esnext/components/CartProvider/CartProviderV2.client.js
@@ -0,0 +1,513 @@
+import React, { useCallback, useEffect, useMemo, useRef, useState, useTransition, } from 'react';
+import { CountryCode, } from '../../storefront-api-types.js';
+import { CartContext } from './context.js';
+import { useCartAPIStateMachine } from './useCartAPIStateMachine.client.js';
+import { CART_ID_STORAGE_KEY } from './constants.js';
+import { ClientAnalytics } from '../../foundation/Analytics/ClientAnalytics.js';
+export function CartProviderV2({ children, numCartLines, onCreate, onLineAdd, onLineRemove, onLineUpdate, onNoteUpdate, onBuyerIdentityUpdate, onAttributesUpdate, onDiscountCodesUpdate, onCreateComplete, onLineAddComplete, onLineRemoveComplete, onLineUpdateComplete, onNoteUpdateComplete, onBuyerIdentityUpdateComplete, onAttributesUpdateComplete, onDiscountCodesUpdateComplete, data: cart, cartFragment = defaultCartFragment, customerAccessToken, countryCode = CountryCode.Us, }) {
+    if (countryCode)
+        countryCode = countryCode.toUpperCase();
+    const [prevCountryCode, setPrevCountryCode] = useState(countryCode);
+    const [prevCustomerAccessToken, setPrevCustomerAccessToken] = useState(customerAccessToken);
+    const customerOverridesCountryCode = useRef(false);
+    if (prevCountryCode !== countryCode ||
+        prevCustomerAccessToken !== customerAccessToken) {
+        setPrevCountryCode(countryCode);
+        setPrevCustomerAccessToken(customerAccessToken);
+        customerOverridesCountryCode.current = false;
+    }
+    const [cartState, cartSend] = useCartAPIStateMachine({
+        numCartLines,
+        data: cart,
+        cartFragment,
+        countryCode,
+        onCartActionEntry(context, event) {
+            try {
+                switch (event.type) {
+                    case 'CART_CREATE':
+                        return onCreate?.();
+                    case 'CARTLINE_ADD':
+                        return onLineAdd?.();
+                    case 'CARTLINE_REMOVE':
+                        return onLineRemove?.();
+                    case 'CARTLINE_UPDATE':
+                        return onLineUpdate?.();
+                    case 'NOTE_UPDATE':
+                        return onNoteUpdate?.();
+                    case 'BUYER_IDENTITY_UPDATE':
+                        return onBuyerIdentityUpdate?.();
+                    case 'CART_ATTRIBUTES_UPDATE':
+                        return onAttributesUpdate?.();
+                    case 'DISCOUNT_CODES_UPDATE':
+                        return onDiscountCodesUpdate?.();
+                }
+            }
+            catch (error) {
+                console.error('Cart entry action failed', error);
+            }
+        },
+        onCartActionOptimisticUI(context, event) {
+            if (!context?.cart)
+                return { cart: undefined };
+            switch (event.type) {
+                case 'CARTLINE_REMOVE':
+                    return {
+                        ...context,
+                        lastValidCart: context.cart,
+                        cart: {
+                            ...context.cart,
+                            lines: context?.cart?.lines.filter(({ id }) => !event.payload.lines.includes(id)),
+                        },
+                    };
+                case 'CARTLINE_UPDATE':
+                    return {
+                        ...context,
+                        lastValidCart: context.cart,
+                        cart: {
+                            ...context.cart,
+                            lines: context.cart.lines.map((line) => {
+                                const updatedLine = event.payload.lines.find(({ id }) => id === line.id);
+                                if (updatedLine && updatedLine.quantity) {
+                                    return {
+                                        ...line,
+                                        quantity: updatedLine.quantity,
+                                    };
+                                }
+                                return line;
+                            }),
+                        },
+                    };
+            }
+            return { cart: context.cart ? { ...context.cart } : undefined };
+        },
+        onCartActionComplete(context, event) {
+            const cartActionEvent = event.payload.cartActionEvent;
+            try {
+                switch (event.type) {
+                    case 'RESOLVE':
+                        switch (cartActionEvent.type) {
+                            case 'CART_CREATE':
+                                publishCreateAnalytics(context, cartActionEvent);
+                                return onCreateComplete?.();
+                            case 'CARTLINE_ADD':
+                                publishLineAddAnalytics(context, cartActionEvent);
+                                return onLineAddComplete?.();
+                            case 'CARTLINE_REMOVE':
+                                publishLineRemoveAnalytics(context, cartActionEvent);
+                                return onLineRemoveComplete?.();
+                            case 'CARTLINE_UPDATE':
+                                publishLineUpdateAnalytics(context, cartActionEvent);
+                                return onLineUpdateComplete?.();
+                            case 'NOTE_UPDATE':
+                                return onNoteUpdateComplete?.();
+                            case 'BUYER_IDENTITY_UPDATE':
+                                if (countryCodeNotUpdated(context, cartActionEvent)) {
+                                    customerOverridesCountryCode.current = true;
+                                }
+                                return onBuyerIdentityUpdateComplete?.();
+                            case 'CART_ATTRIBUTES_UPDATE':
+                                return onAttributesUpdateComplete?.();
+                            case 'DISCOUNT_CODES_UPDATE':
+                                publishDiscountCodesUpdateAnalytics(context, cartActionEvent);
+                                return onDiscountCodesUpdateComplete?.();
+                        }
+                }
+            }
+            catch (error) {
+                console.error('onCartActionComplete failed', error);
+            }
+        },
+    });
+    const cartReady = useRef(false);
+    const cartCompleted = cartState.matches('cartCompleted');
+    const countryChanged = (cartState.value === 'idle' ||
+        cartState.value === 'error' ||
+        cartState.value === 'cartCompleted') &&
+        countryCode !== cartState?.context?.cart?.buyerIdentity?.countryCode &&
+        !cartState.context.errors;
+    const fetchingFromStorage = useRef(false);
+    /**
+     * Initializes cart with priority in this order:
+     * 1. cart props
+     * 2. localStorage cartId
+     */
+    useEffect(() => {
+        if (!cartReady.current && !fetchingFromStorage.current) {
+            if (!cart && storageAvailable('localStorage')) {
+                fetchingFromStorage.current = true;
+                try {
+                    const cartId = window.localStorage.getItem(CART_ID_STORAGE_KEY);
+                    if (cartId) {
+                        cartSend({ type: 'CART_FETCH', payload: { cartId } });
+                    }
+                }
+                catch (error) {
+                    console.warn('error fetching cartId');
+                    console.warn(error);
+                }
+            }
+            cartReady.current = true;
+        }
+    }, [cart, cartReady, cartSend]);
+    // Update cart country code if cart and props countryCode's as different
+    useEffect(() => {
+        if (!countryChanged || customerOverridesCountryCode.current)
+            return;
+        cartSend({
+            type: 'BUYER_IDENTITY_UPDATE',
+            payload: { buyerIdentity: { countryCode, customerAccessToken } },
+        });
+    }, [
+        countryCode,
+        customerAccessToken,
+        countryChanged,
+        customerOverridesCountryCode,
+        cartSend,
+    ]);
+    // send cart events when ready
+    const onCartReadySend = useCallback((cartEvent) => {
+        if (!cartReady.current) {
+            return console.warn("Cart isn't ready yet");
+        }
+        cartSend(cartEvent);
+    }, [cartSend]);
+    // save cart id to local storage
+    useEffect(() => {
+        if (cartState?.context?.cart?.id && storageAvailable('localStorage')) {
+            try {
+                window.localStorage.setItem(CART_ID_STORAGE_KEY, cartState.context.cart?.id);
+            }
+            catch (error) {
+                console.warn('Failed to save cartId to localStorage', error);
+            }
+        }
+    }, [cartState?.context?.cart?.id]);
+    // delete cart from local storage if cart fetched has been completed
+    useEffect(() => {
+        if (cartCompleted && storageAvailable('localStorage')) {
+            try {
+                window.localStorage.removeItem(CART_ID_STORAGE_KEY);
+            }
+            catch (error) {
+                console.warn('Failed to delete cartId from localStorage', error);
+            }
+        }
+    }, [cartCompleted]);
+    const cartCreate = useCallback((cartInput) => {
+        if (countryCode && !cartInput.buyerIdentity?.countryCode) {
+            if (cartInput.buyerIdentity == null) {
+                cartInput.buyerIdentity = {};
+            }
+            cartInput.buyerIdentity.countryCode = countryCode;
+        }
+        if (customerAccessToken &&
+            !cartInput.buyerIdentity?.customerAccessToken) {
+            if (cartInput.buyerIdentity == null) {
+                cartInput.buyerIdentity = {};
+            }
+            cartInput.buyerIdentity.customerAccessToken = customerAccessToken;
+        }
+        onCartReadySend({
+            type: 'CART_CREATE',
+            payload: cartInput,
+        });
+    }, [countryCode, customerAccessToken, onCartReadySend]);
+    // Delays the cart state in the context if the page is hydrating
+    // preventing suspense boundary errors.
+    const cartDisplayState = useDelayedStateUntilHydration(cartState);
+    const cartContextValue = useMemo(() => {
+        return {
+            ...(cartDisplayState?.context?.cart ?? { lines: [], attributes: [] }),
+            status: transposeStatus(cartDisplayState.value),
+            error: cartDisplayState?.context?.errors,
+            totalQuantity: cartDisplayState?.context?.cart?.totalQuantity ?? 0,
+            cartCreate,
+            linesAdd(lines) {
+                if (cartDisplayState?.context?.cart?.id) {
+                    onCartReadySend({
+                        type: 'CARTLINE_ADD',
+                        payload: { lines },
+                    });
+                }
+                else {
+                    cartCreate({ lines });
+                }
+            },
+            linesRemove(lines) {
+                onCartReadySend({
+                    type: 'CARTLINE_REMOVE',
+                    payload: {
+                        lines,
+                    },
+                });
+            },
+            linesUpdate(lines) {
+                onCartReadySend({
+                    type: 'CARTLINE_UPDATE',
+                    payload: {
+                        lines,
+                    },
+                });
+            },
+            noteUpdate(note) {
+                onCartReadySend({
+                    type: 'NOTE_UPDATE',
+                    payload: {
+                        note,
+                    },
+                });
+            },
+            buyerIdentityUpdate(buyerIdentity) {
+                onCartReadySend({
+                    type: 'BUYER_IDENTITY_UPDATE',
+                    payload: {
+                        buyerIdentity,
+                    },
+                });
+            },
+            cartAttributesUpdate(attributes) {
+                onCartReadySend({
+                    type: 'CART_ATTRIBUTES_UPDATE',
+                    payload: {
+                        attributes,
+                    },
+                });
+            },
+            discountCodesUpdate(discountCodes) {
+                onCartReadySend({
+                    type: 'DISCOUNT_CODES_UPDATE',
+                    payload: {
+                        discountCodes,
+                    },
+                });
+            },
+            cartFragment,
+        };
+    }, [
+        cartCreate,
+        cartDisplayState?.context?.cart,
+        cartDisplayState?.context?.errors,
+        cartDisplayState.value,
+        cartFragment,
+        onCartReadySend,
+    ]);
+    return (React.createElement(CartContext.Provider, { value: cartContextValue }, children));
+}
+function transposeStatus(status) {
+    switch (status) {
+        case 'uninitialized':
+        case 'initializationError':
+            return 'uninitialized';
+        case 'idle':
+        case 'cartCompleted':
+        case 'error':
+            return 'idle';
+        case 'cartFetching':
+            return 'fetching';
+        case 'cartCreating':
+            return 'creating';
+        case 'cartLineAdding':
+        case 'cartLineRemoving':
+        case 'cartLineUpdating':
+        case 'noteUpdating':
+        case 'buyerIdentityUpdating':
+        case 'cartAttributesUpdating':
+        case 'discountCodesUpdating':
+            return 'updating';
+    }
+}
+/**
+ * Delays a state update until hydration finishes. Useful for preventing suspense boundaries errors when updating a context
+ * @remarks this uses startTransition and waits for it to finish.
+ */
+function useDelayedStateUntilHydration(state) {
+    const [isPending, startTransition] = useTransition();
+    const [delayedState, setDelayedState] = useState(state);
+    const firstTimePending = useRef(false);
+    if (isPending) {
+        firstTimePending.current = true;
+    }
+    const firstTimePendingFinished = useRef(false);
+    if (!isPending && firstTimePending.current) {
+        firstTimePendingFinished.current = true;
+    }
+    useEffect(() => {
+        startTransition(() => {
+            if (!firstTimePendingFinished.current) {
+                setDelayedState(state);
+            }
+        });
+    }, [state]);
+    const displayState = firstTimePendingFinished.current ? state : delayedState;
+    return displayState;
+}
+/** Check for storage availability funciton obtained from
+ * https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API
+ */
+function storageAvailable(type) {
+    let storage;
+    try {
+        storage = window[type];
+        const x = '__storage_test__';
+        storage.setItem(x, x);
+        storage.removeItem(x);
+        return true;
+    }
+    catch (e) {
+        return (e instanceof DOMException &&
+            // everything except Firefox
+            (e.code === 22 ||
+                // Firefox
+                e.code === 1014 ||
+                // test name field too, because code might not be present
+                // everything except Firefox
+                e.name === 'QuotaExceededError' ||
+                // Firefox
+                e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&
+            // acknowledge QuotaExceededError only if there's something already stored
+            storage &&
+            storage.length !== 0);
+    }
+}
+function countryCodeNotUpdated(context, event) {
+    return (event.payload.buyerIdentity.countryCode &&
+        context.cart?.buyerIdentity?.countryCode !==
+            event.payload.buyerIdentity.countryCode);
+}
+// Cart Analytics
+function publishCreateAnalytics(context, event) {
+    ClientAnalytics.publish(ClientAnalytics.eventNames.ADD_TO_CART, true, {
+        addedCartLines: event.payload.lines,
+        cart: context.rawCartResult,
+        prevCart: null,
+    });
+}
+function publishLineAddAnalytics(context, event) {
+    ClientAnalytics.publish(ClientAnalytics.eventNames.ADD_TO_CART, true, {
+        addedCartLines: event.payload.lines,
+        cart: context.rawCartResult,
+        prevCart: context.prevCart,
+    });
+}
+function publishLineUpdateAnalytics(context, event) {
+    ClientAnalytics.publish(ClientAnalytics.eventNames.UPDATE_CART, true, {
+        updatedCartLines: event.payload.lines,
+        oldCart: context.prevCart,
+        cart: context.rawCartResult,
+        prevCart: context.prevCart,
+    });
+}
+function publishLineRemoveAnalytics(context, event) {
+    ClientAnalytics.publish(ClientAnalytics.eventNames.REMOVE_FROM_CART, true, {
+        removedCartLines: event.payload.lines,
+        cart: context.rawCartResult,
+        prevCart: context.prevCart,
+    });
+}
+function publishDiscountCodesUpdateAnalytics(context, event) {
+    ClientAnalytics.publish(ClientAnalytics.eventNames.DISCOUNT_CODE_UPDATED, true, {
+        updatedDiscountCodes: event.payload.discountCodes,
+        cart: context.rawCartResult,
+        prevCart: context.prevCart,
+    });
+}
+export const defaultCartFragment = `
+fragment CartFragment on Cart {
+  id
+  checkoutUrl
+  totalQuantity
+  buyerIdentity {
+    countryCode
+    customer {
+      id
+      email
+      firstName
+      lastName
+      displayName
+    }
+    email
+    phone
+  }
+  lines(first: $numCartLines) {
+    edges {
+      node {
+        id
+        quantity
+        attributes {
+          key
+          value
+        }
+        cost {
+          totalAmount {
+            amount
+            currencyCode
+          }
+          compareAtAmountPerQuantity {
+            amount
+            currencyCode
+          }
+        }
+        merchandise {
+          ... on ProductVariant {
+            id
+            availableForSale
+            compareAtPriceV2 {
+              ...MoneyFragment
+            }
+            priceV2 {
+              ...MoneyFragment
+            }
+            requiresShipping
+            title
+            image {
+              ...ImageFragment
+            }
+            product {
+              handle
+              title
+            }
+            selectedOptions {
+              name
+              value
+            }
+          }
+        }
+      }
+    }
+  }
+  cost {
+    subtotalAmount {
+      ...MoneyFragment
+    }
+    totalAmount {
+      ...MoneyFragment
+    }
+    totalDutyAmount {
+      ...MoneyFragment
+    }
+    totalTaxAmount {
+      ...MoneyFragment
+    }
+  }
+  note
+  attributes {
+    key
+    value
+  }
+  discountCodes {
+    code
+  }
+}
+
+fragment MoneyFragment on MoneyV2 {
+  currencyCode
+  amount
+}
+fragment ImageFragment on Image {
+  id
+  url
+  altText
+  width
+  height
+}
+`;
diff --git a/dist/dist/esnext/components/CartProvider/cart-queries.d.ts b/dist/dist/esnext/components/CartProvider/cart-queries.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cb4406cec7eed25ec3e88be1108ef7f9d691847e
--- /dev/null
+++ b/dist/dist/esnext/components/CartProvider/cart-queries.d.ts
@@ -0,0 +1,10 @@
+export declare const CartLineAdd: (cartFragment: string) => string;
+export declare const CartCreate: (cartFragment: string) => string;
+export declare const CartLineRemove: (cartFragment: string) => string;
+export declare const CartLineUpdate: (cartFragment: string) => string;
+export declare const CartNoteUpdate: (cartFragment: string) => string;
+export declare const CartBuyerIdentityUpdate: (cartFragment: string) => string;
+export declare const CartAttributesUpdate: (cartFragment: string) => string;
+export declare const CartDiscountCodesUpdate: (cartFragment: string) => string;
+export declare const CartQuery: (cartFragment: string) => string;
+export declare const defaultCartFragment = "\nfragment CartFragment on Cart {\n  id\n  checkoutUrl\n  totalQuantity\n  buyerIdentity {\n    countryCode\n    customer {\n      id\n      email\n      firstName\n      lastName\n      displayName\n    }\n    email\n    phone\n  }\n  lines(first: $numCartLines) {\n    edges {\n      node {\n        id\n        quantity\n        attributes {\n          key\n          value\n        }\n        cost {\n          totalAmount {\n            amount\n            currencyCode\n          }\n          compareAtAmountPerQuantity {\n            amount\n            currencyCode\n          }\n        }\n        merchandise {\n          ... on ProductVariant {\n            id\n            availableForSale\n            compareAtPriceV2 {\n              ...MoneyFragment\n            }\n            priceV2 {\n              ...MoneyFragment\n            }\n            requiresShipping\n            title\n            image {\n              ...ImageFragment\n            }\n            product {\n              handle\n              title\n              id\n            }\n            selectedOptions {\n              name\n              value\n            }\n          }\n        }\n      }\n    }\n  }\n  cost {\n    subtotalAmount {\n      ...MoneyFragment\n    }\n    totalAmount {\n      ...MoneyFragment\n    }\n    totalDutyAmount {\n      ...MoneyFragment\n    }\n    totalTaxAmount {\n      ...MoneyFragment\n    }\n  }\n  note\n  attributes {\n    key\n    value\n  }\n  discountCodes {\n    code\n  }\n}\n\nfragment MoneyFragment on MoneyV2 {\n  currencyCode\n  amount\n}\nfragment ImageFragment on Image {\n  id\n  url\n  altText\n  width\n  height\n}\n";
diff --git a/dist/dist/esnext/components/CartProvider/cart-queries.js b/dist/dist/esnext/components/CartProvider/cart-queries.js
new file mode 100644
index 0000000000000000000000000000000000000000..c7012a99096b4f1af28103e90332eb690cde4a20
--- /dev/null
+++ b/dist/dist/esnext/components/CartProvider/cart-queries.js
@@ -0,0 +1,203 @@
+export const CartLineAdd = (cartFragment) => `
+mutation CartLineAdd($cartId: ID!, $lines: [CartLineInput!]!, $numCartLines: Int = 250, $country: CountryCode = ZZ) @inContext(country: $country) {
+  cartLinesAdd(cartId: $cartId, lines: $lines) {
+    cart {
+      ...CartFragment
+    }
+  }
+}
+
+${cartFragment}
+`;
+export const CartCreate = (cartFragment) => `
+mutation CartCreate($input: CartInput!, $numCartLines: Int = 250, $country: CountryCode = ZZ) @inContext(country: $country) {
+  cartCreate(input: $input) {
+    cart {
+      ...CartFragment
+    }
+  }
+}
+
+${cartFragment}
+`;
+export const CartLineRemove = (cartFragment) => `
+mutation CartLineRemove($cartId: ID!, $lines: [ID!]!, $numCartLines: Int = 250, $country: CountryCode = ZZ) @inContext(country: $country) {
+  cartLinesRemove(cartId: $cartId, lineIds: $lines) {
+    cart {
+      ...CartFragment
+    }
+  }
+}
+
+${cartFragment}
+`;
+export const CartLineUpdate = (cartFragment) => `
+mutation CartLineUpdate($cartId: ID!, $lines: [CartLineUpdateInput!]!, $numCartLines: Int = 250, $country: CountryCode = ZZ) @inContext(country: $country) {
+  cartLinesUpdate(cartId: $cartId, lines: $lines) {
+    cart {
+      ...CartFragment
+    }
+  }
+}
+
+${cartFragment}
+`;
+export const CartNoteUpdate = (cartFragment) => `
+mutation CartNoteUpdate($cartId: ID!, $note: String, $numCartLines: Int = 250, $country: CountryCode = ZZ) @inContext(country: $country) {
+  cartNoteUpdate(cartId: $cartId, note: $note) {
+    cart {
+      ...CartFragment
+    }
+  }
+}
+
+${cartFragment}
+`;
+export const CartBuyerIdentityUpdate = (cartFragment) => `
+mutation CartBuyerIdentityUpdate(
+  $cartId: ID!
+  $buyerIdentity: CartBuyerIdentityInput!
+  $numCartLines: Int = 250
+  $country: CountryCode = ZZ
+) @inContext(country: $country) {
+  cartBuyerIdentityUpdate(cartId: $cartId, buyerIdentity: $buyerIdentity) {
+    cart {
+      ...CartFragment
+    }
+  }
+}
+
+${cartFragment}
+`;
+export const CartAttributesUpdate = (cartFragment) => `
+mutation CartAttributesUpdate($attributes: [AttributeInput!]!, $cartId: ID!, $numCartLines: Int = 250, $country: CountryCode = ZZ) @inContext(country: $country) {
+  cartAttributesUpdate(attributes: $attributes, cartId: $cartId) {
+    cart {
+      ...CartFragment
+    }
+  }
+}
+
+${cartFragment}
+`;
+export const CartDiscountCodesUpdate = (cartFragment) => `
+mutation CartDiscountCodesUpdate($cartId: ID!, $discountCodes: [String!], $numCartLines: Int = 250, $country: CountryCode = ZZ) @inContext(country: $country) {
+  cartDiscountCodesUpdate(cartId: $cartId, discountCodes: $discountCodes) {
+    cart {
+      ...CartFragment
+    }
+  }
+}
+
+${cartFragment}
+`;
+export const CartQuery = (cartFragment) => `
+query CartQuery($id: ID!, $numCartLines: Int = 250, $country: CountryCode = ZZ) @inContext(country: $country) {
+  cart(id: $id) {
+    ...CartFragment
+  }
+}
+
+${cartFragment}
+`;
+export const defaultCartFragment = `
+fragment CartFragment on Cart {
+  id
+  checkoutUrl
+  totalQuantity
+  buyerIdentity {
+    countryCode
+    customer {
+      id
+      email
+      firstName
+      lastName
+      displayName
+    }
+    email
+    phone
+  }
+  lines(first: $numCartLines) {
+    edges {
+      node {
+        id
+        quantity
+        attributes {
+          key
+          value
+        }
+        cost {
+          totalAmount {
+            amount
+            currencyCode
+          }
+          compareAtAmountPerQuantity {
+            amount
+            currencyCode
+          }
+        }
+        merchandise {
+          ... on ProductVariant {
+            id
+            availableForSale
+            compareAtPriceV2 {
+              ...MoneyFragment
+            }
+            priceV2 {
+              ...MoneyFragment
+            }
+            requiresShipping
+            title
+            image {
+              ...ImageFragment
+            }
+            product {
+              handle
+              title
+              id
+            }
+            selectedOptions {
+              name
+              value
+            }
+          }
+        }
+      }
+    }
+  }
+  cost {
+    subtotalAmount {
+      ...MoneyFragment
+    }
+    totalAmount {
+      ...MoneyFragment
+    }
+    totalDutyAmount {
+      ...MoneyFragment
+    }
+    totalTaxAmount {
+      ...MoneyFragment
+    }
+  }
+  note
+  attributes {
+    key
+    value
+  }
+  discountCodes {
+    code
+  }
+}
+
+fragment MoneyFragment on MoneyV2 {
+  currencyCode
+  amount
+}
+fragment ImageFragment on Image {
+  id
+  url
+  altText
+  width
+  height
+}
+`;
diff --git a/dist/dist/esnext/components/CartProvider/constants.d.ts b/dist/dist/esnext/components/CartProvider/constants.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..20741815b5bae175bbf8238087458ec958b66c8e
--- /dev/null
+++ b/dist/dist/esnext/components/CartProvider/constants.d.ts
@@ -0,0 +1,2 @@
+export declare const CART_ID_STORAGE_KEY = "shopifyCartId";
+export declare const CART_COOKIE_TTL_DAYS = 14;
diff --git a/dist/dist/esnext/components/CartProvider/constants.js b/dist/dist/esnext/components/CartProvider/constants.js
new file mode 100644
index 0000000000000000000000000000000000000000..f3025db06e0f3d3cbf2b0a81b02bc2864235976f
--- /dev/null
+++ b/dist/dist/esnext/components/CartProvider/constants.js
@@ -0,0 +1,2 @@
+export const CART_ID_STORAGE_KEY = 'shopifyCartId';
+export const CART_COOKIE_TTL_DAYS = 14;
diff --git a/dist/dist/esnext/components/CartProvider/context.d.ts b/dist/dist/esnext/components/CartProvider/context.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a045d9f4512b80c29916797dbb8f06fcc9ae2204
--- /dev/null
+++ b/dist/dist/esnext/components/CartProvider/context.d.ts
@@ -0,0 +1,2 @@
+import { CartWithActions } from './types.js';
+export declare const CartContext: import("react").Context<CartWithActions | null>;
diff --git a/dist/dist/esnext/components/CartProvider/context.js b/dist/dist/esnext/components/CartProvider/context.js
new file mode 100644
index 0000000000000000000000000000000000000000..797b9f7a81452c6fa80abb9e3e4e9283036f22cf
--- /dev/null
+++ b/dist/dist/esnext/components/CartProvider/context.js
@@ -0,0 +1,2 @@
+import { createContext } from 'react';
+export const CartContext = createContext(null);
diff --git a/dist/dist/esnext/components/CartProvider/graphql/CartAttributesUpdateMutation.d.ts b/dist/dist/esnext/components/CartProvider/graphql/CartAttributesUpdateMutation.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0afa82ae0552065af671f663ca44dd135f5be1d5
--- /dev/null
+++ b/dist/dist/esnext/components/CartProvider/graphql/CartAttributesUpdateMutation.d.ts
@@ -0,0 +1,96 @@
+/**
+ * THIS FILE IS AUTO-GENERATED, DO NOT EDIT.
+ * Instead, you can edit the associated .graphql file to query for additional fields and this file will be updated when you run `yarn graphql-types`
+ */
+import * as Types from '../../../storefront-api-types.js';
+export declare type CartAttributesUpdateMutationVariables = Types.Exact<{
+    attributes: Array<Types.AttributeInput> | Types.AttributeInput;
+    cartId: Types.Scalars['ID'];
+    numCartLines?: Types.InputMaybe<Types.Scalars['Int']>;
+    country?: Types.InputMaybe<Types.CountryCode>;
+}>;
+export declare type CartAttributesUpdateMutation = {
+    __typename?: 'Mutation';
+} & {
+    cartAttributesUpdate?: Types.Maybe<{
+        __typename?: 'CartAttributesUpdatePayload';
+    } & {
+        cart?: Types.Maybe<{
+            __typename?: 'Cart';
+        } & Pick<Types.Cart, 'id' | 'checkoutUrl' | 'totalQuantity' | 'note'> & {
+            buyerIdentity: {
+                __typename?: 'CartBuyerIdentity';
+            } & Pick<Types.CartBuyerIdentity, 'countryCode' | 'email' | 'phone'> & {
+                customer?: Types.Maybe<{
+                    __typename?: 'Customer';
+                } & Pick<Types.Customer, 'id' | 'email' | 'firstName' | 'lastName' | 'displayName'>>;
+            };
+            lines: {
+                __typename?: 'CartLineConnection';
+            } & {
+                edges: Array<{
+                    __typename?: 'CartLineEdge';
+                } & {
+                    node: {
+                        __typename?: 'CartLine';
+                    } & Pick<Types.CartLine, 'id' | 'quantity'> & {
+                        attributes: Array<{
+                            __typename?: 'Attribute';
+                        } & Pick<Types.Attribute, 'key' | 'value'>>;
+                        cost: {
+                            __typename?: 'CartLineCost';
+                        } & {
+                            totalAmount: {
+                                __typename?: 'MoneyV2';
+                            } & Pick<Types.MoneyV2, 'amount' | 'currencyCode'>;
+                            compareAtAmountPerQuantity?: Types.Maybe<{
+                                __typename?: 'MoneyV2';
+                            } & Pick<Types.MoneyV2, 'amount' | 'currencyCode'>>;
+                        };
+                        merchandise: {
+                            __typename?: 'ProductVariant';
+                        } & Pick<Types.ProductVariant, 'id' | 'availableForSale' | 'requiresShipping' | 'title'> & {
+                            compareAtPriceV2?: Types.Maybe<{
+                                __typename?: 'MoneyV2';
+                            } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>>;
+                            priceV2: {
+                                __typename?: 'MoneyV2';
+                            } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>;
+                            image?: Types.Maybe<{
+                                __typename?: 'Image';
+                            } & Pick<Types.Image, 'id' | 'url' | 'altText' | 'width' | 'height'>>;
+                            product: {
+                                __typename?: 'Product';
+                            } & Pick<Types.Product, 'handle' | 'title'>;
+                            selectedOptions: Array<{
+                                __typename?: 'SelectedOption';
+                            } & Pick<Types.SelectedOption, 'name' | 'value'>>;
+                        };
+                    };
+                }>;
+            };
+            cost: {
+                __typename?: 'CartCost';
+            } & {
+                subtotalAmount: {
+                    __typename?: 'MoneyV2';
+                } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>;
+                totalAmount: {
+                    __typename?: 'MoneyV2';
+                } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>;
+                totalDutyAmount?: Types.Maybe<{
+                    __typename?: 'MoneyV2';
+                } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>>;
+                totalTaxAmount?: Types.Maybe<{
+                    __typename?: 'MoneyV2';
+                } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>>;
+            };
+            attributes: Array<{
+                __typename?: 'Attribute';
+            } & Pick<Types.Attribute, 'key' | 'value'>>;
+            discountCodes: Array<{
+                __typename?: 'CartDiscountCode';
+            } & Pick<Types.CartDiscountCode, 'code' | 'applicable'>>;
+        }>;
+    }>;
+};
diff --git a/dist/dist/esnext/components/CartProvider/graphql/CartAttributesUpdateMutation.js b/dist/dist/esnext/components/CartProvider/graphql/CartAttributesUpdateMutation.js
new file mode 100644
index 0000000000000000000000000000000000000000..cb0ff5c3b541f646105198ee23ac0fc3d805023e
--- /dev/null
+++ b/dist/dist/esnext/components/CartProvider/graphql/CartAttributesUpdateMutation.js
@@ -0,0 +1 @@
+export {};
diff --git a/dist/dist/esnext/components/CartProvider/graphql/CartBuyerIdentityUpdateMutation.d.ts b/dist/dist/esnext/components/CartProvider/graphql/CartBuyerIdentityUpdateMutation.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b5434aad9d0f2944b62a9b274b4796636a5f189d
--- /dev/null
+++ b/dist/dist/esnext/components/CartProvider/graphql/CartBuyerIdentityUpdateMutation.d.ts
@@ -0,0 +1,96 @@
+/**
+ * THIS FILE IS AUTO-GENERATED, DO NOT EDIT.
+ * Instead, you can edit the associated .graphql file to query for additional fields and this file will be updated when you run `yarn graphql-types`
+ */
+import * as Types from '../../../storefront-api-types.js';
+export declare type CartBuyerIdentityUpdateMutationVariables = Types.Exact<{
+    cartId: Types.Scalars['ID'];
+    buyerIdentity: Types.CartBuyerIdentityInput;
+    numCartLines?: Types.InputMaybe<Types.Scalars['Int']>;
+    country?: Types.InputMaybe<Types.CountryCode>;
+}>;
+export declare type CartBuyerIdentityUpdateMutation = {
+    __typename?: 'Mutation';
+} & {
+    cartBuyerIdentityUpdate?: Types.Maybe<{
+        __typename?: 'CartBuyerIdentityUpdatePayload';
+    } & {
+        cart?: Types.Maybe<{
+            __typename?: 'Cart';
+        } & Pick<Types.Cart, 'id' | 'checkoutUrl' | 'totalQuantity' | 'note'> & {
+            buyerIdentity: {
+                __typename?: 'CartBuyerIdentity';
+            } & Pick<Types.CartBuyerIdentity, 'countryCode' | 'email' | 'phone'> & {
+                customer?: Types.Maybe<{
+                    __typename?: 'Customer';
+                } & Pick<Types.Customer, 'id' | 'email' | 'firstName' | 'lastName' | 'displayName'>>;
+            };
+            lines: {
+                __typename?: 'CartLineConnection';
+            } & {
+                edges: Array<{
+                    __typename?: 'CartLineEdge';
+                } & {
+                    node: {
+                        __typename?: 'CartLine';
+                    } & Pick<Types.CartLine, 'id' | 'quantity'> & {
+                        attributes: Array<{
+                            __typename?: 'Attribute';
+                        } & Pick<Types.Attribute, 'key' | 'value'>>;
+                        cost: {
+                            __typename?: 'CartLineCost';
+                        } & {
+                            totalAmount: {
+                                __typename?: 'MoneyV2';
+                            } & Pick<Types.MoneyV2, 'amount' | 'currencyCode'>;
+                            compareAtAmountPerQuantity?: Types.Maybe<{
+                                __typename?: 'MoneyV2';
+                            } & Pick<Types.MoneyV2, 'amount' | 'currencyCode'>>;
+                        };
+                        merchandise: {
+                            __typename?: 'ProductVariant';
+                        } & Pick<Types.ProductVariant, 'id' | 'availableForSale' | 'requiresShipping' | 'title'> & {
+                            compareAtPriceV2?: Types.Maybe<{
+                                __typename?: 'MoneyV2';
+                            } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>>;
+                            priceV2: {
+                                __typename?: 'MoneyV2';
+                            } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>;
+                            image?: Types.Maybe<{
+                                __typename?: 'Image';
+                            } & Pick<Types.Image, 'id' | 'url' | 'altText' | 'width' | 'height'>>;
+                            product: {
+                                __typename?: 'Product';
+                            } & Pick<Types.Product, 'handle' | 'title'>;
+                            selectedOptions: Array<{
+                                __typename?: 'SelectedOption';
+                            } & Pick<Types.SelectedOption, 'name' | 'value'>>;
+                        };
+                    };
+                }>;
+            };
+            cost: {
+                __typename?: 'CartCost';
+            } & {
+                subtotalAmount: {
+                    __typename?: 'MoneyV2';
+                } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>;
+                totalAmount: {
+                    __typename?: 'MoneyV2';
+                } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>;
+                totalDutyAmount?: Types.Maybe<{
+                    __typename?: 'MoneyV2';
+                } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>>;
+                totalTaxAmount?: Types.Maybe<{
+                    __typename?: 'MoneyV2';
+                } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>>;
+            };
+            attributes: Array<{
+                __typename?: 'Attribute';
+            } & Pick<Types.Attribute, 'key' | 'value'>>;
+            discountCodes: Array<{
+                __typename?: 'CartDiscountCode';
+            } & Pick<Types.CartDiscountCode, 'code' | 'applicable'>>;
+        }>;
+    }>;
+};
diff --git a/dist/dist/esnext/components/CartProvider/graphql/CartBuyerIdentityUpdateMutation.js b/dist/dist/esnext/components/CartProvider/graphql/CartBuyerIdentityUpdateMutation.js
new file mode 100644
index 0000000000000000000000000000000000000000..cb0ff5c3b541f646105198ee23ac0fc3d805023e
--- /dev/null
+++ b/dist/dist/esnext/components/CartProvider/graphql/CartBuyerIdentityUpdateMutation.js
@@ -0,0 +1 @@
+export {};
diff --git a/dist/dist/esnext/components/CartProvider/graphql/CartCreateMutation.d.ts b/dist/dist/esnext/components/CartProvider/graphql/CartCreateMutation.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a17166fd1aa886a83c1e475dbdf34b4a6ed5daf0
--- /dev/null
+++ b/dist/dist/esnext/components/CartProvider/graphql/CartCreateMutation.d.ts
@@ -0,0 +1,95 @@
+/**
+ * THIS FILE IS AUTO-GENERATED, DO NOT EDIT.
+ * Instead, you can edit the associated .graphql file to query for additional fields and this file will be updated when you run `yarn graphql-types`
+ */
+import * as Types from '../../../storefront-api-types.js';
+export declare type CartCreateMutationVariables = Types.Exact<{
+    input: Types.CartInput;
+    numCartLines?: Types.InputMaybe<Types.Scalars['Int']>;
+    country?: Types.InputMaybe<Types.CountryCode>;
+}>;
+export declare type CartCreateMutation = {
+    __typename?: 'Mutation';
+} & {
+    cartCreate?: Types.Maybe<{
+        __typename?: 'CartCreatePayload';
+    } & {
+        cart?: Types.Maybe<{
+            __typename?: 'Cart';
+        } & Pick<Types.Cart, 'id' | 'checkoutUrl' | 'totalQuantity' | 'note'> & {
+            buyerIdentity: {
+                __typename?: 'CartBuyerIdentity';
+            } & Pick<Types.CartBuyerIdentity, 'countryCode' | 'email' | 'phone'> & {
+                customer?: Types.Maybe<{
+                    __typename?: 'Customer';
+                } & Pick<Types.Customer, 'id' | 'email' | 'firstName' | 'lastName' | 'displayName'>>;
+            };
+            lines: {
+                __typename?: 'CartLineConnection';
+            } & {
+                edges: Array<{
+                    __typename?: 'CartLineEdge';
+                } & {
+                    node: {
+                        __typename?: 'CartLine';
+                    } & Pick<Types.CartLine, 'id' | 'quantity'> & {
+                        attributes: Array<{
+                            __typename?: 'Attribute';
+                        } & Pick<Types.Attribute, 'key' | 'value'>>;
+                        cost: {
+                            __typename?: 'CartLineCost';
+                        } & {
+                            totalAmount: {
+                                __typename?: 'MoneyV2';
+                            } & Pick<Types.MoneyV2, 'amount' | 'currencyCode'>;
+                            compareAtAmountPerQuantity?: Types.Maybe<{
+                                __typename?: 'MoneyV2';
+                            } & Pick<Types.MoneyV2, 'amount' | 'currencyCode'>>;
+                        };
+                        merchandise: {
+                            __typename?: 'ProductVariant';
+                        } & Pick<Types.ProductVariant, 'id' | 'availableForSale' | 'requiresShipping' | 'title'> & {
+                            compareAtPriceV2?: Types.Maybe<{
+                                __typename?: 'MoneyV2';
+                            } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>>;
+                            priceV2: {
+                                __typename?: 'MoneyV2';
+                            } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>;
+                            image?: Types.Maybe<{
+                                __typename?: 'Image';
+                            } & Pick<Types.Image, 'id' | 'url' | 'altText' | 'width' | 'height'>>;
+                            product: {
+                                __typename?: 'Product';
+                            } & Pick<Types.Product, 'handle' | 'title'>;
+                            selectedOptions: Array<{
+                                __typename?: 'SelectedOption';
+                            } & Pick<Types.SelectedOption, 'name' | 'value'>>;
+                        };
+                    };
+                }>;
+            };
+            cost: {
+                __typename?: 'CartCost';
+            } & {
+                subtotalAmount: {
+                    __typename?: 'MoneyV2';
+                } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>;
+                totalAmount: {
+                    __typename?: 'MoneyV2';
+                } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>;
+                totalDutyAmount?: Types.Maybe<{
+                    __typename?: 'MoneyV2';
+                } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>>;
+                totalTaxAmount?: Types.Maybe<{
+                    __typename?: 'MoneyV2';
+                } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>>;
+            };
+            attributes: Array<{
+                __typename?: 'Attribute';
+            } & Pick<Types.Attribute, 'key' | 'value'>>;
+            discountCodes: Array<{
+                __typename?: 'CartDiscountCode';
+            } & Pick<Types.CartDiscountCode, 'code' | 'applicable'>>;
+        }>;
+    }>;
+};
diff --git a/dist/dist/esnext/components/CartProvider/graphql/CartCreateMutation.js b/dist/dist/esnext/components/CartProvider/graphql/CartCreateMutation.js
new file mode 100644
index 0000000000000000000000000000000000000000..cb0ff5c3b541f646105198ee23ac0fc3d805023e
--- /dev/null
+++ b/dist/dist/esnext/components/CartProvider/graphql/CartCreateMutation.js
@@ -0,0 +1 @@
+export {};
diff --git a/dist/dist/esnext/components/CartProvider/graphql/CartDiscountCodesUpdateMutation.d.ts b/dist/dist/esnext/components/CartProvider/graphql/CartDiscountCodesUpdateMutation.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a42985e0a8c8e2d3d869c6407417a84a8dba0422
--- /dev/null
+++ b/dist/dist/esnext/components/CartProvider/graphql/CartDiscountCodesUpdateMutation.d.ts
@@ -0,0 +1,96 @@
+/**
+ * THIS FILE IS AUTO-GENERATED, DO NOT EDIT.
+ * Instead, you can edit the associated .graphql file to query for additional fields and this file will be updated when you run `yarn graphql-types`
+ */
+import * as Types from '../../../storefront-api-types.js';
+export declare type CartDiscountCodesUpdateMutationVariables = Types.Exact<{
+    cartId: Types.Scalars['ID'];
+    discountCodes?: Types.InputMaybe<Array<Types.Scalars['String']> | Types.Scalars['String']>;
+    numCartLines?: Types.InputMaybe<Types.Scalars['Int']>;
+    country?: Types.InputMaybe<Types.CountryCode>;
+}>;
+export declare type CartDiscountCodesUpdateMutation = {
+    __typename?: 'Mutation';
+} & {
+    cartDiscountCodesUpdate?: Types.Maybe<{
+        __typename?: 'CartDiscountCodesUpdatePayload';
+    } & {
+        cart?: Types.Maybe<{
+            __typename?: 'Cart';
+        } & Pick<Types.Cart, 'id' | 'checkoutUrl' | 'totalQuantity' | 'note'> & {
+            buyerIdentity: {
+                __typename?: 'CartBuyerIdentity';
+            } & Pick<Types.CartBuyerIdentity, 'countryCode' | 'email' | 'phone'> & {
+                customer?: Types.Maybe<{
+                    __typename?: 'Customer';
+                } & Pick<Types.Customer, 'id' | 'email' | 'firstName' | 'lastName' | 'displayName'>>;
+            };
+            lines: {
+                __typename?: 'CartLineConnection';
+            } & {
+                edges: Array<{
+                    __typename?: 'CartLineEdge';
+                } & {
+                    node: {
+                        __typename?: 'CartLine';
+                    } & Pick<Types.CartLine, 'id' | 'quantity'> & {
+                        attributes: Array<{
+                            __typename?: 'Attribute';
+                        } & Pick<Types.Attribute, 'key' | 'value'>>;
+                        cost: {
+                            __typename?: 'CartLineCost';
+                        } & {
+                            totalAmount: {
+                                __typename?: 'MoneyV2';
+                            } & Pick<Types.MoneyV2, 'amount' | 'currencyCode'>;
+                            compareAtAmountPerQuantity?: Types.Maybe<{
+                                __typename?: 'MoneyV2';
+                            } & Pick<Types.MoneyV2, 'amount' | 'currencyCode'>>;
+                        };
+                        merchandise: {
+                            __typename?: 'ProductVariant';
+                        } & Pick<Types.ProductVariant, 'id' | 'availableForSale' | 'requiresShipping' | 'title'> & {
+                            compareAtPriceV2?: Types.Maybe<{
+                                __typename?: 'MoneyV2';
+                            } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>>;
+                            priceV2: {
+                                __typename?: 'MoneyV2';
+                            } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>;
+                            image?: Types.Maybe<{
+                                __typename?: 'Image';
+                            } & Pick<Types.Image, 'id' | 'url' | 'altText' | 'width' | 'height'>>;
+                            product: {
+                                __typename?: 'Product';
+                            } & Pick<Types.Product, 'handle' | 'title'>;
+                            selectedOptions: Array<{
+                                __typename?: 'SelectedOption';
+                            } & Pick<Types.SelectedOption, 'name' | 'value'>>;
+                        };
+                    };
+                }>;
+            };
+            cost: {
+                __typename?: 'CartCost';
+            } & {
+                subtotalAmount: {
+                    __typename?: 'MoneyV2';
+                } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>;
+                totalAmount: {
+                    __typename?: 'MoneyV2';
+                } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>;
+                totalDutyAmount?: Types.Maybe<{
+                    __typename?: 'MoneyV2';
+                } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>>;
+                totalTaxAmount?: Types.Maybe<{
+                    __typename?: 'MoneyV2';
+                } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>>;
+            };
+            attributes: Array<{
+                __typename?: 'Attribute';
+            } & Pick<Types.Attribute, 'key' | 'value'>>;
+            discountCodes: Array<{
+                __typename?: 'CartDiscountCode';
+            } & Pick<Types.CartDiscountCode, 'code' | 'applicable'>>;
+        }>;
+    }>;
+};
diff --git a/dist/dist/esnext/components/CartProvider/graphql/CartDiscountCodesUpdateMutation.js b/dist/dist/esnext/components/CartProvider/graphql/CartDiscountCodesUpdateMutation.js
new file mode 100644
index 0000000000000000000000000000000000000000..cb0ff5c3b541f646105198ee23ac0fc3d805023e
--- /dev/null
+++ b/dist/dist/esnext/components/CartProvider/graphql/CartDiscountCodesUpdateMutation.js
@@ -0,0 +1 @@
+export {};
diff --git a/dist/dist/esnext/components/CartProvider/graphql/CartFragment.d.ts b/dist/dist/esnext/components/CartProvider/graphql/CartFragment.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a9ca7392de6d30c21eb60e07c3f68e41d76ff448
--- /dev/null
+++ b/dist/dist/esnext/components/CartProvider/graphql/CartFragment.d.ts
@@ -0,0 +1,82 @@
+/**
+ * THIS FILE IS AUTO-GENERATED, DO NOT EDIT.
+ * Instead, you can edit the associated .graphql file to query for additional fields and this file will be updated when you run `yarn graphql-types`
+ */
+import * as Types from '../../../storefront-api-types.js';
+export declare type CartFragmentFragment = {
+    __typename?: 'Cart';
+} & Pick<Types.Cart, 'id' | 'checkoutUrl' | 'totalQuantity' | 'note'> & {
+    buyerIdentity: {
+        __typename?: 'CartBuyerIdentity';
+    } & Pick<Types.CartBuyerIdentity, 'countryCode' | 'email' | 'phone'> & {
+        customer?: Types.Maybe<{
+            __typename?: 'Customer';
+        } & Pick<Types.Customer, 'id' | 'email' | 'firstName' | 'lastName' | 'displayName'>>;
+    };
+    lines: {
+        __typename?: 'CartLineConnection';
+    } & {
+        edges: Array<{
+            __typename?: 'CartLineEdge';
+        } & {
+            node: {
+                __typename?: 'CartLine';
+            } & Pick<Types.CartLine, 'id' | 'quantity'> & {
+                attributes: Array<{
+                    __typename?: 'Attribute';
+                } & Pick<Types.Attribute, 'key' | 'value'>>;
+                cost: {
+                    __typename?: 'CartLineCost';
+                } & {
+                    totalAmount: {
+                        __typename?: 'MoneyV2';
+                    } & Pick<Types.MoneyV2, 'amount' | 'currencyCode'>;
+                    compareAtAmountPerQuantity?: Types.Maybe<{
+                        __typename?: 'MoneyV2';
+                    } & Pick<Types.MoneyV2, 'amount' | 'currencyCode'>>;
+                };
+                merchandise: {
+                    __typename?: 'ProductVariant';
+                } & Pick<Types.ProductVariant, 'id' | 'availableForSale' | 'requiresShipping' | 'title'> & {
+                    compareAtPriceV2?: Types.Maybe<{
+                        __typename?: 'MoneyV2';
+                    } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>>;
+                    priceV2: {
+                        __typename?: 'MoneyV2';
+                    } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>;
+                    image?: Types.Maybe<{
+                        __typename?: 'Image';
+                    } & Pick<Types.Image, 'id' | 'url' | 'altText' | 'width' | 'height'>>;
+                    product: {
+                        __typename?: 'Product';
+                    } & Pick<Types.Product, 'handle' | 'title'>;
+                    selectedOptions: Array<{
+                        __typename?: 'SelectedOption';
+                    } & Pick<Types.SelectedOption, 'name' | 'value'>>;
+                };
+            };
+        }>;
+    };
+    cost: {
+        __typename?: 'CartCost';
+    } & {
+        subtotalAmount: {
+            __typename?: 'MoneyV2';
+        } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>;
+        totalAmount: {
+            __typename?: 'MoneyV2';
+        } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>;
+        totalDutyAmount?: Types.Maybe<{
+            __typename?: 'MoneyV2';
+        } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>>;
+        totalTaxAmount?: Types.Maybe<{
+            __typename?: 'MoneyV2';
+        } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>>;
+    };
+    attributes: Array<{
+        __typename?: 'Attribute';
+    } & Pick<Types.Attribute, 'key' | 'value'>>;
+    discountCodes: Array<{
+        __typename?: 'CartDiscountCode';
+    } & Pick<Types.CartDiscountCode, 'code' | 'applicable'>>;
+};
diff --git a/dist/dist/esnext/components/CartProvider/graphql/CartFragment.js b/dist/dist/esnext/components/CartProvider/graphql/CartFragment.js
new file mode 100644
index 0000000000000000000000000000000000000000..cb0ff5c3b541f646105198ee23ac0fc3d805023e
--- /dev/null
+++ b/dist/dist/esnext/components/CartProvider/graphql/CartFragment.js
@@ -0,0 +1 @@
+export {};
diff --git a/dist/dist/esnext/components/CartProvider/graphql/CartLineAddMutation.d.ts b/dist/dist/esnext/components/CartProvider/graphql/CartLineAddMutation.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8868bccecad74b29f62a6135532e94aecf47d246
--- /dev/null
+++ b/dist/dist/esnext/components/CartProvider/graphql/CartLineAddMutation.d.ts
@@ -0,0 +1,96 @@
+/**
+ * THIS FILE IS AUTO-GENERATED, DO NOT EDIT.
+ * Instead, you can edit the associated .graphql file to query for additional fields and this file will be updated when you run `yarn graphql-types`
+ */
+import * as Types from '../../../storefront-api-types.js';
+export declare type CartLineAddMutationVariables = Types.Exact<{
+    cartId: Types.Scalars['ID'];
+    lines: Array<Types.CartLineInput> | Types.CartLineInput;
+    numCartLines?: Types.InputMaybe<Types.Scalars['Int']>;
+    country?: Types.InputMaybe<Types.CountryCode>;
+}>;
+export declare type CartLineAddMutation = {
+    __typename?: 'Mutation';
+} & {
+    cartLinesAdd?: Types.Maybe<{
+        __typename?: 'CartLinesAddPayload';
+    } & {
+        cart?: Types.Maybe<{
+            __typename?: 'Cart';
+        } & Pick<Types.Cart, 'id' | 'checkoutUrl' | 'totalQuantity' | 'note'> & {
+            buyerIdentity: {
+                __typename?: 'CartBuyerIdentity';
+            } & Pick<Types.CartBuyerIdentity, 'countryCode' | 'email' | 'phone'> & {
+                customer?: Types.Maybe<{
+                    __typename?: 'Customer';
+                } & Pick<Types.Customer, 'id' | 'email' | 'firstName' | 'lastName' | 'displayName'>>;
+            };
+            lines: {
+                __typename?: 'CartLineConnection';
+            } & {
+                edges: Array<{
+                    __typename?: 'CartLineEdge';
+                } & {
+                    node: {
+                        __typename?: 'CartLine';
+                    } & Pick<Types.CartLine, 'id' | 'quantity'> & {
+                        attributes: Array<{
+                            __typename?: 'Attribute';
+                        } & Pick<Types.Attribute, 'key' | 'value'>>;
+                        cost: {
+                            __typename?: 'CartLineCost';
+                        } & {
+                            totalAmount: {
+                                __typename?: 'MoneyV2';
+                            } & Pick<Types.MoneyV2, 'amount' | 'currencyCode'>;
+                            compareAtAmountPerQuantity?: Types.Maybe<{
+                                __typename?: 'MoneyV2';
+                            } & Pick<Types.MoneyV2, 'amount' | 'currencyCode'>>;
+                        };
+                        merchandise: {
+                            __typename?: 'ProductVariant';
+                        } & Pick<Types.ProductVariant, 'id' | 'availableForSale' | 'requiresShipping' | 'title'> & {
+                            compareAtPriceV2?: Types.Maybe<{
+                                __typename?: 'MoneyV2';
+                            } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>>;
+                            priceV2: {
+                                __typename?: 'MoneyV2';
+                            } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>;
+                            image?: Types.Maybe<{
+                                __typename?: 'Image';
+                            } & Pick<Types.Image, 'id' | 'url' | 'altText' | 'width' | 'height'>>;
+                            product: {
+                                __typename?: 'Product';
+                            } & Pick<Types.Product, 'handle' | 'title'>;
+                            selectedOptions: Array<{
+                                __typename?: 'SelectedOption';
+                            } & Pick<Types.SelectedOption, 'name' | 'value'>>;
+                        };
+                    };
+                }>;
+            };
+            cost: {
+                __typename?: 'CartCost';
+            } & {
+                subtotalAmount: {
+                    __typename?: 'MoneyV2';
+                } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>;
+                totalAmount: {
+                    __typename?: 'MoneyV2';
+                } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>;
+                totalDutyAmount?: Types.Maybe<{
+                    __typename?: 'MoneyV2';
+                } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>>;
+                totalTaxAmount?: Types.Maybe<{
+                    __typename?: 'MoneyV2';
+                } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>>;
+            };
+            attributes: Array<{
+                __typename?: 'Attribute';
+            } & Pick<Types.Attribute, 'key' | 'value'>>;
+            discountCodes: Array<{
+                __typename?: 'CartDiscountCode';
+            } & Pick<Types.CartDiscountCode, 'code' | 'applicable'>>;
+        }>;
+    }>;
+};
diff --git a/dist/dist/esnext/components/CartProvider/graphql/CartLineAddMutation.js b/dist/dist/esnext/components/CartProvider/graphql/CartLineAddMutation.js
new file mode 100644
index 0000000000000000000000000000000000000000..cb0ff5c3b541f646105198ee23ac0fc3d805023e
--- /dev/null
+++ b/dist/dist/esnext/components/CartProvider/graphql/CartLineAddMutation.js
@@ -0,0 +1 @@
+export {};
diff --git a/dist/dist/esnext/components/CartProvider/graphql/CartLineRemoveMutation.d.ts b/dist/dist/esnext/components/CartProvider/graphql/CartLineRemoveMutation.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e8e56a815cff08a5bc84bad22eff3c2651698997
--- /dev/null
+++ b/dist/dist/esnext/components/CartProvider/graphql/CartLineRemoveMutation.d.ts
@@ -0,0 +1,96 @@
+/**
+ * THIS FILE IS AUTO-GENERATED, DO NOT EDIT.
+ * Instead, you can edit the associated .graphql file to query for additional fields and this file will be updated when you run `yarn graphql-types`
+ */
+import * as Types from '../../../storefront-api-types.js';
+export declare type CartLineRemoveMutationVariables = Types.Exact<{
+    cartId: Types.Scalars['ID'];
+    lines: Array<Types.Scalars['ID']> | Types.Scalars['ID'];
+    numCartLines?: Types.InputMaybe<Types.Scalars['Int']>;
+    country?: Types.InputMaybe<Types.CountryCode>;
+}>;
+export declare type CartLineRemoveMutation = {
+    __typename?: 'Mutation';
+} & {
+    cartLinesRemove?: Types.Maybe<{
+        __typename?: 'CartLinesRemovePayload';
+    } & {
+        cart?: Types.Maybe<{
+            __typename?: 'Cart';
+        } & Pick<Types.Cart, 'id' | 'checkoutUrl' | 'totalQuantity' | 'note'> & {
+            buyerIdentity: {
+                __typename?: 'CartBuyerIdentity';
+            } & Pick<Types.CartBuyerIdentity, 'countryCode' | 'email' | 'phone'> & {
+                customer?: Types.Maybe<{
+                    __typename?: 'Customer';
+                } & Pick<Types.Customer, 'id' | 'email' | 'firstName' | 'lastName' | 'displayName'>>;
+            };
+            lines: {
+                __typename?: 'CartLineConnection';
+            } & {
+                edges: Array<{
+                    __typename?: 'CartLineEdge';
+                } & {
+                    node: {
+                        __typename?: 'CartLine';
+                    } & Pick<Types.CartLine, 'id' | 'quantity'> & {
+                        attributes: Array<{
+                            __typename?: 'Attribute';
+                        } & Pick<Types.Attribute, 'key' | 'value'>>;
+                        cost: {
+                            __typename?: 'CartLineCost';
+                        } & {
+                            totalAmount: {
+                                __typename?: 'MoneyV2';
+                            } & Pick<Types.MoneyV2, 'amount' | 'currencyCode'>;
+                            compareAtAmountPerQuantity?: Types.Maybe<{
+                                __typename?: 'MoneyV2';
+                            } & Pick<Types.MoneyV2, 'amount' | 'currencyCode'>>;
+                        };
+                        merchandise: {
+                            __typename?: 'ProductVariant';
+                        } & Pick<Types.ProductVariant, 'id' | 'availableForSale' | 'requiresShipping' | 'title'> & {
+                            compareAtPriceV2?: Types.Maybe<{
+                                __typename?: 'MoneyV2';
+                            } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>>;
+                            priceV2: {
+                                __typename?: 'MoneyV2';
+                            } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>;
+                            image?: Types.Maybe<{
+                                __typename?: 'Image';
+                            } & Pick<Types.Image, 'id' | 'url' | 'altText' | 'width' | 'height'>>;
+                            product: {
+                                __typename?: 'Product';
+                            } & Pick<Types.Product, 'handle' | 'title'>;
+                            selectedOptions: Array<{
+                                __typename?: 'SelectedOption';
+                            } & Pick<Types.SelectedOption, 'name' | 'value'>>;
+                        };
+                    };
+                }>;
+            };
+            cost: {
+                __typename?: 'CartCost';
+            } & {
+                subtotalAmount: {
+                    __typename?: 'MoneyV2';
+                } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>;
+                totalAmount: {
+                    __typename?: 'MoneyV2';
+                } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>;
+                totalDutyAmount?: Types.Maybe<{
+                    __typename?: 'MoneyV2';
+                } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>>;
+                totalTaxAmount?: Types.Maybe<{
+                    __typename?: 'MoneyV2';
+                } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>>;
+            };
+            attributes: Array<{
+                __typename?: 'Attribute';
+            } & Pick<Types.Attribute, 'key' | 'value'>>;
+            discountCodes: Array<{
+                __typename?: 'CartDiscountCode';
+            } & Pick<Types.CartDiscountCode, 'code' | 'applicable'>>;
+        }>;
+    }>;
+};
diff --git a/dist/dist/esnext/components/CartProvider/graphql/CartLineRemoveMutation.js b/dist/dist/esnext/components/CartProvider/graphql/CartLineRemoveMutation.js
new file mode 100644
index 0000000000000000000000000000000000000000..cb0ff5c3b541f646105198ee23ac0fc3d805023e
--- /dev/null
+++ b/dist/dist/esnext/components/CartProvider/graphql/CartLineRemoveMutation.js
@@ -0,0 +1 @@
+export {};
diff --git a/dist/dist/esnext/components/CartProvider/graphql/CartLineUpdateMutation.d.ts b/dist/dist/esnext/components/CartProvider/graphql/CartLineUpdateMutation.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..aa3ed8527c36353e5731daffc337c83302548357
--- /dev/null
+++ b/dist/dist/esnext/components/CartProvider/graphql/CartLineUpdateMutation.d.ts
@@ -0,0 +1,96 @@
+/**
+ * THIS FILE IS AUTO-GENERATED, DO NOT EDIT.
+ * Instead, you can edit the associated .graphql file to query for additional fields and this file will be updated when you run `yarn graphql-types`
+ */
+import * as Types from '../../../storefront-api-types.js';
+export declare type CartLineUpdateMutationVariables = Types.Exact<{
+    cartId: Types.Scalars['ID'];
+    lines: Array<Types.CartLineUpdateInput> | Types.CartLineUpdateInput;
+    numCartLines?: Types.InputMaybe<Types.Scalars['Int']>;
+    country?: Types.InputMaybe<Types.CountryCode>;
+}>;
+export declare type CartLineUpdateMutation = {
+    __typename?: 'Mutation';
+} & {
+    cartLinesUpdate?: Types.Maybe<{
+        __typename?: 'CartLinesUpdatePayload';
+    } & {
+        cart?: Types.Maybe<{
+            __typename?: 'Cart';
+        } & Pick<Types.Cart, 'id' | 'checkoutUrl' | 'totalQuantity' | 'note'> & {
+            buyerIdentity: {
+                __typename?: 'CartBuyerIdentity';
+            } & Pick<Types.CartBuyerIdentity, 'countryCode' | 'email' | 'phone'> & {
+                customer?: Types.Maybe<{
+                    __typename?: 'Customer';
+                } & Pick<Types.Customer, 'id' | 'email' | 'firstName' | 'lastName' | 'displayName'>>;
+            };
+            lines: {
+                __typename?: 'CartLineConnection';
+            } & {
+                edges: Array<{
+                    __typename?: 'CartLineEdge';
+                } & {
+                    node: {
+                        __typename?: 'CartLine';
+                    } & Pick<Types.CartLine, 'id' | 'quantity'> & {
+                        attributes: Array<{
+                            __typename?: 'Attribute';
+                        } & Pick<Types.Attribute, 'key' | 'value'>>;
+                        cost: {
+                            __typename?: 'CartLineCost';
+                        } & {
+                            totalAmount: {
+                                __typename?: 'MoneyV2';
+                            } & Pick<Types.MoneyV2, 'amount' | 'currencyCode'>;
+                            compareAtAmountPerQuantity?: Types.Maybe<{
+                                __typename?: 'MoneyV2';
+                            } & Pick<Types.MoneyV2, 'amount' | 'currencyCode'>>;
+                        };
+                        merchandise: {
+                            __typename?: 'ProductVariant';
+                        } & Pick<Types.ProductVariant, 'id' | 'availableForSale' | 'requiresShipping' | 'title'> & {
+                            compareAtPriceV2?: Types.Maybe<{
+                                __typename?: 'MoneyV2';
+                            } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>>;
+                            priceV2: {
+                                __typename?: 'MoneyV2';
+                            } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>;
+                            image?: Types.Maybe<{
+                                __typename?: 'Image';
+                            } & Pick<Types.Image, 'id' | 'url' | 'altText' | 'width' | 'height'>>;
+                            product: {
+                                __typename?: 'Product';
+                            } & Pick<Types.Product, 'handle' | 'title'>;
+                            selectedOptions: Array<{
+                                __typename?: 'SelectedOption';
+                            } & Pick<Types.SelectedOption, 'name' | 'value'>>;
+                        };
+                    };
+                }>;
+            };
+            cost: {
+                __typename?: 'CartCost';
+            } & {
+                subtotalAmount: {
+                    __typename?: 'MoneyV2';
+                } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>;
+                totalAmount: {
+                    __typename?: 'MoneyV2';
+                } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>;
+                totalDutyAmount?: Types.Maybe<{
+                    __typename?: 'MoneyV2';
+                } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>>;
+                totalTaxAmount?: Types.Maybe<{
+                    __typename?: 'MoneyV2';
+                } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>>;
+            };
+            attributes: Array<{
+                __typename?: 'Attribute';
+            } & Pick<Types.Attribute, 'key' | 'value'>>;
+            discountCodes: Array<{
+                __typename?: 'CartDiscountCode';
+            } & Pick<Types.CartDiscountCode, 'code' | 'applicable'>>;
+        }>;
+    }>;
+};
diff --git a/dist/dist/esnext/components/CartProvider/graphql/CartLineUpdateMutation.js b/dist/dist/esnext/components/CartProvider/graphql/CartLineUpdateMutation.js
new file mode 100644
index 0000000000000000000000000000000000000000..cb0ff5c3b541f646105198ee23ac0fc3d805023e
--- /dev/null
+++ b/dist/dist/esnext/components/CartProvider/graphql/CartLineUpdateMutation.js
@@ -0,0 +1 @@
+export {};
diff --git a/dist/dist/esnext/components/CartProvider/graphql/CartNoteUpdateMutation.d.ts b/dist/dist/esnext/components/CartProvider/graphql/CartNoteUpdateMutation.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b0a72ea8f2c738ed7fbe7b469c34b67b5b5bdf99
--- /dev/null
+++ b/dist/dist/esnext/components/CartProvider/graphql/CartNoteUpdateMutation.d.ts
@@ -0,0 +1,96 @@
+/**
+ * THIS FILE IS AUTO-GENERATED, DO NOT EDIT.
+ * Instead, you can edit the associated .graphql file to query for additional fields and this file will be updated when you run `yarn graphql-types`
+ */
+import * as Types from '../../../storefront-api-types.js';
+export declare type CartNoteUpdateMutationVariables = Types.Exact<{
+    cartId: Types.Scalars['ID'];
+    note?: Types.InputMaybe<Types.Scalars['String']>;
+    numCartLines?: Types.InputMaybe<Types.Scalars['Int']>;
+    country?: Types.InputMaybe<Types.CountryCode>;
+}>;
+export declare type CartNoteUpdateMutation = {
+    __typename?: 'Mutation';
+} & {
+    cartNoteUpdate?: Types.Maybe<{
+        __typename?: 'CartNoteUpdatePayload';
+    } & {
+        cart?: Types.Maybe<{
+            __typename?: 'Cart';
+        } & Pick<Types.Cart, 'id' | 'checkoutUrl' | 'totalQuantity' | 'note'> & {
+            buyerIdentity: {
+                __typename?: 'CartBuyerIdentity';
+            } & Pick<Types.CartBuyerIdentity, 'countryCode' | 'email' | 'phone'> & {
+                customer?: Types.Maybe<{
+                    __typename?: 'Customer';
+                } & Pick<Types.Customer, 'id' | 'email' | 'firstName' | 'lastName' | 'displayName'>>;
+            };
+            lines: {
+                __typename?: 'CartLineConnection';
+            } & {
+                edges: Array<{
+                    __typename?: 'CartLineEdge';
+                } & {
+                    node: {
+                        __typename?: 'CartLine';
+                    } & Pick<Types.CartLine, 'id' | 'quantity'> & {
+                        attributes: Array<{
+                            __typename?: 'Attribute';
+                        } & Pick<Types.Attribute, 'key' | 'value'>>;
+                        cost: {
+                            __typename?: 'CartLineCost';
+                        } & {
+                            totalAmount: {
+                                __typename?: 'MoneyV2';
+                            } & Pick<Types.MoneyV2, 'amount' | 'currencyCode'>;
+                            compareAtAmountPerQuantity?: Types.Maybe<{
+                                __typename?: 'MoneyV2';
+                            } & Pick<Types.MoneyV2, 'amount' | 'currencyCode'>>;
+                        };
+                        merchandise: {
+                            __typename?: 'ProductVariant';
+                        } & Pick<Types.ProductVariant, 'id' | 'availableForSale' | 'requiresShipping' | 'title'> & {
+                            compareAtPriceV2?: Types.Maybe<{
+                                __typename?: 'MoneyV2';
+                            } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>>;
+                            priceV2: {
+                                __typename?: 'MoneyV2';
+                            } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>;
+                            image?: Types.Maybe<{
+                                __typename?: 'Image';
+                            } & Pick<Types.Image, 'id' | 'url' | 'altText' | 'width' | 'height'>>;
+                            product: {
+                                __typename?: 'Product';
+                            } & Pick<Types.Product, 'handle' | 'title'>;
+                            selectedOptions: Array<{
+                                __typename?: 'SelectedOption';
+                            } & Pick<Types.SelectedOption, 'name' | 'value'>>;
+                        };
+                    };
+                }>;
+            };
+            cost: {
+                __typename?: 'CartCost';
+            } & {
+                subtotalAmount: {
+                    __typename?: 'MoneyV2';
+                } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>;
+                totalAmount: {
+                    __typename?: 'MoneyV2';
+                } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>;
+                totalDutyAmount?: Types.Maybe<{
+                    __typename?: 'MoneyV2';
+                } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>>;
+                totalTaxAmount?: Types.Maybe<{
+                    __typename?: 'MoneyV2';
+                } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>>;
+            };
+            attributes: Array<{
+                __typename?: 'Attribute';
+            } & Pick<Types.Attribute, 'key' | 'value'>>;
+            discountCodes: Array<{
+                __typename?: 'CartDiscountCode';
+            } & Pick<Types.CartDiscountCode, 'code' | 'applicable'>>;
+        }>;
+    }>;
+};
diff --git a/dist/dist/esnext/components/CartProvider/graphql/CartNoteUpdateMutation.js b/dist/dist/esnext/components/CartProvider/graphql/CartNoteUpdateMutation.js
new file mode 100644
index 0000000000000000000000000000000000000000..cb0ff5c3b541f646105198ee23ac0fc3d805023e
--- /dev/null
+++ b/dist/dist/esnext/components/CartProvider/graphql/CartNoteUpdateMutation.js
@@ -0,0 +1 @@
+export {};
diff --git a/dist/dist/esnext/components/CartProvider/graphql/CartQuery.d.ts b/dist/dist/esnext/components/CartProvider/graphql/CartQuery.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..712cd12858f596525150a243cd8ef94068f920b0
--- /dev/null
+++ b/dist/dist/esnext/components/CartProvider/graphql/CartQuery.d.ts
@@ -0,0 +1,91 @@
+/**
+ * THIS FILE IS AUTO-GENERATED, DO NOT EDIT.
+ * Instead, you can edit the associated .graphql file to query for additional fields and this file will be updated when you run `yarn graphql-types`
+ */
+import * as Types from '../../../storefront-api-types.js';
+export declare type CartQueryQueryVariables = Types.Exact<{
+    id: Types.Scalars['ID'];
+    numCartLines?: Types.InputMaybe<Types.Scalars['Int']>;
+    country?: Types.InputMaybe<Types.CountryCode>;
+}>;
+export declare type CartQueryQuery = {
+    __typename?: 'QueryRoot';
+} & {
+    cart?: Types.Maybe<{
+        __typename?: 'Cart';
+    } & Pick<Types.Cart, 'id' | 'checkoutUrl' | 'totalQuantity' | 'note'> & {
+        buyerIdentity: {
+            __typename?: 'CartBuyerIdentity';
+        } & Pick<Types.CartBuyerIdentity, 'countryCode' | 'email' | 'phone'> & {
+            customer?: Types.Maybe<{
+                __typename?: 'Customer';
+            } & Pick<Types.Customer, 'id' | 'email' | 'firstName' | 'lastName' | 'displayName'>>;
+        };
+        lines: {
+            __typename?: 'CartLineConnection';
+        } & {
+            edges: Array<{
+                __typename?: 'CartLineEdge';
+            } & {
+                node: {
+                    __typename?: 'CartLine';
+                } & Pick<Types.CartLine, 'id' | 'quantity'> & {
+                    attributes: Array<{
+                        __typename?: 'Attribute';
+                    } & Pick<Types.Attribute, 'key' | 'value'>>;
+                    cost: {
+                        __typename?: 'CartLineCost';
+                    } & {
+                        totalAmount: {
+                            __typename?: 'MoneyV2';
+                        } & Pick<Types.MoneyV2, 'amount' | 'currencyCode'>;
+                        compareAtAmountPerQuantity?: Types.Maybe<{
+                            __typename?: 'MoneyV2';
+                        } & Pick<Types.MoneyV2, 'amount' | 'currencyCode'>>;
+                    };
+                    merchandise: {
+                        __typename?: 'ProductVariant';
+                    } & Pick<Types.ProductVariant, 'id' | 'availableForSale' | 'requiresShipping' | 'title'> & {
+                        compareAtPriceV2?: Types.Maybe<{
+                            __typename?: 'MoneyV2';
+                        } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>>;
+                        priceV2: {
+                            __typename?: 'MoneyV2';
+                        } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>;
+                        image?: Types.Maybe<{
+                            __typename?: 'Image';
+                        } & Pick<Types.Image, 'id' | 'url' | 'altText' | 'width' | 'height'>>;
+                        product: {
+                            __typename?: 'Product';
+                        } & Pick<Types.Product, 'handle' | 'title'>;
+                        selectedOptions: Array<{
+                            __typename?: 'SelectedOption';
+                        } & Pick<Types.SelectedOption, 'name' | 'value'>>;
+                    };
+                };
+            }>;
+        };
+        cost: {
+            __typename?: 'CartCost';
+        } & {
+            subtotalAmount: {
+                __typename?: 'MoneyV2';
+            } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>;
+            totalAmount: {
+                __typename?: 'MoneyV2';
+            } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>;
+            totalDutyAmount?: Types.Maybe<{
+                __typename?: 'MoneyV2';
+            } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>>;
+            totalTaxAmount?: Types.Maybe<{
+                __typename?: 'MoneyV2';
+            } & Pick<Types.MoneyV2, 'currencyCode' | 'amount'>>;
+        };
+        attributes: Array<{
+            __typename?: 'Attribute';
+        } & Pick<Types.Attribute, 'key' | 'value'>>;
+        discountCodes: Array<{
+            __typename?: 'CartDiscountCode';
+        } & Pick<Types.CartDiscountCode, 'code' | 'applicable'>>;
+    }>;
+};
diff --git a/dist/dist/esnext/components/CartProvider/graphql/CartQuery.js b/dist/dist/esnext/components/CartProvider/graphql/CartQuery.js
new file mode 100644
index 0000000000000000000000000000000000000000..cb0ff5c3b541f646105198ee23ac0fc3d805023e
--- /dev/null
+++ b/dist/dist/esnext/components/CartProvider/graphql/CartQuery.js
@@ -0,0 +1 @@
+export {};
diff --git a/dist/dist/esnext/components/CartProvider/hooks.client.d.ts b/dist/dist/esnext/components/CartProvider/hooks.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..30f7c3034e43e040607c3fbfb0d3844c8875ca93
--- /dev/null
+++ b/dist/dist/esnext/components/CartProvider/hooks.client.d.ts
@@ -0,0 +1,15 @@
+import { CartInput } from '../../storefront-api-types.js';
+import { Cart } from './types.js';
+export declare function useCartFetch(): <T, K>({ query, variables, }: {
+    query: string;
+    variables: T;
+}) => Promise<{
+    data: K | undefined;
+    errors: any;
+}>;
+export declare function useInstantCheckout(): {
+    cart: Cart | undefined;
+    checkoutUrl: string | undefined;
+    error: string | undefined;
+    createInstantCheckout: (cartInput: CartInput) => Promise<void>;
+};
diff --git a/dist/dist/esnext/components/CartProvider/hooks.client.js b/dist/dist/esnext/components/CartProvider/hooks.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..2f80158108d7c4d1e581b51b851339d79ee0074c
--- /dev/null
+++ b/dist/dist/esnext/components/CartProvider/hooks.client.js
@@ -0,0 +1,71 @@
+import React, { useState } from 'react';
+import { useShop } from '../../foundation/index.js';
+import { flattenConnection } from '../../utilities/index.js';
+import { CartCreate, defaultCartFragment } from './cart-queries.js';
+import { SHOPIFY_STOREFRONT_ID_HEADER, STOREFRONT_API_PUBLIC_TOKEN_HEADER, SHOPIFY_STOREFRONT_Y_HEADER, SHOPIFY_STOREFRONT_S_HEADER, SHOPIFY_Y, SHOPIFY_S, } from '../../constants.js';
+import { parse } from 'worktop/cookie';
+export function useCartFetch() {
+    const { storeDomain, storefrontApiVersion, storefrontToken, storefrontId } = useShop();
+    return React.useCallback(({ query, variables, }) => {
+        const headers = {
+            'Content-Type': 'application/json',
+            'X-SDK-Variant': 'hydrogen',
+            'X-SDK-Version': storefrontApiVersion,
+            [STOREFRONT_API_PUBLIC_TOKEN_HEADER]: storefrontToken,
+        };
+        if (storefrontId) {
+            headers[SHOPIFY_STOREFRONT_ID_HEADER] = storefrontId;
+        }
+        // Find Shopify cookies
+        const cookieData = parse(document.cookie);
+        if (cookieData[SHOPIFY_Y] && cookieData[SHOPIFY_S]) {
+            headers[SHOPIFY_STOREFRONT_Y_HEADER] = cookieData[SHOPIFY_Y];
+            headers[SHOPIFY_STOREFRONT_S_HEADER] = cookieData[SHOPIFY_S];
+        }
+        return fetch(`https://${storeDomain}/api/${storefrontApiVersion}/graphql.json`, {
+            method: 'POST',
+            headers,
+            body: JSON.stringify({
+                query: query.toString(),
+                variables,
+            }),
+        })
+            .then((res) => res.json())
+            .catch((error) => {
+            return {
+                data: undefined,
+                errors: error.toString(),
+            };
+        });
+    }, [storeDomain, storefrontApiVersion, storefrontToken, storefrontId]);
+}
+export function useInstantCheckout() {
+    const [cart, updateCart] = useState();
+    const [checkoutUrl, updateCheckoutUrl] = useState();
+    const [error, updateError] = useState();
+    const fetch = useCartFetch();
+    const createInstantCheckout = React.useCallback(async (cartInput) => {
+        const { data, errors } = await fetch({
+            query: CartCreate(defaultCartFragment),
+            variables: {
+                input: cartInput,
+            },
+        });
+        if (errors) {
+            updateError(errors);
+            updateCart(undefined);
+            updateCheckoutUrl(undefined);
+        }
+        if (data?.cartCreate?.cart) {
+            const dataCart = data.cartCreate.cart;
+            updateCart({
+                ...dataCart,
+                // @ts-expect-error While the cart still uses fragments, there will be a TS error here until we remove those fragments and get the type in-line
+                lines: flattenConnection(dataCart.lines),
+                note: dataCart.note ?? undefined,
+            });
+            updateCheckoutUrl(dataCart.checkoutUrl);
+        }
+    }, [fetch]);
+    return { cart, checkoutUrl, error, createInstantCheckout };
+}
diff --git a/dist/dist/esnext/components/CartProvider/index.d.ts b/dist/dist/esnext/components/CartProvider/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..81b6a51fb4eb6642ddbf61a4ecbed33213d85704
--- /dev/null
+++ b/dist/dist/esnext/components/CartProvider/index.d.ts
@@ -0,0 +1,4 @@
+export { CartProvider } from './CartProvider.client.js';
+export { useCartFetch, useInstantCheckout } from './hooks.client.js';
+export { useCart } from '../../hooks/useCart/index.js';
+export type { State, Status, Cart, CartWithActions, CartAction, } from './types.js';
diff --git a/dist/dist/esnext/components/CartProvider/index.js b/dist/dist/esnext/components/CartProvider/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..67da87cae8417a26709d51e6973318d4ffc9a23f
--- /dev/null
+++ b/dist/dist/esnext/components/CartProvider/index.js
@@ -0,0 +1,3 @@
+export { CartProvider } from './CartProvider.client.js';
+export { useCartFetch, useInstantCheckout } from './hooks.client.js';
+export { useCart } from '../../hooks/useCart/index.js';
diff --git a/dist/dist/esnext/components/CartProvider/tests/fixtures.d.ts b/dist/dist/esnext/components/CartProvider/tests/fixtures.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..aa6949706764da43693dd93b53d3d89b68fe63b7
--- /dev/null
+++ b/dist/dist/esnext/components/CartProvider/tests/fixtures.d.ts
@@ -0,0 +1,254 @@
+import type { CartWithActions } from '../types.js';
+import { CartFragmentFragment } from '../graphql/CartFragment.js';
+export declare const CART: {
+    id: string;
+    checkoutUrl: string;
+    attributes: never[];
+    buyerIdentity: {};
+    discountCodes: never[];
+    totalQuantity: number;
+    cost: {
+        subtotalAmount: {
+            currencyCode: import("../../../storefront-api-types.js").CurrencyCode;
+            amount: string;
+        };
+        totalAmount: {
+            currencyCode: import("../../../storefront-api-types.js").CurrencyCode;
+            amount: string;
+        };
+        totalTaxAmount: {
+            currencyCode: import("../../../storefront-api-types.js").CurrencyCode;
+            amount: string;
+        };
+        totalDutyAmount: {
+            currencyCode: import("../../../storefront-api-types.js").CurrencyCode;
+            amount: string;
+        };
+    };
+    lines: {
+        edges: never[];
+    };
+};
+export declare function getCartMock(options?: Partial<CartFragmentFragment>): {
+    __typename?: "Cart" | undefined;
+    id: string;
+    note?: import("../../../storefront-api-types.js").Maybe<string> | undefined;
+    checkoutUrl: string;
+    totalQuantity: number;
+    buyerIdentity: {};
+    lines: ({
+        __typename?: "CartLineConnection" | undefined;
+    } & {
+        edges: ({
+            __typename?: "CartLineEdge" | undefined;
+        } & {
+            node: {
+                __typename?: "CartLine" | undefined;
+            } & Pick<import("../../../storefront-api-types.js").CartLine, "id" | "quantity"> & {
+                attributes: ({
+                    __typename?: "Attribute" | undefined;
+                } & Pick<import("../../../storefront-api-types.js").Attribute, "key" | "value">)[];
+                cost: {
+                    __typename?: "CartLineCost" | undefined;
+                } & {
+                    totalAmount: {
+                        __typename?: "MoneyV2" | undefined;
+                    } & Pick<import("../../../storefront-api-types.js").MoneyV2, "currencyCode" | "amount">;
+                    compareAtAmountPerQuantity?: import("../../../storefront-api-types.js").Maybe<{
+                        __typename?: "MoneyV2" | undefined;
+                    } & Pick<import("../../../storefront-api-types.js").MoneyV2, "currencyCode" | "amount">> | undefined;
+                };
+                merchandise: {
+                    __typename?: "ProductVariant" | undefined;
+                } & Pick<import("../../../storefront-api-types.js").ProductVariant, "id" | "title" | "availableForSale" | "requiresShipping"> & {
+                    compareAtPriceV2?: import("../../../storefront-api-types.js").Maybe<{
+                        __typename?: "MoneyV2" | undefined;
+                    } & Pick<import("../../../storefront-api-types.js").MoneyV2, "currencyCode" | "amount">> | undefined;
+                    priceV2: {
+                        __typename?: "MoneyV2" | undefined;
+                    } & Pick<import("../../../storefront-api-types.js").MoneyV2, "currencyCode" | "amount">;
+                    image?: import("../../../storefront-api-types.js").Maybe<{
+                        __typename?: "Image" | undefined;
+                    } & Pick<import("../../../storefront-api-types.js").Image, "id" | "height" | "width" | "url" | "altText">> | undefined;
+                    product: {
+                        __typename?: "Product" | undefined;
+                    } & Pick<import("../../../storefront-api-types.js").Product, "title" | "handle">;
+                    selectedOptions: ({
+                        __typename?: "SelectedOption" | undefined;
+                    } & Pick<import("../../../storefront-api-types.js").SelectedOption, "name" | "value">)[];
+                };
+            };
+        })[];
+    }) | {
+        edges: never[];
+    };
+    cost: ({
+        __typename?: "CartCost" | undefined;
+    } & {
+        subtotalAmount: {
+            __typename?: "MoneyV2" | undefined;
+        } & Pick<import("../../../storefront-api-types.js").MoneyV2, "currencyCode" | "amount">;
+        totalAmount: {
+            __typename?: "MoneyV2" | undefined;
+        } & Pick<import("../../../storefront-api-types.js").MoneyV2, "currencyCode" | "amount">;
+        totalDutyAmount?: import("../../../storefront-api-types.js").Maybe<{
+            __typename?: "MoneyV2" | undefined;
+        } & Pick<import("../../../storefront-api-types.js").MoneyV2, "currencyCode" | "amount">> | undefined;
+        totalTaxAmount?: import("../../../storefront-api-types.js").Maybe<{
+            __typename?: "MoneyV2" | undefined;
+        } & Pick<import("../../../storefront-api-types.js").MoneyV2, "currencyCode" | "amount">> | undefined;
+    }) | {
+        subtotalAmount: {
+            currencyCode: import("../../../storefront-api-types.js").CurrencyCode;
+            amount: string;
+        };
+        totalAmount: {
+            currencyCode: import("../../../storefront-api-types.js").CurrencyCode;
+            amount: string;
+        };
+        totalTaxAmount: {
+            currencyCode: import("../../../storefront-api-types.js").CurrencyCode;
+            amount: string;
+        };
+        totalDutyAmount: {
+            currencyCode: import("../../../storefront-api-types.js").CurrencyCode;
+            amount: string;
+        };
+    };
+    attributes: ({
+        __typename?: "Attribute" | undefined;
+    } & Pick<import("../../../storefront-api-types.js").Attribute, "key" | "value">)[];
+    discountCodes: ({
+        __typename?: "CartDiscountCode" | undefined;
+    } & Pick<import("../../../storefront-api-types.js").CartDiscountCode, "code" | "applicable">)[];
+};
+export declare const CART_WITH_LINES: {
+    lines: {
+        edges: {
+            node: {
+                attributes: {
+                    key: string;
+                    value: string;
+                }[];
+                quantity: number;
+                id: string;
+                merchandise: {
+                    id: string;
+                    availableForSale: boolean;
+                    priceV2: {
+                        amount: string;
+                        currencyCode: import("../../../storefront-api-types.js").CurrencyCode;
+                    };
+                    product: {
+                        handle: string;
+                        title: string;
+                    };
+                    requiresShipping: boolean;
+                    selectedOptions: {
+                        name: string;
+                        value: string;
+                    }[];
+                    title: string;
+                };
+                cost: {
+                    totalAmount: {
+                        amount: string;
+                        currencyCode: import("../../../storefront-api-types.js").CurrencyCode;
+                    };
+                    compareAtAmount: {
+                        amount: string;
+                        currencyCode: import("../../../storefront-api-types.js").CurrencyCode;
+                    };
+                };
+            };
+        }[];
+    };
+    id: string;
+    checkoutUrl: string;
+    attributes: never[];
+    buyerIdentity: {};
+    discountCodes: never[];
+    totalQuantity: number;
+    cost: {
+        subtotalAmount: {
+            currencyCode: import("../../../storefront-api-types.js").CurrencyCode;
+            amount: string;
+        };
+        totalAmount: {
+            currencyCode: import("../../../storefront-api-types.js").CurrencyCode;
+            amount: string;
+        };
+        totalTaxAmount: {
+            currencyCode: import("../../../storefront-api-types.js").CurrencyCode;
+            amount: string;
+        };
+        totalDutyAmount: {
+            currencyCode: import("../../../storefront-api-types.js").CurrencyCode;
+            amount: string;
+        };
+    };
+};
+export declare const CART_WITH_LINES_FLATTENED: {
+    lines: import("type-fest/source/partial-deep.js").PartialObjectDeep<{
+        attributes: {
+            key: string;
+            value: string;
+        }[];
+        quantity: number;
+        id: string;
+        merchandise: {
+            id: string;
+            availableForSale: boolean;
+            priceV2: {
+                amount: string;
+                currencyCode: import("../../../storefront-api-types.js").CurrencyCode;
+            };
+            product: {
+                handle: string;
+                title: string;
+            };
+            requiresShipping: boolean;
+            selectedOptions: {
+                name: string;
+                value: string;
+            }[];
+            title: string;
+        };
+        cost: {
+            totalAmount: {
+                amount: string;
+                currencyCode: import("../../../storefront-api-types.js").CurrencyCode;
+            };
+            compareAtAmount: {
+                amount: string;
+                currencyCode: import("../../../storefront-api-types.js").CurrencyCode;
+            };
+        };
+    }>[];
+    id: string;
+    checkoutUrl: string;
+    attributes: never[];
+    buyerIdentity: {};
+    discountCodes: never[];
+    totalQuantity: number;
+    cost: {
+        subtotalAmount: {
+            currencyCode: import("../../../storefront-api-types.js").CurrencyCode;
+            amount: string;
+        };
+        totalAmount: {
+            currencyCode: import("../../../storefront-api-types.js").CurrencyCode;
+            amount: string;
+        };
+        totalTaxAmount: {
+            currencyCode: import("../../../storefront-api-types.js").CurrencyCode;
+            amount: string;
+        };
+        totalDutyAmount: {
+            currencyCode: import("../../../storefront-api-types.js").CurrencyCode;
+            amount: string;
+        };
+    };
+};
+export declare const CART_ACTIONS: CartWithActions;
+export declare const CART_WITH_ACTIONS: CartWithActions;
diff --git a/dist/dist/esnext/components/CartProvider/tests/fixtures.js b/dist/dist/esnext/components/CartProvider/tests/fixtures.js
new file mode 100644
index 0000000000000000000000000000000000000000..0fb71465c41cc30d50a73c5abc4a1e1335ccbeb1
--- /dev/null
+++ b/dist/dist/esnext/components/CartProvider/tests/fixtures.js
@@ -0,0 +1,53 @@
+import { CART_LINE } from '../../CartLineProvider/tests/fixtures.js';
+import { getPrice } from '../../../utilities/tests/price.js';
+import { flattenConnection } from '../../../utilities/index.js';
+import { defaultCartFragment } from '../cart-queries.js';
+export const CART = {
+    id: 'abc',
+    checkoutUrl: 'https://shopify.com/checkout',
+    attributes: [],
+    buyerIdentity: {},
+    discountCodes: [],
+    totalQuantity: 0,
+    cost: {
+        subtotalAmount: getPrice(),
+        totalAmount: getPrice(),
+        totalTaxAmount: getPrice(),
+        totalDutyAmount: getPrice(),
+    },
+    lines: { edges: [] },
+};
+export function getCartMock(options) {
+    return { ...CART, ...options };
+}
+export const CART_WITH_LINES = {
+    ...CART,
+    lines: { edges: [{ node: CART_LINE }] },
+};
+export const CART_WITH_LINES_FLATTENED = {
+    ...CART,
+    lines: flattenConnection(CART_WITH_LINES.lines),
+};
+export const CART_ACTIONS = {
+    // @ts-ignore
+    lines: [],
+    attributes: [],
+    status: 'idle',
+    cartCreate: () => { },
+    linesAdd: () => { },
+    linesRemove: () => { },
+    linesUpdate: () => { },
+    noteUpdate: () => { },
+    buyerIdentityUpdate: () => { },
+    cartAttributesUpdate: () => { },
+    discountCodesUpdate: () => { },
+    totalQuantity: CART_WITH_LINES_FLATTENED.lines.reduce((prev, curr) => {
+        return prev + (curr?.quantity ?? 0);
+    }, 0),
+    cartFragment: defaultCartFragment,
+};
+// @ts-ignore
+export const CART_WITH_ACTIONS = {
+    ...CART_ACTIONS,
+    ...CART_WITH_LINES_FLATTENED,
+};
diff --git a/dist/dist/esnext/components/CartProvider/types.d.ts b/dist/dist/esnext/components/CartProvider/types.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1193411b0dadd4222630dbfc7bfad48a3f04c127
--- /dev/null
+++ b/dist/dist/esnext/components/CartProvider/types.d.ts
@@ -0,0 +1,275 @@
+import { CartInput, CartLineInput, CartLineUpdateInput, MutationCartNoteUpdateArgs, CartBuyerIdentityInput, MutationCartAttributesUpdateArgs } from '../../storefront-api-types.js';
+import { CartFragmentFragment } from './graphql/CartFragment.js';
+import { StateMachine } from '@xstate/fsm';
+export declare type Status = State['status'];
+export interface Cart {
+    /** The cart's ID if it has been created through the Storefront API. */
+    id?: string;
+    /** The cart lines. */
+    lines: CartFragmentFragment['lines']['edges'][1]['node'][];
+    /** The checkout URL for the cart, if the cart has been created in the Storefront API. */
+    checkoutUrl?: string;
+    /** The cart's note. */
+    note?: string;
+    /** The cart's buyer identity. */
+    buyerIdentity?: CartFragmentFragment['buyerIdentity'];
+    /** The cart's attributes. */
+    attributes: CartFragmentFragment['attributes'];
+    /** The discount codes applied to the cart. */
+    discountCodes?: CartFragmentFragment['discountCodes'];
+    /** The cost for the cart, including the subtotal, total, taxes, and duties. */
+    cost?: CartFragmentFragment['cost'];
+    /** The total number of items in the cart, across all lines. If there are no lines, then the value is 0. */
+    totalQuantity: number;
+}
+export interface CartWithActions extends Cart {
+    /** The status of the cart. This returns 'uninitialized' when the cart is not yet created, `creating` when the cart is being created, `fetching` when an existing cart is being fetched, `updating` when the cart is updating, and `idle` when the cart isn't being created or updated. */
+    status: Status;
+    /** If an error occurred on the previous cart action, then `error` will exist and `cart` will be put back into the last valid status it was in. */
+    error?: string;
+    /** A callback that creates a cart. Expects the same input you would provide to the Storefront API's `cartCreate` mutation. */
+    cartCreate: (cart: CartInput) => void;
+    /** A callback that adds lines to the cart. Expects the same `lines` input that you would provide to the Storefront API's `cartLinesAdd` mutation. If a cart doesn't already exist, then it will create the cart for you. */
+    linesAdd: (lines: CartLineInput[]) => void;
+    /** A callback that removes lines from the cart. Expects the same `lines` input that you would provide to the Storefront API's `cartLinesRemove` mutation. Only lines that are included in the `lines` parameter will be in the cart afterwards. */
+    linesRemove: (lines: string[]) => void;
+    /** A callback that updates lines in the cart. Expects the same `lines` input that you would provide to the Storefront API's `cartLinesUpdate` mutation. If a line item is not included in the `lines` parameter, it will still exist in the cart and will not be changed. */
+    linesUpdate: (lines: CartLineUpdateInput[]) => void;
+    /** A callback that updates the note in the cart. Expects the same `note` input that you would provide to the Storefront API's `cartNoteUpdate` mutation. */
+    noteUpdate: (note: MutationCartNoteUpdateArgs['note']) => void;
+    /** A callback that updates the buyer identity in the cart. Expects the same `buyerIdentity` input that you would provide to the Storefront API's `cartBuyerIdentityUpdate` mutation. */
+    buyerIdentityUpdate: (buyerIdenity: CartBuyerIdentityInput) => void;
+    /** A callback that updates the cart attributes. Expects the same `attributes` input that you would provide to the Storefront API's `cartAttributesUpdate` mutation. */
+    cartAttributesUpdate: (attributes: MutationCartAttributesUpdateArgs['attributes']) => void;
+    /** A callback that updates the cart's discount codes. Expects the same `codes` input that you would provide to the Storefront API's `cartDiscountCodesUpdate` mutation. */
+    discountCodesUpdate: (discountCodes: string[]) => void;
+    /** The total number of items in the cart, across all lines. If there are no lines, then the value is 0. */
+    totalQuantity: number;
+    /** The fragment used to query the cart object for all queries and mutations. */
+    cartFragment: string;
+}
+export declare type State = 
+/** A cart has not been created yet, or an error occurred when a cart was attempting to be created or fetched. */
+{
+    status: 'uninitialized';
+    error?: string;
+}
+/** An existing cart is being fetched from the Storefront API. */
+ | {
+    status: 'fetching';
+}
+/** A new cart is being created through the Storefront API. */
+ | {
+    status: 'creating';
+}
+/** The cart is in the process of being updated. */
+ | {
+    status: 'updating';
+    cart: Cart;
+    lastValidCart: Cart;
+}
+/** The cart has been created and no action is currently happening. */
+ | {
+    status: 'idle';
+    cart: Cart;
+    error?: string;
+};
+export declare type CartAction = {
+    type: 'cartFetch';
+} | {
+    type: 'cartCreate';
+} | {
+    type: 'addLineItem';
+} | {
+    type: 'removeLineItem';
+    lines: string[];
+} | {
+    type: 'updateLineItem';
+    lines: CartLineUpdateInput[];
+} | {
+    type: 'noteUpdate';
+} | {
+    type: 'buyerIdentityUpdate';
+} | {
+    type: 'cartAttributesUpdate';
+} | {
+    type: 'discountCodesUpdate';
+} | {
+    type: 'resolve';
+    cart: Cart;
+    rawCartResult?: CartFragmentFragment;
+} | {
+    type: 'reject';
+    errors: any;
+} | {
+    type: 'resetCart';
+};
+export declare type CartMachineContext = {
+    cart?: Cart;
+    lastValidCart?: Cart;
+    rawCartResult?: CartFragmentFragment;
+    prevCart?: Cart;
+    errors?: any;
+};
+export declare type CartFetchEvent = {
+    type: 'CART_FETCH';
+    payload: {
+        cartId: string;
+    };
+};
+export declare type CartCreateEvent = {
+    type: 'CART_CREATE';
+    payload: CartInput;
+};
+export declare type CartSetEvent = {
+    type: 'CART_SET';
+    payload: {
+        cart: CartFragmentFragment;
+    };
+};
+export declare type CartLineAddEvent = {
+    type: 'CARTLINE_ADD';
+    payload: {
+        lines: CartLineInput[];
+    };
+};
+export declare type CartLineRemoveEvent = {
+    type: 'CARTLINE_REMOVE';
+    payload: {
+        lines: string[];
+    };
+};
+export declare type CartLineUpdateEvent = {
+    type: 'CARTLINE_UPDATE';
+    payload: {
+        lines: CartLineUpdateInput[];
+    };
+};
+export declare type NoteUpdateEvent = {
+    type: 'NOTE_UPDATE';
+    payload: {
+        note: MutationCartNoteUpdateArgs['note'];
+    };
+};
+export declare type BuyerIdentityUpdateEvent = {
+    type: 'BUYER_IDENTITY_UPDATE';
+    payload: {
+        buyerIdentity: CartBuyerIdentityInput;
+    };
+};
+export declare type CartAttributesUpdateEvent = {
+    type: 'CART_ATTRIBUTES_UPDATE';
+    payload: {
+        attributes: MutationCartAttributesUpdateArgs['attributes'];
+    };
+};
+export declare type DiscountCodesUpdateEvent = {
+    type: 'DISCOUNT_CODES_UPDATE';
+    payload: {
+        discountCodes: string[];
+    };
+};
+export declare type CartMachineActionEvent = CartFetchEvent | CartCreateEvent | CartSetEvent | CartLineAddEvent | CartLineRemoveEvent | CartLineUpdateEvent | NoteUpdateEvent | BuyerIdentityUpdateEvent | CartAttributesUpdateEvent | DiscountCodesUpdateEvent;
+export declare type CartMachineFetchResultEvent = {
+    type: 'CART_COMPLETED';
+    payload: {
+        cartActionEvent: CartMachineActionEvent;
+    };
+} | {
+    type: 'RESOLVE';
+    payload: {
+        cartActionEvent: CartMachineActionEvent;
+        cart: Cart;
+        rawCartResult: CartFragmentFragment;
+    };
+} | {
+    type: 'ERROR';
+    payload: {
+        cartActionEvent: CartMachineActionEvent;
+        errors: any;
+    };
+};
+export declare type CartMachineEvent = CartMachineActionEvent | CartMachineFetchResultEvent;
+export declare type CartMachineTypeState = {
+    value: 'uninitialized';
+    context: CartMachineContext & {
+        cart: undefined;
+        lastValidCart: undefined;
+        prevCart: undefined;
+        errors?: any;
+    };
+} | {
+    value: 'initializationError';
+    context: CartMachineContext & {
+        cart: undefined;
+        lastValidCart: undefined;
+        prevCart: undefined;
+        errors: any;
+    };
+} | {
+    value: 'cartCompleted';
+    context: CartMachineContext & {
+        cart: undefined;
+        prevCart?: Cart;
+        lastValidCart: undefined;
+        errors: any;
+    };
+} | {
+    value: 'idle';
+    context: CartMachineContext & {
+        cart: Cart;
+        prevCart?: Cart;
+        lastValidCart?: Cart;
+        errors?: any;
+    };
+} | {
+    value: 'error';
+    context: CartMachineContext & {
+        cart?: Cart;
+        prevCart?: Cart;
+        lastValidCart?: Cart;
+        errors: any;
+    };
+} | {
+    value: 'cartFetching';
+    context: CartMachineContext;
+} | {
+    value: 'cartCreating';
+    context: CartMachineContext;
+} | {
+    value: 'cartLineRemoving';
+    context: CartMachineContext;
+} | {
+    value: 'cartLineUpdating';
+    context: CartMachineContext;
+} | {
+    value: 'cartLineAdding';
+    context: CartMachineContext;
+} | {
+    value: 'noteUpdating';
+    context: CartMachineContext;
+} | {
+    value: 'buyerIdentityUpdating';
+    context: CartMachineContext;
+} | {
+    value: 'cartAttributesUpdating';
+    context: CartMachineContext;
+} | {
+    value: 'discountCodesUpdating';
+    context: CartMachineContext;
+};
+export declare type CartMachineAction = StateMachine.ActionFunction<CartMachineContext, CartMachineEvent>;
+export declare type CartMachineActions = {
+    cartFetchAction: CartMachineAction;
+    cartCreateAction: CartMachineAction;
+    cartLineRemoveAction: CartMachineAction;
+    cartLineUpdateAction: CartMachineAction;
+    cartLineAddAction: CartMachineAction;
+    noteUpdateAction: CartMachineAction;
+    buyerIdentityUpdateAction: CartMachineAction;
+    cartAttributesUpdateAction: CartMachineAction;
+    discountCodesUpdateAction: CartMachineAction;
+    onCartActionEntry?: CartMachineAction;
+    onCartActionOptimisticUI?: StateMachine.AssignActionObject<CartMachineContext, CartMachineEvent>;
+    onCartActionComplete?: CartMachineAction;
+};
diff --git a/dist/dist/esnext/components/CartProvider/types.js b/dist/dist/esnext/components/CartProvider/types.js
new file mode 100644
index 0000000000000000000000000000000000000000..cb0ff5c3b541f646105198ee23ac0fc3d805023e
--- /dev/null
+++ b/dist/dist/esnext/components/CartProvider/types.js
@@ -0,0 +1 @@
+export {};
diff --git a/dist/dist/esnext/components/CartProvider/useCartAPIStateMachine.client.d.ts b/dist/dist/esnext/components/CartProvider/useCartAPIStateMachine.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b2e69f4cbd275f7554298a96e7679221a58ecba0
--- /dev/null
+++ b/dist/dist/esnext/components/CartProvider/useCartAPIStateMachine.client.d.ts
@@ -0,0 +1,21 @@
+import { StateMachine } from '@xstate/fsm';
+import { CartFragmentFragment } from './graphql/CartFragment.js';
+import { Cart, CartMachineActionEvent, CartMachineContext, CartMachineEvent, CartMachineFetchResultEvent, CartMachineTypeState } from './types.js';
+import { CountryCode } from '../../storefront-api-types.js';
+export declare function useCartAPIStateMachine({ numCartLines, onCartActionEntry, onCartActionOptimisticUI, onCartActionComplete, data: cart, cartFragment, countryCode, }: {
+    /**  Maximum number of cart lines to fetch. Defaults to 250 cart lines. */
+    numCartLines?: number;
+    /** A callback that is invoked just before a Cart API action executes. */
+    onCartActionEntry?: (context: CartMachineContext, event: CartMachineActionEvent) => void;
+    /** A callback that is invoked after executing the entry actions for optimistic UI changes.  */
+    onCartActionOptimisticUI?: (context: CartMachineContext, event: CartMachineEvent) => Partial<CartMachineContext>;
+    /** A callback that is invoked after a Cart API completes. */
+    onCartActionComplete?: (context: CartMachineContext, event: CartMachineFetchResultEvent) => void;
+    /** An object with fields that correspond to the Storefront API's [Cart object](https://shopify.dev/api/storefront/latest/objects/cart). */
+    data?: CartFragmentFragment;
+    /** A fragment used to query the Storefront API's [Cart object](https://shopify.dev/api/storefront/latest/objects/cart) for all queries and mutations. A default value is used if no argument is provided. */
+    cartFragment: string;
+    /** The ISO country code for i18n. */
+    countryCode?: CountryCode;
+}): readonly [StateMachine.State<CartMachineContext, CartMachineEvent, CartMachineTypeState>, (event: "CART_FETCH" | "CART_CREATE" | "CART_SET" | "CARTLINE_ADD" | "CARTLINE_REMOVE" | "CARTLINE_UPDATE" | "NOTE_UPDATE" | "BUYER_IDENTITY_UPDATE" | "CART_ATTRIBUTES_UPDATE" | "DISCOUNT_CODES_UPDATE" | "CART_COMPLETED" | "RESOLVE" | "ERROR" | CartMachineEvent) => void, StateMachine.Service<CartMachineContext, CartMachineEvent, CartMachineTypeState>];
+export declare function cartFromGraphQL(cart: CartFragmentFragment): Cart;
diff --git a/dist/dist/esnext/components/CartProvider/useCartAPIStateMachine.client.js b/dist/dist/esnext/components/CartProvider/useCartAPIStateMachine.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..da8e1190cbc6c7690a3c0768945a8d95fed9678f
--- /dev/null
+++ b/dist/dist/esnext/components/CartProvider/useCartAPIStateMachine.client.js
@@ -0,0 +1,266 @@
+import { useMachine } from '@xstate/react/fsm';
+import { createMachine, assign } from '@xstate/fsm';
+import { flattenConnection } from '../../utilities/flattenConnection/index.js';
+import { useCartActions } from './CartActions.client.js';
+import { useMemo } from 'react';
+function invokeCart(action, options) {
+    return {
+        entry: [
+            ...(options?.entryActions || []),
+            'onCartActionEntry',
+            'onCartActionOptimisticUI',
+            action,
+        ],
+        on: {
+            RESOLVE: {
+                target: options?.resolveTarget || 'idle',
+                actions: [
+                    assign({
+                        prevCart: (context) => context?.cart,
+                        cart: (_, event) => event?.payload?.cart,
+                        rawCartResult: (_, event) => event?.payload?.rawCartResult,
+                        errors: (_) => undefined,
+                    }),
+                ],
+            },
+            ERROR: {
+                target: options?.errorTarget || 'error',
+                actions: [
+                    assign({
+                        prevCart: (context) => context?.cart,
+                        cart: (context, _) => context?.lastValidCart,
+                        errors: (_, event) => event?.payload?.errors,
+                    }),
+                ],
+            },
+            CART_COMPLETED: {
+                target: 'cartCompleted',
+                actions: assign({
+                    prevCart: (_) => undefined,
+                    cart: (_) => undefined,
+                    lastValidCart: (_) => undefined,
+                    errors: (_) => undefined,
+                }),
+            },
+        },
+        exit: ['onCartActionComplete', ...(options?.exitActions || [])],
+    };
+}
+const INITIALIZING_CART_EVENTS = {
+    CART_FETCH: {
+        target: 'cartFetching',
+    },
+    CART_CREATE: {
+        target: 'cartCreating',
+    },
+    CART_SET: {
+        target: 'idle',
+        actions: [
+            assign({
+                rawCartResult: (_, event) => event.payload.cart,
+                cart: (_, event) => cartFromGraphQL(event.payload.cart),
+            }),
+        ],
+    },
+};
+const UPDATING_CART_EVENTS = {
+    CARTLINE_ADD: {
+        target: 'cartLineAdding',
+    },
+    CARTLINE_UPDATE: {
+        target: 'cartLineUpdating',
+    },
+    CARTLINE_REMOVE: {
+        target: 'cartLineRemoving',
+    },
+    NOTE_UPDATE: {
+        target: 'noteUpdating',
+    },
+    BUYER_IDENTITY_UPDATE: {
+        target: 'buyerIdentityUpdating',
+    },
+    CART_ATTRIBUTES_UPDATE: {
+        target: 'cartAttributesUpdating',
+    },
+    DISCOUNT_CODES_UPDATE: {
+        target: 'discountCodesUpdating',
+    },
+};
+function createCartMachine(initialCart) {
+    return createMachine({
+        id: 'Cart',
+        initial: initialCart ? 'idle' : 'uninitialized',
+        context: {
+            cart: initialCart && cartFromGraphQL(initialCart),
+        },
+        states: {
+            uninitialized: {
+                on: INITIALIZING_CART_EVENTS,
+            },
+            cartCompleted: {
+                on: INITIALIZING_CART_EVENTS,
+            },
+            initializationError: {
+                on: INITIALIZING_CART_EVENTS,
+            },
+            idle: {
+                on: { ...INITIALIZING_CART_EVENTS, ...UPDATING_CART_EVENTS },
+            },
+            error: {
+                on: { ...INITIALIZING_CART_EVENTS, ...UPDATING_CART_EVENTS },
+            },
+            cartFetching: invokeCart('cartFetchAction', {
+                errorTarget: 'initializationError',
+            }),
+            cartCreating: invokeCart('cartCreateAction', {
+                errorTarget: 'initializationError',
+            }),
+            cartLineRemoving: invokeCart('cartLineRemoveAction'),
+            cartLineUpdating: invokeCart('cartLineUpdateAction'),
+            cartLineAdding: invokeCart('cartLineAddAction'),
+            noteUpdating: invokeCart('noteUpdateAction'),
+            buyerIdentityUpdating: invokeCart('buyerIdentityUpdateAction'),
+            cartAttributesUpdating: invokeCart('cartAttributesUpdateAction'),
+            discountCodesUpdating: invokeCart('discountCodesUpdateAction'),
+        },
+    });
+}
+export function useCartAPIStateMachine({ numCartLines, onCartActionEntry, onCartActionOptimisticUI, onCartActionComplete, data: cart, cartFragment, countryCode, }) {
+    const { cartFetch, cartCreate, cartLineAdd, cartLineUpdate, cartLineRemove, noteUpdate, buyerIdentityUpdate, cartAttributesUpdate, discountCodesUpdate, } = useCartActions({
+        numCartLines,
+        cartFragment,
+        countryCode,
+    });
+    const cartMachine = useMemo(() => createCartMachine(cart), [cart]);
+    const [state, send, service] = useMachine(cartMachine, {
+        actions: {
+            cartFetchAction: async (_, event) => {
+                if (event.type !== 'CART_FETCH')
+                    return;
+                const { data, errors } = await cartFetch(event?.payload?.cartId);
+                const resultEvent = eventFromFetchResult(event, data?.cart, errors);
+                send(resultEvent);
+            },
+            cartCreateAction: async (_, event) => {
+                if (event.type !== 'CART_CREATE')
+                    return;
+                const { data, errors } = await cartCreate(event?.payload);
+                const resultEvent = eventFromFetchResult(event, data?.cartCreate?.cart, errors);
+                send(resultEvent);
+            },
+            cartLineAddAction: async (context, event) => {
+                if (event.type !== 'CARTLINE_ADD' || !context?.cart?.id)
+                    return;
+                const { data, errors } = await cartLineAdd(context.cart.id, event.payload.lines);
+                const resultEvent = eventFromFetchResult(event, data?.cartLinesAdd?.cart, errors);
+                send(resultEvent);
+            },
+            cartLineUpdateAction: async (context, event) => {
+                if (event.type !== 'CARTLINE_UPDATE' || !context?.cart?.id)
+                    return;
+                const { data, errors } = await cartLineUpdate(context.cart.id, event.payload.lines);
+                const resultEvent = eventFromFetchResult(event, data?.cartLinesUpdate?.cart, errors);
+                send(resultEvent);
+            },
+            cartLineRemoveAction: async (context, event) => {
+                if (event.type !== 'CARTLINE_REMOVE' || !context?.cart?.id)
+                    return;
+                const { data, errors } = await cartLineRemove(context.cart.id, event.payload.lines);
+                const resultEvent = eventFromFetchResult(event, data?.cartLinesRemove?.cart, errors);
+                send(resultEvent);
+            },
+            noteUpdateAction: async (context, event) => {
+                if (event.type !== 'NOTE_UPDATE' || !context?.cart?.id)
+                    return;
+                const { data, errors } = await noteUpdate(context.cart.id, event.payload.note);
+                const resultEvent = eventFromFetchResult(event, data?.cartNoteUpdate?.cart, errors);
+                send(resultEvent);
+            },
+            buyerIdentityUpdateAction: async (context, event) => {
+                if (event.type !== 'BUYER_IDENTITY_UPDATE' || !context?.cart?.id)
+                    return;
+                const { data, errors } = await buyerIdentityUpdate(context.cart.id, event.payload.buyerIdentity);
+                const resultEvent = eventFromFetchResult(event, data?.cartBuyerIdentityUpdate?.cart, errors);
+                send(resultEvent);
+            },
+            cartAttributesUpdateAction: async (context, event) => {
+                if (event.type !== 'CART_ATTRIBUTES_UPDATE' || !context?.cart?.id)
+                    return;
+                const { data, errors } = await cartAttributesUpdate(context.cart.id, event.payload.attributes);
+                const resultEvent = eventFromFetchResult(event, data?.cartAttributesUpdate?.cart, errors);
+                send(resultEvent);
+            },
+            discountCodesUpdateAction: async (context, event) => {
+                if (event.type !== 'DISCOUNT_CODES_UPDATE' || !context?.cart?.id)
+                    return;
+                const { data, errors } = await discountCodesUpdate(context.cart.id, event.payload.discountCodes);
+                const resultEvent = eventFromFetchResult(event, data?.cartDiscountCodesUpdate?.cart, errors);
+                send(resultEvent);
+            },
+            ...(onCartActionEntry && {
+                onCartActionEntry: (context, event) => {
+                    if (isCartActionEvent(event)) {
+                        onCartActionEntry(context, event);
+                    }
+                },
+            }),
+            ...(onCartActionOptimisticUI && {
+                onCartActionOptimisticUI: assign((context, event) => {
+                    return onCartActionOptimisticUI(context, event);
+                }),
+            }),
+            ...(onCartActionComplete && {
+                onCartActionComplete: (context, event) => {
+                    if (isCartFetchResultEvent(event)) {
+                        onCartActionComplete(context, event);
+                    }
+                },
+            }),
+        },
+    });
+    return useMemo(() => [state, send, service], [state, send, service]);
+}
+export function cartFromGraphQL(cart) {
+    return {
+        ...cart,
+        // @ts-expect-error While the cart still uses fragments, there will be a TS error here until we remove those fragments and get the type in-line
+        lines: flattenConnection(cart.lines),
+        note: cart.note ?? undefined,
+    };
+}
+function eventFromFetchResult(cartActionEvent, cart, errors) {
+    if (errors) {
+        return { type: 'ERROR', payload: { errors, cartActionEvent } };
+    }
+    if (!cart) {
+        return {
+            type: 'CART_COMPLETED',
+            payload: {
+                cartActionEvent,
+            },
+        };
+    }
+    return {
+        type: 'RESOLVE',
+        payload: {
+            cart: cartFromGraphQL(cart),
+            rawCartResult: cart,
+            cartActionEvent,
+        },
+    };
+}
+function isCartActionEvent(event) {
+    return (event.type === 'CART_CREATE' ||
+        event.type === 'CARTLINE_ADD' ||
+        event.type === 'CARTLINE_UPDATE' ||
+        event.type === 'CARTLINE_REMOVE' ||
+        event.type === 'NOTE_UPDATE' ||
+        event.type === 'BUYER_IDENTITY_UPDATE' ||
+        event.type === 'CART_ATTRIBUTES_UPDATE' ||
+        event.type === 'DISCOUNT_CODES_UPDATE');
+}
+function isCartFetchResultEvent(event) {
+    return (event.type === 'RESOLVE' ||
+        event.type === 'ERROR' ||
+        event.type === 'CART_COMPLETED');
+}
diff --git a/dist/dist/esnext/components/CartShopPayButton/CartShopPayButton.client.d.ts b/dist/dist/esnext/components/CartShopPayButton/CartShopPayButton.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..553f6f3e9ff8c6df5ba6d7a9283396613a3cf348
--- /dev/null
+++ b/dist/dist/esnext/components/CartShopPayButton/CartShopPayButton.client.d.ts
@@ -0,0 +1,7 @@
+import React from 'react';
+import { ShopPayButton } from '../ShopPayButton/index.js';
+/**
+ * The `CartShopPayButton` component renders a `ShopPayButton` for the items in the cart.
+ * It must be a descendent of a `CartProvider` component.
+ */
+export declare function CartShopPayButton(props: Omit<React.ComponentProps<typeof ShopPayButton>, 'variantIds'>): JSX.Element;
diff --git a/dist/dist/esnext/components/CartShopPayButton/CartShopPayButton.client.js b/dist/dist/esnext/components/CartShopPayButton/CartShopPayButton.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..0e09730484ebfbd8a5e02914a533f382a9e94a8a
--- /dev/null
+++ b/dist/dist/esnext/components/CartShopPayButton/CartShopPayButton.client.js
@@ -0,0 +1,17 @@
+import React, { useMemo } from 'react';
+import { useCart } from '../CartProvider/index.js';
+import { ShopPayButton } from '../ShopPayButton/index.js';
+/**
+ * The `CartShopPayButton` component renders a `ShopPayButton` for the items in the cart.
+ * It must be a descendent of a `CartProvider` component.
+ */
+export function CartShopPayButton(props) {
+    const { lines } = useCart();
+    const idsAndQuantities = useMemo(() => {
+        return lines.map((line) => ({
+            id: line.merchandise.id,
+            quantity: line.quantity,
+        }));
+    }, [lines]);
+    return (React.createElement(ShopPayButton, { variantIdsAndQuantities: idsAndQuantities, ...props }));
+}
diff --git a/dist/dist/esnext/components/CartShopPayButton/index.d.ts b/dist/dist/esnext/components/CartShopPayButton/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d06a2a1be4314497bc7fa444dbf816298884ab10
--- /dev/null
+++ b/dist/dist/esnext/components/CartShopPayButton/index.d.ts
@@ -0,0 +1 @@
+export { CartShopPayButton } from './CartShopPayButton.client.js';
diff --git a/dist/dist/esnext/components/CartShopPayButton/index.js b/dist/dist/esnext/components/CartShopPayButton/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..d06a2a1be4314497bc7fa444dbf816298884ab10
--- /dev/null
+++ b/dist/dist/esnext/components/CartShopPayButton/index.js
@@ -0,0 +1 @@
+export { CartShopPayButton } from './CartShopPayButton.client.js';
diff --git a/dist/dist/esnext/components/ExternalVideo/ExternalVideo.d.ts b/dist/dist/esnext/components/ExternalVideo/ExternalVideo.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..78eb17e88b744bc24d34a341acc9793b19bd4b27
--- /dev/null
+++ b/dist/dist/esnext/components/ExternalVideo/ExternalVideo.d.ts
@@ -0,0 +1,21 @@
+import { YouTube, Vimeo } from '../../utilities/index.js';
+import type { ExternalVideo as ExternalVideoType } from '../../storefront-api-types.js';
+import type { PartialDeep } from 'type-fest';
+interface ExternalVideoProps {
+    /**
+     * An object with fields that correspond to the Storefront API's [ExternalVideo object](https://shopify.dev/api/storefront/reference/products/externalvideo).
+     */
+    data: PartialDeep<ExternalVideoType>;
+    /** An object containing the options available for either
+     * [YouTube](https://developers.google.com/youtube/player_parameters#Parameters) or
+     * [Vimeo](https://vimeo.zendesk.com/hc/en-us/articles/360001494447-Using-Player-Parameters).
+     */
+    options?: YouTube | Vimeo;
+}
+declare type PropsWeControl = 'src';
+/**
+ * The `ExternalVideo` component renders an embedded video for the Storefront
+ * API's [ExternalVideo object](https://shopify.dev/api/storefront/reference/products/externalvideo).
+ */
+export declare function ExternalVideo(props: Omit<JSX.IntrinsicElements['iframe'], PropsWeControl> & ExternalVideoProps): JSX.Element;
+export {};
diff --git a/dist/dist/esnext/components/ExternalVideo/ExternalVideo.js b/dist/dist/esnext/components/ExternalVideo/ExternalVideo.js
new file mode 100644
index 0000000000000000000000000000000000000000..f03ef98910d1e326f4e9fedd445623c0cc743493
--- /dev/null
+++ b/dist/dist/esnext/components/ExternalVideo/ExternalVideo.js
@@ -0,0 +1,14 @@
+import React from 'react';
+import { useEmbeddedVideoUrl } from '../../utilities/index.js';
+/**
+ * The `ExternalVideo` component renders an embedded video for the Storefront
+ * API's [ExternalVideo object](https://shopify.dev/api/storefront/reference/products/externalvideo).
+ */
+export function ExternalVideo(props) {
+    const { data, options, id = data.id, frameBorder = '0', allow = 'accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture', allowFullScreen = true, loading = 'lazy', ...passthroughProps } = props;
+    if (!data.embedUrl) {
+        throw new Error(`<ExternalVideo/> requires the 'embedUrl' property`);
+    }
+    const url = useEmbeddedVideoUrl(data.embedUrl, options);
+    return (React.createElement("iframe", { ...passthroughProps, id: id ?? data.embedUrl, frameBorder: frameBorder, allow: allow, allowFullScreen: allowFullScreen, src: url, loading: loading }));
+}
diff --git a/dist/dist/esnext/components/ExternalVideo/index.d.ts b/dist/dist/esnext/components/ExternalVideo/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2ffdf8ad3e29d7e18c12f0a5d63aa88cd735b960
--- /dev/null
+++ b/dist/dist/esnext/components/ExternalVideo/index.d.ts
@@ -0,0 +1 @@
+export { ExternalVideo } from './ExternalVideo.js';
diff --git a/dist/dist/esnext/components/ExternalVideo/index.js b/dist/dist/esnext/components/ExternalVideo/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..2ffdf8ad3e29d7e18c12f0a5d63aa88cd735b960
--- /dev/null
+++ b/dist/dist/esnext/components/ExternalVideo/index.js
@@ -0,0 +1 @@
+export { ExternalVideo } from './ExternalVideo.js';
diff --git a/dist/dist/esnext/components/Image/Image.d.ts b/dist/dist/esnext/components/Image/Image.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2a944a1482557695893f8fd993e52d6d7be53d48
--- /dev/null
+++ b/dist/dist/esnext/components/Image/Image.d.ts
@@ -0,0 +1,105 @@
+import * as React from 'react';
+import type { Image as ImageType } from '../../storefront-api-types.js';
+import type { PartialDeep, Simplify, SetRequired } from 'type-fest';
+declare type HtmlImageProps = React.ImgHTMLAttributes<HTMLImageElement>;
+declare type ImageProps<GenericLoaderOpts> = ShopifyImageProps | ExternalImageProps<GenericLoaderOpts>;
+/**
+ * The `Image` component renders an image for the Storefront API's
+ * [Image object](https://shopify.dev/api/storefront/reference/common-objects/image) by using the `data` prop, or a custom location by using the `src` prop. You can [customize this component](https://shopify.dev/api/hydrogen/components#customizing-hydrogen-components) using passthrough props.
+ *
+ * An image's width and height are determined using the following priority list:
+ * 1. The width and height values for the `loaderOptions` prop
+ * 2. The width and height values for bare props
+ * 3. The width and height values for the `data` prop
+ *
+ * If only one of `width` or `height` are defined, then the other will attempt to be calculated based on the image's aspect ratio,
+ * provided that both `data.width` and `data.height` are available. If `data.width` and `data.height` aren't available, then the aspect ratio cannot be determined and the missing
+ * value will remain as `null`
+ */
+export declare function Image<GenericLoaderOpts>(props: ImageProps<GenericLoaderOpts>): JSX.Element;
+export declare type ShopifyLoaderOptions = {
+    crop?: 'top' | 'bottom' | 'left' | 'right' | 'center';
+    scale?: 2 | 3;
+    width?: HtmlImageProps['width'] | ImageType['width'];
+    height?: HtmlImageProps['height'] | ImageType['height'];
+};
+export declare type ShopifyLoaderParams = Simplify<ShopifyLoaderOptions & {
+    src: ImageType['url'];
+}>;
+export declare type ShopifyImageProps = Omit<HtmlImageProps, 'src'> & {
+    /** An object with fields that correspond to the Storefront API's
+     * [Image object](https://shopify.dev/api/storefront/reference/common-objects/image).
+     * The `data` prop is required if `src` isn't used, but both props shouldn't be used
+     * at the same time. If both `src` and `data` are passed, then `data` takes priority.
+     */
+    data: SetRequired<PartialDeep<ImageType>, 'url'>;
+    /** A custom function that generates the image URL. Parameters passed in
+     * are either `ShopifyLoaderParams` if using the `data` prop, or the
+     * `LoaderOptions` object that you pass to `loaderOptions`.
+     */
+    loader?: (params: ShopifyLoaderParams) => string;
+    /** An object of `loader` function options. For example, if the `loader` function
+     * requires a `scale` option, then the value can be a property of the
+     * `loaderOptions` object (for example, `{scale: 2}`). When the `data` prop
+     * is used, the object shape will be `ShopifyLoaderOptions`. When the `src`
+     * prop is used, the data shape is whatever you define it to be, and this shape
+     * will be passed to `loader`.
+     */
+    loaderOptions?: ShopifyLoaderOptions;
+    /**
+     * 'src' shouldn't be passed when 'data' is used.
+     */
+    src?: never;
+    /**
+     * An array of pixel widths to overwrite the default generated srcset. For example, `[300, 600, 800]`.
+     */
+    widths?: (HtmlImageProps['width'] | ImageType['width'])[];
+};
+declare type LoaderProps<GenericLoaderOpts> = {
+    /** A URL string. This string can be an absolute path or a relative path depending
+     * on the `loader`. The `src` prop is required if `data` isn't used, but both
+     * props shouldn't be used at the same time. If both `src` and `data` are passed,
+     * then `data` takes priority.
+     */
+    src: HtmlImageProps['src'];
+    /** The integer or string value for the width of the image. This is a required prop
+     * when `src` is present.
+     */
+    width: HtmlImageProps['width'];
+    /** The integer or string value for the height of the image. This is a required prop
+     * when `src` is present.
+     */
+    height: HtmlImageProps['height'];
+    /** An object of `loader` function options. For example, if the `loader` function
+     * requires a `scale` option, then the value can be a property of the
+     * `loaderOptions` object (for example, `{scale: 2}`). When the `data` prop
+     * is used, the object shape will be `ShopifyLoaderOptions`. When the `src`
+     * prop is used, the data shape is whatever you define it to be, and this shape
+     * will be passed to `loader`.
+     */
+    loaderOptions?: GenericLoaderOpts;
+};
+export declare type ExternalImageProps<GenericLoaderOpts> = SetRequired<HtmlImageProps, 'src' | 'width' | 'height' | 'alt'> & {
+    /** A custom function that generates the image URL. Parameters passed in
+     * are either `ShopifyLoaderParams` if using the `data` prop, or the
+     * `LoaderOptions` object that you pass to `loaderOptions`.
+     */
+    loader?: (params: LoaderProps<GenericLoaderOpts>) => string;
+    /** An object of `loader` function options. For example, if the `loader` function
+     * requires a `scale` option, then the value can be a property of the
+     * `loaderOptions` object (for example, `{scale: 2}`). When the `data` prop
+     * is used, the object shape will be `ShopifyLoaderOptions`. When the `src`
+     * prop is used, the data shape is whatever you define it to be, and this shape
+     * will be passed to `loader`.
+     */
+    loaderOptions?: GenericLoaderOpts;
+    /**
+     * 'data' shouldn't be passed when 'src' is used.
+     */
+    data?: never;
+    /**
+     * An array of pixel widths to generate a srcset. For example, `[300, 600, 800]`.
+     */
+    widths?: HtmlImageProps['width'][];
+};
+export {};
diff --git a/dist/dist/esnext/components/Image/Image.js b/dist/dist/esnext/components/Image/Image.js
new file mode 100644
index 0000000000000000000000000000000000000000..0df688e6763ebb735b8d057a5b3af1fb991c8dd5
--- /dev/null
+++ b/dist/dist/esnext/components/Image/Image.js
@@ -0,0 +1,145 @@
+import * as React from 'react';
+import { getShopifyImageDimensions, shopifyImageLoader, addImageSizeParametersToUrl, IMG_SRC_SET_SIZES, } from '../../utilities/index.js';
+/**
+ * The `Image` component renders an image for the Storefront API's
+ * [Image object](https://shopify.dev/api/storefront/reference/common-objects/image) by using the `data` prop, or a custom location by using the `src` prop. You can [customize this component](https://shopify.dev/api/hydrogen/components#customizing-hydrogen-components) using passthrough props.
+ *
+ * An image's width and height are determined using the following priority list:
+ * 1. The width and height values for the `loaderOptions` prop
+ * 2. The width and height values for bare props
+ * 3. The width and height values for the `data` prop
+ *
+ * If only one of `width` or `height` are defined, then the other will attempt to be calculated based on the image's aspect ratio,
+ * provided that both `data.width` and `data.height` are available. If `data.width` and `data.height` aren't available, then the aspect ratio cannot be determined and the missing
+ * value will remain as `null`
+ */
+export function Image(props) {
+    if (!props.data && !props.src) {
+        throw new Error(`<Image/>: requires either a 'data' or 'src' prop.`);
+    }
+    if (__HYDROGEN_DEV__ && props.data && props.src) {
+        console.warn(`<Image/>: using both 'data' and 'src' props is not supported; using the 'data' prop by default`);
+    }
+    if (props.data) {
+        return React.createElement(ShopifyImage, { ...props });
+    }
+    else {
+        return React.createElement(ExternalImage, { ...props });
+    }
+}
+function ShopifyImage({ data, width, height, loading, loader = shopifyImageLoader, loaderOptions, widths, decoding = 'async', ...rest }) {
+    if (!data.url) {
+        throw new Error(`<Image/>: the 'data' prop requires the 'url' property`);
+    }
+    if (__HYDROGEN_DEV__ && !data.altText && !rest.alt) {
+        console.warn(`<Image/>: the 'data' prop should have the 'altText' property, or the 'alt' prop, and one of them should not be empty. ${`Image: ${data.id ?? data.url}`}`);
+    }
+    const { width: imgElementWidth, height: imgElementHeight } = getShopifyImageDimensions({
+        data,
+        loaderOptions,
+        elementProps: {
+            width,
+            height,
+        },
+    });
+    if (__HYDROGEN_DEV__ && (!imgElementWidth || !imgElementHeight)) {
+        console.warn(`<Image/>: the 'data' prop requires either 'width' or 'data.width', and 'height' or 'data.height' properties. ${`Image: ${data.id ?? data.url}`}`);
+    }
+    let finalSrc = data.url;
+    if (loader) {
+        finalSrc = loader({
+            ...loaderOptions,
+            src: data.url,
+            width: imgElementWidth,
+            height: imgElementHeight,
+        });
+        if (typeof finalSrc !== 'string' || !finalSrc) {
+            throw new Error(`<Image/>: 'loader' did not return a valid string. ${`Image: ${data.id ?? data.url}`}`);
+        }
+    }
+    // determining what the intended width of the image is. For example, if the width is specified and lower than the image width, then that is the maximum image width
+    // to prevent generating a srcset with widths bigger than needed or to generate images that would distort because of being larger than original
+    const maxWidth = width && imgElementWidth && width < imgElementWidth
+        ? width
+        : imgElementWidth;
+    const finalSrcset = rest.srcSet ??
+        internalImageSrcSet({
+            ...loaderOptions,
+            widths,
+            src: data.url,
+            width: maxWidth,
+            height: imgElementHeight,
+            loader,
+        });
+    /* eslint-disable hydrogen/prefer-image-component */
+    return (React.createElement("img", { id: data.id ?? '', alt: data.altText ?? rest.alt ?? '', loading: loading ?? 'lazy', ...rest, src: finalSrc, width: imgElementWidth ?? undefined, height: imgElementHeight ?? undefined, srcSet: finalSrcset, decoding: decoding }));
+    /* eslint-enable hydrogen/prefer-image-component */
+}
+function ExternalImage({ src, width, height, alt, loader, loaderOptions, widths, loading, decoding = 'async', ...rest }) {
+    if (!width || !height) {
+        throw new Error(`<Image/>: when 'src' is provided, 'width' and 'height' are required and need to be valid values (i.e. greater than zero). Provided values: 'src': ${src}, 'width': ${width}, 'height': ${height}`);
+    }
+    if (__HYDROGEN_DEV__ && !alt) {
+        console.warn(`<Image/>: when 'src' is provided, 'alt' should also be provided. ${`Image: ${src}`}`);
+    }
+    if (widths &&
+        Array.isArray(widths) &&
+        widths.some((size) => isNaN(size)))
+        throw new Error(`<Image/>: the 'widths' property must be an array of numbers`);
+    let finalSrc = src;
+    if (loader) {
+        finalSrc = loader({ src, width, height, ...loaderOptions });
+        if (typeof finalSrc !== 'string' || !finalSrc) {
+            throw new Error(`<Image/>: 'loader' did not return a valid string`);
+        }
+    }
+    let finalSrcset = rest.srcSet ?? undefined;
+    if (!finalSrcset && loader && widths) {
+        // Height is a requirement in the LoaderProps, so  to keep the aspect ratio, we must determine the height based on the default values
+        const heightToWidthRatio = parseInt(height.toString()) / parseInt(width.toString());
+        finalSrcset = widths
+            ?.map((width) => parseInt(width, 10))
+            ?.map((width) => `${loader({
+            ...loaderOptions,
+            src,
+            width,
+            height: Math.floor(width * heightToWidthRatio),
+        })} ${width}w`)
+            .join(', ');
+    }
+    /* eslint-disable hydrogen/prefer-image-component */
+    return (React.createElement("img", { ...rest, src: finalSrc, 
+        // @ts-expect-error TS doesn't understand that it could exist
+        width: loaderOptions?.width ?? width, 
+        // @ts-expect-error TS doesn't understand that it could exist
+        height: loaderOptions?.height ?? height, alt: alt ?? '', loading: loading ?? 'lazy', srcSet: finalSrcset, decoding: decoding }));
+    /* eslint-enable hydrogen/prefer-image-component */
+}
+function internalImageSrcSet({ src, width, crop, scale, widths, loader, height, }) {
+    const hasCustomWidths = widths && Array.isArray(widths);
+    if (hasCustomWidths && widths.some((size) => isNaN(size))) {
+        throw new Error(`<Image/>: the 'widths' must be an array of numbers`);
+    }
+    let aspectRatio = 1;
+    if (width && height) {
+        aspectRatio = Number(height) / Number(width);
+    }
+    let setSizes = hasCustomWidths ? widths : IMG_SRC_SET_SIZES;
+    if (!hasCustomWidths &&
+        width &&
+        width < IMG_SRC_SET_SIZES[IMG_SRC_SET_SIZES.length - 1]) {
+        setSizes = IMG_SRC_SET_SIZES.filter((size) => size <= width);
+    }
+    const srcGenerator = loader ? loader : addImageSizeParametersToUrl;
+    return setSizes
+        .map((size) => `${srcGenerator({
+        src,
+        width: size,
+        // height is not applied if there is no crop
+        // if there is crop, then height is applied as a ratio of the original width + height aspect ratio * size
+        height: crop ? Number(size) * aspectRatio : undefined,
+        crop,
+        scale,
+    })} ${size}w`)
+        .join(', ');
+}
diff --git a/dist/dist/esnext/components/Image/index.d.ts b/dist/dist/esnext/components/Image/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2c01532d4d818b2e04a2545f49890b27df1b098d
--- /dev/null
+++ b/dist/dist/esnext/components/Image/index.d.ts
@@ -0,0 +1,2 @@
+export { Image } from './Image.js';
+export type { ShopifyLoaderParams, ShopifyLoaderOptions, ShopifyImageProps, ExternalImageProps, } from './Image.js';
diff --git a/dist/dist/esnext/components/Image/index.js b/dist/dist/esnext/components/Image/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..8ad79eb9f4a5fe60871909fcdd8b1d55125b5dd8
--- /dev/null
+++ b/dist/dist/esnext/components/Image/index.js
@@ -0,0 +1 @@
+export { Image } from './Image.js';
diff --git a/dist/dist/esnext/components/Link/Link.client.d.ts b/dist/dist/esnext/components/Link/Link.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..824b39891ce0c35065ad3fbc7dd7b9d97463dccf
--- /dev/null
+++ b/dist/dist/esnext/components/Link/Link.client.d.ts
@@ -0,0 +1,27 @@
+import React from 'react';
+export interface LinkProps extends Omit<React.AnchorHTMLAttributes<HTMLAnchorElement>, 'href'> {
+    /** The destination URL that the link points to. This is the `href` attribute of the underlying `<a>` element. */
+    to: string;
+    /** Whether to update the state object or URL of the current history entry. Refer to the [history.replaceState documentation](https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState). */
+    replace?: boolean;
+    /** The custom client state with the navigation. */
+    clientState?: any;
+    /** Whether to reload the whole document on navigation. */
+    reloadDocument?: boolean;
+    /** Whether to prefetch the link source when the user signals intent. Defaults to `true`. For more information, refer to [Prefetching a link source](https://shopify.dev/custom-storefronts/hydrogen/framework/routes#prefetching-a-link-source). */
+    prefetch?: boolean;
+    /** Whether to emulate natural browser behavior and restore scroll position on navigation. Defaults to `true`. */
+    scroll?: boolean;
+    /** Override the `basePath` inherited from the Route */
+    basePath?: string;
+}
+/**
+ * The `Link` component is used to navigate between routes. Because it renders an underlying `<a>` element, all
+ * properties available to the `<a>` element are also available to the `Link` component.
+ * For more information, refer to the [`<a>` element documentation](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#attributes).
+ */
+export declare const Link: React.ForwardRefExoticComponent<LinkProps & React.RefAttributes<HTMLAnchorElement>>;
+/**
+ * Credit: Remix's <Link> component.
+ */
+export declare function composeEventHandlers<EventType extends React.SyntheticEvent | Event>(theirHandler: ((event: EventType) => any) | undefined, ourHandler: (event: EventType) => any): (event: EventType) => any;
diff --git a/dist/dist/esnext/components/Link/Link.client.js b/dist/dist/esnext/components/Link/Link.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..18917f43d90c71ce2b4d5094e3b45eaac71e2342
--- /dev/null
+++ b/dist/dist/esnext/components/Link/Link.client.js
@@ -0,0 +1,145 @@
+import React, { useCallback, useEffect, useState } from 'react';
+import { useLocation } from '../../foundation/Router/BrowserRouter.client.js';
+import { createPath } from 'history';
+import { buildPath, useNavigate, } from '../../foundation/useNavigate/useNavigate.js';
+import { RSC_PATHNAME } from '../../constants.js';
+import { useInternalServerProps } from '../../foundation/useServerProps/use-server-props.js';
+import { useBasePath } from '../../foundation/useRouteParams/RouteParamsProvider.client.js';
+/**
+ * The `Link` component is used to navigate between routes. Because it renders an underlying `<a>` element, all
+ * properties available to the `<a>` element are also available to the `Link` component.
+ * For more information, refer to the [`<a>` element documentation](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#attributes).
+ */
+export const Link = React.forwardRef(function Link(props, ref) {
+    const navigate = useNavigate();
+    const location = useLocation();
+    const [_, startTransition] = React.useTransition();
+    const routeBasePath = useBasePath();
+    /**
+     * Inspired by Remix's Link component
+     */
+    const [shouldPrefetch, setShouldPrefetch] = useState(false);
+    const [maybePrefetch, setMaybePrefetch] = useState(false);
+    const { reloadDocument, target, replace: _replace, onClick, clientState, prefetch = true, scroll = true, } = props;
+    const to = buildPath(props.basePath ?? routeBasePath, props.to);
+    const internalClick = useCallback((e) => {
+        if (onClick)
+            onClick(e);
+        if (!reloadDocument && // do regular browser stuff
+            e.button === 0 && // Ignore everything but left clicks
+            (!target || target === '_self') && // Let browser handle "target=_blank"
+            !isModifiedEvent(e) // Ignore modifier key clicks
+        ) {
+            e.preventDefault();
+            // If the URL hasn't changed, the regular <a> will do a replace
+            const replace = !!_replace || createPath(location) === createPath({ pathname: to });
+            navigate(to, {
+                replace,
+                scroll,
+                clientState,
+                basePath: '/', // path was already resolved with the base
+            });
+        }
+    }, [
+        onClick,
+        reloadDocument,
+        target,
+        _replace,
+        location,
+        to,
+        navigate,
+        clientState,
+        scroll,
+    ]);
+    const signalPrefetchIntent = () => {
+        /**
+         * startTransition to yield to more important updates
+         */
+        startTransition(() => {
+            if (prefetch && !!to) {
+                setMaybePrefetch(true);
+            }
+        });
+    };
+    const cancelPrefetchIntent = () => {
+        /**
+         * startTransition to yield to more important updates
+         */
+        startTransition(() => {
+            if (prefetch) {
+                setMaybePrefetch(false);
+            }
+        });
+    };
+    /**
+     * Wrapping `maybePrefetch` inside useEffect allows the user to quickly graze over
+     * a link without triggering a prefetch.
+     */
+    useEffect(() => {
+        if (maybePrefetch) {
+            const id = setTimeout(() => {
+                setShouldPrefetch(true);
+            }, 100);
+            return () => {
+                clearTimeout(id);
+            };
+        }
+    }, [maybePrefetch]);
+    const onMouseEnter = composeEventHandlers(props.onMouseEnter, signalPrefetchIntent);
+    const onMouseLeave = composeEventHandlers(props.onMouseLeave, cancelPrefetchIntent);
+    const onFocus = composeEventHandlers(props.onFocus, signalPrefetchIntent);
+    const onBlur = composeEventHandlers(props.onBlur, cancelPrefetchIntent);
+    const onTouchStart = composeEventHandlers(props.onTouchStart, signalPrefetchIntent);
+    return (React.createElement(React.Fragment, null,
+        React.createElement("a", { ...without(props, [
+                'to',
+                'replace',
+                'clientState',
+                'reloadDocument',
+                'prefetch',
+                'scroll',
+            ]), ref: ref, rel: props.rel ??
+                (to.startsWith('http') || to.startsWith('//')
+                    ? 'noreferrer noopener'
+                    : undefined), onClick: internalClick, onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave, onFocus: onFocus, onBlur: onBlur, onTouchStart: onTouchStart, href: to }, props.children),
+        shouldPrefetch && React.createElement(Prefetch, { pathname: to })));
+});
+function Prefetch({ pathname }) {
+    const { getProposedLocationServerProps } = useInternalServerProps();
+    const location = useLocation();
+    const newPath = createPath({ pathname });
+    if (pathname.startsWith('http') || newPath === createPath(location)) {
+        return null;
+    }
+    const newLocation = new URL(newPath, window.location.href);
+    const proposedServerState = getProposedLocationServerProps({
+        pathname: newLocation.pathname,
+        search: newLocation.search,
+    });
+    const href = `${RSC_PATHNAME}?state=` +
+        encodeURIComponent(JSON.stringify(proposedServerState));
+    return React.createElement("link", { rel: "prefetch", as: "fetch", href: href });
+}
+/**
+ * Credit: Remix's <Link> component.
+ */
+export function composeEventHandlers(theirHandler, ourHandler) {
+    return (event) => {
+        theirHandler?.(event);
+        if (!event.defaultPrevented) {
+            ourHandler(event);
+        }
+    };
+}
+function isModifiedEvent(event) {
+    return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
+}
+function without(obj, props) {
+    const newObj = {};
+    for (const key of Object.keys(obj)) {
+        if (!props.includes(key)) {
+            newObj[key] = obj[key];
+        }
+    }
+    return newObj;
+}
diff --git a/dist/dist/esnext/components/Link/index.d.ts b/dist/dist/esnext/components/Link/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6f629d6b1a21d3814f8f86647a2a6978de1293cb
--- /dev/null
+++ b/dist/dist/esnext/components/Link/index.d.ts
@@ -0,0 +1 @@
+export { Link } from './Link.client.js';
diff --git a/dist/dist/esnext/components/Link/index.js b/dist/dist/esnext/components/Link/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..6f629d6b1a21d3814f8f86647a2a6978de1293cb
--- /dev/null
+++ b/dist/dist/esnext/components/Link/index.js
@@ -0,0 +1 @@
+export { Link } from './Link.client.js';
diff --git a/dist/dist/esnext/components/LocalizationProvider/LocalizationClientProvider.client.d.ts b/dist/dist/esnext/components/LocalizationProvider/LocalizationClientProvider.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..66310c5ab382cd33ec1d636a9356de69bb536b97
--- /dev/null
+++ b/dist/dist/esnext/components/LocalizationProvider/LocalizationClientProvider.client.d.ts
@@ -0,0 +1,6 @@
+import { ReactNode } from 'react';
+import type { LocalizationContextValue } from '../../foundation/ShopifyProvider/types.js';
+export default function LocalizationClientProvider({ localization, children, }: {
+    children: ReactNode;
+    localization: LocalizationContextValue;
+}): JSX.Element;
diff --git a/dist/dist/esnext/components/LocalizationProvider/LocalizationClientProvider.client.js b/dist/dist/esnext/components/LocalizationProvider/LocalizationClientProvider.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..8c11e34c924fa3b498c471d535d6a3aac8c8370f
--- /dev/null
+++ b/dist/dist/esnext/components/LocalizationProvider/LocalizationClientProvider.client.js
@@ -0,0 +1,5 @@
+import React from 'react';
+import { LocalizationContext } from '../../foundation/ShopifyProvider/ShopifyProvider.client.js';
+export default function LocalizationClientProvider({ localization, children, }) {
+    return (React.createElement(LocalizationContext.Provider, { value: localization }, children));
+}
diff --git a/dist/dist/esnext/components/LocalizationProvider/LocalizationProvider.server.d.ts b/dist/dist/esnext/components/LocalizationProvider/LocalizationProvider.server.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..76ea672adcfcbf2192a1f1147a06b6c105d7f020
--- /dev/null
+++ b/dist/dist/esnext/components/LocalizationProvider/LocalizationProvider.server.d.ts
@@ -0,0 +1,22 @@
+import { ReactNode } from 'react';
+import { CountryCode, LanguageCode } from '../../storefront-api-types.js';
+export interface LocalizationProviderProps {
+    /** A `ReactNode` element. */
+    children: ReactNode;
+    /**
+     * Override the `isoCode` to define the active country
+     */
+    countryCode?: CountryCode;
+    /**
+     * Override the `languageCode` to define the active language
+     */
+    languageCode?: LanguageCode;
+}
+/**
+ * The `LocalizationProvider` component automatically queries the Storefront API's
+ * [`localization`](https://shopify.dev/api/storefront/reference/common-objects/queryroot) field
+ * for the `isoCode` and `name` of the `country` and keeps this information in a context.
+ *
+ * Any descendents of this provider can use the `useLocalization` hook.
+ */
+export declare function LocalizationProvider(props: LocalizationProviderProps): JSX.Element;
diff --git a/dist/dist/esnext/components/LocalizationProvider/LocalizationProvider.server.js b/dist/dist/esnext/components/LocalizationProvider/LocalizationProvider.server.js
new file mode 100644
index 0000000000000000000000000000000000000000..9320603a388ecdd2b8a6bc84aa8d80d7d32bbf96
--- /dev/null
+++ b/dist/dist/esnext/components/LocalizationProvider/LocalizationProvider.server.js
@@ -0,0 +1,23 @@
+import React from 'react';
+import LocalizationClientProvider from './LocalizationClientProvider.client.js';
+import { useShop } from '../../foundation/useShop/index.js';
+import { useServerRequest } from '../../foundation/ServerRequestProvider/index.js';
+import { log } from '../../utilities/log/index.js';
+import { getLocalizationContextValue } from '../../foundation/ShopifyProvider/ShopifyProvider.server.js';
+/**
+ * The `LocalizationProvider` component automatically queries the Storefront API's
+ * [`localization`](https://shopify.dev/api/storefront/reference/common-objects/queryroot) field
+ * for the `isoCode` and `name` of the `country` and keeps this information in a context.
+ *
+ * Any descendents of this provider can use the `useLocalization` hook.
+ */
+export function LocalizationProvider(props) {
+    if (import.meta.env.DEV) {
+        log.warn('<LocalizationProvider> is no longer necessary. Pass localization props directly to `<ShopifyProvider>` instead.');
+    }
+    const { defaultLanguageCode, defaultCountryCode } = useShop();
+    const request = useServerRequest();
+    const localization = getLocalizationContextValue(defaultLanguageCode, defaultCountryCode, props.languageCode, props.countryCode);
+    request.ctx.localization = localization;
+    return (React.createElement(LocalizationClientProvider, { localization: localization }, props.children));
+}
diff --git a/dist/dist/esnext/components/LocalizationProvider/index.d.ts b/dist/dist/esnext/components/LocalizationProvider/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..21f088addace8affb28efb6f3e3cd24ebbbc8d75
--- /dev/null
+++ b/dist/dist/esnext/components/LocalizationProvider/index.d.ts
@@ -0,0 +1 @@
+export { LocalizationProvider } from './LocalizationProvider.server.js';
diff --git a/dist/dist/esnext/components/LocalizationProvider/index.js b/dist/dist/esnext/components/LocalizationProvider/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..21f088addace8affb28efb6f3e3cd24ebbbc8d75
--- /dev/null
+++ b/dist/dist/esnext/components/LocalizationProvider/index.js
@@ -0,0 +1 @@
+export { LocalizationProvider } from './LocalizationProvider.server.js';
diff --git a/dist/dist/esnext/components/MediaFile/MediaFile.d.ts b/dist/dist/esnext/components/MediaFile/MediaFile.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..69b4ff2ff8cdb531f2bea04cdab7943b0a48c454
--- /dev/null
+++ b/dist/dist/esnext/components/MediaFile/MediaFile.d.ts
@@ -0,0 +1,19 @@
+import React from 'react';
+import { type ShopifyImageProps } from '../Image/index.js';
+import { Video } from '../Video/index.js';
+import { ExternalVideo } from '../ExternalVideo/index.js';
+import type { MediaEdge as MediaEdgeType } from '../../storefront-api-types.js';
+import type { PartialDeep } from 'type-fest';
+export interface MediaFileProps {
+    /** An object with fields that correspond to the Storefront API's [Media object](https://shopify.dev/api/storefront/reference/products/media). */
+    data: PartialDeep<MediaEdgeType['node']>;
+    /** The options for the `Image`, `Video`, or `ExternalVideo` components. */
+    options?: ShopifyImageProps | React.ComponentProps<typeof Video>['previewImageOptions'] | React.ComponentProps<typeof ExternalVideo>['options'];
+}
+/**
+ * The `MediaFile` component renders the media for the Storefront API's
+ * [Media object](https://shopify.dev/api/storefront/reference/products/media). It renders an `Image`, a
+ * `Video`, an `ExternalVideo`, or a `ModelViewer` depending on the `mediaContentType` of the
+ * `media` provided as a prop.
+ */
+export declare function MediaFile({ data, options, ...passthroughProps }: MediaFileProps): JSX.Element | null;
diff --git a/dist/dist/esnext/components/MediaFile/MediaFile.js b/dist/dist/esnext/components/MediaFile/MediaFile.js
new file mode 100644
index 0000000000000000000000000000000000000000..c37c8ff8357a28a80c44ee85676ed4f126ad812f
--- /dev/null
+++ b/dist/dist/esnext/components/MediaFile/MediaFile.js
@@ -0,0 +1,32 @@
+import React from 'react';
+import { Image } from '../Image/index.js';
+import { Video } from '../Video/index.js';
+import { ExternalVideo } from '../ExternalVideo/index.js';
+import { ModelViewer } from '../ModelViewer/index.js';
+/**
+ * The `MediaFile` component renders the media for the Storefront API's
+ * [Media object](https://shopify.dev/api/storefront/reference/products/media). It renders an `Image`, a
+ * `Video`, an `ExternalVideo`, or a `ModelViewer` depending on the `mediaContentType` of the
+ * `media` provided as a prop.
+ */
+export function MediaFile({ data, options, ...passthroughProps }) {
+    switch (data.mediaContentType) {
+        case 'IMAGE': {
+            const dataImage = data
+                .image;
+            if (!dataImage || !dataImage.url) {
+                console.warn(`No "image" property was found on the "data" prop for <MediaFile/>, for the "type='image'"`);
+                return null;
+            }
+            return (React.createElement(Image, { ...passthroughProps, data: dataImage, loaderOptions: options }));
+        }
+        case 'VIDEO':
+            return (React.createElement(Video, { ...passthroughProps, data: data, previewImageOptions: options }));
+        case 'EXTERNAL_VIDEO':
+            return (React.createElement(ExternalVideo, { ...passthroughProps, data: data, options: options }));
+        case 'MODEL_3D':
+            return (React.createElement(ModelViewer, { ...passthroughProps, data: data }));
+        default:
+            return null;
+    }
+}
diff --git a/dist/dist/esnext/components/MediaFile/index.d.ts b/dist/dist/esnext/components/MediaFile/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ee54533fc2817760a1008119a19838f84e7b1ccd
--- /dev/null
+++ b/dist/dist/esnext/components/MediaFile/index.d.ts
@@ -0,0 +1 @@
+export { MediaFile, MediaFileProps } from './MediaFile.js';
diff --git a/dist/dist/esnext/components/MediaFile/index.js b/dist/dist/esnext/components/MediaFile/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..d956bc8c8d67832085f75b989d7f71816a9e5493
--- /dev/null
+++ b/dist/dist/esnext/components/MediaFile/index.js
@@ -0,0 +1 @@
+export { MediaFile } from './MediaFile.js';
diff --git a/dist/dist/esnext/components/Metafield/Metafield.client.d.ts b/dist/dist/esnext/components/Metafield/Metafield.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1e773eede57f5470a23a644691458933885d7e04
--- /dev/null
+++ b/dist/dist/esnext/components/Metafield/Metafield.client.d.ts
@@ -0,0 +1,17 @@
+import { type ElementType } from 'react';
+import type { Props } from '../types.js';
+import type { Metafield } from '../../storefront-api-types.js';
+import type { PartialDeep } from 'type-fest';
+export interface MetafieldProps<TTag> {
+    /** An object with fields that correspond to the Storefront API's [Metafield object](https://shopify.dev/api/storefront/reference/common-objects/metafield). */
+    data: PartialDeep<Metafield> | null;
+    /** An HTML tag to be rendered as the base element wrapper. The default value varies depending on [metafield.type](https://shopify.dev/apps/metafields/types). */
+    as?: TTag;
+}
+/**
+ * The `Metafield` component renders the value of a Storefront
+ * API's [Metafield object](https://shopify.dev/api/storefront/reference/common-objects/metafield).
+ *
+ * Renders a smart default of the Metafield's `value`. For more information, refer to the [Default output](#default-output) section.
+ */
+export declare function Metafield<TTag extends ElementType>(props: Props<TTag> & MetafieldProps<TTag>): JSX.Element | null;
diff --git a/dist/dist/esnext/components/Metafield/Metafield.client.js b/dist/dist/esnext/components/Metafield/Metafield.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..945f10478f9367c66e978127f1e707b80a1e3c95
--- /dev/null
+++ b/dist/dist/esnext/components/Metafield/Metafield.client.js
@@ -0,0 +1,102 @@
+import React, { useMemo } from 'react';
+import { useLocalization } from '../../hooks/useLocalization/useLocalization.js';
+import { getMeasurementAsString } from '../../utilities/measurement.js';
+import { Image } from '../Image/index.js';
+import { Video } from '../Video/index.js';
+import { flattenConnection } from '../../utilities/flattenConnection/index.js';
+import { parseMetafield } from '../../utilities/parseMetafield/index.js';
+/**
+ * The `Metafield` component renders the value of a Storefront
+ * API's [Metafield object](https://shopify.dev/api/storefront/reference/common-objects/metafield).
+ *
+ * Renders a smart default of the Metafield's `value`. For more information, refer to the [Default output](#default-output) section.
+ */
+export function Metafield(props) {
+    const { data, children, as, ...passthroughProps } = props;
+    const { locale } = useLocalization();
+    const parsedMetafield = useMemo(() => parseMetafield(data), [data]);
+    if (!parsedMetafield) {
+        if (__HYDROGEN_DEV__) {
+            console.warn(`<Metafield/>: nothing was passed to the data prop 'data'`);
+        }
+        return null;
+    }
+    if (parsedMetafield.value === null || parsedMetafield.value === undefined) {
+        if (__HYDROGEN_DEV__) {
+            console.warn(`<Metafield/>: No metafield value for metafield ${parsedMetafield.id ?? parsedMetafield.key}`);
+        }
+        return null;
+    }
+    switch (parsedMetafield.type) {
+        case 'date': {
+            const Wrapper = as ?? 'time';
+            return (React.createElement(Wrapper, { ...passthroughProps }, parsedMetafield.value.toLocaleDateString(locale)));
+        }
+        case 'date_time': {
+            const Wrapper = as ?? 'time';
+            return (React.createElement(Wrapper, { ...passthroughProps }, parsedMetafield.value.toLocaleString(locale)));
+        }
+        case 'weight':
+        case 'dimension':
+        case 'volume': {
+            const Wrapper = as ?? 'span';
+            return (React.createElement(Wrapper, { ...passthroughProps }, getMeasurementAsString(parsedMetafield.value, locale)));
+        }
+        case 'rating': {
+            const Wrapper = as ?? 'span';
+            return (React.createElement(Wrapper, { ...passthroughProps }, parsedMetafield.value.value));
+        }
+        case 'single_line_text_field': {
+            const Wrapper = as ?? 'span';
+            return (React.createElement(Wrapper, { ...passthroughProps, dangerouslySetInnerHTML: { __html: parsedMetafield.value } }));
+        }
+        case 'multi_line_text_field': {
+            const Wrapper = as ?? 'div';
+            return (React.createElement(Wrapper, { ...passthroughProps, dangerouslySetInnerHTML: {
+                    __html: parsedMetafield.value.split('\n').join('<br/>'),
+                } }));
+        }
+        case 'url': {
+            const protocolLessUrl = new URL(parsedMetafield.value);
+            return (React.createElement("a", { href: protocolLessUrl.href.replace(protocolLessUrl.protocol, ''), ...passthroughProps }, parsedMetafield.value));
+        }
+        case 'json': {
+            const Wrapper = as ?? 'span';
+            return (React.createElement(Wrapper, { ...passthroughProps }, JSON.stringify(parsedMetafield.value)));
+        }
+        case 'product_reference':
+        case 'variant_reference':
+        case 'page_reference': {
+            const Wrapper = as ?? 'span';
+            const ref = parsedMetafield.reference;
+            return (React.createElement(Wrapper, { ...passthroughProps }, ref?.title ?? ref?.id ?? ''));
+        }
+        case 'list.single_line_text_field': {
+            const Wrapper = as ?? 'ul';
+            const refArray = parsedMetafield.references
+                ? flattenConnection(parsedMetafield.references)
+                : [];
+            return (React.createElement(Wrapper, { ...passthroughProps }, refArray.map((ref, index) => (
+            // there's no unique way to identify these strings, so we do our best by combining the string with the index for the key
+            // eslint-disable-next-line react/no-array-index-key
+            React.createElement("li", { key: `${ref ?? ''}-${index}` }, ref)))));
+        }
+        case 'file_reference': {
+            if (parsedMetafield.reference?.__typename === 'MediaImage') {
+                const ref = parsedMetafield.reference;
+                return ref.image ? (React.createElement(Image, { data: ref.image, ...passthroughProps })) : null;
+            }
+            else if (parsedMetafield.reference?.__typename === 'GenericFile') {
+                const ref = parsedMetafield.reference;
+                return ref.previewImage ? (React.createElement("a", { href: parsedMetafield.reference?.url ?? '', ...passthroughProps },
+                    React.createElement(Image, { data: ref.previewImage }))) : null;
+            }
+            else if (parsedMetafield.reference?.__typename === 'Video') {
+                const ref = parsedMetafield.reference;
+                return React.createElement(Video, { ...passthroughProps, data: ref });
+            }
+        }
+    }
+    const Wrapper = as ?? 'span';
+    return (React.createElement(Wrapper, { ...passthroughProps }, parsedMetafield.value?.toString()));
+}
diff --git a/dist/dist/esnext/components/Metafield/components/StarRating/StarRating.d.ts b/dist/dist/esnext/components/Metafield/components/StarRating/StarRating.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..44a3de782f54d79f0eba0733fa33b1d2303f7aaa
--- /dev/null
+++ b/dist/dist/esnext/components/Metafield/components/StarRating/StarRating.d.ts
@@ -0,0 +1,12 @@
+import { Rating } from '../../../../types.js';
+export declare const STAR_EMPTY = "\u2606";
+export declare const STAR_FILLED = "\u2605";
+export interface StarRatingProps<TTag> {
+    rating: Rating;
+    /** An HTML tag to be rendered as the base element wrapper. The default is `div`. */
+    as?: TTag;
+}
+export declare function StarRating<TTag extends keyof JSX.IntrinsicElements = 'div'>(props: JSX.IntrinsicElements[TTag] & StarRatingProps<TTag>): JSX.Element;
+export declare function Star({ percentFilled }: {
+    percentFilled: number;
+}): JSX.Element;
diff --git a/dist/dist/esnext/components/Metafield/components/StarRating/StarRating.js b/dist/dist/esnext/components/Metafield/components/StarRating/StarRating.js
new file mode 100644
index 0000000000000000000000000000000000000000..3cc649df1cc0403f85a8aa15760d309d0da9773a
--- /dev/null
+++ b/dist/dist/esnext/components/Metafield/components/StarRating/StarRating.js
@@ -0,0 +1,48 @@
+import React, { useMemo } from 'react';
+export const STAR_EMPTY = '';
+export const STAR_FILLED = '';
+export function StarRating(props) {
+    const { as, rating, ...passthroughProps } = props;
+    const starsArray = useMemo(() => {
+        const ratingMin = Math.floor(rating.scale_min);
+        const ratingMax = Math.floor(rating.scale_max);
+        const ratingInteger = Math.floor(rating.value);
+        const ratingPercent = (rating.value % 1) * 100;
+        const stars = [];
+        for (let i = ratingMin; i <= ratingMax; i++) {
+            if (i <= ratingInteger) {
+                stars.push(React.createElement(Star, { key: i, percentFilled: 100 }));
+            }
+            else if (i > ratingInteger + 1) {
+                stars.push(React.createElement(Star, { key: i, percentFilled: 0 }));
+            }
+            else {
+                stars.push(React.createElement(Star, { key: i, percentFilled: ratingPercent }));
+            }
+        }
+        return stars;
+    }, [rating.scale_min, rating.scale_max, rating.value]);
+    const Wrapper = as ?? 'div';
+    return React.createElement(Wrapper, { ...passthroughProps }, starsArray);
+}
+export function Star({ percentFilled }) {
+    if (percentFilled === 100) {
+        return React.createElement("span", null, STAR_FILLED);
+    }
+    if (percentFilled === 0) {
+        return React.createElement("span", null, STAR_EMPTY);
+    }
+    return (React.createElement("span", { style: {
+            position: 'relative',
+            display: 'inline-block',
+        } },
+        React.createElement("span", null, STAR_EMPTY),
+        React.createElement("span", { style: {
+                display: 'inline-block',
+                position: 'absolute',
+                top: '0',
+                left: '0',
+                width: `${percentFilled}%`,
+                overflow: 'hidden',
+            } }, STAR_FILLED)));
+}
diff --git a/dist/dist/esnext/components/Metafield/components/StarRating/index.d.ts b/dist/dist/esnext/components/Metafield/components/StarRating/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dc8809c101061f060f54574a53c60f35268fcd07
--- /dev/null
+++ b/dist/dist/esnext/components/Metafield/components/StarRating/index.d.ts
@@ -0,0 +1 @@
+export { StarRating } from './StarRating.js';
diff --git a/dist/dist/esnext/components/Metafield/components/StarRating/index.js b/dist/dist/esnext/components/Metafield/components/StarRating/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..dc8809c101061f060f54574a53c60f35268fcd07
--- /dev/null
+++ b/dist/dist/esnext/components/Metafield/components/StarRating/index.js
@@ -0,0 +1 @@
+export { StarRating } from './StarRating.js';
diff --git a/dist/dist/esnext/components/Metafield/components/index.d.ts b/dist/dist/esnext/components/Metafield/components/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..24e5d6c8a5ef95fb19643ac42173d7b8f0a6a8a7
--- /dev/null
+++ b/dist/dist/esnext/components/Metafield/components/index.d.ts
@@ -0,0 +1 @@
+export { StarRating } from './StarRating/index.js';
diff --git a/dist/dist/esnext/components/Metafield/components/index.js b/dist/dist/esnext/components/Metafield/components/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..24e5d6c8a5ef95fb19643ac42173d7b8f0a6a8a7
--- /dev/null
+++ b/dist/dist/esnext/components/Metafield/components/index.js
@@ -0,0 +1 @@
+export { StarRating } from './StarRating/index.js';
diff --git a/dist/dist/esnext/components/Metafield/index.d.ts b/dist/dist/esnext/components/Metafield/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..83b6d8b51bfb4fac7fc9200a482221b5f945c313
--- /dev/null
+++ b/dist/dist/esnext/components/Metafield/index.d.ts
@@ -0,0 +1,2 @@
+export { Metafield } from './Metafield.client.js';
+export type { MetafieldType } from './types.js';
diff --git a/dist/dist/esnext/components/Metafield/index.js b/dist/dist/esnext/components/Metafield/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..6c30124e8641c2abcfe6a0dca135ce592018bc7e
--- /dev/null
+++ b/dist/dist/esnext/components/Metafield/index.js
@@ -0,0 +1 @@
+export { Metafield } from './Metafield.client.js';
diff --git a/dist/dist/esnext/components/Metafield/types.d.ts b/dist/dist/esnext/components/Metafield/types.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..529ab5b06a4def68904625ec67e56607ddd81ec7
--- /dev/null
+++ b/dist/dist/esnext/components/Metafield/types.d.ts
@@ -0,0 +1,4 @@
+import { Metafield } from '../../storefront-api-types.js';
+export declare type MetafieldType = Omit<Partial<Metafield>, 'value'> & {
+    value?: string | number | boolean | Date | Record<string, any>;
+};
diff --git a/dist/dist/esnext/components/Metafield/types.js b/dist/dist/esnext/components/Metafield/types.js
new file mode 100644
index 0000000000000000000000000000000000000000..cb0ff5c3b541f646105198ee23ac0fc3d805023e
--- /dev/null
+++ b/dist/dist/esnext/components/Metafield/types.js
@@ -0,0 +1 @@
+export {};
diff --git a/dist/dist/esnext/components/ModelViewer/ModelViewer.client.d.ts b/dist/dist/esnext/components/ModelViewer/ModelViewer.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1360a64de00d0314d9b1da92572286b2d8e880f5
--- /dev/null
+++ b/dist/dist/esnext/components/ModelViewer/ModelViewer.client.d.ts
@@ -0,0 +1,128 @@
+import { ReactNode, ElementType } from 'react';
+import { Props } from '../types.js';
+import type { Model3d } from '../../storefront-api-types.js';
+import type { PartialDeep } from 'type-fest';
+interface ModelViewerProps {
+    /** Any ReactNode elements. */
+    children?: ReactNode;
+    /** An object with fields that correspond to the Storefront API's [Model3D object](https://shopify.dev/api/storefront/latest/objects/model3d). */
+    data: PartialDeep<Model3d>;
+    /** A string of either `auto`, `lazy`, or `eager` to indicate the conditions for preloading. Refer to [loading in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-loading-attributes-loading). */
+    loading?: 'auto' | 'lazy' | 'eager';
+    /** A URL to display an image instead of the model. This is useful for showing the user something before a model is loaded and ready to render. If no URL is provided, then [Model3d.previewImage](https://shopify.dev/api/storefront/latest/objects/model3d) is used. Refer to [poster in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-loading-attributes-poster). */
+    poster?: string;
+    /** A string of either `auto`, `interaction`, or `manual` to indicate when the model should be revealed. Refer to [reveal in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-loading-attributes-reveal). */
+    reveal?: 'auto' | 'interaction' | 'manual';
+    /** A boolean to enable an AR experience. Refer to [ar in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-augmentedreality-attributes-ar). */
+    ar?: boolean;
+    /** A prioritized list of `webxr`, `scene-viewer`, and/or `quick-look` to indicate the types of AR experiences to enable. Refer to [ar-modes in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-augmentedreality-attributes-arModes). */
+    arModes?: 'webxr' | 'scene-viewer' | 'quick-look';
+    /** A string of `auto` or `fixed` to control the scaling behaviour. Refer to [ar-scale in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-augmentedreality-attributes-arScale). */
+    arScale?: 'auto' | 'fixed';
+    /** A styring of either `floor` or `wall` to indicate where to place the object in AR. Refer to [ar-placement in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-augmentedreality-attributes-arPlacement). */
+    arPlacement?: 'floor' | 'wall';
+    /** The url to a USDZ model which will be used on supported iOS 12+ devices via AR Quick Look on Safari. Refer to [ios-source in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-augmentedreality-attributes-iosSrc). */
+    iosSrc?: string;
+    /** A boolean to enable camera controls. Refer to [attributes in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#stagingandcameras-attributes). */
+    cameraControls?: boolean;
+    /** A string of `pan-x`, `pan-y`, or `none`. Refer to [touch-action in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-stagingandcameras-attributes-touch-action). */
+    touchAction?: 'pan-x' | 'pan-y' | 'none';
+    /** A boolean to disable zoom. Refer to [disable-zoom in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-stagingandcameras-attributes-disable-zoom). */
+    disableZoom?: boolean;
+    /** A number to adjust the speed of theta and phi orbit interactions. Refer to [orbit-sensitivity in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-stagingandcameras-attributes-orbitSensitivity). */
+    orbitSensitivity?: number;
+    /** A boolean to enable auto rotate. Refer to [auto-rotate in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-stagingandcameras-attributes-autoRotate). */
+    autoRotate?: boolean;
+    /** A number in milliseconds to specify the delay before auto rotation begins. Refer to [auto-rotate-delay in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-stagingandcameras-attributes-autoRotateDelay). */
+    autoRotateDelay?: number;
+    /**  The speed of auto rotation. Refer to [rotation-per-second in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-stagingandcameras-attributes-rotationPerSecond). */
+    rotationPerSecond?: string;
+    /** A string of either `allow-when-focused` or `always-allow` to indicate whether the viewer requires focus before interacting with it. Refer to [interaction-policy in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-stagingandcameras-attributes-interactionPolicy). */
+    interactionPolicy?: 'allow-when-focused' | 'always-allow';
+    /** A string of either 'auto', 'when-focused', or 'none' indicating the conditions under which the visual and audible interaction prompt will display. Refer to [interaction-prompts in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-stagingandcameras-attributes-interactionPrompt). */
+    interactionPrompt?: 'auto' | 'when-focused' | 'none';
+    /** A string of either `wiggle` or `basic` indicating the presentation style of the interaction-prompt when it is raised. Refer to [interaction-prompt-style in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-stagingandcameras-attributes-interactionPromptStyle). */
+    interactionPromptStyle?: 'wiggle' | 'basic';
+    /** A number to indicate how long the model viewer should wait before prompting the user visually for interaction. Refer to [interaction-prompt-threshold in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-stagingandcameras-attributes-interactionPromptThreshold). */
+    interactionPromptThreshold?: number;
+    /** A string of the starting orbital position of the camera. Refer to [camera-orbit in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-stagingandcameras-attributes-cameraOrbit). */
+    cameraOrbit?: string;
+    /** A string of the point the camera orbits around. Refer to [camera-target in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-stagingandcameras-attributes-cameraTarget). */
+    cameraTarget?: string;
+    /** A string of the vertical field of view of the camera. Refer to [field-of-view in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-stagingandcameras-attributes-fieldOfView). */
+    fieldOfView?: string;
+    /** A string of the maxiumum orbital values of the camera. Refer to [max-camera-orbit in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-stagingandcameras-attributes-maxCameraOrbit). */
+    maxCameraOrbit?: string;
+    /** A string of the minimum orbital values of the camera. Refer to [min-camera-orbit in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-stagingandcameras-attributes-minCameraOrbit). */
+    minCameraOrbit?: string;
+    /** A number indicating the max field of view of the camera. Refer to [max-field-of-view in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-stagingandcameras-attributes-maxFieldOfView). */
+    maxFieldOfView?: number;
+    /** A number indicating the min field of view of the camera. Refer to [min-field-of-view in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-stagingandcameras-attributes-minFieldOfView). */
+    minFieldOfView?: number;
+    /** A string of `tight` or `legacy` for calculating the model's bounding box. Refer to [bounds in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-stagingandcameras-attributes-bounds). */
+    bounds?: 'tight' | 'legacy';
+    /** A number indicating the rate of interpolation when the camera or model moves. Refer to [interpolation-decay in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-stagingandcameras-attributes-interpolationDecay). */
+    interpolationDecay?: number;
+    /** A string for the background image of the scene. Refer to [skybox-image in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-lightingandenv-attributes-skyboxImage). */
+    skyboxImage?: string;
+    /** A string to control the environmental reflection of the model. Refer to [environment-image in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-lightingandenv-attributes-environmentImage). */
+    environmentImage?: string;
+    /** A number indicating the exposure of the model and the skybox. Refer to [exposure in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-lightingandenv-attributes-exposure). */
+    exposure?: number;
+    /** A number for the opacity of the shadow. Refer to [shadow-intensity in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-lightingandenv-attributes-shadowIntensity). */
+    shadowIntensity?: number;
+    /** A number for the bluriness of the shadow. Refer to [shadow-softness in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-lightingandenv-attributes-shadowSoftness). */
+    shadowSoftness?: number;
+    /** A string of the animation to play by name. Refer to [animation-name in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-animation-attributes-animationName). */
+    animationName?: string;
+    /** A string of the animation crossfade duration between the previous and next animations. Refer to [animation-cross-fade-duration in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-animation-attributes-animationCrossfadeDuration). */
+    animationCrossfadeDuration?: string;
+    /** A boolean to enable the model animations. Refer to [autoplay in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-animation-attributes-autoplay). */
+    autoplay?: boolean;
+    /** A string to select a model variant by name. Refer to [variant-name in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-scenegraph-attributes-variantName). */
+    variantName?: string;
+    /** A string to rotate the model. Refer to [orientation in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-scenegraph-attributes-orientation). */
+    orientation?: string;
+    /** A string to scale the model. Refer to [scale in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-scenegraph-attributes-scale). */
+    scale?: string;
+    /** The callback to invoke when the 'error' event is triggered. Refer to [error in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-loading-events-error). */
+    onError?: (event: Event) => void;
+    /** The callback to invoke when the `load` event is triggered. Refer to [load in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-loading-events-load). */
+    onLoad?: (event: Event) => void;
+    /** The callback to invoke when the 'preload' event is triggered. Refer to [preload in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-loading-events-preload). */
+    onPreload?: (event: Event) => void;
+    /** The callback to invoke when the 'model-visibility' event is triggered. Refer to [model-visibility in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-loading-events-modelVisibility). */
+    onModelVisibility?: (event: Event) => void;
+    /** The callback to invoke when the 'progress' event is triggered. Refer to [progress in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-loading-events-progress). */
+    onProgress?: (event: Event) => void;
+    /** The callback to invoke when the 'ar-status' event is triggered. Refer to [ar-status in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-augmentedreality-events-arStatus). */
+    onArStatus?: (event: Event) => void;
+    /** The callback to invoke when the 'ar-tracking' event is triggered. Refer to [ar-tracking in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-augmentedreality-events-arTracking). */
+    onArTracking?: (event: Event) => void;
+    /** The callback to invoke when the 'quick-look-button-tapped' event is triggered. Refer to [quick-look-button-tapped in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-augmentedreality-events-quickLookButtonTapped). */
+    onQuickLookButtonTapped?: (event: Event) => void;
+    /** The callback to invoke when the 'camera-change' event is triggered. Refer to [camera-change in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-stagingandcameras-events-cameraChange). */
+    onCameraChange?: (event: Event) => void;
+    /** The callback to invoke when the 'environment-change' event is triggered. Refer to [environment-change in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-lightingandenv-events-environmentChange).  */
+    onEnvironmentChange?: (event: Event) => void;
+    /**  The callback to invoke when the 'play' event is triggered. Refer to [play in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-animation-events-play). */
+    onPlay?: (event: Event) => void;
+    /**  The callback to invoke when the 'pause' event is triggered. Refer to [pause in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-animation-events-pause). */
+    onPause?: (event: Event) => void;
+    /** The callback to invoke when the 'scene-graph-ready' event is triggered. Refer to [scene-graph-ready in the <model-viewer> documentation](https://modelviewer.dev/docs/index.html#entrydocs-scenegraph-events-sceneGraphReady). */
+    onSceneGraphReady?: (event: Event) => void;
+}
+declare type PropsWeControl = 'src' | 'poster';
+declare global {
+    namespace JSX {
+        interface IntrinsicElements {
+            'model-viewer': any;
+        }
+    }
+}
+/**
+ * The `ModelViewer` component renders a 3D model (with the `model-viewer` tag) for
+ * the Storefront API's [Model3d object](https://shopify.dev/api/storefront/reference/products/model3d).
+ */
+export declare function ModelViewer<TTag extends ElementType>(props: Props<TTag, PropsWeControl> & ModelViewerProps): JSX.Element | null;
+export {};
diff --git a/dist/dist/esnext/components/ModelViewer/ModelViewer.client.js b/dist/dist/esnext/components/ModelViewer/ModelViewer.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..bd9e966bb0ef17d3b9515fd1509a26add19db866
--- /dev/null
+++ b/dist/dist/esnext/components/ModelViewer/ModelViewer.client.js
@@ -0,0 +1,104 @@
+import React, { useState, useEffect, useCallback, } from 'react';
+import { useLoadScript } from '../../hooks/useLoadScript/useLoadScript.client.js';
+/**
+ * The `ModelViewer` component renders a 3D model (with the `model-viewer` tag) for
+ * the Storefront API's [Model3d object](https://shopify.dev/api/storefront/reference/products/model3d).
+ */
+export function ModelViewer(props) {
+    const [modelViewer, setModelViewer] = useState(undefined);
+    const callbackRef = useCallback((node) => {
+        setModelViewer(node);
+    }, []);
+    const { data, id = data.id, children, className, ...passthroughProps } = props;
+    const modelViewerLoadedStatus = useLoadScript('https://unpkg.com/@google/model-viewer@v1.8.0/dist/model-viewer.min.js', {
+        module: true,
+    });
+    useEffect(() => {
+        if (modelViewer == null) {
+            return;
+        }
+        if (passthroughProps.onError)
+            modelViewer.addEventListener('error', passthroughProps.onError);
+        if (passthroughProps.onLoad)
+            modelViewer.addEventListener('load', passthroughProps.onLoad);
+        if (passthroughProps.onPreload)
+            modelViewer.addEventListener('preload', passthroughProps.onPreload);
+        if (passthroughProps.onModelVisibility)
+            modelViewer.addEventListener('model-visibility', passthroughProps.onModelVisibility);
+        if (passthroughProps.onProgress)
+            modelViewer.addEventListener('progress', passthroughProps.onProgress);
+        if (passthroughProps.onArStatus)
+            modelViewer.addEventListener('ar-status', passthroughProps.onArStatus);
+        if (passthroughProps.onArTracking)
+            modelViewer.addEventListener('ar-tracking', passthroughProps.onArTracking);
+        if (passthroughProps.onQuickLookButtonTapped)
+            modelViewer.addEventListener('quick-look-button-tapped', passthroughProps.onQuickLookButtonTapped);
+        if (passthroughProps.onCameraChange)
+            modelViewer.addEventListener('camera-change', passthroughProps.onCameraChange);
+        if (passthroughProps.onEnvironmentChange)
+            modelViewer.addEventListener('environment-change', passthroughProps.onEnvironmentChange);
+        if (passthroughProps.onPlay)
+            modelViewer.addEventListener('play', passthroughProps.onPlay);
+        if (passthroughProps.onPause)
+            modelViewer.addEventListener('ar-status', passthroughProps.onPause);
+        if (passthroughProps.onSceneGraphReady)
+            modelViewer.addEventListener('scene-graph-ready', passthroughProps.onSceneGraphReady);
+        return () => {
+            if (modelViewer == null) {
+                return;
+            }
+            if (passthroughProps.onError)
+                modelViewer.removeEventListener('error', passthroughProps.onError);
+            if (passthroughProps.onLoad)
+                modelViewer.removeEventListener('load', passthroughProps.onLoad);
+            if (passthroughProps.onPreload)
+                modelViewer.removeEventListener('preload', passthroughProps.onPreload);
+            if (passthroughProps.onModelVisibility)
+                modelViewer.removeEventListener('model-visibility', passthroughProps.onModelVisibility);
+            if (passthroughProps.onProgress)
+                modelViewer.removeEventListener('progress', passthroughProps.onProgress);
+            if (passthroughProps.onArStatus)
+                modelViewer.removeEventListener('ar-status', passthroughProps.onArStatus);
+            if (passthroughProps.onArTracking)
+                modelViewer.removeEventListener('ar-tracking', passthroughProps.onArTracking);
+            if (passthroughProps.onQuickLookButtonTapped)
+                modelViewer.removeEventListener('quick-look-button-tapped', passthroughProps.onQuickLookButtonTapped);
+            if (passthroughProps.onCameraChange)
+                modelViewer.removeEventListener('camera-change', passthroughProps.onCameraChange);
+            if (passthroughProps.onEnvironmentChange)
+                modelViewer.removeEventListener('environment-change', passthroughProps.onEnvironmentChange);
+            if (passthroughProps.onPlay)
+                modelViewer.removeEventListener('play', passthroughProps.onPlay);
+            if (passthroughProps.onPause)
+                modelViewer.removeEventListener('ar-status', passthroughProps.onPause);
+            if (passthroughProps.onSceneGraphReady)
+                modelViewer.removeEventListener('scene-graph-ready', passthroughProps.onSceneGraphReady);
+        };
+    }, [
+        modelViewer,
+        passthroughProps.onArStatus,
+        passthroughProps.onArTracking,
+        passthroughProps.onCameraChange,
+        passthroughProps.onEnvironmentChange,
+        passthroughProps.onError,
+        passthroughProps.onLoad,
+        passthroughProps.onModelVisibility,
+        passthroughProps.onPause,
+        passthroughProps.onPlay,
+        passthroughProps.onPreload,
+        passthroughProps.onProgress,
+        passthroughProps.onQuickLookButtonTapped,
+        passthroughProps.onSceneGraphReady,
+    ]);
+    if (modelViewerLoadedStatus !== 'done') {
+        // TODO: What do we want to display while the model-viewer library loads?
+        return null;
+    }
+    if (!data.sources?.[0]?.url) {
+        throw new Error(`<ModelViewer/> requires 'data.sources' prop to be an array, with an object that has a property 'url' on it`);
+    }
+    if (!data.alt) {
+        console.warn(`<ModelViewer/> requires the 'data.alt' prop for accessibility`);
+    }
+    return (React.createElement("model-viewer", { ref: callbackRef, ...passthroughProps, class: className, id: id, src: data.sources[0].url, alt: data.alt, "camera-controls": passthroughProps.cameraControls ?? true, poster: passthroughProps.poster || data.previewImage?.url, autoplay: passthroughProps.autoplay ?? true, loading: passthroughProps.loading, reveal: passthroughProps.reveal, ar: passthroughProps.ar, "ar-modes": passthroughProps.arModes, "ar-scale": passthroughProps.arScale, "ar-placement": passthroughProps.arPlacement, "ios-src": passthroughProps.iosSrc, "touch-action": passthroughProps.touchAction, "disable-zoom": passthroughProps.disableZoom, "orbit-sensitivity": passthroughProps.orbitSensitivity, "auto-rotate": passthroughProps.autoRotate, "auto-rotate-delay": passthroughProps.autoRotateDelay, "rotation-per-second": passthroughProps.rotationPerSecond, "interaction-policy": passthroughProps.interactionPolicy, "interaction-prompt": passthroughProps.interactionPrompt, "interaction-prompt-style": passthroughProps.interactionPromptStyle, "interaction-prompt-threshold": passthroughProps.interactionPromptThreshold, "camera-orbit": passthroughProps.cameraOrbit, "camera-target": passthroughProps.cameraTarget, "field-of-view": passthroughProps.fieldOfView, "max-camera-orbit": passthroughProps.maxCameraOrbit, "min-camera-orbit": passthroughProps.minCameraOrbit, "max-field-of-view": passthroughProps.maxFieldOfView, "min-field-of-view": passthroughProps.minFieldOfView, bounds: passthroughProps.bounds, "interpolation-decay": passthroughProps.interpolationDecay ?? 100, "skybox-image": passthroughProps.skyboxImage, "environment-image": passthroughProps.environmentImage, exposure: passthroughProps.exposure, "shadow-intensity": passthroughProps.shadowIntensity ?? 0, "shadow-softness": passthroughProps.shadowSoftness ?? 0, "animation-name": passthroughProps.animationName, "animation-crossfade-duration": passthroughProps.animationCrossfadeDuration, "variant-name": passthroughProps.variantName, orientation: passthroughProps.orientation, scale: passthroughProps.scale }, children));
+}
diff --git a/dist/dist/esnext/components/ModelViewer/index.d.ts b/dist/dist/esnext/components/ModelViewer/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d908f0ae4d40c961e26f72e376709da8eb72a038
--- /dev/null
+++ b/dist/dist/esnext/components/ModelViewer/index.d.ts
@@ -0,0 +1 @@
+export { ModelViewer } from './ModelViewer.client.js';
diff --git a/dist/dist/esnext/components/ModelViewer/index.js b/dist/dist/esnext/components/ModelViewer/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..d908f0ae4d40c961e26f72e376709da8eb72a038
--- /dev/null
+++ b/dist/dist/esnext/components/ModelViewer/index.js
@@ -0,0 +1 @@
+export { ModelViewer } from './ModelViewer.client.js';
diff --git a/dist/dist/esnext/components/Money/Money.client.d.ts b/dist/dist/esnext/components/Money/Money.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..246b801aa906120323699633a0d0d0df5e648d6f
--- /dev/null
+++ b/dist/dist/esnext/components/Money/Money.client.d.ts
@@ -0,0 +1,25 @@
+import React, { type ReactNode } from 'react';
+import type { MoneyV2, UnitPriceMeasurement } from '../../storefront-api-types.js';
+import type { PartialDeep } from 'type-fest';
+interface CustomProps<ComponentGeneric extends React.ElementType> {
+    /** An HTML tag or React Component to be rendered as the base element wrapper. The default is `div`. */
+    as?: ComponentGeneric;
+    /** An object with fields that correspond to the Storefront API's [MoneyV2 object](https://shopify.dev/api/storefront/reference/common-objects/moneyv2). */
+    data: PartialDeep<MoneyV2>;
+    /** Whether to remove the currency symbol from the output. */
+    withoutCurrency?: boolean;
+    /** Whether to remove trailing zeros (fractional money) from the output. */
+    withoutTrailingZeros?: boolean;
+    /** A [UnitPriceMeasurement object](https://shopify.dev/api/storefront/latest/objects/unitpricemeasurement). */
+    measurement?: PartialDeep<UnitPriceMeasurement>;
+    /** Customizes the separator between the money output and the measurement output. Used with the `measurement` prop. Defaults to `'/'`. */
+    measurementSeparator?: ReactNode;
+}
+declare type MoneyProps<ComponentGeneric extends React.ElementType> = CustomProps<ComponentGeneric> & Omit<React.ComponentPropsWithoutRef<ComponentGeneric>, keyof CustomProps<ComponentGeneric>>;
+/**
+ * The `Money` component renders a string of the Storefront API's
+ * [MoneyV2 object](https://shopify.dev/api/storefront/reference/common-objects/moneyv2) according to the
+ * `locale` in [the `LocalizationProvider` component](https://shopify.dev/api/hydrogen/components/localization/localizationprovider).
+ */
+export declare function Money<TTag extends React.ElementType>({ data, as, withoutCurrency, withoutTrailingZeros, measurement, measurementSeparator, ...passthroughProps }: MoneyProps<TTag>): JSX.Element;
+export {};
diff --git a/dist/dist/esnext/components/Money/Money.client.js b/dist/dist/esnext/components/Money/Money.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..3e4753658c1c12e232d9424d773b274c4c2f1fda
--- /dev/null
+++ b/dist/dist/esnext/components/Money/Money.client.js
@@ -0,0 +1,39 @@
+import React from 'react';
+import { useMoney } from '../../hooks/index.js';
+/**
+ * The `Money` component renders a string of the Storefront API's
+ * [MoneyV2 object](https://shopify.dev/api/storefront/reference/common-objects/moneyv2) according to the
+ * `locale` in [the `LocalizationProvider` component](https://shopify.dev/api/hydrogen/components/localization/localizationprovider).
+ */
+export function Money({ data, as, withoutCurrency, withoutTrailingZeros, measurement, measurementSeparator = '/', ...passthroughProps }) {
+    if (!isMoney(data)) {
+        throw new Error(`<Money/> needs a valid 'data' prop that has 'amount' and 'currencyCode'`);
+    }
+    const moneyObject = useMoney(data);
+    const Wrapper = as ?? 'div';
+    let output = moneyObject.localizedString;
+    if (withoutCurrency || withoutTrailingZeros) {
+        if (withoutCurrency && !withoutTrailingZeros) {
+            output = moneyObject.amount;
+        }
+        else if (!withoutCurrency && withoutTrailingZeros) {
+            output = moneyObject.withoutTrailingZeros;
+        }
+        else {
+            // both
+            output = moneyObject.withoutTrailingZerosAndCurrency;
+        }
+    }
+    return (React.createElement(Wrapper, { ...passthroughProps },
+        output,
+        measurement && measurement.referenceUnit && (React.createElement(React.Fragment, null,
+            measurementSeparator,
+            measurement.referenceUnit))));
+}
+// required in order to narrow the money object down and make TS happy
+function isMoney(maybeMoney) {
+    return (typeof maybeMoney.amount === 'string' &&
+        !!maybeMoney.amount &&
+        typeof maybeMoney.currencyCode === 'string' &&
+        !!maybeMoney.currencyCode);
+}
diff --git a/dist/dist/esnext/components/Money/index.d.ts b/dist/dist/esnext/components/Money/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..20adaf681710340999a846750957015395af30be
--- /dev/null
+++ b/dist/dist/esnext/components/Money/index.d.ts
@@ -0,0 +1 @@
+export { Money } from './Money.client.js';
diff --git a/dist/dist/esnext/components/Money/index.js b/dist/dist/esnext/components/Money/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..20adaf681710340999a846750957015395af30be
--- /dev/null
+++ b/dist/dist/esnext/components/Money/index.js
@@ -0,0 +1 @@
+export { Money } from './Money.client.js';
diff --git a/dist/dist/esnext/components/ProductOptionsProvider/ProductOptionsProvider.client.d.ts b/dist/dist/esnext/components/ProductOptionsProvider/ProductOptionsProvider.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..130ed9b4670d4689a0261cca96e4ee9b0a41c855
--- /dev/null
+++ b/dist/dist/esnext/components/ProductOptionsProvider/ProductOptionsProvider.client.d.ts
@@ -0,0 +1,21 @@
+import React from 'react';
+import type { Product, ProductVariant as ProductVariantType } from '../../storefront-api-types.js';
+import type { PartialDeep } from 'type-fest';
+declare type InitialVariantId = ProductVariantType['id'] | null;
+interface ProductOptionsProviderProps {
+    /** A [Product object](https://shopify.dev/api/storefront/reference/products/product). */
+    data: PartialDeep<Product>;
+    /** A `ReactNode` element. */
+    children: React.ReactNode;
+    /**
+     * The initially selected variant.
+     * The following logic applies to `initialVariantId`:
+     * 1. If `initialVariantId` is provided, then it's used even if it's out of stock.
+     * 2. If `initialVariantId` is provided but is `null`, then no variant is used.
+     * 3. If nothing is passed to `initialVariantId` then the first available / in-stock variant is used.
+     * 4. If nothing is passed to `initialVariantId` and no variants are in stock, then the first variant is used.
+     */
+    initialVariantId?: InitialVariantId;
+}
+export declare function ProductOptionsProvider({ children, data: product, initialVariantId: explicitVariantId, }: ProductOptionsProviderProps): JSX.Element;
+export {};
diff --git a/dist/dist/esnext/components/ProductOptionsProvider/ProductOptionsProvider.client.js b/dist/dist/esnext/components/ProductOptionsProvider/ProductOptionsProvider.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..6add23ef9a3f16a047222429a25943cb08ec39f5
--- /dev/null
+++ b/dist/dist/esnext/components/ProductOptionsProvider/ProductOptionsProvider.client.js
@@ -0,0 +1,133 @@
+import React, { useMemo, useState, useEffect, useCallback } from 'react';
+import { ProductOptionsContext } from './context.js';
+import { getSelectedVariant, getOptions, } from '../../hooks/useProductOptions/helpers.js';
+import { flattenConnection } from '../../utilities/flattenConnection/index.js';
+export function ProductOptionsProvider({ children, data: product, initialVariantId: explicitVariantId, }) {
+    // The flattened variants
+    const variants = useMemo(() => flattenConnection(product.variants ?? {}), [product.variants]);
+    if (!isProductVariantArray(variants)) {
+        throw new Error(`<ProductOptionsProvider/> requires 'product.variants.nodes' or 'product.variants.edges'`);
+    }
+    // All the options available for a product, based on all the variants
+    const options = useMemo(() => getOptions(variants), [variants]);
+    /**
+     * Track the selectedVariant within the provider.
+     */
+    const [selectedVariant, setSelectedVariant] = useState(() => getVariantBasedOnIdProp(explicitVariantId, variants));
+    /**
+     * Track the selectedOptions within the provider. If a `initialVariantId`
+     * is passed, use that to select initial options.
+     */
+    const [selectedOptions, setSelectedOptions] = useState(() => getSelectedOptions(selectedVariant));
+    /**
+     * When the initialVariantId changes, we need to make sure we
+     * update the selected variant and selected options. If not,
+     * then the selected variant and options will reference incorrect
+     * values.
+     */
+    useEffect(() => {
+        const newSelectedVariant = getVariantBasedOnIdProp(explicitVariantId, variants);
+        setSelectedVariant(newSelectedVariant);
+        setSelectedOptions(getSelectedOptions(newSelectedVariant));
+    }, [explicitVariantId, variants]);
+    /**
+     * Allow the developer to select an option.
+     */
+    const setSelectedOption = useCallback((name, value) => {
+        setSelectedOptions((selectedOptions) => {
+            const opts = { ...selectedOptions, [name]: value };
+            setSelectedVariant(getSelectedVariant(variants, opts));
+            return opts;
+        });
+    }, [setSelectedOptions, variants]);
+    const isOptionInStock = useCallback((option, value) => {
+        const proposedVariant = getSelectedVariant(variants, {
+            ...selectedOptions,
+            ...{ [option]: value },
+        });
+        return proposedVariant?.availableForSale ?? true;
+    }, [selectedOptions, variants]);
+    const sellingPlanGroups = useMemo(() => flattenConnection(product.sellingPlanGroups ?? {}).map((sellingPlanGroup) => ({
+        ...sellingPlanGroup,
+        sellingPlans: flattenConnection(sellingPlanGroup?.sellingPlans ?? {}),
+    })), [product.sellingPlanGroups]);
+    /**
+     * Track the selectedSellingPlan within the hook. If `initialSellingPlanId`
+     * is passed, use that as an initial value. Look it up from the `selectedVariant`, since
+     * that is also a requirement.
+     */
+    const [selectedSellingPlan, setSelectedSellingPlan] = useState(undefined);
+    const selectedSellingPlanAllocation = useMemo(() => {
+        if (!selectedVariant || !selectedSellingPlan) {
+            return;
+        }
+        if (!selectedVariant.sellingPlanAllocations?.nodes &&
+            !selectedVariant.sellingPlanAllocations?.edges) {
+            throw new Error(`<ProductOptionsProvider/>: You must include 'sellingPlanAllocations.nodes' or 'sellingPlanAllocations.edges' in your variants in order to calculate selectedSellingPlanAllocation`);
+        }
+        return flattenConnection(selectedVariant.sellingPlanAllocations).find((allocation) => allocation?.sellingPlan?.id === selectedSellingPlan.id);
+    }, [selectedVariant, selectedSellingPlan]);
+    const value = useMemo(() => ({
+        variants,
+        variantsConnection: product.variants,
+        options,
+        selectedVariant,
+        setSelectedVariant,
+        selectedOptions,
+        setSelectedOption,
+        setSelectedOptions,
+        isOptionInStock,
+        selectedSellingPlan,
+        setSelectedSellingPlan,
+        selectedSellingPlanAllocation,
+        sellingPlanGroups,
+        sellingPlanGroupsConnection: product.sellingPlanGroups,
+    }), [
+        isOptionInStock,
+        options,
+        product.sellingPlanGroups,
+        product.variants,
+        selectedOptions,
+        selectedSellingPlan,
+        selectedSellingPlanAllocation,
+        selectedVariant,
+        sellingPlanGroups,
+        setSelectedOption,
+        variants,
+    ]);
+    return (React.createElement(ProductOptionsContext.Provider, { value: value }, children));
+}
+function getVariantBasedOnIdProp(explicitVariantId, variants) {
+    // get the initial variant based on the logic outlined in the comments for 'initialVariantId' above
+    // * 1. If `initialVariantId` is provided, then it's used even if it's out of stock.
+    if (explicitVariantId) {
+        const foundVariant = variants.find((variant) => variant?.id === explicitVariantId);
+        if (!foundVariant) {
+            console.warn(`<ProductOptionsProvider/> received a 'initialVariantId' prop, but could not actually find a variant with that ID`);
+        }
+        return foundVariant;
+    }
+    // * 2. If `initialVariantId` is provided but is `null`, then no variant is used.
+    if (explicitVariantId === null) {
+        return null;
+    }
+    // * 3. If nothing is passed to `initialVariantId` then the first available / in-stock variant is used.
+    // * 4. If nothing is passed to `initialVariantId` and no variants are in stock, then the first variant is used.
+    if (explicitVariantId === undefined) {
+        return variants.find((variant) => variant?.availableForSale) || variants[0];
+    }
+}
+function getSelectedOptions(selectedVariant) {
+    return selectedVariant?.selectedOptions
+        ? selectedVariant.selectedOptions.reduce((memo, optionSet) => {
+            memo[optionSet?.name ?? ''] = optionSet?.value ?? '';
+            return memo;
+        }, {})
+        : {};
+}
+function isProductVariantArray(maybeVariantArray) {
+    if (!maybeVariantArray || !Array.isArray(maybeVariantArray)) {
+        return false;
+    }
+    return true;
+}
diff --git a/dist/dist/esnext/components/ProductOptionsProvider/context.d.ts b/dist/dist/esnext/components/ProductOptionsProvider/context.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9b546d271c865a4b08b4092f4246c48abb1a4600
--- /dev/null
+++ b/dist/dist/esnext/components/ProductOptionsProvider/context.d.ts
@@ -0,0 +1,2 @@
+import type { ProductOptionsHookValue } from '../../hooks/index.js';
+export declare const ProductOptionsContext: import("react").Context<ProductOptionsHookValue | null>;
diff --git a/dist/dist/esnext/components/ProductOptionsProvider/context.js b/dist/dist/esnext/components/ProductOptionsProvider/context.js
new file mode 100644
index 0000000000000000000000000000000000000000..8ed5747f23193a9c2afeb584bc99f68e87e3addb
--- /dev/null
+++ b/dist/dist/esnext/components/ProductOptionsProvider/context.js
@@ -0,0 +1,2 @@
+import { createContext } from 'react';
+export const ProductOptionsContext = createContext(null);
diff --git a/dist/dist/esnext/components/ProductOptionsProvider/index.d.ts b/dist/dist/esnext/components/ProductOptionsProvider/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7c06695254d98a2319cfd0f2cf01bc34b1d7fe81
--- /dev/null
+++ b/dist/dist/esnext/components/ProductOptionsProvider/index.d.ts
@@ -0,0 +1 @@
+export { ProductOptionsProvider } from './ProductOptionsProvider.client.js';
diff --git a/dist/dist/esnext/components/ProductOptionsProvider/index.js b/dist/dist/esnext/components/ProductOptionsProvider/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..7c06695254d98a2319cfd0f2cf01bc34b1d7fe81
--- /dev/null
+++ b/dist/dist/esnext/components/ProductOptionsProvider/index.js
@@ -0,0 +1 @@
+export { ProductOptionsProvider } from './ProductOptionsProvider.client.js';
diff --git a/dist/dist/esnext/components/ProductPrice/ProductPrice.client.d.ts b/dist/dist/esnext/components/ProductPrice/ProductPrice.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5b71f678e52514743177d2cdbb458b96cf2d40b4
--- /dev/null
+++ b/dist/dist/esnext/components/ProductPrice/ProductPrice.client.d.ts
@@ -0,0 +1,18 @@
+import React from 'react';
+import type { Product } from '../../storefront-api-types.js';
+import { Money } from '../Money/index.js';
+import type { PartialDeep } from 'type-fest';
+export interface ProductPriceProps {
+    data: PartialDeep<Product>;
+    /** The type of price. Valid values: `regular` (default) or `compareAt`. */
+    priceType?: 'regular' | 'compareAt';
+    /** The type of value. Valid values: `min` (default), `max` or `unit`. */
+    valueType?: 'max' | 'min' | 'unit';
+    /** The ID of the variant. */
+    variantId?: string;
+}
+/**
+ * The `ProductPrice` component renders a `Money` component with the product
+ * [`priceRange`](https://shopify.dev/api/storefront/reference/products/productpricerange)'s `maxVariantPrice` or `minVariantPrice`, for either the regular price or compare at price range.
+ */
+export declare function ProductPrice(props: Omit<React.ComponentProps<typeof Money>, 'data' | 'measurement'> & ProductPriceProps): JSX.Element | null;
diff --git a/dist/dist/esnext/components/ProductPrice/ProductPrice.client.js b/dist/dist/esnext/components/ProductPrice/ProductPrice.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..eb2883b80096f89472013283d0e1c178b569e111
--- /dev/null
+++ b/dist/dist/esnext/components/ProductPrice/ProductPrice.client.js
@@ -0,0 +1,54 @@
+import React from 'react';
+import { Money } from '../Money/index.js';
+import { flattenConnection } from '../../utilities/flattenConnection/index.js';
+/**
+ * The `ProductPrice` component renders a `Money` component with the product
+ * [`priceRange`](https://shopify.dev/api/storefront/reference/products/productpricerange)'s `maxVariantPrice` or `minVariantPrice`, for either the regular price or compare at price range.
+ */
+export function ProductPrice(props) {
+    const { priceType = 'regular', variantId, valueType = 'min', data: product, ...passthroughProps } = props;
+    if (product == null) {
+        throw new Error(`<ProductPrice/> requires a product as the 'data' prop`);
+    }
+    let price;
+    let measurement;
+    const variant = variantId
+        ? flattenConnection(product?.variants ?? {}).find((variant) => variant?.id === variantId) ?? null
+        : null;
+    if (priceType === 'compareAt') {
+        if (variantId && variant) {
+            if (variant.compareAtPriceV2?.amount === variant.priceV2?.amount) {
+                return null;
+            }
+            price = variant.compareAtPriceV2;
+        }
+        else if (valueType === 'max') {
+            price = product?.compareAtPriceRange?.maxVariantPrice;
+        }
+        else {
+            price = product?.compareAtPriceRange?.minVariantPrice;
+        }
+    }
+    else {
+        if (variantId && variant) {
+            price = variant.priceV2;
+            if (valueType === 'unit') {
+                price = variant.unitPrice;
+                measurement = variant.unitPriceMeasurement;
+            }
+        }
+        else if (valueType === 'max') {
+            price = product.priceRange?.maxVariantPrice;
+        }
+        else {
+            price = product.priceRange?.minVariantPrice;
+        }
+    }
+    if (!price) {
+        return null;
+    }
+    if (measurement) {
+        return (React.createElement(Money, { ...passthroughProps, data: price, measurement: measurement }));
+    }
+    return React.createElement(Money, { ...passthroughProps, data: price });
+}
diff --git a/dist/dist/esnext/components/ProductPrice/index.d.ts b/dist/dist/esnext/components/ProductPrice/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5514768e33810eb4387bbbe0c0c72d568d8ae8ec
--- /dev/null
+++ b/dist/dist/esnext/components/ProductPrice/index.d.ts
@@ -0,0 +1 @@
+export { ProductPrice } from './ProductPrice.client.js';
diff --git a/dist/dist/esnext/components/ProductPrice/index.js b/dist/dist/esnext/components/ProductPrice/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..5514768e33810eb4387bbbe0c0c72d568d8ae8ec
--- /dev/null
+++ b/dist/dist/esnext/components/ProductPrice/index.js
@@ -0,0 +1 @@
+export { ProductPrice } from './ProductPrice.client.js';
diff --git a/dist/dist/esnext/components/Seo/CollectionSeo.client.d.ts b/dist/dist/esnext/components/Seo/CollectionSeo.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4451f1cabc280771e67eae823dcec3ae2d759e13
--- /dev/null
+++ b/dist/dist/esnext/components/Seo/CollectionSeo.client.d.ts
@@ -0,0 +1,3 @@
+import type { Collection as CollectionType } from '../../storefront-api-types.js';
+import type { PartialDeep } from 'type-fest';
+export declare function CollectionSeo({ title, description, seo, image, }: PartialDeep<CollectionType>): JSX.Element;
diff --git a/dist/dist/esnext/components/Seo/CollectionSeo.client.js b/dist/dist/esnext/components/Seo/CollectionSeo.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..24688691b2828cbb750c7d22796ed9dd05e12e68
--- /dev/null
+++ b/dist/dist/esnext/components/Seo/CollectionSeo.client.js
@@ -0,0 +1,14 @@
+import React from 'react';
+import { TitleSeo } from './TitleSeo.client.js';
+import { DescriptionSeo } from './DescriptionSeo.client.js';
+import { TwitterSeo } from './TwitterSeo.client.js';
+import { ImageSeo } from './ImageSeo.client.js';
+export function CollectionSeo({ title, description, seo, image, }) {
+    const seoTitle = seo?.title ?? title;
+    const seoDescription = seo?.description ?? description;
+    return (React.createElement(React.Fragment, null,
+        React.createElement(TitleSeo, { title: seoTitle }),
+        React.createElement(DescriptionSeo, { description: seoDescription }),
+        React.createElement(TwitterSeo, { title: seoTitle, description: seoDescription }),
+        image && React.createElement(ImageSeo, { ...image })));
+}
diff --git a/dist/dist/esnext/components/Seo/DefaultPageSeo.client.d.ts b/dist/dist/esnext/components/Seo/DefaultPageSeo.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..313262255dcc68573e14d5ce8aaa244404ecfd39
--- /dev/null
+++ b/dist/dist/esnext/components/Seo/DefaultPageSeo.client.d.ts
@@ -0,0 +1,3 @@
+import type { DefaultPage } from './seo-types.js';
+import type { PartialDeep } from 'type-fest';
+export declare function DefaultPageSeo({ title, description, url, titleTemplate, lang, }: PartialDeep<DefaultPage>): JSX.Element;
diff --git a/dist/dist/esnext/components/Seo/DefaultPageSeo.client.js b/dist/dist/esnext/components/Seo/DefaultPageSeo.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..1a32468e44bd962a3491cf08bd532b638c831115
--- /dev/null
+++ b/dist/dist/esnext/components/Seo/DefaultPageSeo.client.js
@@ -0,0 +1,18 @@
+import React from 'react';
+import { Head } from '../../foundation/Head/index.js';
+import { useLocalization } from '../../hooks/useLocalization/useLocalization.js';
+import { TitleSeo } from './TitleSeo.client.js';
+import { DescriptionSeo } from './DescriptionSeo.client.js';
+import { TwitterSeo } from './TwitterSeo.client.js';
+export function DefaultPageSeo({ title, description, url, titleTemplate, lang, }) {
+    const { language: { isoCode: fallBacklang }, } = useLocalization();
+    return (React.createElement(React.Fragment, null,
+        React.createElement(Head, { defaultTitle: title ?? '', titleTemplate: titleTemplate ?? `%s - ${title}` },
+            React.createElement("html", { lang: lang ?? fallBacklang }),
+            React.createElement("meta", { property: "og:type", content: "website" }),
+            React.createElement("meta", { property: "og:site_name", content: title ?? '' }),
+            React.createElement("meta", { property: "og:url", content: url })),
+        React.createElement(TitleSeo, { title: title }),
+        React.createElement(DescriptionSeo, { description: description }),
+        React.createElement(TwitterSeo, { title: title, description: description })));
+}
diff --git a/dist/dist/esnext/components/Seo/DescriptionSeo.client.d.ts b/dist/dist/esnext/components/Seo/DescriptionSeo.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6335f90392e89d85ec03f4c12babf40d863b924b
--- /dev/null
+++ b/dist/dist/esnext/components/Seo/DescriptionSeo.client.d.ts
@@ -0,0 +1,4 @@
+import type { Seo as SeoType } from '../../storefront-api-types.js';
+export declare function DescriptionSeo({ description, }: {
+    description?: SeoType['description'];
+}): JSX.Element | null;
diff --git a/dist/dist/esnext/components/Seo/DescriptionSeo.client.js b/dist/dist/esnext/components/Seo/DescriptionSeo.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..9bf1805c5471b23137102e2cdad356cc2a266191
--- /dev/null
+++ b/dist/dist/esnext/components/Seo/DescriptionSeo.client.js
@@ -0,0 +1,10 @@
+import React from 'react';
+import { Head } from '../../foundation/Head/index.js';
+export function DescriptionSeo({ description, }) {
+    if (!description) {
+        return null;
+    }
+    return (React.createElement(Head, null,
+        React.createElement("meta", { name: "description", content: description }),
+        React.createElement("meta", { property: "og:description", content: description })));
+}
diff --git a/dist/dist/esnext/components/Seo/HomePageSeo.client.d.ts b/dist/dist/esnext/components/Seo/HomePageSeo.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f01da78a8719a1747d8027a5f0c44fffc4f163a0
--- /dev/null
+++ b/dist/dist/esnext/components/Seo/HomePageSeo.client.d.ts
@@ -0,0 +1,2 @@
+import type { HomePage } from './seo-types.js';
+export declare function HomePageSeo({ title, description, url, titleTemplate, }: HomePage): JSX.Element;
diff --git a/dist/dist/esnext/components/Seo/HomePageSeo.client.js b/dist/dist/esnext/components/Seo/HomePageSeo.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..304ffa51c8600185d3ba7b4075024189503b33dc
--- /dev/null
+++ b/dist/dist/esnext/components/Seo/HomePageSeo.client.js
@@ -0,0 +1,25 @@
+import React from 'react';
+import { Head } from '../../foundation/Head/index.js';
+import { TitleSeo } from './TitleSeo.client.js';
+import { DescriptionSeo } from './DescriptionSeo.client.js';
+export function HomePageSeo({ title, description, url, titleTemplate, }) {
+    const organizationSchema = {
+        '@context': 'http://schema.org',
+        '@type': 'Organization',
+        name: title,
+        url,
+    };
+    const webSiteSchema = {
+        '@context': 'http://schema.org',
+        '@type': 'WebSite',
+        name: title,
+        url,
+    };
+    return (React.createElement(React.Fragment, null,
+        React.createElement(Head, { defaultTitle: title ?? '', titleTemplate: titleTemplate ?? `%s` },
+            React.createElement("meta", { property: "og:url", content: url }),
+            React.createElement("script", { type: "application/ld+json" }, JSON.stringify(organizationSchema)),
+            React.createElement("script", { type: "application/ld+json" }, JSON.stringify(webSiteSchema))),
+        React.createElement(TitleSeo, { title: title }),
+        description && React.createElement(DescriptionSeo, { description: description })));
+}
diff --git a/dist/dist/esnext/components/Seo/ImageSeo.client.d.ts b/dist/dist/esnext/components/Seo/ImageSeo.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c97cf3cfa5afcb798e4a03ce6e56b6a67f03e916
--- /dev/null
+++ b/dist/dist/esnext/components/Seo/ImageSeo.client.d.ts
@@ -0,0 +1,3 @@
+import type { Image } from '../../storefront-api-types.js';
+import type { PartialDeep } from 'type-fest';
+export declare function ImageSeo({ url, width, height, altText }: PartialDeep<Image>): JSX.Element;
diff --git a/dist/dist/esnext/components/Seo/ImageSeo.client.js b/dist/dist/esnext/components/Seo/ImageSeo.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..3a07281932926038d464a009f8db2462cfd0ee65
--- /dev/null
+++ b/dist/dist/esnext/components/Seo/ImageSeo.client.js
@@ -0,0 +1,10 @@
+import React from 'react';
+import { Head } from '../../foundation/Head/index.js';
+export function ImageSeo({ url, width, height, altText }) {
+    return (React.createElement(Head, null,
+        url && React.createElement("meta", { property: "og:image", content: url }),
+        url && React.createElement("meta", { property: "og:image:secure_url", content: url }),
+        width && React.createElement("meta", { property: "og:image:width", content: `${width}` }),
+        height && React.createElement("meta", { property: "og:image:height", content: `${height}` }),
+        altText && React.createElement("meta", { property: "og:image:alt", content: altText })));
+}
diff --git a/dist/dist/esnext/components/Seo/NoIndexSeo.client.d.ts b/dist/dist/esnext/components/Seo/NoIndexSeo.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9c21a8e6ccc5b81871b5507e7b289514dca3acf2
--- /dev/null
+++ b/dist/dist/esnext/components/Seo/NoIndexSeo.client.d.ts
@@ -0,0 +1,3 @@
+import type { DefaultPage } from './seo-types.js';
+import type { PartialDeep } from 'type-fest';
+export declare function NoIndexPageSeo({ title, titleTemplate, lang, }: PartialDeep<DefaultPage>): JSX.Element;
diff --git a/dist/dist/esnext/components/Seo/NoIndexSeo.client.js b/dist/dist/esnext/components/Seo/NoIndexSeo.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..1cc46f85cdbf8bc0e63238ec964c59686bf9c676
--- /dev/null
+++ b/dist/dist/esnext/components/Seo/NoIndexSeo.client.js
@@ -0,0 +1,10 @@
+import React from 'react';
+import { useLocalization } from '../../hooks/useLocalization/useLocalization.js';
+import { Head } from '../../foundation/Head/Head.client.js';
+export function NoIndexPageSeo({ title, titleTemplate, lang, }) {
+    const { language: { isoCode: fallBacklang }, } = useLocalization();
+    return (React.createElement(React.Fragment, null,
+        React.createElement(Head, { defaultTitle: title ?? '', titleTemplate: titleTemplate ?? `%s - ${title}` },
+            React.createElement("html", { lang: lang ?? fallBacklang }),
+            React.createElement("meta", { name: "robots", content: "noindex" }))));
+}
diff --git a/dist/dist/esnext/components/Seo/PageSeo.client.d.ts b/dist/dist/esnext/components/Seo/PageSeo.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b176ed0bd0e80c9d4e038e31e7f0615ff02ac7f3
--- /dev/null
+++ b/dist/dist/esnext/components/Seo/PageSeo.client.d.ts
@@ -0,0 +1,3 @@
+import type { Page as PageType } from '../../storefront-api-types.js';
+import type { PartialDeep } from 'type-fest';
+export declare function PageSeo({ title, seo }: PartialDeep<PageType>): JSX.Element;
diff --git a/dist/dist/esnext/components/Seo/PageSeo.client.js b/dist/dist/esnext/components/Seo/PageSeo.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..242f6cafea0f51c596542c47bc8323c3e3faa9fe
--- /dev/null
+++ b/dist/dist/esnext/components/Seo/PageSeo.client.js
@@ -0,0 +1,12 @@
+import React from 'react';
+import { TitleSeo } from './TitleSeo.client.js';
+import { DescriptionSeo } from './DescriptionSeo.client.js';
+import { TwitterSeo } from './TwitterSeo.client.js';
+export function PageSeo({ title, seo }) {
+    const seoTitle = seo?.title ?? title;
+    const seoDescription = seo?.description;
+    return (React.createElement(React.Fragment, null,
+        React.createElement(TitleSeo, { title: seoTitle }),
+        React.createElement(DescriptionSeo, { description: seoDescription }),
+        React.createElement(TwitterSeo, { title: seoTitle, description: seoDescription })));
+}
diff --git a/dist/dist/esnext/components/Seo/ProductSeo.client.d.ts b/dist/dist/esnext/components/Seo/ProductSeo.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b65889744b830ef0f680f98f77e23b01f32bd14c
--- /dev/null
+++ b/dist/dist/esnext/components/Seo/ProductSeo.client.d.ts
@@ -0,0 +1,5 @@
+import type { Scalars, Product as ProductType } from '../../storefront-api-types.js';
+import type { PartialDeep } from 'type-fest';
+export declare function ProductSeo({ url, title, description, seo, vendor, featuredImage, variants, }: PartialDeep<ProductType> & {
+    url: Scalars['URL'];
+}): JSX.Element;
diff --git a/dist/dist/esnext/components/Seo/ProductSeo.client.js b/dist/dist/esnext/components/Seo/ProductSeo.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..6866f2b3380703d6ddd03fed7b0e67bfb19ac6b5
--- /dev/null
+++ b/dist/dist/esnext/components/Seo/ProductSeo.client.js
@@ -0,0 +1,62 @@
+import React from 'react';
+import { Head } from '../../foundation/Head/index.js';
+import { TitleSeo } from './TitleSeo.client.js';
+import { DescriptionSeo } from './DescriptionSeo.client.js';
+import { TwitterSeo } from './TwitterSeo.client.js';
+import { ImageSeo } from './ImageSeo.client.js';
+import { flattenConnection } from '../../utilities/flattenConnection/index.js';
+export function ProductSeo({ url, title, description, seo, vendor, featuredImage, variants, }) {
+    const seoTitle = seo?.title ?? title;
+    const seoDescription = seo?.description ?? description;
+    let firstVariantPrice;
+    const productSchema = {
+        '@context': 'http://schema.org/',
+        '@type': 'Product',
+        name: title,
+        description,
+        brand: {
+            '@type': 'Thing',
+            name: vendor,
+        },
+        url,
+    };
+    if (featuredImage) {
+        productSchema.image = featuredImage.url;
+    }
+    const flattenedVariants = flattenConnection(variants ?? {});
+    if (flattenedVariants.length) {
+        const firstVariant = flattenedVariants[0];
+        firstVariantPrice = firstVariant?.priceV2;
+        if (firstVariant && firstVariant.sku) {
+            productSchema.sku = firstVariant.sku;
+        }
+        productSchema.offers = flattenedVariants.map((node) => {
+            if (!node || !node.priceV2?.amount || !node.priceV2.currencyCode) {
+                throw new Error(`<ProductSeo/> requires variant.PriceV2 'amount' and 'currency`);
+            }
+            const offerSchema = {
+                '@type': 'Offer',
+                availability: `https://schema.org/${node.availableForSale ? 'InStock' : 'OutOfStock'}`,
+                price: node.priceV2.amount,
+                priceCurrency: node.priceV2.currencyCode,
+            };
+            if (node.sku) {
+                offerSchema.sku = node.sku;
+            }
+            if (node.image && node.image.url) {
+                offerSchema.image = node.image.url;
+            }
+            return offerSchema;
+        });
+    }
+    return (React.createElement(React.Fragment, null,
+        React.createElement(Head, null,
+            React.createElement("meta", { property: "og:type", content: "og:product" }),
+            firstVariantPrice && (React.createElement("meta", { property: "og:price:amount", content: `${firstVariantPrice.amount}` })),
+            firstVariantPrice && (React.createElement("meta", { property: "og:price:currency", content: firstVariantPrice.currencyCode })),
+            React.createElement("script", { type: "application/ld+json" }, JSON.stringify(productSchema))),
+        React.createElement(TitleSeo, { title: seoTitle }),
+        React.createElement(DescriptionSeo, { description: seoDescription }),
+        React.createElement(TwitterSeo, { title: seoTitle, description: seoDescription }),
+        featuredImage && React.createElement(ImageSeo, { ...featuredImage })));
+}
diff --git a/dist/dist/esnext/components/Seo/Seo.client.d.ts b/dist/dist/esnext/components/Seo/Seo.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..afc1007936bb67c865eac07d5a5f32d58bec774b
--- /dev/null
+++ b/dist/dist/esnext/components/Seo/Seo.client.d.ts
@@ -0,0 +1,30 @@
+import { type ComponentProps } from 'react';
+import { ProductSeo } from './ProductSeo.client.js';
+import { CollectionSeo } from './CollectionSeo.client.js';
+import { PageSeo } from './PageSeo.client.js';
+import { NoIndexPageSeo } from './NoIndexSeo.client.js';
+import type { DefaultPage as DefaultPageType, HomePage as HomePageType } from './seo-types';
+declare type Props = {
+    type: 'defaultSeo';
+    data: Omit<DefaultPageType, 'url'>;
+} | {
+    type: 'homepage';
+    data: Omit<HomePageType, 'url'>;
+} | {
+    type: 'product';
+    data: Omit<ComponentProps<typeof ProductSeo>, 'url'>;
+} | {
+    type: 'collection';
+    data: ComponentProps<typeof CollectionSeo>;
+} | {
+    type: 'page';
+    data: ComponentProps<typeof PageSeo>;
+} | {
+    type: 'noindex';
+    data: ComponentProps<typeof NoIndexPageSeo>;
+};
+/**
+ * The `Seo` component renders SEO information on a webpage.
+ */
+export declare function Seo(props: Props): JSX.Element | null;
+export {};
diff --git a/dist/dist/esnext/components/Seo/Seo.client.js b/dist/dist/esnext/components/Seo/Seo.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..c197dc71394e2c864fdd6ce28a50195c92754d9f
--- /dev/null
+++ b/dist/dist/esnext/components/Seo/Seo.client.js
@@ -0,0 +1,31 @@
+import React from 'react';
+import { useUrl } from '../../foundation/useUrl/index.js';
+import { DefaultPageSeo } from './DefaultPageSeo.client.js';
+import { HomePageSeo } from './HomePageSeo.client.js';
+import { ProductSeo } from './ProductSeo.client.js';
+import { CollectionSeo } from './CollectionSeo.client.js';
+import { PageSeo } from './PageSeo.client.js';
+import { NoIndexPageSeo } from './NoIndexSeo.client.js';
+/**
+ * The `Seo` component renders SEO information on a webpage.
+ */
+export function Seo(props) {
+    const url = useUrl().href;
+    switch (props.type) {
+        case 'defaultSeo':
+            return React.createElement(DefaultPageSeo, { ...{ url, ...props.data } });
+        case 'homepage':
+            return React.createElement(HomePageSeo, { ...{ url, ...props.data } });
+        case 'product':
+            return React.createElement(ProductSeo, { ...{ url, ...props.data } });
+        case 'collection':
+            return React.createElement(CollectionSeo, { ...props.data });
+        case 'page':
+            return React.createElement(PageSeo, { ...props.data });
+        case 'noindex':
+            return React.createElement(NoIndexPageSeo, { ...props.data });
+        default:
+            console.warn('The <Seo/> only accepts type prop with values of defaultSeo, homepage, product, collection, or page.');
+            return null;
+    }
+}
diff --git a/dist/dist/esnext/components/Seo/TitleSeo.client.d.ts b/dist/dist/esnext/components/Seo/TitleSeo.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f132cc3d76e065a884073abc527a3a2990724ecd
--- /dev/null
+++ b/dist/dist/esnext/components/Seo/TitleSeo.client.d.ts
@@ -0,0 +1,3 @@
+import type { Seo as SeoType } from '../../storefront-api-types.js';
+import type { PartialDeep } from 'type-fest';
+export declare function TitleSeo({ title }: PartialDeep<SeoType>): JSX.Element | null;
diff --git a/dist/dist/esnext/components/Seo/TitleSeo.client.js b/dist/dist/esnext/components/Seo/TitleSeo.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..c017f8282fc05afe21c5197b479bd33ab1d3bc3b
--- /dev/null
+++ b/dist/dist/esnext/components/Seo/TitleSeo.client.js
@@ -0,0 +1,10 @@
+import React from 'react';
+import { Head } from '../../foundation/Head/index.js';
+export function TitleSeo({ title }) {
+    if (!title) {
+        return null;
+    }
+    return (React.createElement(Head, null,
+        React.createElement("title", null, title),
+        React.createElement("meta", { property: "og:title", content: title })));
+}
diff --git a/dist/dist/esnext/components/Seo/TwitterSeo.client.d.ts b/dist/dist/esnext/components/Seo/TwitterSeo.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6dd84aa807bc1cab845246389bbc8d0c515b11d9
--- /dev/null
+++ b/dist/dist/esnext/components/Seo/TwitterSeo.client.d.ts
@@ -0,0 +1,2 @@
+import type { Twitter } from './seo-types.js';
+export declare function TwitterSeo({ site, title, description }: Partial<Twitter>): JSX.Element;
diff --git a/dist/dist/esnext/components/Seo/TwitterSeo.client.js b/dist/dist/esnext/components/Seo/TwitterSeo.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..7b1e1e92cc2d9562dea31e387942bd7bca53741e
--- /dev/null
+++ b/dist/dist/esnext/components/Seo/TwitterSeo.client.js
@@ -0,0 +1,9 @@
+import React from 'react';
+import { Head } from '../../foundation/Head/index.js';
+export function TwitterSeo({ site, title, description }) {
+    return (React.createElement(Head, null,
+        React.createElement("meta", { name: "twitter:card", content: "summary_large_image" }),
+        site && React.createElement("meta", { name: "twitter:site", content: site }),
+        title && React.createElement("meta", { name: "twitter:title", content: title }),
+        description && React.createElement("meta", { name: "twitter:description", content: description })));
+}
diff --git a/dist/dist/esnext/components/Seo/index.d.ts b/dist/dist/esnext/components/Seo/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..62370d4a4b4e5cc43931f6131c239083935c0a18
--- /dev/null
+++ b/dist/dist/esnext/components/Seo/index.d.ts
@@ -0,0 +1 @@
+export { Seo } from './Seo.client.js';
diff --git a/dist/dist/esnext/components/Seo/index.js b/dist/dist/esnext/components/Seo/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..62370d4a4b4e5cc43931f6131c239083935c0a18
--- /dev/null
+++ b/dist/dist/esnext/components/Seo/index.js
@@ -0,0 +1 @@
+export { Seo } from './Seo.client.js';
diff --git a/dist/dist/esnext/components/Seo/seo-types.d.ts b/dist/dist/esnext/components/Seo/seo-types.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..589bcd0050f3fd65cccce63744319813db785a30
--- /dev/null
+++ b/dist/dist/esnext/components/Seo/seo-types.d.ts
@@ -0,0 +1,18 @@
+import type { Scalars, Shop as ShopType, Seo as SeoType } from '../../storefront-api-types.js';
+export interface Twitter {
+    site: string;
+    title: SeoType['title'];
+    description: SeoType['description'];
+}
+export interface HomePage {
+    description: ShopType['description'];
+    title: ShopType['name'];
+    url: Scalars['URL'];
+    titleTemplate?: string;
+}
+export interface DefaultPage extends ShopType {
+    title: ShopType['name'];
+    url: Scalars['URL'];
+    titleTemplate?: string;
+    lang?: string;
+}
diff --git a/dist/dist/esnext/components/Seo/seo-types.js b/dist/dist/esnext/components/Seo/seo-types.js
new file mode 100644
index 0000000000000000000000000000000000000000..cb0ff5c3b541f646105198ee23ac0fc3d805023e
--- /dev/null
+++ b/dist/dist/esnext/components/Seo/seo-types.js
@@ -0,0 +1 @@
+export {};
diff --git a/dist/dist/esnext/components/ShopPayButton/ShopPayButton.client.d.ts b/dist/dist/esnext/components/ShopPayButton/ShopPayButton.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c7f8b0a2d734347964b19075fda9ac9fff42f919
--- /dev/null
+++ b/dist/dist/esnext/components/ShopPayButton/ShopPayButton.client.d.ts
@@ -0,0 +1,40 @@
+declare type ShopPayButtonProps = {
+    /** A string of classes to apply to the `div` that wraps the Shop Pay button. */
+    className?: string;
+    /** A string that's applied to the [CSS custom property (variable)](https://developer.mozilla.org/en-US/docs/Web/CSS/--*) `--shop-pay-button-width` for the [Buy with Shop Pay component](https://shopify.dev/custom-storefronts/tools/web-components#buy-with-shop-pay-component). */
+    width?: string;
+} & ({
+    /** An array of IDs of the variants to purchase with Shop Pay. This will only ever have a quantity of 1 for each variant. If you want to use other quantities, then use 'variantIdsAndQuantities'. */
+    variantIds: string[];
+    /** An array of variant IDs and quantities to purchase with Shop Pay. */
+    variantIdsAndQuantities?: never;
+} | {
+    /** An array of IDs of the variants to purchase with Shop Pay. This will only ever have a quantity of 1 for each variant. If you want to use other quantities, then use 'variantIdsAndQuantities'. */
+    variantIds?: never;
+    /** An array of variant IDs and quantities to purchase with Shop Pay. */
+    variantIdsAndQuantities: Array<{
+        id: string;
+        quantity: number;
+    }>;
+});
+declare global {
+    namespace JSX {
+        interface IntrinsicElements {
+            'shop-pay-button': {
+                variants: string;
+                'store-url': string;
+            };
+        }
+    }
+}
+/**
+ * The `ShopPayButton` component renders a button that redirects to the Shop Pay checkout.
+ */
+export declare function ShopPayButton({ variantIds, className, variantIdsAndQuantities, width, }: ShopPayButtonProps): JSX.Element;
+/**
+ * Takes a string in the format of "gid://shopify/ProductVariant/41007289630776" and returns a string of the ID part at the end: "41007289630776"
+ */
+export declare function getIdFromGid(id?: string): string | undefined;
+export declare const MissingPropsErrorMessage = "You must pass in either \"variantIds\" or \"variantIdsAndQuantities\" to ShopPayButton";
+export declare const DoublePropsErrorMessage = "You must provide either a variantIds or variantIdsAndQuantities prop, but not both in the ShopPayButton component";
+export {};
diff --git a/dist/dist/esnext/components/ShopPayButton/ShopPayButton.client.js b/dist/dist/esnext/components/ShopPayButton/ShopPayButton.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..dcfdb81614163d53c26ad0613dd393c42be1d027
--- /dev/null
+++ b/dist/dist/esnext/components/ShopPayButton/ShopPayButton.client.js
@@ -0,0 +1,56 @@
+import React from 'react';
+import { useShop } from '../../foundation/useShop/index.js';
+import { useLoadScript } from '../../hooks/useLoadScript/useLoadScript.client.js';
+const URL = 'https://cdn.shopify.com/shopifycloud/shop-js/v1.0/client.js';
+/**
+ * The `ShopPayButton` component renders a button that redirects to the Shop Pay checkout.
+ */
+export function ShopPayButton({ variantIds, className, variantIdsAndQuantities, width, }) {
+    const { storeDomain } = useShop();
+    const shopPayLoadedStatus = useLoadScript(URL);
+    let ids;
+    if (variantIds && variantIdsAndQuantities) {
+        throw new Error(DoublePropsErrorMessage);
+    }
+    if (variantIds) {
+        ids = variantIds.reduce((prev, curr) => {
+            const bareId = getIdFromGid(curr);
+            if (bareId) {
+                prev.push(bareId);
+            }
+            return prev;
+        }, []);
+    }
+    else if (variantIdsAndQuantities) {
+        ids = variantIdsAndQuantities.reduce((prev, curr) => {
+            const bareId = getIdFromGid(curr?.id);
+            if (bareId) {
+                prev.push(`${bareId}:${curr?.quantity ?? 1}`);
+            }
+            return prev;
+        }, []);
+    }
+    else {
+        throw new Error(MissingPropsErrorMessage);
+    }
+    const style = width
+        ? {
+            '--shop-pay-button-width': width,
+        }
+        : undefined;
+    return (
+    /* eslint-disable jsx-a11y/no-noninteractive-tabindex */
+    React.createElement("div", { className: className, tabIndex: 0, style: style }, shopPayLoadedStatus === 'done' && (React.createElement("shop-pay-button", { "store-url": `https://${storeDomain}`, variants: ids.join(',') })))
+    /* eslint-enable jsx-a11y/no-noninteractive-tabindex */
+    );
+}
+/**
+ * Takes a string in the format of "gid://shopify/ProductVariant/41007289630776" and returns a string of the ID part at the end: "41007289630776"
+ */
+export function getIdFromGid(id) {
+    if (!id)
+        return;
+    return id.split('/').pop();
+}
+export const MissingPropsErrorMessage = `You must pass in either "variantIds" or "variantIdsAndQuantities" to ShopPayButton`;
+export const DoublePropsErrorMessage = `You must provide either a variantIds or variantIdsAndQuantities prop, but not both in the ShopPayButton component`;
diff --git a/dist/dist/esnext/components/ShopPayButton/index.d.ts b/dist/dist/esnext/components/ShopPayButton/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ec056b477c36d2ee9b09829c667066775d7308fa
--- /dev/null
+++ b/dist/dist/esnext/components/ShopPayButton/index.d.ts
@@ -0,0 +1 @@
+export { ShopPayButton } from './ShopPayButton.client.js';
diff --git a/dist/dist/esnext/components/ShopPayButton/index.js b/dist/dist/esnext/components/ShopPayButton/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..ec056b477c36d2ee9b09829c667066775d7308fa
--- /dev/null
+++ b/dist/dist/esnext/components/ShopPayButton/index.js
@@ -0,0 +1 @@
+export { ShopPayButton } from './ShopPayButton.client.js';
diff --git a/dist/dist/esnext/components/Video/Video.d.ts b/dist/dist/esnext/components/Video/Video.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8655c6e71a7bf7768d20aa28a447aa14838541a6
--- /dev/null
+++ b/dist/dist/esnext/components/Video/Video.d.ts
@@ -0,0 +1,19 @@
+import { type HTMLAttributes } from 'react';
+import { shopifyImageLoader } from '../../utilities/index.js';
+import type { Video as VideoType } from '../../storefront-api-types.js';
+import type { PartialDeep } from 'type-fest';
+interface VideoProps {
+    /** An object with fields that correspond to the Storefront API's [Video object](https://shopify.dev/api/storefront/latest/objects/video). */
+    data: PartialDeep<VideoType>;
+    /** An object of image size options for the video's `previewImage`. Uses `shopifyImageLoader` to generate the `poster` URL. */
+    previewImageOptions?: Parameters<typeof shopifyImageLoader>[0];
+    /** Props that will be passed to the `video` element's `source` children elements. */
+    sourceProps?: HTMLAttributes<HTMLSourceElement> & {
+        'data-testid'?: string;
+    };
+}
+/**
+ * The `Video` component renders a `video` for the Storefront API's [Video object](https://shopify.dev/api/storefront/reference/products/video).
+ */
+export declare function Video(props: JSX.IntrinsicElements['video'] & VideoProps): JSX.Element;
+export {};
diff --git a/dist/dist/esnext/components/Video/Video.js b/dist/dist/esnext/components/Video/Video.js
new file mode 100644
index 0000000000000000000000000000000000000000..0d545fb3834e6c977e065e03254fc5cec2731a2e
--- /dev/null
+++ b/dist/dist/esnext/components/Video/Video.js
@@ -0,0 +1,23 @@
+import React from 'react';
+import { shopifyImageLoader } from '../../utilities/index.js';
+/**
+ * The `Video` component renders a `video` for the Storefront API's [Video object](https://shopify.dev/api/storefront/reference/products/video).
+ */
+export function Video(props) {
+    const { data, previewImageOptions, id = data.id, playsInline = true, controls = true, sourceProps = {}, ...passthroughProps } = props;
+    const posterUrl = shopifyImageLoader({
+        src: data.previewImage?.url ?? '',
+        ...previewImageOptions,
+    });
+    if (!data.sources) {
+        throw new Error(`<Video/> requires a 'data.sources' array`);
+    }
+    return (
+    // eslint-disable-next-line jsx-a11y/media-has-caption
+    React.createElement("video", { ...passthroughProps, id: id, playsInline: playsInline, controls: controls, poster: posterUrl }, data.sources.map((source) => {
+        if (!(source?.url && source?.mimeType)) {
+            throw new Error(`<Video/> needs 'source.url' and 'source.mimeType'`);
+        }
+        return (React.createElement("source", { ...sourceProps, key: source.url, src: source.url, type: source.mimeType }));
+    })));
+}
diff --git a/dist/dist/esnext/components/Video/index.d.ts b/dist/dist/esnext/components/Video/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8b9e5b431f09699f3959cbeabcf51bd5cea454f4
--- /dev/null
+++ b/dist/dist/esnext/components/Video/index.d.ts
@@ -0,0 +1 @@
+export { Video } from './Video.js';
diff --git a/dist/dist/esnext/components/Video/index.js b/dist/dist/esnext/components/Video/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..8b9e5b431f09699f3959cbeabcf51bd5cea454f4
--- /dev/null
+++ b/dist/dist/esnext/components/Video/index.js
@@ -0,0 +1 @@
+export { Video } from './Video.js';
diff --git a/dist/dist/esnext/components/index.d.ts b/dist/dist/esnext/components/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a00023a7c0e0f6ff8a2844af57517704232a9f4b
--- /dev/null
+++ b/dist/dist/esnext/components/index.d.ts
@@ -0,0 +1,27 @@
+export { Link } from './Link/index.js';
+export { MediaFile } from './MediaFile/index.js';
+export { Video } from './Video/index.js';
+export { Image, type ExternalImageProps, type ShopifyImageProps, } from './Image/index.js';
+export { ExternalVideo } from './ExternalVideo/index.js';
+export { AddToCartButton } from './AddToCartButton/index.js';
+export { ModelViewer } from './ModelViewer/index.js';
+export { Money } from './Money/index.js';
+export { Metafield } from './Metafield/index.js';
+export type { MetafieldType } from './Metafield/index.js';
+export { CartLineProvider, useCartLine } from './CartLineProvider/index.js';
+export { CartLineImage } from './CartLineImage/index.js';
+export { CartLinePrice } from './CartLinePrice/index.js';
+export { CartLineProductTitle } from './CartLineProductTitle/index.js';
+export { CartLineQuantity } from './CartLineQuantity/index.js';
+export { CartLineQuantityAdjustButton } from './CartLineQuantityAdjustButton/index.js';
+export { CartLines } from './CartLines/index.js';
+export { CartCheckoutButton } from './CartCheckoutButton/index.js';
+export { CartShopPayButton } from './CartShopPayButton/index.js';
+export { CartCost } from './CartCost/index.js';
+export { CartProvider, useCart, useInstantCheckout, } from './CartProvider/index.js';
+export type { State, Status, Cart, CartWithActions, CartAction, } from './CartProvider/index.js';
+export { ProductOptionsProvider } from './ProductOptionsProvider/index.js';
+export { ProductPrice } from './ProductPrice/index.js';
+export { BuyNowButton } from './BuyNowButton/index.js';
+export { ShopPayButton } from './ShopPayButton/index.js';
+export { Seo } from './Seo/index.js';
diff --git a/dist/dist/esnext/components/index.js b/dist/dist/esnext/components/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..5dfd1b3459114a8faed8ef91b1ebaf2ee39ba8d5
--- /dev/null
+++ b/dist/dist/esnext/components/index.js
@@ -0,0 +1,25 @@
+export { Link } from './Link/index.js';
+export { MediaFile } from './MediaFile/index.js';
+export { Video } from './Video/index.js';
+export { Image, } from './Image/index.js';
+export { ExternalVideo } from './ExternalVideo/index.js';
+export { AddToCartButton } from './AddToCartButton/index.js';
+export { ModelViewer } from './ModelViewer/index.js';
+export { Money } from './Money/index.js';
+export { Metafield } from './Metafield/index.js';
+export { CartLineProvider, useCartLine } from './CartLineProvider/index.js';
+export { CartLineImage } from './CartLineImage/index.js';
+export { CartLinePrice } from './CartLinePrice/index.js';
+export { CartLineProductTitle } from './CartLineProductTitle/index.js';
+export { CartLineQuantity } from './CartLineQuantity/index.js';
+export { CartLineQuantityAdjustButton } from './CartLineQuantityAdjustButton/index.js';
+export { CartLines } from './CartLines/index.js';
+export { CartCheckoutButton } from './CartCheckoutButton/index.js';
+export { CartShopPayButton } from './CartShopPayButton/index.js';
+export { CartCost } from './CartCost/index.js';
+export { CartProvider, useCart, useInstantCheckout, } from './CartProvider/index.js';
+export { ProductOptionsProvider } from './ProductOptionsProvider/index.js';
+export { ProductPrice } from './ProductPrice/index.js';
+export { BuyNowButton } from './BuyNowButton/index.js';
+export { ShopPayButton } from './ShopPayButton/index.js';
+export { Seo } from './Seo/index.js';
diff --git a/dist/dist/esnext/components/types.d.ts b/dist/dist/esnext/components/types.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0462f408f2ad32f302e8962416c216e6145604ef
--- /dev/null
+++ b/dist/dist/esnext/components/types.d.ts
@@ -0,0 +1,71 @@
+import { ReactNode, ElementType, ComponentProps, ReactElement } from 'react';
+/**
+ * Inspired by HeadlessUI
+ * @see https://github.com/tailwindlabs/headlessui/blob/6a01c54b15bc0291af737dfc2a225dca88f3fa55/packages/\@headlessui-react/src/types.ts#L11-L13
+ */
+/**
+ * Used as a default value for TOmitableProps. Actual values will be element props
+ * we control e.g. `value` which we don't want developers to set on a component.
+ */
+declare const __: "__";
+declare type __ = typeof __;
+/**
+ * This helper type pulls the ComponentProps from a given `TTag` element. This is
+ * nice because it smartly pulls props from native HTML elements in addition to
+ * React components.
+ */
+declare type PropsOf<TTag = any> = TTag extends ElementType ? ComponentProps<TTag> : never;
+/**
+ * This is a "global" list of props we are always going to control, meaning
+ * we'll omit the original prop definition if it exists.
+ */
+declare type PropsWeControl = keyof OurProps;
+/**
+ * This is the "global" list of our props, similar to above. It is applied to
+ * every component using `Props`.
+ */
+declare type OurProps = {
+    children?: ReactNode;
+};
+declare type CleanProps<TTag, TOmitableProps extends keyof any = __> = TOmitableProps extends __ ? Omit<PropsOf<TTag>, PropsWeControl> : Omit<PropsOf<TTag>, TOmitableProps | PropsWeControl>;
+/**
+ * Props is a helper type which allows us to combine the base props of a given element `TTag`, combine "global" `OurProps`,
+ * and Omit props that we do not allow for the given component.
+ *
+ * ## How to use Props
+ *
+ * Think of it like a function!
+ * - The first arg, `TTag`, should extend `React.ElementType` and it might default to a native HTML element,
+ * like `input`.
+ * - The second arg, `TOmittableProps`, is optional. It is a string or union of strings that represent props
+ * that you do NOT allow in your component, because you overwrite them and control them yourself. One example
+ * of this is an `onClick` handler for e.g. a button.
+ *
+ * You can combine `Props` with your own type definition with & to define props for your component.
+ *
+ * Example:
+ *
+ * ```
+ * type MyProps = {
+ *   customThing: string
+ * }
+ *
+ * type PropsWeControl = 'onClick'
+ *
+ * export function MyButton<TTag extends React.ElementType = 'button'>(props: Props<TTag, PropsWeControl> & MyProps) {
+ *   const {customThing, children, ...passthroughProps} = props;
+ *
+ *   return <button {...passthroughProps} onClick={() => {}}>{children}</button>
+ * }
+ * ```
+ *
+ */
+export declare type Props<TTag, TOmitableProps extends keyof any = __> = CleanProps<TTag, TOmitableProps> & OurProps;
+/**
+ * While similar to `Props`, this props an additional second argument `TSlot` which represents the interface
+ * of the object passed to the callback via render props. Useful for headless components that expect render props.
+ */
+export declare type PropsWithSlot<TTag, TSlot = any, TOmitableProps extends keyof any = __> = CleanProps<TTag, TOmitableProps> & {
+    children?: ReactNode | ((props: TSlot) => ReactElement);
+};
+export {};
diff --git a/dist/dist/esnext/components/types.js b/dist/dist/esnext/components/types.js
new file mode 100644
index 0000000000000000000000000000000000000000..8a74b05ff572337a36252848863abd865a8c2e35
--- /dev/null
+++ b/dist/dist/esnext/components/types.js
@@ -0,0 +1,10 @@
+/**
+ * Inspired by HeadlessUI
+ * @see https://github.com/tailwindlabs/headlessui/blob/6a01c54b15bc0291af737dfc2a225dca88f3fa55/packages/\@headlessui-react/src/types.ts#L11-L13
+ */
+/**
+ * Used as a default value for TOmitableProps. Actual values will be element props
+ * we control e.g. `value` which we don't want developers to set on a component.
+ */
+const __ = '__';
+export {};
diff --git a/dist/dist/esnext/config.d.ts b/dist/dist/esnext/config.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fb67f1536f12effcf60ae3a22bd78eb7597c2c19
--- /dev/null
+++ b/dist/dist/esnext/config.d.ts
@@ -0,0 +1,7 @@
+import type { InlineHydrogenConfig } from './types.js';
+export declare const defineConfig: (params: InlineHydrogenConfig) => InlineHydrogenConfig;
+export type { InlineHydrogenConfig as HydrogenConfig };
+export { ShopifyServerAnalyticsConnector } from './foundation/Analytics/connectors/Shopify/ServerAnalyticsConnector.js';
+export { PerformanceMetricsServerAnalyticsConnector } from './foundation/Analytics/connectors/PerformanceMetrics/ServerAnalyticsConnector.js';
+export { CookieSessionStorage } from './foundation/CookieSessionStorage/CookieSessionStorage.js';
+export { MemorySessionStorage } from './foundation/MemorySessionStorage/MemorySessionStorage.js';
diff --git a/dist/dist/esnext/config.js b/dist/dist/esnext/config.js
new file mode 100644
index 0000000000000000000000000000000000000000..2e5b37d577a4f68817ee17f4ed465db6cd10e7c4
--- /dev/null
+++ b/dist/dist/esnext/config.js
@@ -0,0 +1,5 @@
+export const defineConfig = (params) => params;
+export { ShopifyServerAnalyticsConnector } from './foundation/Analytics/connectors/Shopify/ServerAnalyticsConnector.js';
+export { PerformanceMetricsServerAnalyticsConnector } from './foundation/Analytics/connectors/PerformanceMetrics/ServerAnalyticsConnector.js';
+export { CookieSessionStorage } from './foundation/CookieSessionStorage/CookieSessionStorage.js';
+export { MemorySessionStorage } from './foundation/MemorySessionStorage/MemorySessionStorage.js';
diff --git a/dist/dist/esnext/constants.d.ts b/dist/dist/esnext/constants.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..858e5eb62c67daf3817d4b4443a72ae5e7be291b
--- /dev/null
+++ b/dist/dist/esnext/constants.d.ts
@@ -0,0 +1,14 @@
+export declare const RSC_PATHNAME = "/__rsc";
+export declare const EVENT_PATHNAME = "/__event";
+export declare const EVENT_PATHNAME_REGEX: RegExp;
+export declare const OXYGEN_SECRET_TOKEN_ENVIRONMENT_VARIABLE = "SHOPIFY_STOREFRONT_API_SECRET_TOKEN";
+export declare const STOREFRONT_API_SECRET_TOKEN_HEADER = "Shopify-Storefront-Private-Token";
+export declare const STOREFRONT_API_PUBLIC_TOKEN_HEADER = "X-Shopify-Storefront-Access-Token";
+export declare const FORM_REDIRECT_COOKIE = "Hydrogen-Redirect";
+export declare const STOREFRONT_API_BUYER_IP_HEADER = "Shopify-Storefront-Buyer-IP";
+export declare const SHOPIFY_STOREFRONT_ID_VARIABLE = "SHOPIFY_STOREFRONT_ID";
+export declare const SHOPIFY_STOREFRONT_ID_HEADER = "Shopify-Storefront-Id";
+export declare const SHOPIFY_STOREFRONT_Y_HEADER = "Shopify-Storefront-Y";
+export declare const SHOPIFY_STOREFRONT_S_HEADER = "Shopify-Storefront-S";
+export declare const SHOPIFY_Y = "_shopify_y";
+export declare const SHOPIFY_S = "_shopify_s";
diff --git a/dist/dist/esnext/constants.js b/dist/dist/esnext/constants.js
new file mode 100644
index 0000000000000000000000000000000000000000..0e9803636654277f96259d062d1e3aef13c2eb2c
--- /dev/null
+++ b/dist/dist/esnext/constants.js
@@ -0,0 +1,14 @@
+export const RSC_PATHNAME = '/__rsc';
+export const EVENT_PATHNAME = '/__event';
+export const EVENT_PATHNAME_REGEX = new RegExp(`^${EVENT_PATHNAME}/`);
+export const OXYGEN_SECRET_TOKEN_ENVIRONMENT_VARIABLE = 'SHOPIFY_STOREFRONT_API_SECRET_TOKEN';
+export const STOREFRONT_API_SECRET_TOKEN_HEADER = 'Shopify-Storefront-Private-Token';
+export const STOREFRONT_API_PUBLIC_TOKEN_HEADER = 'X-Shopify-Storefront-Access-Token';
+export const FORM_REDIRECT_COOKIE = 'Hydrogen-Redirect';
+export const STOREFRONT_API_BUYER_IP_HEADER = 'Shopify-Storefront-Buyer-IP';
+export const SHOPIFY_STOREFRONT_ID_VARIABLE = 'SHOPIFY_STOREFRONT_ID';
+export const SHOPIFY_STOREFRONT_ID_HEADER = 'Shopify-Storefront-Id';
+export const SHOPIFY_STOREFRONT_Y_HEADER = 'Shopify-Storefront-Y';
+export const SHOPIFY_STOREFRONT_S_HEADER = 'Shopify-Storefront-S';
+export const SHOPIFY_Y = '_shopify_y';
+export const SHOPIFY_S = '_shopify_s';
diff --git a/dist/dist/esnext/entry-client.d.ts b/dist/dist/esnext/entry-client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8f3979307ef24f170371a98f23fb1096e0a64aa0
--- /dev/null
+++ b/dist/dist/esnext/entry-client.d.ts
@@ -0,0 +1,3 @@
+import type { ClientHandler } from './types.js';
+declare const renderHydrogen: ClientHandler;
+export default renderHydrogen;
diff --git a/dist/dist/esnext/entry-client.js b/dist/dist/esnext/entry-client.js
new file mode 100644
index 0000000000000000000000000000000000000000..130dfe4551a2757bbef045c41c2c87d87ed37b7f
--- /dev/null
+++ b/dist/dist/esnext/entry-client.js
@@ -0,0 +1,197 @@
+import React, { Suspense, useState, StrictMode, Fragment, startTransition, useEffect, } from 'react';
+import { hydrateRoot } from 'react-dom/client';
+import { ErrorBoundary } from 'react-error-boundary/dist/react-error-boundary.esm';
+import { createFromFetch, createFromReadableStream,
+// @ts-ignore
+ } from '@shopify/hydrogen/vendor/react-server-dom-vite';
+import { RSC_PATHNAME } from './constants.js';
+import { ServerPropsProvider } from './foundation/ServerPropsProvider/index.js';
+import { ClientAnalytics } from './foundation/Analytics/index.js';
+// @ts-expect-error
+import CustomErrorPage from 'virtual__error.jsx';
+let rscReader;
+const cache = new Map();
+// Hydrate an SSR response from <meta> tags placed in the DOM.
+const flightChunks = [];
+const FLIGHT_ATTRIBUTE = 'data-flight';
+const requestIdleCallbackHydrogen = (typeof self !== 'undefined' &&
+    self.requestIdleCallback &&
+    self.requestIdleCallback.bind(window)) ||
+    function (cb) {
+        const start = Date.now();
+        return setTimeout(function () {
+            cb({
+                didTimeout: false,
+                timeRemaining() {
+                    return Math.max(0, 50 - (Date.now() - start));
+                },
+            });
+        }, 1);
+    };
+function addElementToFlightChunks(el) {
+    // We don't need to decode, because `.getAttribute` already decodes
+    const chunk = el.getAttribute(FLIGHT_ATTRIBUTE);
+    if (chunk) {
+        flightChunks.push(chunk);
+    }
+}
+// Get initial payload
+document
+    .querySelectorAll('[' + FLIGHT_ATTRIBUTE + ']')
+    .forEach(addElementToFlightChunks);
+// Create a mutation observer on the document to detect when new
+// <meta data-flight> tags are added, and add them to the array.
+const observer = new MutationObserver((mutations) => {
+    mutations.forEach((mutation) => {
+        mutation.addedNodes.forEach((node) => {
+            if (node instanceof HTMLElement &&
+                node.tagName === 'META' &&
+                node.hasAttribute(FLIGHT_ATTRIBUTE)) {
+                addElementToFlightChunks(node);
+            }
+        });
+    });
+});
+observer.observe(document.documentElement, {
+    childList: true,
+    subtree: true,
+});
+if (flightChunks.length > 0) {
+    const contentLoaded = new Promise((resolve) => document.addEventListener('DOMContentLoaded', resolve));
+    try {
+        rscReader = new ReadableStream({
+            start(controller) {
+                const encoder = new TextEncoder();
+                const write = (chunk) => {
+                    controller.enqueue(encoder.encode(chunk));
+                    return 0;
+                };
+                flightChunks.forEach(write);
+                flightChunks.push = write;
+                contentLoaded.then(() => {
+                    controller.close();
+                    observer.disconnect();
+                });
+            },
+        });
+    }
+    catch (_) {
+        // Old browser, will try a new hydration request later
+    }
+}
+const renderHydrogen = async (ClientWrapper) => {
+    const root = document.getElementById('root');
+    if (!root) {
+        console.error(`Could not find a root element <div id="root"></div> to render.`);
+        return;
+    }
+    if (import.meta.hot) {
+        import.meta.hot.on('hydrogen-browser-console', ({ type, data }) => {
+            if (type === 'warn') {
+                console.warn(data);
+            }
+        });
+    }
+    let config;
+    try {
+        config = JSON.parse(root.dataset.clientConfig ?? '{}');
+    }
+    catch (error) {
+        config = {};
+        if (__HYDROGEN_DEV__) {
+            console.warn('Could not parse client configuration in browser', error.message);
+        }
+    }
+    const RootComponent = 
+    // Default to StrictMode on, unless explicitly turned off
+    config.strictMode !== false ? StrictMode : Fragment;
+    // Fixes hydration in `useId`: https://github.com/Shopify/hydrogen/issues/1589
+    const ServerRequestProviderMock = () => null;
+    requestIdleCallbackHydrogen(() => {
+        startTransition(() => {
+            hydrateRoot(root, React.createElement(RootComponent, null,
+                React.createElement(ServerRequestProviderMock, null),
+                React.createElement(ErrorBoundary, { FallbackComponent: CustomErrorPage
+                        ? ({ error }) => (React.createElement(CustomErrorWrapper, { error: error, errorPage: CustomErrorPage }))
+                        : DefaultError },
+                    React.createElement(Suspense, { fallback: null },
+                        React.createElement(Content, { clientWrapper: ClientWrapper })))));
+        });
+    });
+};
+export default renderHydrogen;
+function Content({ clientWrapper: ClientWrapper = ({ children }) => children, }) {
+    const [serverProps, setServerProps] = useState({
+        pathname: window.location.pathname,
+        search: window.location.search,
+    });
+    const [rscResponseFromApiRoute, setRscResponseFromApiRoute] = useState(null);
+    const response = useServerResponse(serverProps, rscResponseFromApiRoute);
+    useEffect(() => {
+        // If server props ever change, then use a fresh
+        // _rsc request and ignore any response from API routes.
+        setRscResponseFromApiRoute(null);
+    }, [serverProps]);
+    return (React.createElement(ServerPropsProvider, { initialServerProps: serverProps, setServerPropsForRsc: setServerProps, setRscResponseFromApiRoute: setRscResponseFromApiRoute },
+        React.createElement(ClientWrapper, null, response.readRoot())));
+}
+function CustomErrorWrapper({ error, errorPage, }) {
+    const Error = React.lazy(errorPage);
+    return (React.createElement(ErrorBoundary, { FallbackComponent: ({ error: errorRenderingCustomPage }) => {
+            if (import.meta.env.DEV) {
+                console.error('Error rendering custom error page:\n' + errorRenderingCustomPage);
+            }
+            return React.createElement(DefaultError, { error: error });
+        } },
+        React.createElement(Suspense, { fallback: null },
+            React.createElement(Error, { error: error }))));
+}
+function DefaultError({ error }) {
+    return (React.createElement("div", { style: {
+            padding: '2em',
+            textAlign: 'center',
+        } },
+        React.createElement("h1", { style: { fontSize: '2em', marginBottom: '1em', fontWeight: 'bold' } }, "Something's wrong here..."),
+        React.createElement("div", { style: { fontSize: '1.1em' } },
+            React.createElement("p", null, "We found an error while loading this page."),
+            React.createElement("p", null,
+                "Please, refresh or go back to the",
+                ' ',
+                React.createElement("a", { href: "/", style: { textDecoration: 'underline' } }, "home page"),
+                "."))));
+}
+function useServerResponse(state, apiRouteRscResponse) {
+    const key = JSON.stringify(state);
+    if (apiRouteRscResponse) {
+        cache.clear();
+        cache.set(apiRouteRscResponse.url, apiRouteRscResponse.response);
+        return apiRouteRscResponse.response;
+    }
+    let response = cache.get(key);
+    if (response) {
+        return response;
+    }
+    if (rscReader) {
+        // The flight response was inlined during SSR, use it directly.
+        response = createFromReadableStream(rscReader);
+        rscReader = null;
+    }
+    else {
+        if (
+        /* @ts-ignore */
+        window.BOOMR &&
+            /* @ts-ignore */
+            window.BOOMR.plugins &&
+            /* @ts-ignore */
+            window.BOOMR.plugins.Hydrogen) {
+            /* @ts-ignore */
+            window.BOOMR.plugins.Hydrogen.trackSubPageLoadPerformance();
+        }
+        ClientAnalytics.resetPageAnalyticsData();
+        // Request a new flight response.
+        response = createFromFetch(fetch(`${RSC_PATHNAME}?state=` + encodeURIComponent(key)));
+    }
+    cache.clear();
+    cache.set(key, response);
+    return response;
+}
diff --git a/dist/dist/esnext/entry-server.d.ts b/dist/dist/esnext/entry-server.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..be6585cb95a6f68d14729ee446e34ee28e774b9a
--- /dev/null
+++ b/dist/dist/esnext/entry-server.d.ts
@@ -0,0 +1,6 @@
+import type { RequestHandler } from './types.js';
+declare global {
+    var __HYDROGEN_WORKER__: boolean;
+}
+export declare const renderHydrogen: (App: any) => RequestHandler;
+export default renderHydrogen;
diff --git a/dist/dist/esnext/entry-server.js b/dist/dist/esnext/entry-server.js
new file mode 100644
index 0000000000000000000000000000000000000000..0a8c1f8f4de5280d56d274c508ffcf0ff9c22276
--- /dev/null
+++ b/dist/dist/esnext/entry-server.js
@@ -0,0 +1,633 @@
+import React, { Suspense } from 'react';
+import { logServerResponse, logCacheControlHeaders, logQueryTimings, getLoggerWithContext, setLogger, } from './utilities/log/index.js';
+import { getErrorMarkup } from './utilities/error.js';
+import { Html, applyHtmlHead } from './foundation/Html/Html.js';
+import { HydrogenResponse } from './foundation/HydrogenResponse/HydrogenResponse.server.js';
+import { HydrogenRequest } from './foundation/HydrogenRequest/HydrogenRequest.server.js';
+import { preloadRequestCacheData, ServerRequestProvider, } from './foundation/ServerRequestProvider/index.js';
+import { getApiRouteFromURL, renderApiRoute, getApiRoutes, } from './utilities/apiRoutes.js';
+import { ServerPropsProvider } from './foundation/ServerPropsProvider/index.js';
+import { isBotUA } from './utilities/bot-ua.js';
+import { getCache, setCache } from './foundation/runtime.js';
+import { ssrRenderToPipeableStream, ssrRenderToReadableStream, rscRenderToReadableStream, createFromReadableStream, bufferReadableStream, } from './streaming.server.js';
+import { getTemplate } from './utilities/template.js';
+import { Analytics } from './foundation/Analytics/Analytics.server.js';
+import { DevTools } from './foundation/DevTools/DevTools.server.js';
+import { getSyncSessionApi } from './foundation/session/session.js';
+import { parseJSON } from './utilities/parse.js';
+import { htmlEncode } from './utilities/index.js';
+import { splitCookiesString } from 'set-cookie-parser';
+import { deleteItemFromCache, getItemFromCache, isStale, setItemInCache, } from './foundation/Cache/cache.js';
+import { CacheShort, NO_STORE } from './foundation/Cache/strategies/index.js';
+import { getBuiltInRoute } from './foundation/BuiltInRoutes/BuiltInRoutes.js';
+import { FORM_REDIRECT_COOKIE } from './constants.js';
+// Importing 'stream' directly breaks Vite resolve
+// when building for workers, even though this code
+// does not run in a worker. Looks like tree-shaking
+// kicks in after the import analysis/bundle.
+// @ts-ignore
+import stream from 'virtual__stream';
+const PassThrough = stream.PassThrough;
+const DOCTYPE = '<!DOCTYPE html>';
+const CONTENT_TYPE = 'Content-Type';
+const HTML_CONTENT_TYPE = 'text/html; charset=UTF-8';
+export const renderHydrogen = (App) => {
+    const handleRequest = async function (rawRequest, options) {
+        const { cache, context, buyerIpHeader, headers } = options;
+        const request = new HydrogenRequest(rawRequest);
+        const url = new URL(request.url);
+        let sessionApi = options.sessionApi;
+        const { default: importedConfig } = await import(
+        // @ts-ignore
+        'virtual__hydrogen.config.ts');
+        const inlineHydrogenConfig = typeof importedConfig === 'function' ? importedConfig() : importedConfig;
+        const { default: hydrogenRoutes } = await import(
+        // @ts-ignore
+        'virtual__hydrogen-routes.server.jsx');
+        const hydrogenConfig = {
+            ...inlineHydrogenConfig,
+            routes: hydrogenRoutes,
+        };
+        request.ctx.hydrogenConfig = hydrogenConfig;
+        request.ctx.buyerIpHeader = buyerIpHeader;
+        setLogger(hydrogenConfig.logger);
+        const log = getLoggerWithContext(request);
+        const response = new HydrogenResponse(request.url, null, {
+            headers: headers || {},
+        });
+        if (request.cookies.get(FORM_REDIRECT_COOKIE)) {
+            response.headers.set('SET-COOKIE', `${FORM_REDIRECT_COOKIE}=`);
+            response.doNotStream();
+        }
+        if (hydrogenConfig.poweredByHeader ?? true) {
+            // If undefined in the config, then always show the header
+            response.headers.set('powered-by', 'Shopify-Hydrogen');
+        }
+        sessionApi ??= hydrogenConfig.session?.(log);
+        request.ctx.session = getSyncSessionApi(request, response, log, sessionApi);
+        /**
+         * Inject the cache & context into the module loader so we can pull it out for subrequests.
+         */
+        request.ctx.runtime = context;
+        setCache(cache);
+        const builtInRouteResource = getBuiltInRoute(url);
+        if (builtInRouteResource) {
+            const apiResponse = await renderApiRoute(request, {
+                resource: builtInRouteResource,
+                params: {},
+                hasServerComponent: false,
+            }, hydrogenConfig, {
+                session: sessionApi,
+                suppressLog: true,
+            });
+            return apiResponse instanceof Request
+                ? handleRequest(apiResponse, {
+                    ...options,
+                    sessionApi,
+                    headers: apiResponse.headers,
+                })
+                : apiResponse;
+        }
+        // Check if we have cached response
+        if (cache) {
+            const cachedResponse = await getItemFromCache(request.cacheKey());
+            if (cachedResponse) {
+                if (isStale(request, cachedResponse)) {
+                    const lockCacheKey = request.cacheKey(true);
+                    const staleWhileRevalidatePromise = getItemFromCache(lockCacheKey).then(async (lockExists) => {
+                        if (lockExists)
+                            return;
+                        try {
+                            // Don't stream when creating a response for cache
+                            response.doNotStream();
+                            await setItemInCache(lockCacheKey, new Response(null), CacheShort({
+                                maxAge: 10,
+                            }));
+                            await processRequest(handleRequest, App, url, request, sessionApi, options, response, hydrogenConfig, true);
+                            response.markAsSent();
+                        }
+                        catch (e) {
+                            log.error('Cache revalidate error', e);
+                        }
+                    });
+                    // Asynchronously wait for it in workers
+                    request.ctx.runtime?.waitUntil?.(staleWhileRevalidatePromise);
+                }
+                return cachedResponse;
+            }
+        }
+        const result = await processRequest(handleRequest, App, url, request, sessionApi, options, response, hydrogenConfig);
+        response.markAsSent();
+        return result;
+    };
+    if (__HYDROGEN_WORKER__)
+        return handleRequest;
+    return ((rawRequest, options) => handleFetchResponseInNode(handleRequest(rawRequest, options), options.streamableResponse));
+};
+async function processRequest(handleRequest, App, url, request, sessionApi, options, response, hydrogenConfig, revalidate = false) {
+    const { dev, nonce, indexTemplate, streamableResponse: nodeResponse } = options;
+    const log = getLoggerWithContext(request);
+    const isRSCRequest = request.isRscRequest();
+    const apiRoute = !isRSCRequest && getApiRoute(url, hydrogenConfig.routes);
+    // The API Route might have a default export, making it also a server component
+    // If it does, only render the API route if the request method is GET
+    if (apiRoute && (!apiRoute.hasServerComponent || request.method !== 'GET')) {
+        const apiResponse = await renderApiRoute(request, apiRoute, hydrogenConfig, {
+            session: sessionApi,
+        });
+        return apiResponse instanceof Request
+            ? handleRequest(apiResponse, {
+                ...options,
+                sessionApi,
+                headers: apiResponse.headers,
+            })
+            : apiResponse;
+    }
+    const state = isRSCRequest
+        ? parseJSON(decodeURIComponent(url.searchParams.get('state') || '{}'))
+        : {
+            pathname: decodeURIComponent(url.pathname),
+            search: decodeURIComponent(url.search),
+        };
+    const rsc = runRSC({ App, state, log, request, response });
+    if (isRSCRequest) {
+        const buffered = await bufferReadableStream(rsc.readable.getReader());
+        const rscDidError = !!rsc.didError();
+        postRequestTasks('rsc', rscDidError ? 500 : 200, request, response, rscDidError);
+        if (rscDidError) {
+            response.headers.set('cache-control', response.cacheControlHeader);
+            cacheResponse(response, request, [buffered], revalidate);
+        }
+        return new Response(buffered, {
+            headers: response.headers,
+        });
+    }
+    if (isBotUA(url, request.headers.get('user-agent'))) {
+        response.doNotStream();
+    }
+    return runSSR({
+        log,
+        dev,
+        rsc,
+        nonce,
+        state,
+        request,
+        response,
+        nodeResponse,
+        revalidate,
+        template: await getTemplate(indexTemplate, url),
+    });
+}
+function getApiRoute(url, routes) {
+    const apiRoutes = getApiRoutes(routes);
+    return getApiRouteFromURL(url, apiRoutes);
+}
+function assembleHtml({ ssrHtml, rscPayload, request, template, }) {
+    let html = applyHtmlHead(ssrHtml, request.ctx.head, template);
+    if (rscPayload) {
+        html = html.replace('</body>', 
+        // This must be a function to avoid replacing
+        // special patterns like `$1` in `String.replace`.
+        () => flightContainer(rscPayload) + '</body>');
+    }
+    return html;
+}
+/**
+ * Run the SSR/Fizz part of the App. If streaming is disabled,
+ * this buffers the output and applies SEO enhancements.
+ */
+async function runSSR({ rsc, state, request, response, nodeResponse, nonce, dev, log, revalidate, template: { raw: template, noScriptTemplate, bootstrapModules, bootstrapScripts, linkHeader, }, }) {
+    let ssrDidError;
+    const didError = () => rsc.didError() ?? ssrDidError;
+    const [rscReadableForFizz, rscReadableForFlight] = rsc.readable.tee();
+    const rscResponse = createFromReadableStream(rscReadableForFizz);
+    const RscConsumer = () => rscResponse.readRoot();
+    const AppSSR = (React.createElement(Html, { template: response.canStream() ? noScriptTemplate : template, hydrogenConfig: request.ctx.hydrogenConfig },
+        React.createElement(ServerRequestProvider, { request: request },
+            React.createElement(ServerPropsProvider, { initialServerProps: state, setServerPropsForRsc: () => { }, setRscResponseFromApiRoute: () => { } },
+                React.createElement(Suspense, { fallback: null },
+                    React.createElement(RscConsumer, null))))));
+    if (linkHeader) {
+        const existingLinkHeader = response.headers.get('Link');
+        response.headers.set('Link', existingLinkHeader ? existingLinkHeader + ', ' + linkHeader : linkHeader);
+    }
+    log.trace('start ssr');
+    const rscReadable = response.canStream()
+        ? new ReadableStream({
+            start(controller) {
+                log.trace('rsc start chunks');
+                const encoder = new TextEncoder();
+                bufferReadableStream(rscReadableForFlight.getReader(), (chunk) => {
+                    const metaTag = flightContainer(chunk);
+                    controller.enqueue(encoder.encode(metaTag));
+                }).then(() => {
+                    log.trace('rsc finish chunks');
+                    return controller.close();
+                });
+            },
+        })
+        : rscReadableForFlight;
+    if (__HYDROGEN_WORKER__) {
+        const encoder = new TextEncoder();
+        const transform = new TransformStream();
+        const writable = transform.writable.getWriter();
+        const responseOptions = {};
+        const savedChunks = tagOnWrite(writable);
+        let ssrReadable;
+        try {
+            ssrReadable = await ssrRenderToReadableStream(AppSSR, {
+                nonce,
+                bootstrapScripts,
+                bootstrapModules,
+                onError(error) {
+                    ssrDidError = error;
+                    if (dev && !writable.closed && !!responseOptions.status) {
+                        writable.write(getErrorMarkup(error));
+                    }
+                    log.error(error);
+                },
+            });
+        }
+        catch (error) {
+            log.error(error);
+            return new Response(template + (dev ? getErrorMarkup(error) : ''), {
+                status: 500,
+                headers: { [CONTENT_TYPE]: HTML_CONTENT_TYPE },
+            });
+        }
+        if (response.canStream())
+            log.trace('worker ready to stream');
+        ssrReadable.allReady.then(() => log.trace('worker complete ssr'));
+        const prepareForStreaming = () => {
+            Object.assign(responseOptions, getResponseOptions(response, didError()));
+            if (responseOptions.status >= 400) {
+                responseOptions.headers.set('cache-control', 'no-store');
+            }
+            else {
+                /**
+                 * TODO: This assumes `response.cache()` has been called _before_ any
+                 * queries which might be caught behind Suspense. Clarify this or add
+                 * additional checks downstream?
+                 */
+                /**
+                 * TODO: Also add `Vary` headers for `accept-language` and any other keys
+                 * we want to shard our full-page cache for all Hydrogen storefronts.
+                 */
+                responseOptions.headers.set('cache-control', response.cacheControlHeader);
+            }
+            if (isRedirect(responseOptions)) {
+                return false;
+            }
+            responseOptions.headers.set(CONTENT_TYPE, HTML_CONTENT_TYPE);
+            writable.write(encoder.encode(DOCTYPE));
+            const error = didError();
+            if (error) {
+                // This error was delayed until the headers were properly sent.
+                writable.write(encoder.encode(dev ? getErrorMarkup(error) : template));
+            }
+            return true;
+        };
+        const shouldFlushBody = response.canStream()
+            ? prepareForStreaming()
+            : await ssrReadable.allReady.then(prepareForStreaming);
+        if (shouldFlushBody) {
+            let bufferedSsr = '';
+            let isPendingSsrWrite = false;
+            const writingSSR = bufferReadableStream(ssrReadable.getReader(), response.canStream()
+                ? (chunk) => {
+                    bufferedSsr += chunk;
+                    if (!isPendingSsrWrite) {
+                        isPendingSsrWrite = true;
+                        setTimeout(() => {
+                            isPendingSsrWrite = false;
+                            // React can write fractional chunks synchronously.
+                            // This timeout ensures we only write full HTML tags
+                            // in order to allow RSC writing concurrently.
+                            if (bufferedSsr) {
+                                writable.write(encoder.encode(bufferedSsr));
+                                bufferedSsr = '';
+                            }
+                        }, 0);
+                    }
+                }
+                : undefined);
+            const writingRSC = bufferReadableStream(rscReadable.getReader(), response.canStream()
+                ? (scriptTag) => writable.write(encoder.encode(scriptTag))
+                : undefined);
+            Promise.all([writingSSR, writingRSC]).then(([ssrHtml, rscPayload]) => {
+                if (!response.canStream()) {
+                    const html = assembleHtml({ ssrHtml, rscPayload, request, template });
+                    writable.write(encoder.encode(html));
+                }
+                // Last SSR write might be pending, delay closing the writable one tick
+                setTimeout(() => {
+                    writable.close();
+                    postRequestTasks('str', responseOptions.status, request, response, !!didError());
+                    response.status = responseOptions.status;
+                    cacheResponse(response, request, savedChunks, revalidate);
+                }, 0);
+            });
+        }
+        else {
+            // Redirects do not write body
+            writable.close();
+            postRequestTasks('str', responseOptions.status, request, response, !!didError());
+        }
+        if (response.canStream()) {
+            return new Response(transform.readable, responseOptions);
+        }
+        const bufferedBody = await bufferReadableStream(transform.readable.getReader());
+        return new Response(bufferedBody, responseOptions);
+    }
+    else if (nodeResponse) {
+        const savedChunks = tagOnWrite(nodeResponse);
+        nodeResponse.on('finish', () => {
+            response.status = nodeResponse.statusCode;
+            cacheResponse(response, request, savedChunks, revalidate);
+        });
+        const { pipe } = ssrRenderToPipeableStream(AppSSR, {
+            nonce,
+            bootstrapScripts,
+            bootstrapModules,
+            onShellReady() {
+                log.trace('node ready to stream');
+                /**
+                 * TODO: This assumes `response.cache()` has been called _before_ any
+                 * queries which might be caught behind Suspense. Clarify this or add
+                 * additional checks downstream?
+                 */
+                writeHeadToNodeResponse(nodeResponse, response, log, didError());
+                if (isRedirect(nodeResponse)) {
+                    // Return redirects early without further rendering/streaming
+                    return nodeResponse.end();
+                }
+                if (!response.canStream())
+                    return;
+                startWritingToNodeResponse(nodeResponse, dev ? didError() : undefined);
+                setTimeout(() => {
+                    log.trace('node pipe response');
+                    if (!nodeResponse.writableEnded)
+                        pipe(nodeResponse);
+                }, 0);
+                bufferReadableStream(rscReadable.getReader(), (chunk) => {
+                    log.trace('rsc chunk');
+                    if (!nodeResponse.writableEnded)
+                        nodeResponse.write(chunk);
+                });
+            },
+            async onAllReady() {
+                log.trace('node complete ssr');
+                if (!revalidate &&
+                    (response.canStream() || nodeResponse.writableEnded)) {
+                    postRequestTasks('str', nodeResponse.statusCode, request, response, !!didError());
+                    return;
+                }
+                writeHeadToNodeResponse(nodeResponse, response, log, didError());
+                if (isRedirect(nodeResponse)) {
+                    // Redirects found after any async code
+                    return nodeResponse.end();
+                }
+                const bufferedResponse = new PassThrough();
+                const bufferedRscPromise = bufferReadableStream(rscReadable.getReader());
+                let ssrHtml = '';
+                bufferedResponse.on('data', (chunk) => (ssrHtml += chunk.toString()));
+                bufferedResponse.once('error', (error) => (ssrDidError = error));
+                bufferedResponse.once('end', async () => {
+                    const rscPayload = await bufferedRscPromise;
+                    const error = didError();
+                    startWritingToNodeResponse(nodeResponse, dev ? error : undefined);
+                    let html = template;
+                    if (!error) {
+                        html = assembleHtml({ ssrHtml, rscPayload, request, template });
+                    }
+                    postRequestTasks('ssr', nodeResponse.statusCode, request, response, !!didError());
+                    if (!nodeResponse.writableEnded) {
+                        nodeResponse.write(html);
+                        nodeResponse.end();
+                    }
+                });
+                pipe(bufferedResponse);
+            },
+            onShellError(error) {
+                log.error(error);
+                if (!nodeResponse.writableEnded) {
+                    writeHeadToNodeResponse(nodeResponse, response, log, error);
+                    startWritingToNodeResponse(nodeResponse, dev ? error : undefined);
+                    nodeResponse.write(template);
+                    nodeResponse.end();
+                }
+            },
+            onError(error) {
+                if (error.message?.includes('stream closed early')) {
+                    // This seems to happen when Fizz is still streaming
+                    // but nodeResponse has been closed by the browser.
+                    // This is common in tests and during development
+                    // due to frequent page refresh.
+                    return;
+                }
+                ssrDidError = error;
+                if (dev && nodeResponse.headersSent && !nodeResponse.writableEnded) {
+                    // Calling write would flush headers automatically.
+                    // Delay this error until headers are properly sent.
+                    nodeResponse.write(getErrorMarkup(error));
+                }
+                log.error(error);
+            },
+        });
+    }
+}
+/**
+ * Run the RSC/Flight part of the App
+ */
+function runRSC({ App, state, log, request, response }) {
+    const serverProps = { ...state, request, response, log };
+    request.ctx.router.serverProps = serverProps;
+    preloadRequestCacheData(request);
+    const AppRSC = (React.createElement(ServerRequestProvider, { request: request },
+        React.createElement(App, { ...serverProps }),
+        React.createElement(Suspense, { fallback: null },
+            React.createElement(Analytics, null)),
+        request.ctx.hydrogenConfig?.__EXPERIMENTAL__devTools && (React.createElement(Suspense, { fallback: null },
+            React.createElement(DevTools, null)))));
+    let rscDidError;
+    const rscReadable = rscRenderToReadableStream(AppRSC, {
+        onError(e) {
+            rscDidError = e;
+            log.error(e);
+        },
+    });
+    return { readable: rscReadable, didError: () => rscDidError };
+}
+export default renderHydrogen;
+function startWritingToNodeResponse(nodeResponse, error) {
+    if (nodeResponse.writableEnded)
+        return;
+    if (!nodeResponse.headersSent) {
+        nodeResponse.setHeader(CONTENT_TYPE, HTML_CONTENT_TYPE);
+        nodeResponse.write(DOCTYPE);
+    }
+    if (error) {
+        // This error was delayed until the headers were properly sent.
+        nodeResponse.write(getErrorMarkup(error));
+    }
+}
+function getResponseOptions({ headers, status, statusText }, error) {
+    const responseInit = {
+        headers,
+        status: error ? 500 : status,
+    };
+    if (!error && statusText) {
+        responseInit.statusText = statusText;
+    }
+    return responseInit;
+}
+function writeHeadToNodeResponse(nodeResponse, componentResponse, log, error) {
+    if (nodeResponse.headersSent)
+        return;
+    log.trace('writeHeadToNodeResponse');
+    const { headers, status, statusText } = getResponseOptions(componentResponse, error);
+    if (status >= 400) {
+        nodeResponse.setHeader('cache-control', 'no-store');
+    }
+    else {
+        /**
+         * TODO: Also add `Vary` headers for `accept-language` and any other keys
+         * we want to shard our full-page cache for all Hydrogen storefronts.
+         */
+        nodeResponse.setHeader('cache-control', componentResponse.cacheControlHeader);
+    }
+    nodeResponse.statusCode = status;
+    if (statusText) {
+        nodeResponse.statusMessage = statusText;
+    }
+    setNodeHeaders(headers, nodeResponse);
+}
+function isRedirect(response) {
+    const status = response.status ?? response.statusCode ?? 0;
+    return status >= 300 && status < 400;
+}
+function flightContainer(chunk) {
+    return `<meta data-flight="${htmlEncode(chunk)}" />`;
+}
+function postRequestTasks(type, status, request, response, didError) {
+    logServerResponse(type, request, status, didError);
+    logCacheControlHeaders(type, request, response);
+    logQueryTimings(type, request);
+    request.savePreloadQueries();
+}
+/**
+ * Ensure Node.js environments handle the fetch Response correctly.
+ */
+function handleFetchResponseInNode(fetchResponsePromise, nodeResponse) {
+    if (nodeResponse) {
+        fetchResponsePromise.then((response) => {
+            if (!response || nodeResponse.writableEnded)
+                return;
+            setNodeHeaders(response.headers, nodeResponse);
+            nodeResponse.statusCode = response.status;
+            if (response.body) {
+                if (response.body instanceof ReadableStream) {
+                    bufferReadableStream(response.body.getReader(), (chunk) => {
+                        nodeResponse.write(chunk);
+                    }).then(() => nodeResponse.end());
+                }
+                else {
+                    nodeResponse.write(response.body);
+                    nodeResponse.end();
+                }
+            }
+            else {
+                nodeResponse.end();
+            }
+        });
+    }
+    return fetchResponsePromise;
+}
+/**
+ * Convert Headers to outgoing Node.js headers.
+ * Specifically, parse set-cookie headers to split them properly as separate
+ * `set-cookie` headers rather than a single, combined header.
+ */
+function setNodeHeaders(headers, nodeResponse) {
+    for (const [key, value] of headers.entries()) {
+        if (key.toLowerCase() === 'set-cookie') {
+            nodeResponse.setHeader(key, splitCookiesString(value));
+        }
+        else {
+            nodeResponse.setHeader(key, value);
+        }
+    }
+}
+function tagOnWrite(response) {
+    const originalWrite = response.write;
+    const decoder = new TextDecoder();
+    const savedChunks = [];
+    response.write = (arg) => {
+        if (arg instanceof Uint8Array) {
+            savedChunks.push(decoder.decode(arg));
+        }
+        else {
+            savedChunks.push(arg);
+        }
+        // @ts-ignore
+        return originalWrite.apply(response, [arg]);
+    };
+    return savedChunks;
+}
+async function cacheResponse(response, request, chunks, revalidate) {
+    const cache = getCache();
+    /**
+     * Only full page cache on cachable responses where response
+     *
+     * - have content to cache
+     * - have status 200
+     * - does not have no-store on cache-control header
+     * - does not have set-cookie header
+     * - is a GET request
+     * - does not have a session or does not have an active customer access token
+     */
+    if (cache &&
+        chunks.length > 0 &&
+        response.status === 200 &&
+        response.cache().mode !== NO_STORE &&
+        !response.headers.has('Set-Cookie') &&
+        /get/i.test(request.method) &&
+        !sessionHasCustomerAccessToken(request)) {
+        if (revalidate) {
+            await saveCacheResponse(response, request, chunks);
+        }
+        else {
+            const cachePutPromise = Promise.resolve(true).then(() => saveCacheResponse(response, request, chunks));
+            request.ctx.runtime?.waitUntil?.(cachePutPromise);
+        }
+    }
+}
+function sessionHasCustomerAccessToken(request) {
+    const session = request.ctx.session;
+    // Need to wrap this in a try catch because session.get can
+    // throw a promise if it is not ready
+    try {
+        const sessionData = session?.get();
+        return sessionData && sessionData['customerAccessToken'];
+    }
+    catch (error) {
+        return false;
+    }
+}
+async function saveCacheResponse(response, request, chunks) {
+    const cache = getCache();
+    if (cache && chunks.length > 0) {
+        const { headers, status, statusText } = getResponseOptions(response);
+        headers.set('cache-control', response.cacheControlHeader);
+        const currentHeader = headers.get('Content-Type');
+        if (!currentHeader && !request.isRscRequest()) {
+            headers.set('Content-Type', HTML_CONTENT_TYPE);
+        }
+        await setItemInCache(request.cacheKey(), new Response(chunks.join(''), {
+            status,
+            statusText,
+            headers,
+        }), response.cache());
+        deleteItemFromCache(request.cacheKey(true));
+    }
+}
diff --git a/dist/dist/esnext/experimental.d.ts b/dist/dist/esnext/experimental.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5ed3f1e7f2478f336d9c401db43a346aa8b4edeb
--- /dev/null
+++ b/dist/dist/esnext/experimental.d.ts
@@ -0,0 +1,3 @@
+export { Form } from './foundation/Form/Form.client.js';
+export { useFlashSession } from './foundation/useSession/useSession.js';
+export { CartProviderV2 } from './components/CartProvider/CartProviderV2.client.js';
diff --git a/dist/dist/esnext/experimental.js b/dist/dist/esnext/experimental.js
new file mode 100644
index 0000000000000000000000000000000000000000..5ed3f1e7f2478f336d9c401db43a346aa8b4edeb
--- /dev/null
+++ b/dist/dist/esnext/experimental.js
@@ -0,0 +1,3 @@
+export { Form } from './foundation/Form/Form.client.js';
+export { useFlashSession } from './foundation/useSession/useSession.js';
+export { CartProviderV2 } from './components/CartProvider/CartProviderV2.client.js';
diff --git a/dist/dist/esnext/foundation/Analytics/Analytics.client.d.ts b/dist/dist/esnext/foundation/Analytics/Analytics.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd664f8b7b46a73fffb639d324fd3de4c9d3edbc
--- /dev/null
+++ b/dist/dist/esnext/foundation/Analytics/Analytics.client.d.ts
@@ -0,0 +1,3 @@
+export declare function Analytics({ analyticsDataFromServer, }: {
+    analyticsDataFromServer: any;
+}): null;
diff --git a/dist/dist/esnext/foundation/Analytics/Analytics.client.js b/dist/dist/esnext/foundation/Analytics/Analytics.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..55aa8a73b495689d6bc914edf6b937c4285b9db7
--- /dev/null
+++ b/dist/dist/esnext/foundation/Analytics/Analytics.client.js
@@ -0,0 +1,30 @@
+import { useEffect } from 'react';
+import { ClientAnalytics } from './ClientAnalytics.js';
+export function Analytics({ analyticsDataFromServer, }) {
+    useEffect(() => {
+        const urlParams = new URLSearchParams(window.location.search);
+        addUTMData(urlParams, 'id');
+        addUTMData(urlParams, 'source');
+        addUTMData(urlParams, 'campaign');
+        addUTMData(urlParams, 'medium');
+        addUTMData(urlParams, 'content');
+        addUTMData(urlParams, 'term');
+        ClientAnalytics.pushToPageAnalyticsData(analyticsDataFromServer);
+        ClientAnalytics.publish(ClientAnalytics.eventNames.PAGE_VIEW, true);
+        if (analyticsDataFromServer.publishEventsOnNavigate) {
+            analyticsDataFromServer.publishEventsOnNavigate.forEach((eventName) => {
+                ClientAnalytics.publish(eventName, true);
+            });
+        }
+    }, [analyticsDataFromServer]);
+    return null;
+}
+function addUTMData(urlParams, key) {
+    if (urlParams.has(`utm_${key}`)) {
+        ClientAnalytics.pushToPageAnalyticsData({
+            utm: {
+                [key]: urlParams.get(`utm_${key}`),
+            },
+        });
+    }
+}
diff --git a/dist/dist/esnext/foundation/Analytics/Analytics.server.d.ts b/dist/dist/esnext/foundation/Analytics/Analytics.server.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..41e8a4cd81359b89a67eee8d8e10b9dee4d17cbf
--- /dev/null
+++ b/dist/dist/esnext/foundation/Analytics/Analytics.server.d.ts
@@ -0,0 +1 @@
+export declare function Analytics(): JSX.Element;
diff --git a/dist/dist/esnext/foundation/Analytics/Analytics.server.js b/dist/dist/esnext/foundation/Analytics/Analytics.server.js
new file mode 100644
index 0000000000000000000000000000000000000000..64613283ff41f5ddc3ab5e0bdc534fbb4f7df332
--- /dev/null
+++ b/dist/dist/esnext/foundation/Analytics/Analytics.server.js
@@ -0,0 +1,47 @@
+import * as React from 'react';
+import { useServerAnalytics } from './hook.js';
+import { Analytics as AnalyticsClient } from './Analytics.client.js';
+import { useServerRequest } from '../ServerRequestProvider/index.js';
+import AnalyticsErrorBoundary from '../AnalyticsErrorBoundary.client.js';
+import { wrapPromise } from '../../utilities/index.js';
+const DELAY_KEY_1 = 'analytics-delay-1';
+const DELAY_KEY_2 = 'analytics-delay-2';
+export function Analytics() {
+    const cache = useServerRequest().ctx.cache;
+    // If render cache is empty, create a 50 ms delay so that React doesn't resolve this
+    // component too early and potentially cause a mismatch in hydration
+    if (cache.size === 0 && !cache.has(DELAY_KEY_1)) {
+        analyticsDelay(cache, DELAY_KEY_1, 50);
+    }
+    // If this delay is created, execute it
+    cache.has(DELAY_KEY_1) && cache.get(DELAY_KEY_1).read();
+    // clean up this key so that it won't be saved to the preload cache
+    cache.delete(DELAY_KEY_1);
+    // Make sure all queries have returned before rendering the Analytics server component
+    cache.forEach((cacheFn) => {
+        if (cacheFn && typeof cacheFn === 'function') {
+            const result = cacheFn.call();
+            if (result instanceof Promise)
+                throw result;
+        }
+    });
+    // If all queries has returned (could be from cached queries),
+    // delay Analytic component by another 1ms (put this component
+    // to the end of the render queue) so that other scheduled
+    // render work can be processed by React's concurrent render first
+    if (cache.size > 1 && !cache.has(DELAY_KEY_2)) {
+        analyticsDelay(cache, DELAY_KEY_2, 1);
+    }
+    cache.has(DELAY_KEY_2) && cache.get(DELAY_KEY_2).read();
+    cache.delete(DELAY_KEY_2);
+    return (React.createElement(AnalyticsErrorBoundary, null,
+        React.createElement(AnalyticsClient, { analyticsDataFromServer: useServerAnalytics() })));
+}
+function analyticsDelay(cache, delayKey, delay) {
+    const delayPromise = wrapPromise(new Promise((resolve) => {
+        setTimeout(() => {
+            resolve(true);
+        }, delay);
+    }));
+    cache.set(delayKey, delayPromise);
+}
diff --git a/dist/dist/esnext/foundation/Analytics/ClientAnalytics.d.ts b/dist/dist/esnext/foundation/Analytics/ClientAnalytics.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3f3399886d8ee5f3370a17b8682836917dabdb28
--- /dev/null
+++ b/dist/dist/esnext/foundation/Analytics/ClientAnalytics.d.ts
@@ -0,0 +1,27 @@
+import type { Subscriber, SubscriberFunction } from './types.js';
+declare function pushToPageAnalyticsData(data: any): void;
+declare function getPageAnalyticsData(): any;
+declare function resetPageAnalyticsData(): void;
+declare function publish(eventname: string, guardDup?: boolean, payload?: {}): void;
+declare function subscribe(eventname: string, callbackFunction: SubscriberFunction): Subscriber;
+declare function pushToServer(init?: RequestInit, searchParam?: string): Promise<Response>;
+declare function hasSentFirstPageView(): Boolean;
+export declare const ClientAnalytics: {
+    pushToPageAnalyticsData: typeof pushToPageAnalyticsData;
+    getPageAnalyticsData: typeof getPageAnalyticsData;
+    resetPageAnalyticsData: typeof resetPageAnalyticsData;
+    publish: typeof publish;
+    subscribe: typeof subscribe;
+    pushToServer: typeof pushToServer;
+    eventNames: {
+        PAGE_VIEW: string;
+        VIEWED_PRODUCT: string;
+        ADD_TO_CART: string;
+        REMOVE_FROM_CART: string;
+        UPDATE_CART: string;
+        DISCOUNT_CODE_UPDATED: string;
+        PERFORMANCE: string;
+    };
+    hasSentFirstPageView: typeof hasSentFirstPageView;
+};
+export {};
diff --git a/dist/dist/esnext/foundation/Analytics/ClientAnalytics.js b/dist/dist/esnext/foundation/Analytics/ClientAnalytics.js
new file mode 100644
index 0000000000000000000000000000000000000000..02c39596e1c1d69a1492ba2a45815fb904dca42b
--- /dev/null
+++ b/dist/dist/esnext/foundation/Analytics/ClientAnalytics.js
@@ -0,0 +1,99 @@
+import { getNamedspacedEventname, mergeDeep } from './utils.js';
+import { eventNames } from './const.js';
+import { EVENT_PATHNAME } from '../../constants.js';
+import { META_ENV_SSR } from '../ssr-interop.js';
+const subscribers = {};
+let pageAnalyticsData = {};
+let isFirstPageViewSent = false;
+const guardDupEvents = {};
+const USAGE_ERROR = 'ClientAnalytics should only be used within the useEffect callback or event handlers';
+function isInvokedFromServer() {
+    if (META_ENV_SSR) {
+        console.warn(USAGE_ERROR);
+        return true;
+    }
+    return false;
+}
+function pushToPageAnalyticsData(data) {
+    if (isInvokedFromServer())
+        return;
+    pageAnalyticsData = mergeDeep(pageAnalyticsData, data);
+}
+function getPageAnalyticsData() {
+    if (isInvokedFromServer())
+        return;
+    return pageAnalyticsData;
+}
+function resetPageAnalyticsData() {
+    if (isInvokedFromServer())
+        return;
+    pageAnalyticsData = {};
+}
+function publish(eventname, guardDup = false, payload = {}) {
+    if (isInvokedFromServer())
+        return;
+    const namedspacedEventname = getNamedspacedEventname(eventname);
+    // De-dup events due to re-renders
+    if (guardDup) {
+        const eventGuardTimeout = guardDupEvents[namedspacedEventname];
+        if (eventGuardTimeout) {
+            clearTimeout(eventGuardTimeout);
+        }
+        const namespacedTimeout = setTimeout(() => {
+            publishEvent(namedspacedEventname, mergeDeep(pageAnalyticsData, payload));
+        }, 100);
+        guardDupEvents[namedspacedEventname] = namespacedTimeout;
+    }
+    else {
+        publishEvent(namedspacedEventname, mergeDeep(pageAnalyticsData, payload));
+    }
+}
+function publishEvent(eventname, payload) {
+    const subs = subscribers[eventname];
+    if (!isFirstPageViewSent && eventname === eventNames.PAGE_VIEW) {
+        isFirstPageViewSent = true;
+    }
+    if (subs) {
+        Object.keys(subs).forEach((key) => {
+            subs[key](payload);
+        });
+    }
+}
+function subscribe(eventname, callbackFunction) {
+    if (isInvokedFromServer())
+        return { unsubscribe: () => { } };
+    const namedspacedEventname = getNamedspacedEventname(eventname);
+    const subs = subscribers[namedspacedEventname];
+    if (!subs) {
+        subscribers[namedspacedEventname] = {};
+    }
+    const subscriberId = Date.now().toString();
+    subscribers[namedspacedEventname][subscriberId] = callbackFunction;
+    return {
+        unsubscribe: () => {
+            delete subscribers[namedspacedEventname][subscriberId];
+        },
+    };
+}
+function pushToServer(init, searchParam) {
+    return fetch(`${EVENT_PATHNAME}${searchParam ? `?${searchParam}` : ''}`, Object.assign({
+        method: 'post',
+        headers: {
+            'cache-control': 'no-cache',
+            'Content-Type': 'application/json',
+        },
+    }, init));
+}
+function hasSentFirstPageView() {
+    return isFirstPageViewSent;
+}
+export const ClientAnalytics = {
+    pushToPageAnalyticsData,
+    getPageAnalyticsData,
+    resetPageAnalyticsData,
+    publish,
+    subscribe,
+    pushToServer,
+    eventNames,
+    hasSentFirstPageView,
+};
diff --git a/dist/dist/esnext/foundation/Analytics/ServerAnalyticsRoute.d.ts b/dist/dist/esnext/foundation/Analytics/ServerAnalyticsRoute.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..392a22700ab1216f927be58e8ee82dd44b45f51c
--- /dev/null
+++ b/dist/dist/esnext/foundation/Analytics/ServerAnalyticsRoute.d.ts
@@ -0,0 +1,4 @@
+import type { ResolvedHydrogenConfig } from '../../types.js';
+export declare function ServerAnalyticsRoute(request: Request, { hydrogenConfig }: {
+    hydrogenConfig: ResolvedHydrogenConfig;
+}): Promise<Response>;
diff --git a/dist/dist/esnext/foundation/Analytics/ServerAnalyticsRoute.js b/dist/dist/esnext/foundation/Analytics/ServerAnalyticsRoute.js
new file mode 100644
index 0000000000000000000000000000000000000000..cfd5e4e47f59d94057948171a7ef32705e38f9d9
--- /dev/null
+++ b/dist/dist/esnext/foundation/Analytics/ServerAnalyticsRoute.js
@@ -0,0 +1,51 @@
+import { log } from '../../utilities/log/index.js';
+const analyticsDefaultResponse = new Response(null, {
+    status: 200,
+});
+export async function ServerAnalyticsRoute(request, { hydrogenConfig }) {
+    const serverAnalyticsConnectors = hydrogenConfig.serverAnalyticsConnectors;
+    if (!serverAnalyticsConnectors) {
+        return analyticsDefaultResponse;
+    }
+    const requestHeader = request.headers;
+    const requestUrl = request.url;
+    let analyticsPromise;
+    if (requestHeader.get('Content-Length') === '0') {
+        analyticsPromise = Promise.resolve(true)
+            .then(async () => {
+            return Promise.all(serverAnalyticsConnectors.map(async (connector) => {
+                return await connector.request(requestUrl, requestHeader);
+            }));
+        })
+            .catch((error) => {
+            log.warn('Failed to resolve server analytics (no content length): ', error);
+        });
+    }
+    else if (requestHeader.get('Content-Type') === 'application/json') {
+        analyticsPromise = Promise.resolve(request.json())
+            .then((data) => {
+            return Promise.all(serverAnalyticsConnectors.map(async (connector) => {
+                return await connector.request(requestUrl, requestHeader, data, 'json');
+            }));
+        })
+            .catch((error) => {
+            log.warn('Fail to resolve server analytics (json): ', error);
+        });
+    }
+    else {
+        analyticsPromise = Promise.resolve(request.text())
+            .then(async (data) => {
+            await serverAnalyticsConnectors.forEach(async (connector) => {
+                await connector.request(requestUrl, requestHeader, data, 'text');
+            });
+            return Promise.all(serverAnalyticsConnectors.map(async (connector) => {
+                return await connector.request(requestUrl, requestHeader, data, 'text');
+            }));
+        })
+            .catch((error) => {
+            log.warn('Failed to resolve server analytics (text): ', error);
+        });
+    }
+    await analyticsPromise;
+    return analyticsDefaultResponse;
+}
diff --git a/dist/dist/esnext/foundation/Analytics/connectors/PerformanceMetrics/PerformanceMetrics.client.d.ts b/dist/dist/esnext/foundation/Analytics/connectors/PerformanceMetrics/PerformanceMetrics.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..88f6e434f1c17356fc2fe1a901442c490b62edab
--- /dev/null
+++ b/dist/dist/esnext/foundation/Analytics/connectors/PerformanceMetrics/PerformanceMetrics.client.d.ts
@@ -0,0 +1,7 @@
+declare global {
+    interface Window {
+        BOOMR: any;
+        BOOMR_onload: any;
+    }
+}
+export declare function PerformanceMetrics(): null;
diff --git a/dist/dist/esnext/foundation/Analytics/connectors/PerformanceMetrics/PerformanceMetrics.client.js b/dist/dist/esnext/foundation/Analytics/connectors/PerformanceMetrics/PerformanceMetrics.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..ee33b8bb5b1c3c7579ca260994a8b6e8c43e4f61
--- /dev/null
+++ b/dist/dist/esnext/foundation/Analytics/connectors/PerformanceMetrics/PerformanceMetrics.client.js
@@ -0,0 +1,83 @@
+import { useEffect } from 'react';
+import { loadScript } from '../../../../utilities/load_script.js';
+import { ClientAnalytics } from '../../ClientAnalytics.js';
+import { useShop } from '../../../useShop/index.js';
+const URL = 'https://cdn.shopify.com/shopifycloud/boomerang/shopify-boomerang-hydrogen.min.js';
+export function PerformanceMetrics() {
+    const { storeDomain } = useShop();
+    useEffect(() => {
+        try {
+            (function () {
+                if (window.BOOMR &&
+                    (window.BOOMR.version || window.BOOMR.snippetExecuted)) {
+                    return;
+                }
+                // Executes only on first mount
+                window.BOOMR = window.BOOMR || {};
+                window.BOOMR.hydrogenPerformanceEvent = (data) => {
+                    const initTime = new Date().getTime();
+                    ClientAnalytics.publish(ClientAnalytics.eventNames.PERFORMANCE, true, data);
+                    const pageData = ClientAnalytics.getPageAnalyticsData();
+                    const shopId = pageData.shopify?.shopId;
+                    fetch('https://monorail-edge.shopifysvc.com/v1/produce', {
+                        method: 'post',
+                        headers: {
+                            'content-type': 'text/plain',
+                        },
+                        body: JSON.stringify({
+                            schema_id: 'hydrogen_buyer_performance/2.0',
+                            payload: {
+                                ...data,
+                                shop_id: shopId
+                                    ? shopId.substring(shopId.lastIndexOf('/') + 1)
+                                    : '',
+                            },
+                            metadata: {
+                                event_created_at_ms: initTime,
+                                event_sent_at_ms: new Date().getTime(),
+                            },
+                        }),
+                    });
+                };
+                window.BOOMR.storeDomain = storeDomain;
+                function boomerangSaveLoadTime(e) {
+                    window.BOOMR_onload = (e && e.timeStamp) || Date.now();
+                }
+                // @ts-ignore
+                function boomerangInit(e) {
+                    e.detail.BOOMR.init();
+                    e.detail.BOOMR.t_end = Date.now();
+                }
+                if (window.addEventListener) {
+                    window.addEventListener('load', boomerangSaveLoadTime, false);
+                    // @ts-ignore
+                }
+                else if (window.attachEvent) {
+                    // @ts-ignore
+                    window.attachEvent('onload', boomerangSaveLoadTime);
+                }
+                if (document.addEventListener) {
+                    document.addEventListener('onBoomerangLoaded', boomerangInit);
+                    // @ts-ignore
+                }
+                else if (document.attachEvent) {
+                    // @ts-ignore
+                    document.attachEvent('onpropertychange', function (e) {
+                        if (!e)
+                            e = event;
+                        if (e.propertyName === 'onBoomerangLoaded')
+                            boomerangInit(e);
+                    });
+                }
+            })();
+            loadScript(URL).catch(() => {
+                // ignore if boomerang doesn't load
+                // most likely because of an ad blocker
+            });
+        }
+        catch (err) {
+            // Do nothing
+        }
+    }, [storeDomain]);
+    return null;
+}
diff --git a/dist/dist/esnext/foundation/Analytics/connectors/PerformanceMetrics/PerformanceMetricsDebug.client.d.ts b/dist/dist/esnext/foundation/Analytics/connectors/PerformanceMetrics/PerformanceMetricsDebug.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..675663b80a11237733dda864e85204beb60316b8
--- /dev/null
+++ b/dist/dist/esnext/foundation/Analytics/connectors/PerformanceMetrics/PerformanceMetricsDebug.client.d.ts
@@ -0,0 +1 @@
+export declare function PerformanceMetricsDebug(): null;
diff --git a/dist/dist/esnext/foundation/Analytics/connectors/PerformanceMetrics/PerformanceMetricsDebug.client.js b/dist/dist/esnext/foundation/Analytics/connectors/PerformanceMetrics/PerformanceMetricsDebug.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..83830afc2a314d478f6ee23e49b166f058cb8cd6
--- /dev/null
+++ b/dist/dist/esnext/foundation/Analytics/connectors/PerformanceMetrics/PerformanceMetricsDebug.client.js
@@ -0,0 +1,23 @@
+import { useEffect } from 'react';
+import { ClientAnalytics } from '../../ClientAnalytics.js';
+const PAD = 10;
+let isInit = false;
+export function PerformanceMetricsDebug() {
+    useEffect(() => {
+        if (!isInit) {
+            isInit = true;
+            ClientAnalytics.subscribe(ClientAnalytics.eventNames.PERFORMANCE, (data) => {
+                console.group(`Performance - ${data.page_load_type} load`);
+                logMetricIf('TTFB:', data.response_start - data.navigation_start);
+                logMetricIf('FCP:', data.first_contentful_paint);
+                logMetricIf('LCP:', data.largest_contentful_paint);
+                logMetricIf('Duration:', data.response_end - data.navigation_start);
+                console.groupEnd();
+            });
+        }
+    });
+    return null;
+}
+function logMetricIf(lable, data) {
+    data && console.log(`${lable.padEnd(PAD)}${Math.round(data)} ms`);
+}
diff --git a/dist/dist/esnext/foundation/Analytics/connectors/PerformanceMetrics/ServerAnalyticsConnector.d.ts b/dist/dist/esnext/foundation/Analytics/connectors/PerformanceMetrics/ServerAnalyticsConnector.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6d315d6da05188e19d89731fd40758371729d5a6
--- /dev/null
+++ b/dist/dist/esnext/foundation/Analytics/connectors/PerformanceMetrics/ServerAnalyticsConnector.d.ts
@@ -0,0 +1,3 @@
+export declare const PerformanceMetricsServerAnalyticsConnector: {
+    request(): Promise<any>;
+};
diff --git a/dist/dist/esnext/foundation/Analytics/connectors/PerformanceMetrics/ServerAnalyticsConnector.js b/dist/dist/esnext/foundation/Analytics/connectors/PerformanceMetrics/ServerAnalyticsConnector.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12ad7e7344bd4d0e96fde68ae15d02bc68b0811
--- /dev/null
+++ b/dist/dist/esnext/foundation/Analytics/connectors/PerformanceMetrics/ServerAnalyticsConnector.js
@@ -0,0 +1,7 @@
+import { log } from '../../../../utilities/log/index.js';
+export const PerformanceMetricsServerAnalyticsConnector = {
+    request() {
+        log.warn('PerformanceMetricsServerAnalyticsConnector has been removed - please remove its reference from hydrogen.config.js');
+        return Promise.resolve();
+    },
+};
diff --git a/dist/dist/esnext/foundation/Analytics/connectors/Shopify/ServerAnalyticsConnector.d.ts b/dist/dist/esnext/foundation/Analytics/connectors/Shopify/ServerAnalyticsConnector.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..25176e8cbe0e3864750a8fc0ce86aeb7faec982b
--- /dev/null
+++ b/dist/dist/esnext/foundation/Analytics/connectors/Shopify/ServerAnalyticsConnector.d.ts
@@ -0,0 +1,3 @@
+export declare const ShopifyServerAnalyticsConnector: {
+    request(): Promise<any>;
+};
diff --git a/dist/dist/esnext/foundation/Analytics/connectors/Shopify/ServerAnalyticsConnector.js b/dist/dist/esnext/foundation/Analytics/connectors/Shopify/ServerAnalyticsConnector.js
new file mode 100644
index 0000000000000000000000000000000000000000..7b4d50bd6b7e09401fbcd5b701fbb48e23e524c0
--- /dev/null
+++ b/dist/dist/esnext/foundation/Analytics/connectors/Shopify/ServerAnalyticsConnector.js
@@ -0,0 +1,7 @@
+import { log } from '../../../../utilities/log/index.js';
+export const ShopifyServerAnalyticsConnector = {
+    request() {
+        log.warn('ShopifyServerAnalyticsConnector has been removed - please remove its reference from hydrogen.config.js');
+        return Promise.resolve();
+    },
+};
diff --git a/dist/dist/esnext/foundation/Analytics/connectors/Shopify/ShopifyAnalytics.client.d.ts b/dist/dist/esnext/foundation/Analytics/connectors/Shopify/ShopifyAnalytics.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..516849accab529d3f1049f42d8f41fa379b68990
--- /dev/null
+++ b/dist/dist/esnext/foundation/Analytics/connectors/Shopify/ShopifyAnalytics.client.d.ts
@@ -0,0 +1,3 @@
+export declare function ShopifyAnalyticsClient({ cookieDomain }: {
+    cookieDomain: string;
+}): null;
diff --git a/dist/dist/esnext/foundation/Analytics/connectors/Shopify/ShopifyAnalytics.client.js b/dist/dist/esnext/foundation/Analytics/connectors/Shopify/ShopifyAnalytics.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..6afe741f6492e611174bce4fd6a5fe207c8816e5
--- /dev/null
+++ b/dist/dist/esnext/foundation/Analytics/connectors/Shopify/ShopifyAnalytics.client.js
@@ -0,0 +1,184 @@
+import { useEffect } from 'react';
+import { parse, stringify } from 'worktop/cookie';
+import { SHOPIFY_Y, SHOPIFY_S } from '../../../../constants.js';
+import { ClientAnalytics } from '../../ClientAnalytics.js';
+import { buildUUID, addDataIf } from './utils.js';
+const longTermLength = 60 * 60 * 24 * 360 * 2; // ~2 year expiry
+const shortTermLength = 60 * 30; // 30 mins
+const myShopifyDomain = 'myshopify.com';
+const oxygenDomain = 'myshopify.dev';
+let isInit = false;
+let microSessionCount = 0;
+export function ShopifyAnalyticsClient({ cookieDomain }) {
+    useEffect(() => {
+        try {
+            // Find Shopify cookies
+            const cookieData = parse(document.cookie);
+            const shopifyYCookie = cookieData[SHOPIFY_Y] || buildUUID();
+            const shopifySCookie = cookieData[SHOPIFY_S] || buildUUID();
+            /**
+             * Set user and session cookies and refresh the expiry time
+             */
+            updateCookie(SHOPIFY_Y, shopifyYCookie, longTermLength, cookieDomain);
+            updateCookie(SHOPIFY_S, shopifySCookie, shortTermLength, cookieDomain);
+            ClientAnalytics.pushToPageAnalyticsData({
+                shopify: {
+                    pageId: buildUUID(),
+                    userId: shopifyYCookie,
+                    sessionId: shopifySCookie,
+                },
+            });
+            microSessionCount = 0;
+            // TODO: Fix with useEvent when ready
+            // RFC: https://github.com/reactjs/rfcs/blob/useevent/text/0000-useevent.md
+            if (!isInit) {
+                isInit = true;
+                const eventNames = ClientAnalytics.eventNames;
+                ClientAnalytics.subscribe(eventNames.PAGE_VIEW, trackPageView);
+                // On a slow network, the pageview event could be already fired before
+                // we subscribed to the pageview event
+                if (ClientAnalytics.hasSentFirstPageView()) {
+                    trackPageView(ClientAnalytics.getPageAnalyticsData());
+                }
+            }
+        }
+        catch (err) {
+            // Do nothing
+        }
+    });
+    return null;
+}
+function updateCookie(cookieName, value, maxage, cookieDomain) {
+    const cookieString = stringify(cookieName, value, {
+        maxage,
+        domain: getCookieDomain(cookieDomain),
+        secure: import.meta.env.PROD,
+        samesite: 'Lax',
+        path: '/',
+    });
+    document.cookie = cookieString;
+    return cookieString;
+}
+function getCookieDomain(cookieDomain) {
+    const hostname = location.hostname;
+    if (hostname.indexOf(myShopifyDomain) !== -1) {
+        return `.${hostname.split('.').slice(-3).join('.')}`;
+    }
+    else if (hostname.indexOf(cookieDomain) !== -1) {
+        return `.${cookieDomain}`;
+    }
+    else {
+        return '';
+    }
+}
+function trackPageView(payload) {
+    microSessionCount += 1;
+    try {
+        payload &&
+            payload.shopify &&
+            sendToServer(storefrontPageViewSchema(payload));
+    }
+    catch (error) {
+        console.error(`Error Shopify analytics: ${ClientAnalytics.eventNames.PAGE_VIEW}`, error);
+    }
+}
+function storefrontPageViewSchema(payload) {
+    return {
+        schema_id: 'trekkie_storefront_page_view/1.4',
+        payload: buildStorefrontPageViewPayload(payload),
+        metadata: {
+            event_created_at_ms: Date.now(),
+        },
+    };
+}
+function buildStorefrontPageViewPayload(payload) {
+    const location = document.location;
+    const shopify = payload.shopify;
+    let formattedData = {
+        appClientId: '6167201',
+        hydrogenSubchannelId: shopify.storefrontId || '0',
+        isPersistentCookie: shopify.isPersistentCookie,
+        uniqToken: shopify.userId,
+        visitToken: shopify.sessionId,
+        microSessionId: shopify.pageId,
+        microSessionCount,
+        url: location.href,
+        path: location.pathname,
+        search: location.search,
+        referrer: document.referrer,
+        title: document.title,
+        shopId: stripGId(shopify.shopId),
+        currency: shopify.currency,
+        contentLanguage: shopify.acceptedLanguage,
+    };
+    formattedData = addDataIf({
+        isMerchantRequest: isMerchantRequest(),
+    }, formattedData);
+    formattedData = addDataIf({
+        pageType: shopify.pageType,
+    }, formattedData);
+    if (shopify.resourceId) {
+        try {
+            formattedData = addDataIf({
+                resourceType: getResourceType(shopify.resourceId),
+                resourceId: stripGId(shopify.resourceId),
+            }, formattedData);
+        }
+        catch (err) {
+            // do nothing
+        }
+    }
+    formattedData = addDataIf({
+        customerId: shopify.customerId,
+    }, formattedData);
+    return formattedData;
+}
+function isMerchantRequest() {
+    const hostname = location.hostname;
+    if (hostname.indexOf(oxygenDomain) !== -1 || hostname === 'localhost') {
+        return true;
+    }
+    return false;
+}
+function stripGId(text) {
+    return parseInt(text.substring(text.lastIndexOf('/') + 1));
+}
+function getResourceType(text) {
+    return text
+        .substring(0, text.lastIndexOf('/'))
+        .replace(/.*shopify\//, '')
+        .toLowerCase();
+}
+const BATCH_SENT_TIMEOUT = 500;
+let batchedData = [];
+let batchedTimeout;
+function sendToServer(data) {
+    batchedData.push(data);
+    if (batchedTimeout) {
+        clearTimeout(batchedTimeout);
+        batchedTimeout = null;
+    }
+    batchedTimeout = setTimeout(() => {
+        const batchedDataToBeSent = {
+            events: batchedData,
+            metadata: {
+                event_sent_at_ms: Date.now(),
+            },
+        };
+        batchedData = [];
+        batchedTimeout = null;
+        // Send to Shopify
+        try {
+            fetch('https://monorail-edge.shopifysvc.com/unstable/produce_batch', {
+                method: 'post',
+                headers: {
+                    'content-type': 'text/plain',
+                },
+                body: JSON.stringify(batchedDataToBeSent),
+            });
+        }
+        catch (error) {
+            // Do nothing
+        }
+    }, BATCH_SENT_TIMEOUT);
+}
diff --git a/dist/dist/esnext/foundation/Analytics/connectors/Shopify/ShopifyAnalytics.server.d.ts b/dist/dist/esnext/foundation/Analytics/connectors/Shopify/ShopifyAnalytics.server.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0281fb21a9529591aad9af416b61621d3f0dcdd9
--- /dev/null
+++ b/dist/dist/esnext/foundation/Analytics/connectors/Shopify/ShopifyAnalytics.server.d.ts
@@ -0,0 +1,3 @@
+export declare function ShopifyAnalytics({ cookieDomain }: {
+    cookieDomain?: string;
+}): JSX.Element;
diff --git a/dist/dist/esnext/foundation/Analytics/connectors/Shopify/ShopifyAnalytics.server.js b/dist/dist/esnext/foundation/Analytics/connectors/Shopify/ShopifyAnalytics.server.js
new file mode 100644
index 0000000000000000000000000000000000000000..80835a146e8314e751092d70ac0d0464d2970cb8
--- /dev/null
+++ b/dist/dist/esnext/foundation/Analytics/connectors/Shopify/ShopifyAnalytics.server.js
@@ -0,0 +1,43 @@
+import React from 'react';
+import { parse } from 'worktop/cookie';
+import AnalyticsErrorBoundary from '../../../AnalyticsErrorBoundary.client.js';
+import { useServerRequest } from '../../../ServerRequestProvider/index.js';
+import { useServerAnalytics } from '../../hook.js';
+import { useShop } from '../../../useShop/index.js';
+import { ShopifyAnalyticsClient } from './ShopifyAnalytics.client.js';
+import { useShopQuery } from '../../../../hooks/useShopQuery/index.js';
+import { CacheLong } from '../../../Cache/strategies/index.js';
+import { gql } from '../../../../utilities/graphql-tag.js';
+import { SHOPIFY_Y, SHOPIFY_S } from '../../../../constants.js';
+export function ShopifyAnalytics({ cookieDomain }) {
+    const { storeDomain, storefrontId } = useShop();
+    const request = useServerRequest();
+    const cookies = parse(request.headers.get('Cookie') || '');
+    const domain = cookieDomain || storeDomain;
+    const { data: { shop: { id, paymentSettings: { currencyCode }, }, }, } = useShopQuery({
+        query: SHOP_QUERY,
+        cache: CacheLong(),
+        preload: '*',
+    });
+    useServerAnalytics({
+        shopify: {
+            shopId: id,
+            currency: currencyCode,
+            storefrontId,
+            acceptedLanguage: request.headers.get('Accept-Language')?.replace(/-.*/, '') || 'en',
+            isPersistentCookie: !!cookies[SHOPIFY_S] || !!cookies[SHOPIFY_Y],
+        },
+    });
+    return (React.createElement(AnalyticsErrorBoundary, null,
+        React.createElement(ShopifyAnalyticsClient, { cookieDomain: domain })));
+}
+const SHOP_QUERY = gql `
+  query shopAnalyticsInfo {
+    shop {
+      id
+      paymentSettings {
+        currencyCode
+      }
+    }
+  }
+`;
diff --git a/dist/dist/esnext/foundation/Analytics/connectors/Shopify/const.d.ts b/dist/dist/esnext/foundation/Analytics/connectors/Shopify/const.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7e16f60c4f1db31748b6b83a57d6e1d9ba3ef3b4
--- /dev/null
+++ b/dist/dist/esnext/foundation/Analytics/connectors/Shopify/const.d.ts
@@ -0,0 +1,26 @@
+export declare const ShopifyAnalyticsConstants: {
+    pageType: {
+        article: string;
+        blog: string;
+        captcha: string;
+        cart: string;
+        collection: string;
+        customersAccount: string;
+        customersActivateAccount: string;
+        customersAddresses: string;
+        customersLogin: string;
+        customersOrder: string;
+        customersRegister: string;
+        customersResetPassword: string;
+        giftCard: string;
+        home: string;
+        listCollections: string;
+        forbidden: string;
+        notFound: string;
+        page: string;
+        password: string;
+        product: string;
+        policy: string;
+        search: string;
+    };
+};
diff --git a/dist/dist/esnext/foundation/Analytics/connectors/Shopify/const.js b/dist/dist/esnext/foundation/Analytics/connectors/Shopify/const.js
new file mode 100644
index 0000000000000000000000000000000000000000..03b0b2f5cbec714de58075c3892a090e4b9689f1
--- /dev/null
+++ b/dist/dist/esnext/foundation/Analytics/connectors/Shopify/const.js
@@ -0,0 +1,49 @@
+// Shopify analytics constants
+const article = 'article';
+const blog = 'blog';
+const captcha = 'captcha';
+const cart = 'cart';
+const collection = 'collection';
+const customersAccount = 'customers/account';
+const customersActivateAccount = 'customers/activate_account';
+const customersAddresses = 'customers/addresses';
+const customersLogin = 'customers/login';
+const customersOrder = 'customers/order';
+const customersRegister = 'customers/register';
+const customersResetPassword = 'customers/reset_password';
+const giftCard = 'gift_card';
+const home = 'index';
+const listCollections = 'list-collections';
+const forbidden = '403';
+const notFound = '404';
+const page = 'page';
+const password = 'password';
+const product = 'product';
+const policy = 'policy';
+const search = 'search';
+export const ShopifyAnalyticsConstants = {
+    pageType: {
+        article,
+        blog,
+        captcha,
+        cart,
+        collection,
+        customersAccount,
+        customersActivateAccount,
+        customersAddresses,
+        customersLogin,
+        customersOrder,
+        customersRegister,
+        customersResetPassword,
+        giftCard,
+        home,
+        listCollections,
+        forbidden,
+        notFound,
+        page,
+        password,
+        product,
+        policy,
+        search,
+    },
+};
diff --git a/dist/dist/esnext/foundation/Analytics/connectors/Shopify/utils.d.ts b/dist/dist/esnext/foundation/Analytics/connectors/Shopify/utils.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..03b08fee46f3791ffe8013048039174c53fe8cc9
--- /dev/null
+++ b/dist/dist/esnext/foundation/Analytics/connectors/Shopify/utils.d.ts
@@ -0,0 +1,3 @@
+export declare function buildUUID(): string;
+export declare function hexTime(): string;
+export declare function addDataIf(keyValuePairs: Record<string, string | number | Boolean>, formattedData: any): any;
diff --git a/dist/dist/esnext/foundation/Analytics/connectors/Shopify/utils.js b/dist/dist/esnext/foundation/Analytics/connectors/Shopify/utils.js
new file mode 100644
index 0000000000000000000000000000000000000000..735ee5867ec83079f552c38ce2461e088268a10b
--- /dev/null
+++ b/dist/dist/esnext/foundation/Analytics/connectors/Shopify/utils.js
@@ -0,0 +1,56 @@
+const zeros = '00000000';
+const tokenHash = 'xxxx-4xxx-xxxx-xxxxxxxxxxxx';
+export function buildUUID() {
+    let hash = '';
+    try {
+        const crypto = window.crypto;
+        const randomValuesArray = new Uint16Array(31);
+        crypto.getRandomValues(randomValuesArray);
+        // Generate a strong UUID
+        let i = 0;
+        hash = tokenHash
+            .replace(/[x]/g, (c, ...args) => {
+            const r = randomValuesArray[i] % 16;
+            const v = c === 'x' ? r : (r & 0x3) | 0x8;
+            i++;
+            return v.toString(16);
+        })
+            .toUpperCase();
+    }
+    catch (err) {
+        // crypto not available, generate weak UUID
+        hash = tokenHash
+            .replace(/[x]/g, (c, ...args) => {
+            const r = (Math.random() * 16) | 0;
+            const v = c === 'x' ? r : (r & 0x3) | 0x8;
+            return v.toString(16);
+        })
+            .toUpperCase();
+    }
+    return `${hexTime()}-${hash}`;
+}
+export function hexTime() {
+    // 32 bit representations of new Date().getTime() and performance.now()
+    let dateNumber = 0;
+    let perfNumber = 0;
+    // Result of zero-fill right shift is always positive
+    dateNumber = new Date().getTime() >>> 0;
+    try {
+        perfNumber = performance.now() >>> 0;
+    }
+    catch (err) {
+        perfNumber = 0;
+    }
+    const output = Math.abs(dateNumber + perfNumber)
+        .toString(16)
+        .toLowerCase();
+    return zeros.substr(0, 8 - output.length) + output;
+}
+export function addDataIf(keyValuePairs, formattedData) {
+    Object.entries(keyValuePairs).forEach(([key, value]) => {
+        if (value) {
+            formattedData[key] = value;
+        }
+    });
+    return formattedData;
+}
diff --git a/dist/dist/esnext/foundation/Analytics/const.d.ts b/dist/dist/esnext/foundation/Analytics/const.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2dab92e07cc3983be446f58d075150b9c330aad7
--- /dev/null
+++ b/dist/dist/esnext/foundation/Analytics/const.d.ts
@@ -0,0 +1,9 @@
+export declare const eventNames: {
+    PAGE_VIEW: string;
+    VIEWED_PRODUCT: string;
+    ADD_TO_CART: string;
+    REMOVE_FROM_CART: string;
+    UPDATE_CART: string;
+    DISCOUNT_CODE_UPDATED: string;
+    PERFORMANCE: string;
+};
diff --git a/dist/dist/esnext/foundation/Analytics/const.js b/dist/dist/esnext/foundation/Analytics/const.js
new file mode 100644
index 0000000000000000000000000000000000000000..2db6ddb005c63b7aa9c338eff0a1632d95140e49
--- /dev/null
+++ b/dist/dist/esnext/foundation/Analytics/const.js
@@ -0,0 +1,9 @@
+export const eventNames = {
+    PAGE_VIEW: 'page-view',
+    VIEWED_PRODUCT: 'viewed-product',
+    ADD_TO_CART: 'add-to-cart',
+    REMOVE_FROM_CART: 'remove-from-cart',
+    UPDATE_CART: 'update-cart',
+    DISCOUNT_CODE_UPDATED: 'discount-code-updated',
+    PERFORMANCE: 'performance',
+};
diff --git a/dist/dist/esnext/foundation/Analytics/hook.d.ts b/dist/dist/esnext/foundation/Analytics/hook.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5f998a2c065473cc8cac2cec9d39547a4887a600
--- /dev/null
+++ b/dist/dist/esnext/foundation/Analytics/hook.d.ts
@@ -0,0 +1 @@
+export declare function useServerAnalytics(data?: any): any;
diff --git a/dist/dist/esnext/foundation/Analytics/hook.js b/dist/dist/esnext/foundation/Analytics/hook.js
new file mode 100644
index 0000000000000000000000000000000000000000..3dcf68312a736b2dd6b9c21d163f6f5b98992bef
--- /dev/null
+++ b/dist/dist/esnext/foundation/Analytics/hook.js
@@ -0,0 +1,9 @@
+import { useServerRequest } from '../ServerRequestProvider/index.js';
+import { mergeDeep } from './utils.js';
+export function useServerAnalytics(data) {
+    const request = useServerRequest();
+    if (data) {
+        request.ctx.analyticsData = mergeDeep(request.ctx.analyticsData, data);
+    }
+    return request.ctx.analyticsData;
+}
diff --git a/dist/dist/esnext/foundation/Analytics/index.d.ts b/dist/dist/esnext/foundation/Analytics/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..42e7c69dc53a91fe082dcf85cb8ba259c755ef57
--- /dev/null
+++ b/dist/dist/esnext/foundation/Analytics/index.d.ts
@@ -0,0 +1 @@
+export { ClientAnalytics } from './ClientAnalytics.js';
diff --git a/dist/dist/esnext/foundation/Analytics/index.js b/dist/dist/esnext/foundation/Analytics/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..42e7c69dc53a91fe082dcf85cb8ba259c755ef57
--- /dev/null
+++ b/dist/dist/esnext/foundation/Analytics/index.js
@@ -0,0 +1 @@
+export { ClientAnalytics } from './ClientAnalytics.js';
diff --git a/dist/dist/esnext/foundation/Analytics/types.d.ts b/dist/dist/esnext/foundation/Analytics/types.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c74b36ca2d45e77393235f058dfa99175a68c7b4
--- /dev/null
+++ b/dist/dist/esnext/foundation/Analytics/types.d.ts
@@ -0,0 +1,5 @@
+export declare type Subscriber = {
+    unsubscribe: () => void;
+};
+export declare type SubscriberFunction = (payload: any) => void;
+export declare type Subscribers = Record<string, Record<string, SubscriberFunction>>;
diff --git a/dist/dist/esnext/foundation/Analytics/types.js b/dist/dist/esnext/foundation/Analytics/types.js
new file mode 100644
index 0000000000000000000000000000000000000000..cb0ff5c3b541f646105198ee23ac0fc3d805023e
--- /dev/null
+++ b/dist/dist/esnext/foundation/Analytics/types.js
@@ -0,0 +1 @@
+export {};
diff --git a/dist/dist/esnext/foundation/Analytics/utils.d.ts b/dist/dist/esnext/foundation/Analytics/utils.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5ab558081f00864e96756e72b773fe1400f6d742
--- /dev/null
+++ b/dist/dist/esnext/foundation/Analytics/utils.d.ts
@@ -0,0 +1,3 @@
+export declare function getNamedspacedEventname(eventname: string): string;
+export declare function isObject(item: any): any;
+export declare function mergeDeep(target: any, ...sources: any[]): any;
diff --git a/dist/dist/esnext/foundation/Analytics/utils.js b/dist/dist/esnext/foundation/Analytics/utils.js
new file mode 100644
index 0000000000000000000000000000000000000000..d787d1d1fdfc8bdd6054961454a6d39695d38140
--- /dev/null
+++ b/dist/dist/esnext/foundation/Analytics/utils.js
@@ -0,0 +1,29 @@
+import { eventNames } from './const.js';
+const RESERVED_EVENT_NAMES = Object.values(eventNames);
+export function getNamedspacedEventname(eventname) {
+    // Any event name that is not in the reserved space will be prefix with `c-`
+    return RESERVED_EVENT_NAMES.indexOf(eventname) === -1
+        ? `c-${eventname}`
+        : eventname;
+}
+export function isObject(item) {
+    return item && typeof item === 'object' && !Array.isArray(item);
+}
+export function mergeDeep(target, ...sources) {
+    if (!sources.length)
+        return target;
+    const source = sources.shift();
+    if (isObject(target) && isObject(source)) {
+        for (const key in source) {
+            if (isObject(source[key])) {
+                if (!target[key])
+                    Object.assign(target, { [key]: {} });
+                mergeDeep(target[key], source[key]);
+            }
+            else {
+                Object.assign(target, { [key]: source[key] });
+            }
+        }
+    }
+    return mergeDeep(target, ...sources);
+}
diff --git a/dist/dist/esnext/foundation/AnalyticsErrorBoundary.client.d.ts b/dist/dist/esnext/foundation/AnalyticsErrorBoundary.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5301567d7acf9c3b8ce32bb6db35bf2fc508a739
--- /dev/null
+++ b/dist/dist/esnext/foundation/AnalyticsErrorBoundary.client.d.ts
@@ -0,0 +1,4 @@
+import type { ReactNode } from 'react';
+export default function AnalyticsErrorBoundary({ children, }: {
+    children: ReactNode;
+}): JSX.Element;
diff --git a/dist/dist/esnext/foundation/AnalyticsErrorBoundary.client.js b/dist/dist/esnext/foundation/AnalyticsErrorBoundary.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..6531974b781b457945b213383893e851ff35189a
--- /dev/null
+++ b/dist/dist/esnext/foundation/AnalyticsErrorBoundary.client.js
@@ -0,0 +1,8 @@
+import React from 'react';
+import { ErrorBoundary } from 'react-error-boundary';
+export default function AnalyticsErrorBoundary({ children, }) {
+    // Analytics fail to load, most likely due to an ad blocker
+    return (React.createElement(ErrorBoundary, { fallbackRender: () => {
+            return null;
+        } }, children));
+}
diff --git a/dist/dist/esnext/foundation/BuiltInRoutes/BuiltInRoutes.d.ts b/dist/dist/esnext/foundation/BuiltInRoutes/BuiltInRoutes.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5c53e803ea58011b108645ffd532dfa3db910deb
--- /dev/null
+++ b/dist/dist/esnext/foundation/BuiltInRoutes/BuiltInRoutes.d.ts
@@ -0,0 +1,2 @@
+import { ResourceGetter } from '../../utilities/apiRoutes.js';
+export declare function getBuiltInRoute(url: URL): ResourceGetter | null;
diff --git a/dist/dist/esnext/foundation/BuiltInRoutes/BuiltInRoutes.js b/dist/dist/esnext/foundation/BuiltInRoutes/BuiltInRoutes.js
new file mode 100644
index 0000000000000000000000000000000000000000..19a2f7357bdfe818ced68de25df7d9d2708ca1f7
--- /dev/null
+++ b/dist/dist/esnext/foundation/BuiltInRoutes/BuiltInRoutes.js
@@ -0,0 +1,23 @@
+import { EVENT_PATHNAME, EVENT_PATHNAME_REGEX } from '../../constants.js';
+import { ServerAnalyticsRoute } from '../Analytics/ServerAnalyticsRoute.js';
+import { HealthCheck } from './healthCheck.js';
+const builtInRoutes = [
+    {
+        pathname: EVENT_PATHNAME,
+        regex: EVENT_PATHNAME_REGEX,
+        resource: ServerAnalyticsRoute,
+    },
+    {
+        pathname: '/__health',
+        resource: HealthCheck,
+    },
+];
+export function getBuiltInRoute(url) {
+    for (const route of builtInRoutes) {
+        if (url.pathname === route.pathname ||
+            (route.regex && route.regex.test(url.pathname))) {
+            return route.resource;
+        }
+    }
+    return null;
+}
diff --git a/dist/dist/esnext/foundation/BuiltInRoutes/healthCheck.d.ts b/dist/dist/esnext/foundation/BuiltInRoutes/healthCheck.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1d53f1d521cc13ca1cdf16ca04a1f40eb86fb2ab
--- /dev/null
+++ b/dist/dist/esnext/foundation/BuiltInRoutes/healthCheck.d.ts
@@ -0,0 +1 @@
+export declare function HealthCheck(): Promise<Response>;
diff --git a/dist/dist/esnext/foundation/BuiltInRoutes/healthCheck.js b/dist/dist/esnext/foundation/BuiltInRoutes/healthCheck.js
new file mode 100644
index 0000000000000000000000000000000000000000..bea2d5769d0d9ed3c0c7524b5b3448f2a4760175
--- /dev/null
+++ b/dist/dist/esnext/foundation/BuiltInRoutes/healthCheck.js
@@ -0,0 +1,3 @@
+export async function HealthCheck() {
+    return new Response(null, { status: 200 });
+}
diff --git a/dist/dist/esnext/foundation/Cache/cache-sub-request.d.ts b/dist/dist/esnext/foundation/Cache/cache-sub-request.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..981c1518ff1f1b955420697a3e12ffe860e4c354
--- /dev/null
+++ b/dist/dist/esnext/foundation/Cache/cache-sub-request.d.ts
@@ -0,0 +1,17 @@
+import type { QueryKey, CachingStrategy } from '../../types.js';
+export declare function generateSubRequestCacheControlHeader(userCacheOptions?: CachingStrategy): string;
+/**
+ * Get an item from the cache. If a match is found, returns a tuple
+ * containing the `JSON.parse` version of the response as well
+ * as the response itself so it can be checked for staleness.
+ */
+export declare function getItemFromCache(key: QueryKey): Promise<undefined | [any, Response]>;
+/**
+ * Put an item into the cache.
+ */
+export declare function setItemInCache(key: QueryKey, value: any, userCacheOptions?: CachingStrategy): Promise<void>;
+export declare function deleteItemFromCache(key: QueryKey): Promise<void>;
+/**
+ * Manually check the response to see if it's stale.
+ */
+export declare function isStale(key: QueryKey, response: Response): boolean;
diff --git a/dist/dist/esnext/foundation/Cache/cache-sub-request.js b/dist/dist/esnext/foundation/Cache/cache-sub-request.js
new file mode 100644
index 0000000000000000000000000000000000000000..9be128a38250d9da0a74f9f01a237732c876b836
--- /dev/null
+++ b/dist/dist/esnext/foundation/Cache/cache-sub-request.js
@@ -0,0 +1,64 @@
+import { getCache } from '../runtime.js';
+import { hashKey } from '../../utilities/hash.js';
+import * as CacheApi from './cache.js';
+import { CacheShort } from './strategies/index.js';
+/**
+ * Wrapper Cache functions for sub queries
+ */
+/**
+ * Cache API is weird. We just need a full URL, so we make one up.
+ */
+function getKeyUrl(key) {
+    return `https://shopify.dev/?${key}`;
+}
+function getCacheOption(userCacheOptions) {
+    return userCacheOptions || CacheShort();
+}
+export function generateSubRequestCacheControlHeader(userCacheOptions) {
+    return CacheApi.generateDefaultCacheControlHeader(getCacheOption(userCacheOptions));
+}
+/**
+ * Get an item from the cache. If a match is found, returns a tuple
+ * containing the `JSON.parse` version of the response as well
+ * as the response itself so it can be checked for staleness.
+ */
+export async function getItemFromCache(key) {
+    const cache = getCache();
+    if (!cache) {
+        return;
+    }
+    const url = getKeyUrl(hashKey(key));
+    const request = new Request(url);
+    const response = await CacheApi.getItemFromCache(request);
+    if (!response) {
+        return;
+    }
+    return [await response.json(), response];
+}
+/**
+ * Put an item into the cache.
+ */
+export async function setItemInCache(key, value, userCacheOptions) {
+    const cache = getCache();
+    if (!cache) {
+        return;
+    }
+    const url = getKeyUrl(hashKey(key));
+    const request = new Request(url);
+    const response = new Response(JSON.stringify(value));
+    await CacheApi.setItemInCache(request, response, getCacheOption(userCacheOptions));
+}
+export async function deleteItemFromCache(key) {
+    const cache = getCache();
+    if (!cache)
+        return;
+    const url = getKeyUrl(hashKey(key));
+    const request = new Request(url);
+    await CacheApi.deleteItemFromCache(request);
+}
+/**
+ * Manually check the response to see if it's stale.
+ */
+export function isStale(key, response) {
+    return CacheApi.isStale(new Request(getKeyUrl(hashKey(key))), response);
+}
diff --git a/dist/dist/esnext/foundation/Cache/cache.d.ts b/dist/dist/esnext/foundation/Cache/cache.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8bb8577e2f126847daeac71d32dfdd16a782aa95
--- /dev/null
+++ b/dist/dist/esnext/foundation/Cache/cache.d.ts
@@ -0,0 +1,17 @@
+import type { CachingStrategy } from '../../types.js';
+export declare function generateDefaultCacheControlHeader(userCacheOptions?: CachingStrategy): string;
+/**
+ * Get an item from the cache. If a match is found, returns a tuple
+ * containing the `JSON.parse` version of the response as well
+ * as the response itself so it can be checked for staleness.
+ */
+export declare function getItemFromCache(request: Request): Promise<Response | undefined>;
+/**
+ * Put an item into the cache.
+ */
+export declare function setItemInCache(request: Request, response: Response, userCacheOptions: CachingStrategy): Promise<void>;
+export declare function deleteItemFromCache(request: Request): Promise<void>;
+/**
+ * Manually check the response to see if it's stale.
+ */
+export declare function isStale(request: Request, response: Response): boolean;
diff --git a/dist/dist/esnext/foundation/Cache/cache.js b/dist/dist/esnext/foundation/Cache/cache.js
new file mode 100644
index 0000000000000000000000000000000000000000..f61a4b2a4a61f3babc987b7cfa5e802659e3ffaa
--- /dev/null
+++ b/dist/dist/esnext/foundation/Cache/cache.js
@@ -0,0 +1,126 @@
+import { getCache } from '../runtime.js';
+import { CacheShort, generateCacheControlHeader } from './strategies/index.js';
+import { logCacheApiStatus } from '../../utilities/log/index.js';
+function getCacheControlSetting(userCacheOptions, options) {
+    if (userCacheOptions && options) {
+        return {
+            ...userCacheOptions,
+            ...options,
+        };
+    }
+    else {
+        return userCacheOptions || CacheShort();
+    }
+}
+export function generateDefaultCacheControlHeader(userCacheOptions) {
+    return generateCacheControlHeader(getCacheControlSetting(userCacheOptions));
+}
+/**
+ * Get an item from the cache. If a match is found, returns a tuple
+ * containing the `JSON.parse` version of the response as well
+ * as the response itself so it can be checked for staleness.
+ */
+export async function getItemFromCache(request) {
+    const cache = getCache();
+    if (!cache) {
+        return;
+    }
+    const response = await cache.match(request);
+    if (!response) {
+        logCacheApiStatus('MISS', request.url);
+        return;
+    }
+    logCacheApiStatus('HIT', request.url);
+    return response;
+}
+/**
+ * Put an item into the cache.
+ */
+export async function setItemInCache(request, response, userCacheOptions) {
+    const cache = getCache();
+    if (!cache) {
+        return;
+    }
+    /**
+     * We are manually managing staled request by adding this workaround.
+     * Why? cache control header support is dependent on hosting platform
+     *
+     * For example:
+     *
+     * Cloudflare's Cache API does not support `stale-while-revalidate`.
+     * Cloudflare cache control header has a very odd behaviour.
+     * Say we have the following cache control header on a request:
+     *
+     *   public, max-age=15, stale-while-revalidate=30
+     *
+     * When there is a cache.match HIT, the cache control header would become
+     *
+     *   public, max-age=14400, stale-while-revalidate=30
+     *
+     * == `stale-while-revalidate` workaround ==
+     * Update response max-age so that:
+     *
+     *   max-age = max-age + stale-while-revalidate
+     *
+     * For example:
+     *
+     *   public, max-age=1, stale-while-revalidate=9
+     *                    |
+     *                    V
+     *   public, max-age=10, stale-while-revalidate=9
+     *
+     * Store the following information in the response header:
+     *
+     *   cache-put-date   - UTC time string of when this request is PUT into cache
+     *
+     * Note on `cache-put-date`: The `response.headers.get('date')` isn't static. I am
+     * not positive what date this is returning but it is never over 500 ms
+     * after subtracting from the current timestamp.
+     *
+     * `isStale` function will use the above information to test for stale-ness of a cached response
+     */
+    const cacheControl = getCacheControlSetting(userCacheOptions);
+    // The padded cache-control to mimic stale-while-revalidate
+    request.headers.set('cache-control', generateDefaultCacheControlHeader(getCacheControlSetting(cacheControl, {
+        maxAge: (cacheControl.maxAge || 0) + (cacheControl.staleWhileRevalidate || 0),
+    })));
+    // The cache-control we want to set on response
+    const cacheControlString = generateDefaultCacheControlHeader(getCacheControlSetting(cacheControl));
+    // CF will override cache-control, so we need to keep a
+    // non-modified real-cache-control
+    response.headers.set('real-cache-control', cacheControlString);
+    response.headers.set('cache-put-date', new Date().toUTCString());
+    logCacheApiStatus('PUT', request.url);
+    await cache.put(request, response);
+}
+export async function deleteItemFromCache(request) {
+    const cache = getCache();
+    if (!cache)
+        return;
+    logCacheApiStatus('DELETE', request.url);
+    await cache.delete(request);
+}
+/**
+ * Manually check the response to see if it's stale.
+ */
+export function isStale(request, response) {
+    const responseDate = response.headers.get('cache-put-date');
+    const cacheControl = response.headers.get('real-cache-control');
+    let responseMaxAge = 0;
+    if (cacheControl) {
+        const maxAgeMatch = cacheControl.match(/max-age=(\d*)/);
+        if (maxAgeMatch && maxAgeMatch.length > 1) {
+            responseMaxAge = parseFloat(maxAgeMatch[1]);
+        }
+    }
+    if (!responseDate) {
+        return false;
+    }
+    const ageInMs = new Date().valueOf() - new Date(responseDate).valueOf();
+    const age = ageInMs / 1000;
+    const result = age > responseMaxAge;
+    if (result) {
+        logCacheApiStatus('STALE', request.url);
+    }
+    return result;
+}
diff --git a/dist/dist/esnext/foundation/Cache/strategies/index.d.ts b/dist/dist/esnext/foundation/Cache/strategies/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8908e63c2a8d0d3e1aa2e06a2c3e9d0fd562d91d
--- /dev/null
+++ b/dist/dist/esnext/foundation/Cache/strategies/index.d.ts
@@ -0,0 +1,7 @@
+import type { CachingStrategy, AllCacheOptions, NoStoreStrategy } from '../../../types.js';
+export declare const NO_STORE = "no-store";
+export declare function generateCacheControlHeader(cacheOptions: CachingStrategy): string;
+export declare function CacheNone(): NoStoreStrategy;
+export declare function CacheShort(overrideOptions?: CachingStrategy): AllCacheOptions;
+export declare function CacheLong(overrideOptions?: CachingStrategy): AllCacheOptions;
+export declare function CacheCustom(overrideOptions: CachingStrategy): AllCacheOptions;
diff --git a/dist/dist/esnext/foundation/Cache/strategies/index.js b/dist/dist/esnext/foundation/Cache/strategies/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..96eef1458dd96c22451fa35e259cf92074adee3c
--- /dev/null
+++ b/dist/dist/esnext/foundation/Cache/strategies/index.js
@@ -0,0 +1,54 @@
+const PUBLIC = 'public';
+const PRIVATE = 'private';
+export const NO_STORE = 'no-store';
+const optionMapping = {
+    maxAge: 'max-age',
+    staleWhileRevalidate: 'stale-while-revalidate',
+    sMaxAge: 's-maxage',
+    staleIfError: 'stale-if-error',
+};
+export function generateCacheControlHeader(cacheOptions) {
+    const cacheControl = [];
+    Object.keys(cacheOptions).forEach((key) => {
+        if (key === 'mode') {
+            cacheControl.push(cacheOptions[key]);
+        }
+        else if (optionMapping[key]) {
+            cacheControl.push(`${optionMapping[key]}=${cacheOptions[key]}`);
+        }
+    });
+    return cacheControl.join(', ');
+}
+export function CacheNone() {
+    return {
+        mode: NO_STORE,
+    };
+}
+function guardExpirableModeType(overrideOptions) {
+    if (overrideOptions?.mode &&
+        overrideOptions?.mode !== PUBLIC &&
+        overrideOptions?.mode !== PRIVATE) {
+        throw Error("'mode' must be either 'public' or 'private'");
+    }
+}
+export function CacheShort(overrideOptions) {
+    guardExpirableModeType(overrideOptions);
+    return {
+        mode: PUBLIC,
+        maxAge: 1,
+        staleWhileRevalidate: 9,
+        ...overrideOptions,
+    };
+}
+export function CacheLong(overrideOptions) {
+    guardExpirableModeType(overrideOptions);
+    return {
+        mode: PUBLIC,
+        maxAge: 3600,
+        staleWhileRevalidate: 82800,
+        ...overrideOptions,
+    };
+}
+export function CacheCustom(overrideOptions) {
+    return overrideOptions;
+}
diff --git a/dist/dist/esnext/foundation/Cookie/Cookie.d.ts b/dist/dist/esnext/foundation/Cookie/Cookie.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8f73805f6497884ebb0582cbeaccc81af292d50d
--- /dev/null
+++ b/dist/dist/esnext/foundation/Cookie/Cookie.d.ts
@@ -0,0 +1,48 @@
+export declare type CookieOptions = {
+    /** Whether to secure the cookie so that [client-side JavaScript can't read the cookie](https://owasp.org/www-community/HttpOnly).
+     */
+    httpOnly?: boolean;
+    /** Whether to secure the cookie so that the browser only sends the cookie over HTTPS. Some
+     * browsers [don't work with secure cookies on localhost](https://owasp.org/www-community/controls/SecureCookieAttribute).
+     */
+    secure?: boolean;
+    /** Declares that the cookie should be restricted to a first-party
+     * or [same-site](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite) context.
+     */
+    sameSite?: 'Lax' | 'Strict' | 'None';
+    /** Tells the browser that the cookie should only be sent to the server if it's
+     * within the [defined path](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#path_attribute).
+     */
+    path?: string;
+    /** [A date on which the cookie will expire](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#define_the_lifetime_of_a_cookie).
+     * If the date is in the past, then the browser will remove the cookie.
+     */
+    expires?: Date;
+    /** Secures the cookie so that it's only used on [specific domains](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#domain_attribute).
+     */
+    domain?: string;
+    /** The [number of seconds until the cookie expires](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#max-agenumber).
+     * `maxAge` takes precedence over `expires` if both are defined.
+     */
+    maxAge?: number;
+};
+/** The `Cookie` component helps you build your own custom cookie and session implementations. All
+ * [Hydrogen session storage mechanisms](https://shopify.dev/custom-storefronts/hydrogen/framework/sessions#types-of-session-storage) use the
+ * same configuration options as what's available in `Cookie`.
+ */
+export declare class Cookie {
+    /** The name of the cookie stored in the browser. */
+    name: string;
+    /** An optional object to configure [how the cookie is persisted in the browser](https://shopify.dev/api/hydrogen/components/framework/cookie#cookie-options). */
+    options?: CookieOptions;
+    data: Record<string, any>;
+    constructor(name: string, options?: CookieOptions);
+    parse(cookie: string): Record<string, any>;
+    set(key: string, value: string): void;
+    setAll(data: Record<string, string>): void;
+    serialize(): string;
+    destroy(): string;
+    get expires(): number;
+    setSessionid(sid: string): void;
+    getSessionId(request: Request): string | null;
+}
diff --git a/dist/dist/esnext/foundation/Cookie/Cookie.js b/dist/dist/esnext/foundation/Cookie/Cookie.js
new file mode 100644
index 0000000000000000000000000000000000000000..60262933ea0162ccd6ab9dbebd8b3f7a9c5d1540
--- /dev/null
+++ b/dist/dist/esnext/foundation/Cookie/Cookie.js
@@ -0,0 +1,72 @@
+import { parse, stringify as stringifyCookie } from 'worktop/cookie';
+import { log } from '../../utilities/log/index.js';
+import { parseJSON } from '../../utilities/parse.js';
+const reservedCookieNames = ['mac', 'user_session_id'];
+/** The `Cookie` component helps you build your own custom cookie and session implementations. All
+ * [Hydrogen session storage mechanisms](https://shopify.dev/custom-storefronts/hydrogen/framework/sessions#types-of-session-storage) use the
+ * same configuration options as what's available in `Cookie`.
+ */
+export class Cookie {
+    /** The name of the cookie stored in the browser. */
+    name;
+    /** An optional object to configure [how the cookie is persisted in the browser](https://shopify.dev/api/hydrogen/components/framework/cookie#cookie-options). */
+    options;
+    data;
+    constructor(name, options = {}) {
+        if (reservedCookieNames.includes(name)) {
+            log.warn(`Warning "${name}" is a reserved cookie name by oxygen!`);
+        }
+        this.options = options;
+        this.options = {
+            ...this.options,
+            expires: 
+            // maxAge takes precedence
+            typeof options.maxAge !== 'undefined'
+                ? new Date(Date.now() + options.maxAge * 1000)
+                : options.expires
+                    ? options.expires
+                    : new Date(Date.now() + 604800000), // default one week
+        };
+        this.name = name;
+        this.data = {};
+    }
+    parse(cookie) {
+        try {
+            const data = parseJSON(parse(cookie)[this.name]);
+            this.data = data;
+        }
+        catch (e) {
+            // failure to parse cookie
+        }
+        return this.data;
+    }
+    set(key, value) {
+        this.data[key] = value;
+    }
+    setAll(data) {
+        this.data = data;
+    }
+    serialize() {
+        return stringifyCookie(this.name, JSON.stringify(this.data), this.options);
+    }
+    destroy() {
+        this.data = {};
+        return stringifyCookie(this.name, '', {
+            ...this.options,
+            expires: new Date(0),
+        });
+    }
+    get expires() {
+        return this.options.expires.getTime();
+    }
+    setSessionid(sid) {
+        return this.set('sid', sid);
+    }
+    getSessionId(request) {
+        const cookieValue = request.headers.get('cookie');
+        if (cookieValue) {
+            return this.parse(cookieValue).sid;
+        }
+        return null;
+    }
+}
diff --git a/dist/dist/esnext/foundation/CookieSessionStorage/CookieSessionStorage.d.ts b/dist/dist/esnext/foundation/CookieSessionStorage/CookieSessionStorage.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e7cd4859ff4b13ee1ab6bcb2df7695b17bf32b92
--- /dev/null
+++ b/dist/dist/esnext/foundation/CookieSessionStorage/CookieSessionStorage.d.ts
@@ -0,0 +1,5 @@
+import type { SessionStorageAdapter } from '../session/session-types.js';
+import type { CookieOptions } from '../Cookie/Cookie.js';
+/** The `CookieSessionStorage` component is the default session storage mechanism for Hydrogen.
+ */
+export declare const CookieSessionStorage: (name: string, options: CookieOptions) => () => SessionStorageAdapter;
diff --git a/dist/dist/esnext/foundation/CookieSessionStorage/CookieSessionStorage.js b/dist/dist/esnext/foundation/CookieSessionStorage/CookieSessionStorage.js
new file mode 100644
index 0000000000000000000000000000000000000000..8b8fbc403280daccec314ac2afa225bc40cd7e3d
--- /dev/null
+++ b/dist/dist/esnext/foundation/CookieSessionStorage/CookieSessionStorage.js
@@ -0,0 +1,32 @@
+import { Cookie } from '../Cookie/Cookie.js';
+/** The `CookieSessionStorage` component is the default session storage mechanism for Hydrogen.
+ */
+export const CookieSessionStorage = function (
+/** The name of the cookie stored in the browser. */
+name, 
+/** An optional object to configure [how the cookie is persisted in the browser](https://shopify.dev/api/hydrogen/components/framework/cookie#cookie-options). */
+options) {
+    return function () {
+        const cookie = new Cookie(name, options);
+        let parsed = false;
+        return {
+            async get(request) {
+                if (!parsed) {
+                    const cookieValue = request.headers.get('cookie');
+                    cookie.parse(cookieValue || '');
+                    parsed = true;
+                }
+                return cookie.data;
+            },
+            async set(request, value) {
+                cookie.setAll(value);
+                return cookie.serialize();
+            },
+            async destroy(request) {
+                // @todo - set expires for Date in past
+                parsed = true;
+                return cookie.destroy();
+            },
+        };
+    };
+};
diff --git a/dist/dist/esnext/foundation/DevTools/DevTools.client.d.ts b/dist/dist/esnext/foundation/DevTools/DevTools.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7870ec2453f32b29727b4390ecb2dc64b3a0009b
--- /dev/null
+++ b/dist/dist/esnext/foundation/DevTools/DevTools.client.d.ts
@@ -0,0 +1,3 @@
+export declare function DevTools({ dataFromServer }: {
+    dataFromServer: any;
+}): JSX.Element | null;
diff --git a/dist/dist/esnext/foundation/DevTools/DevTools.client.js b/dist/dist/esnext/foundation/DevTools/DevTools.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..ada316e94ad413c495398d596fce770dfb2a6923
--- /dev/null
+++ b/dist/dist/esnext/foundation/DevTools/DevTools.client.js
@@ -0,0 +1,17 @@
+import React, { useState, useEffect, useCallback } from 'react';
+import { Interface, Panels } from './components/index.js';
+export function DevTools({ dataFromServer }) {
+    const [open, setOpen] = useState(false);
+    const toggleOpen = useCallback(() => {
+        setOpen((state) => !state);
+    }, []);
+    const [hasMounted, setHasMounted] = useState(false);
+    useEffect(() => {
+        setHasMounted(true);
+    }, []);
+    if (hasMounted) {
+        return (React.createElement(Interface, { open: open, onClose: toggleOpen, onOpen: toggleOpen },
+            React.createElement(Panels, { ...dataFromServer })));
+    }
+    return null;
+}
diff --git a/dist/dist/esnext/foundation/DevTools/DevTools.server.d.ts b/dist/dist/esnext/foundation/DevTools/DevTools.server.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..58f8d3c8162f60617d0c5a08549b062fdd8e11c7
--- /dev/null
+++ b/dist/dist/esnext/foundation/DevTools/DevTools.server.d.ts
@@ -0,0 +1 @@
+export declare function DevTools(): JSX.Element;
diff --git a/dist/dist/esnext/foundation/DevTools/DevTools.server.js b/dist/dist/esnext/foundation/DevTools/DevTools.server.js
new file mode 100644
index 0000000000000000000000000000000000000000..a08fb236902e6b0ab5a4499dca170e0a4836f93a
--- /dev/null
+++ b/dist/dist/esnext/foundation/DevTools/DevTools.server.js
@@ -0,0 +1,15 @@
+import React from 'react';
+import { DevTools as DevToolsClient } from './DevTools.client.js';
+import { useServerRequest } from '../ServerRequestProvider/index.js';
+import { getLocale } from '../../utilities/locale/index.js';
+export function DevTools() {
+    const serverRequest = useServerRequest();
+    const { shopifyConfig } = serverRequest.ctx;
+    const { defaultLanguageCode: languageCode, defaultCountryCode: countryCode, storeDomain, storefrontApiVersion, } = shopifyConfig || {};
+    const settings = {
+        locale: getLocale(languageCode, countryCode),
+        storeDomain,
+        storefrontApiVersion,
+    };
+    return React.createElement(DevToolsClient, { dataFromServer: { settings } });
+}
diff --git a/dist/dist/esnext/foundation/DevTools/components/GraphQL.client.d.ts b/dist/dist/esnext/foundation/DevTools/components/GraphQL.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ff6f5dea5c0651cb69127a46637638b6cd52c008
--- /dev/null
+++ b/dist/dist/esnext/foundation/DevTools/components/GraphQL.client.d.ts
@@ -0,0 +1 @@
+export declare function GraphQL(): JSX.Element;
diff --git a/dist/dist/esnext/foundation/DevTools/components/GraphQL.client.js b/dist/dist/esnext/foundation/DevTools/components/GraphQL.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..0a64fc3decc777a38f0007badfb127ad11c07d60
--- /dev/null
+++ b/dist/dist/esnext/foundation/DevTools/components/GraphQL.client.js
@@ -0,0 +1,25 @@
+import React, { useEffect, useState } from 'react';
+export function GraphQL() {
+    const [warnings, setWarnings] = useState(null);
+    useEffect(() => {
+        if (import.meta.hot) {
+            import.meta.hot.on('hydrogen-dev-tools', ({ type, data }) => {
+                if (type === 'warn') {
+                    setWarnings((state) => [...(state || []), data]);
+                }
+            });
+        }
+    }, []);
+    const warningsMarkup = warnings
+        ? warnings.map((war, i) => (
+        // eslint-disable-next-line react/no-array-index-key
+        React.createElement("li", { key: war + i },
+            React.createElement("pre", null, war))))
+        : null;
+    return (React.createElement("div", null,
+        React.createElement("ul", { style: {
+                fontFamily: 'monospace',
+                paddingTop: '1em',
+                fontSize: '0.9em',
+            } }, warningsMarkup)));
+}
diff --git a/dist/dist/esnext/foundation/DevTools/components/Heading.d.ts b/dist/dist/esnext/foundation/DevTools/components/Heading.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..080b07d41ff94f7689640fefc72e3d33695fcab8
--- /dev/null
+++ b/dist/dist/esnext/foundation/DevTools/components/Heading.d.ts
@@ -0,0 +1,5 @@
+export declare function Heading({ linkText, url, children, }: {
+    linkText?: string;
+    url?: string;
+    children: string;
+}): JSX.Element;
diff --git a/dist/dist/esnext/foundation/DevTools/components/Heading.js b/dist/dist/esnext/foundation/DevTools/components/Heading.js
new file mode 100644
index 0000000000000000000000000000000000000000..dd3aef6e7946e123b7233446a662db5715525161
--- /dev/null
+++ b/dist/dist/esnext/foundation/DevTools/components/Heading.js
@@ -0,0 +1,12 @@
+import React from 'react';
+export function Heading({ linkText, url, children, }) {
+    return (React.createElement("span", { style: { display: 'flex', alignItems: 'baseline', padding: '0 0 0em' } },
+        React.createElement("span", { style: { paddingRight: '0em', flex: 1, fontWeight: 'bold' } },
+            children,
+            ' '),
+        React.createElement("a", { style: {
+                color: 'blue',
+                fontFamily: 'monospace',
+                textDecoration: 'underline',
+            }, href: url }, linkText)));
+}
diff --git a/dist/dist/esnext/foundation/DevTools/components/Interface.client.d.ts b/dist/dist/esnext/foundation/DevTools/components/Interface.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1481802def719e3b2abfeb0b39f01417e90673c8
--- /dev/null
+++ b/dist/dist/esnext/foundation/DevTools/components/Interface.client.d.ts
@@ -0,0 +1,11 @@
+import React from 'react';
+interface Props {
+    open?: boolean;
+    title?: string | React.ReactNode;
+    onClose?: () => void;
+    onOpen?: () => void;
+    activator?: React.ReactElement;
+    children?: React.ReactNode;
+}
+export declare function Interface({ children, onClose, onOpen, ...props }: Props): JSX.Element;
+export {};
diff --git a/dist/dist/esnext/foundation/DevTools/components/Interface.client.js b/dist/dist/esnext/foundation/DevTools/components/Interface.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..f813208410ecd0bcfaef629cb4301c77a6f34264
--- /dev/null
+++ b/dist/dist/esnext/foundation/DevTools/components/Interface.client.js
@@ -0,0 +1,47 @@
+import React from 'react';
+import { CloseIcon, HydrogenIcon } from './icons.js';
+export function Interface({ children, onClose, onOpen, ...props }) {
+    const open = false || props.open;
+    return (React.createElement("div", { id: "hydrogen-dev-tools", "aria-hidden": true, style: {
+            position: 'fixed',
+            zIndex: 100,
+            display: 'flex',
+            flexDirection: 'column',
+            right: 0,
+            bottom: 0,
+            padding: '1.5em',
+            maxWidth: '100%',
+            flexWrap: 'wrap',
+        } },
+        React.createElement("button", { type: "button", style: {
+                position: 'relative',
+                background: 'white',
+                border: '1px solid',
+                padding: '0em 0.5em 0.25em 1.25em',
+                boxShadow: '10px 10px 0px black',
+                display: 'flex',
+                alignItems: 'center',
+                color: 'black',
+            }, onClick: onOpen },
+            React.createElement("div", { style: { textAlign: 'left', flex: 1 } },
+                React.createElement("span", { style: {
+                        fontFamily: 'monospace',
+                        fontWeight: 'bold',
+                        paddingRight: '0.5em',
+                    } }, "Dev tools")),
+            ' ',
+            open ? React.createElement(CloseIcon, null) : React.createElement(HydrogenIcon, null)),
+        React.createElement("div", { style: {
+                display: open ? 'block' : 'none',
+                position: 'relative',
+                top: '-1px',
+                overflow: 'scroll',
+                color: 'black',
+                background: 'white',
+                border: '1px solid',
+                boxShadow: '10px 10px 0px black',
+                maxWidth: '50em',
+                width: '100vw',
+                height: '50vh',
+            } }, children)));
+}
diff --git a/dist/dist/esnext/foundation/DevTools/components/Panels.d.ts b/dist/dist/esnext/foundation/DevTools/components/Panels.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e8a59290f794273d6bbb2b9781b4b8a9ee69bc71
--- /dev/null
+++ b/dist/dist/esnext/foundation/DevTools/components/Panels.d.ts
@@ -0,0 +1,8 @@
+import { ComponentProps } from 'react';
+import { Performance } from './Performance.client.js';
+import { Settings } from './Settings.client.js';
+export interface Props {
+    settings: ComponentProps<typeof Settings>;
+    performance: ComponentProps<typeof Performance>;
+}
+export declare function Panels({ settings }: Props): JSX.Element;
diff --git a/dist/dist/esnext/foundation/DevTools/components/Panels.js b/dist/dist/esnext/foundation/DevTools/components/Panels.js
new file mode 100644
index 0000000000000000000000000000000000000000..3570c592a2cc8badbfd6efb887dee2e1996d49eb
--- /dev/null
+++ b/dist/dist/esnext/foundation/DevTools/components/Panels.js
@@ -0,0 +1,66 @@
+import React, { useState, useEffect } from 'react';
+import { ClientAnalytics } from '../../Analytics/index.js';
+import { Performance } from './Performance.client.js';
+import { Settings } from './Settings.client.js';
+const isComponentPanel = (panel) => panel.component !== undefined;
+export function Panels({ settings }) {
+    const [selectedPanel, setSelectedPanel] = useState(0);
+    const [navigations, setNavigations] = useState([]);
+    useEffect(() => {
+        ClientAnalytics.subscribe(ClientAnalytics.eventNames.PERFORMANCE, ({ response_start, navigation_start, first_contentful_paint, largest_contentful_paint, response_end, page_load_type, url, transfer_size, }) => {
+            setNavigations([
+                ...navigations,
+                {
+                    ttfb: response_start - navigation_start,
+                    fcp: first_contentful_paint,
+                    lcp: largest_contentful_paint,
+                    duration: response_end - navigation_start,
+                    type: `${page_load_type} load`,
+                    size: transfer_size,
+                    url,
+                },
+            ]);
+        });
+    }, [setNavigations, navigations]);
+    const panels = getPanels({ settings, performance: { navigations } });
+    const panelComponents = panels.map((obj, index) => isComponentPanel(obj) ? (React.createElement("div", { key: obj.content, style: { display: selectedPanel === index ? 'block' : 'none' } }, obj.component)) : null);
+    return (React.createElement("div", { style: { display: 'flex', height: '100%' } },
+        React.createElement("div", { style: { borderRight: '1px solid', padding: '1em 0em' } }, panels.map((panel, index) => {
+            const active = selectedPanel === index;
+            const style = {
+                padding: '0em 1.25em',
+                fontWeight: 'bold',
+                textDecoration: active ? 'underline' : 'none',
+                display: 'flex',
+                justifyContent: 'space-between',
+                alignItems: 'center',
+            };
+            if (isComponentPanel(panel)) {
+                return (React.createElement("button", { key: panel.id, type: "button", style: style, onClick: () => setSelectedPanel(index) },
+                    React.createElement("span", null, panel.content)));
+            }
+            return (React.createElement("a", { style: style, target: "_blank", rel: "noreferrer", href: panel.url, key: panel.url },
+                panel.content,
+                React.createElement("span", null, "\u2197")));
+        })),
+        React.createElement("div", { style: { padding: '1em', width: '100%' } }, panelComponents[selectedPanel ? selectedPanel : 0])));
+}
+function getPanels({ settings, performance }) {
+    const panels = {
+        settings: {
+            content: 'Settings',
+            component: React.createElement(Settings, { ...settings }),
+        },
+        performance: {
+            content: 'Performance',
+            component: React.createElement(Performance, { ...performance }),
+        },
+        graphiql: {
+            content: 'GraphiQL',
+            url: '/___graphql',
+        },
+    };
+    return Object.keys(panels).map((key) => {
+        return { ...panels[key], id: key };
+    });
+}
diff --git a/dist/dist/esnext/foundation/DevTools/components/Performance.client.d.ts b/dist/dist/esnext/foundation/DevTools/components/Performance.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1031028d7309dbdcb3b3961da1e2d5112df69947
--- /dev/null
+++ b/dist/dist/esnext/foundation/DevTools/components/Performance.client.d.ts
@@ -0,0 +1,14 @@
+interface Navigation {
+    url: string;
+    type: string;
+    ttfb: number;
+    fcp: number;
+    lcp: number;
+    duration: number;
+    size: number;
+}
+interface Props {
+    navigations: Navigation[];
+}
+export declare function Performance({ navigations }: Props): JSX.Element;
+export {};
diff --git a/dist/dist/esnext/foundation/DevTools/components/Performance.client.js b/dist/dist/esnext/foundation/DevTools/components/Performance.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..56aa635cd6e4f1084c005ce32f9b6c990733df1c
--- /dev/null
+++ b/dist/dist/esnext/foundation/DevTools/components/Performance.client.js
@@ -0,0 +1,25 @@
+import React from 'react';
+import { Heading } from './Heading.js';
+export function Performance({ navigations }) {
+    const navigationsMarkup = navigations.map(({ url, ttfb, fcp, size, duration, type }) => (React.createElement("li", { key: url, style: { padding: '0.5em 0', borderBottom: '1px solid' } },
+        React.createElement(Item, { label: type, value: url.replace('http://localhost:3000', '') }),
+        React.createElement("div", { style: { display: 'flex' } },
+            React.createElement(Item, { label: "TTFB", value: ttfb }),
+            React.createElement(Item, { label: "Duration", value: duration }),
+            React.createElement(Item, { label: "FCP", value: fcp })))));
+    return (React.createElement(React.Fragment, null,
+        React.createElement(Heading, null, "Performance"),
+        React.createElement("ul", null, navigationsMarkup)));
+}
+const Item = ({ label, value, unit }) => {
+    if (!value) {
+        return null;
+    }
+    const val = typeof value === 'string' ? (React.createElement("span", { style: { fontWeight: 'bold' } }, value)) : (`${Math.round(value)}${unit || 'ms'}`);
+    return (React.createElement("span", { style: {
+            fontFamily: 'monospace',
+            padding: '0 2em 0 0',
+        } },
+        label && label.padEnd(10),
+        val));
+};
diff --git a/dist/dist/esnext/foundation/DevTools/components/Settings.client.d.ts b/dist/dist/esnext/foundation/DevTools/components/Settings.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8e91d60c24efbe1abce69ee1c5440b0e7b99ae72
--- /dev/null
+++ b/dist/dist/esnext/foundation/DevTools/components/Settings.client.d.ts
@@ -0,0 +1,8 @@
+import { Locale } from '../../ShopifyProvider/types.js';
+interface Props {
+    locale: Locale;
+    storeDomain: string;
+    storefrontApiVersion: string;
+}
+export declare function Settings(props: Props): JSX.Element;
+export {};
diff --git a/dist/dist/esnext/foundation/DevTools/components/Settings.client.js b/dist/dist/esnext/foundation/DevTools/components/Settings.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..3a225bca44328ef87cd0b29e87e146183cf733b7
--- /dev/null
+++ b/dist/dist/esnext/foundation/DevTools/components/Settings.client.js
@@ -0,0 +1,17 @@
+import React from 'react';
+import { Table } from './Table.js';
+const KEY_MAP = {
+    locale: 'Locale',
+    storeDomain: 'Domain',
+    storefrontApiVersion: 'API Version',
+};
+export function Settings(props) {
+    const items = Object.entries(props).map(([key, value]) => {
+        return {
+            key: KEY_MAP[key],
+            value,
+            type: typeof value,
+        };
+    });
+    return React.createElement(Table, { items: items });
+}
diff --git a/dist/dist/esnext/foundation/DevTools/components/Table.d.ts b/dist/dist/esnext/foundation/DevTools/components/Table.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fa152f18cf005a0db2bece89ba362d9d2353b35f
--- /dev/null
+++ b/dist/dist/esnext/foundation/DevTools/components/Table.d.ts
@@ -0,0 +1,9 @@
+interface Item {
+    key: string;
+    value: string;
+}
+interface TableProps {
+    items: Item[];
+}
+export declare function Table({ items }: TableProps): JSX.Element;
+export {};
diff --git a/dist/dist/esnext/foundation/DevTools/components/Table.js b/dist/dist/esnext/foundation/DevTools/components/Table.js
new file mode 100644
index 0000000000000000000000000000000000000000..2d26b5bf1104505acd96d4ba82f784bca32877e6
--- /dev/null
+++ b/dist/dist/esnext/foundation/DevTools/components/Table.js
@@ -0,0 +1,7 @@
+import React from 'react';
+export function Table({ items }) {
+    const itemsMarkup = items.map(({ key, value }) => (React.createElement("div", { key: key, style: { display: 'flex', paddingBottom: '1em', flexDirection: 'column' } },
+        React.createElement("span", { style: { fontWeight: 'bold' } }, key),
+        React.createElement("span", { style: { width: '70%', fontFamily: 'monospace' } }, value))));
+    return React.createElement("ul", null, itemsMarkup);
+}
diff --git a/dist/dist/esnext/foundation/DevTools/components/icons.d.ts b/dist/dist/esnext/foundation/DevTools/components/icons.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6be93587d5e916871630d23a472728483cd1c15c
--- /dev/null
+++ b/dist/dist/esnext/foundation/DevTools/components/icons.d.ts
@@ -0,0 +1,2 @@
+export declare const CloseIcon: () => JSX.Element;
+export declare const HydrogenIcon: () => JSX.Element;
diff --git a/dist/dist/esnext/foundation/DevTools/components/icons.js b/dist/dist/esnext/foundation/DevTools/components/icons.js
new file mode 100644
index 0000000000000000000000000000000000000000..ad3774e21fd655e89ba266bfaa392f1f0919e50b
--- /dev/null
+++ b/dist/dist/esnext/foundation/DevTools/components/icons.js
@@ -0,0 +1,13 @@
+import React from 'react';
+export const CloseIcon = () => (React.createElement("svg", { style: {
+        height: '2.75em',
+        width: '2.75em',
+        padding: '1em',
+    }, viewBox: "0 0 460.775 460.775", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
+    React.createElement("path", { fill: "black", d: "M285.08,230.397L456.218,59.27c6.076-6.077,6.076-15.911,0-21.986L423.511,4.565c-2.913-2.911-6.866-4.55-10.992-4.55\n\tc-4.127,0-8.08,1.639-10.993,4.55l-171.138,171.14L59.25,4.565c-2.913-2.911-6.866-4.55-10.993-4.55\n\tc-4.126,0-8.08,1.639-10.992,4.55L4.558,37.284c-6.077,6.075-6.077,15.909,0,21.986l171.138,171.128L4.575,401.505\n\tc-6.074,6.077-6.074,15.911,0,21.986l32.709,32.719c2.911,2.911,6.865,4.55,10.992,4.55c4.127,0,8.08-1.639,10.994-4.55\n\tl171.117-171.12l171.118,171.12c2.913,2.911,6.866,4.55,10.993,4.55c4.128,0,8.081-1.639,10.992-4.55l32.709-32.719\n\tc6.074-6.075,6.074-15.909,0-21.986L285.08,230.397z" })));
+export const HydrogenIcon = () => (React.createElement("svg", { style: {
+        height: '2.5em',
+        width: '2.5em',
+    }, width: "131", height: "130", viewBox: "0 0 131 130", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
+    React.createElement("path", { d: "M64.9548 106.281L27.1377 86.1894L40.0714 79.3723L54.6329 87.1049L66.851 80.6638L52.2895 72.9313L65.2231 66.0979L103.04 86.1894L90.1065 93.0064L76.35 85.6989L64.114 92.1563L77.8884 99.4638L64.9548 106.281Z", fill: "black" }),
+    React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M65.2247 25L105.178 46.2267L90.105 54.1716L76.3488 46.8642L66.2525 52.1924L80.028 59.5005L64.9532 67.446L25 46.2196L40.0734 38.2748L54.6349 46.0073L64.713 40.6944L50.1533 32.9628L65.2247 25ZM54.4262 32.9673L68.9896 40.7008L54.6315 48.27L40.0699 40.5374L29.276 46.2267L64.9569 65.1833L75.7495 59.4947L61.9761 52.1878L76.3518 44.6012L90.1087 51.9088L100.902 46.2196L65.2221 27.2634L54.4262 32.9673Z", fill: "black" })));
diff --git a/dist/dist/esnext/foundation/DevTools/components/index.d.ts b/dist/dist/esnext/foundation/DevTools/components/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f0384c8f8e96688e73e024ce1169f4b9e8e3ff28
--- /dev/null
+++ b/dist/dist/esnext/foundation/DevTools/components/index.d.ts
@@ -0,0 +1,2 @@
+export { Interface } from './Interface.client.js';
+export { Panels } from './Panels.js';
diff --git a/dist/dist/esnext/foundation/DevTools/components/index.js b/dist/dist/esnext/foundation/DevTools/components/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..f0384c8f8e96688e73e024ce1169f4b9e8e3ff28
--- /dev/null
+++ b/dist/dist/esnext/foundation/DevTools/components/index.js
@@ -0,0 +1,2 @@
+export { Interface } from './Interface.client.js';
+export { Panels } from './Panels.js';
diff --git a/dist/dist/esnext/foundation/FileRoutes/FileRoutes.server.d.ts b/dist/dist/esnext/foundation/FileRoutes/FileRoutes.server.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..88b036ee23b5a33e69981ee08ca5aacd0c60ad28
--- /dev/null
+++ b/dist/dist/esnext/foundation/FileRoutes/FileRoutes.server.d.ts
@@ -0,0 +1,22 @@
+import type { ImportGlobEagerOutput } from '../../types.js';
+interface FileRoutesProps {
+    /** The routes defined by Vite's [import.meta.globEager](https://vitejs.dev/guide/features.html#glob-import) method. */
+    routes?: ImportGlobEagerOutput;
+    /** A path that's prepended to all file routes. You can modify `basePath` if you want to prefix all file routes. For example, you can prefix all file routes with a locale. */
+    basePath?: string;
+    /** The portion of the file route path that shouldn't be a part of the URL. You need to modify this if you want to import routes from a location other than the default `src/routes`. */
+    dirPrefix?: string | RegExp;
+}
+/**
+ * The `FileRoutes` component builds a set of default Hydrogen routes based on the output provided by Vite's
+ * [import.meta.globEager](https://vitejs.dev/guide/features.html#glob-import) method. You can have multiple
+ * instances of this component to source file routes from multiple locations.
+ */
+export declare function FileRoutes({ routes, basePath, dirPrefix }: FileRoutesProps): JSX.Element | null;
+interface HydrogenRoute {
+    component: any;
+    path: string;
+    exact: boolean;
+}
+export declare function createPageRoutes(pages: ImportGlobEagerOutput, topLevelPath?: string, dirPrefix?: string | RegExp): HydrogenRoute[];
+export {};
diff --git a/dist/dist/esnext/foundation/FileRoutes/FileRoutes.server.js b/dist/dist/esnext/foundation/FileRoutes/FileRoutes.server.js
new file mode 100644
index 0000000000000000000000000000000000000000..ee5be2f69252b33f8d63f0b32cb62d3679b9c562
--- /dev/null
+++ b/dist/dist/esnext/foundation/FileRoutes/FileRoutes.server.js
@@ -0,0 +1,69 @@
+import React, { useMemo } from 'react';
+import { matchPath } from '../../utilities/matchPath.js';
+import { log } from '../../utilities/log/index.js';
+import { extractPathFromRoutesKey } from '../../utilities/apiRoutes.js';
+import { useServerRequest } from '../ServerRequestProvider/index.js';
+import { RouteParamsProvider } from '../useRouteParams/RouteParamsProvider.client.js';
+/**
+ * The `FileRoutes` component builds a set of default Hydrogen routes based on the output provided by Vite's
+ * [import.meta.globEager](https://vitejs.dev/guide/features.html#glob-import) method. You can have multiple
+ * instances of this component to source file routes from multiple locations.
+ */
+export function FileRoutes({ routes, basePath, dirPrefix }) {
+    const request = useServerRequest();
+    const { routeRendered, serverProps } = request.ctx.router;
+    if (routeRendered)
+        return null;
+    if (!routes) {
+        const fileRoutes = request.ctx.hydrogenConfig.routes;
+        routes = fileRoutes.files;
+        dirPrefix ??= fileRoutes.dirPrefix;
+        basePath ??= fileRoutes.basePath;
+    }
+    basePath ??= '/';
+    const pageRoutes = useMemo(() => createPageRoutes(routes, basePath, dirPrefix), [routes, basePath, dirPrefix]);
+    let foundRoute, foundRouteDetails;
+    for (let i = 0; i < pageRoutes.length; i++) {
+        foundRouteDetails = matchPath(serverProps.pathname, pageRoutes[i]);
+        if (foundRouteDetails) {
+            foundRoute = pageRoutes[i];
+            break;
+        }
+    }
+    if (foundRoute) {
+        request.ctx.router.routeRendered = true;
+        request.ctx.router.routeParams = foundRouteDetails.params;
+        return (React.createElement(RouteParamsProvider, { routeParams: foundRouteDetails.params, basePath: basePath },
+            React.createElement(foundRoute.component, { params: foundRouteDetails.params, ...serverProps })));
+    }
+    return null;
+}
+export function createPageRoutes(pages, topLevelPath = '*', dirPrefix = '') {
+    const topLevelPrefix = topLevelPath.replace('*', '').replace(/\/$/, '');
+    const keys = Object.keys(pages);
+    const routes = keys
+        .map((key) => {
+        const path = extractPathFromRoutesKey(key, dirPrefix);
+        /**
+         * Catch-all routes [...handle].jsx don't need an exact match
+         * https://reactrouter.com/core/api/Route/exact-bool
+         */
+        const exact = !/\[(?:[.]{3})(\w+?)\]/.test(key);
+        if (!pages[key].default && !pages[key].api) {
+            log?.warn(`${key} doesn't export a default React component or an API function`);
+        }
+        return {
+            path: topLevelPrefix + path,
+            component: pages[key].default,
+            exact,
+        };
+    })
+        .filter((route) => route.component);
+    /**
+     * Place static paths BEFORE dynamic paths to grant priority.
+     */
+    return [
+        ...routes.filter((route) => !route.path.includes(':')),
+        ...routes.filter((route) => route.path.includes(':')),
+    ];
+}
diff --git a/dist/dist/esnext/foundation/FileSessionStorage/FileSessionStorage.d.ts b/dist/dist/esnext/foundation/FileSessionStorage/FileSessionStorage.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d3e58cb810dda42e17702b0d60d47c01610f5898
--- /dev/null
+++ b/dist/dist/esnext/foundation/FileSessionStorage/FileSessionStorage.d.ts
@@ -0,0 +1,6 @@
+import type { SessionStorageAdapter } from '../session/session-types.js';
+import type { CookieOptions } from '../Cookie/Cookie.js';
+import { Logger } from '../../utilities/log/index.js';
+/** The `FileSessionStorage` component persists session data to the file system.
+ */
+export declare const FileSessionStorage: (name: string, dir: string, cookieOptions: CookieOptions) => (log: Logger) => SessionStorageAdapter;
diff --git a/dist/dist/esnext/foundation/FileSessionStorage/FileSessionStorage.js b/dist/dist/esnext/foundation/FileSessionStorage/FileSessionStorage.js
new file mode 100644
index 0000000000000000000000000000000000000000..2b05611f6e1a6e85c55d0ff47b242c8eff0fb4bb
--- /dev/null
+++ b/dist/dist/esnext/foundation/FileSessionStorage/FileSessionStorage.js
@@ -0,0 +1,149 @@
+import { Cookie } from '../Cookie/Cookie.js';
+import { v4 as uid } from 'uuid';
+import path from 'path';
+import { promises as fsp } from 'fs';
+import { parseJSON } from '../../utilities/parse.js';
+async function wait() {
+    return new Promise((resolve) => setTimeout(resolve));
+}
+let writingLock = false;
+/**
+ * Concurrent requests with the same session can write interfere
+ * writing at the same file, which crashes the process. This locks
+ * so that only one file can be written at a time.
+ *
+ * A better solution would be to have a lock only for the same session.
+ */
+async function startFileLock(promise) {
+    if (!writingLock) {
+        writingLock = true;
+        await promise();
+        writingLock = false;
+    }
+    else {
+        await wait();
+        await startFileLock(promise);
+    }
+}
+/** The `FileSessionStorage` component persists session data to the file system.
+ */
+export const FileSessionStorage = function (
+/** The name of the cookie stored in the browser. */
+name, 
+/** A directory to store the session files in. Each session is stored in a separate file on the file system. */
+dir, 
+/** An optional object to configure [how the cookie is persisted in the browser](https://shopify.dev/api/hydrogen/components/framework/cookie#cookie-options). */
+cookieOptions) {
+    return function (log) {
+        const cookie = new Cookie(name, cookieOptions);
+        let data;
+        return {
+            async get(request) {
+                if (data)
+                    return data;
+                const sid = cookie.getSessionId(request) || uid();
+                const file = getSessionFile(dir, sid);
+                const fileContents = await getFile(file, cookie.expires, log);
+                data = fileContents.data;
+                return data;
+            },
+            async set(request, value) {
+                const sid = cookie.getSessionId(request) || uid();
+                const file = getSessionFile(dir, sid);
+                await writeFile(file, value, cookie.expires);
+                data = value;
+                cookie.setSessionid(sid);
+                return cookie.serialize();
+            },
+            async destroy(request) {
+                const sid = cookie.getSessionId(request);
+                if (sid) {
+                    const file = getSessionFile(dir, sid);
+                    await deleteFile(file);
+                }
+                data = undefined;
+                // @todo - set expires for Date in past
+                return cookie.destroy();
+            },
+        };
+    };
+};
+async function getFile(file, expires, log) {
+    let content = null;
+    const defaultFileContent = {
+        data: {},
+        expires,
+    };
+    await startFileLock(async () => {
+        try {
+            const textContent = await fsp.readFile(file, { encoding: 'utf-8' });
+            try {
+                content = parseJSON(textContent);
+            }
+            catch (error) {
+                log.warn(`Cannot parse existing session file: ${file}`);
+                content = defaultFileContent;
+            }
+            if (content.expires < new Date().getTime() ||
+                content === defaultFileContent) {
+                await fsp.unlink(file);
+                await fsp.writeFile(file, JSON.stringify(defaultFileContent), {
+                    encoding: 'utf-8',
+                    flag: 'wx',
+                });
+                content = defaultFileContent;
+            }
+        }
+        catch (error) {
+            if (error.code !== 'ENOENT')
+                throw error;
+            await fsp.mkdir(path.dirname(file), { recursive: true });
+            await fsp.writeFile(file, JSON.stringify(defaultFileContent), {
+                encoding: 'utf-8',
+                flag: 'wx',
+            });
+        }
+    });
+    return content ? content : defaultFileContent;
+}
+async function writeFile(file, data, expires) {
+    const content = {
+        data,
+        expires,
+    };
+    await startFileLock(async () => {
+        try {
+            await fsp.mkdir(path.dirname(file), { recursive: true });
+        }
+        catch (error) {
+            // directory already exists
+            if (error.code !== 'EEXIST')
+                throw error;
+        }
+        try {
+            await fsp.unlink(file);
+        }
+        catch (error) {
+            if (error.code !== 'ENOENT')
+                throw error;
+        }
+        await fsp.writeFile(file, JSON.stringify(content), {
+            encoding: 'utf-8',
+            flag: 'wx',
+        });
+    });
+}
+async function deleteFile(file) {
+    try {
+        await startFileLock(async () => {
+            await fsp.unlink(file);
+        });
+    }
+    catch (error) {
+        if (error.code !== 'ENOENT')
+            throw error;
+    }
+}
+function getSessionFile(dir, sid) {
+    return path.join(dir, sid.slice(0, 3), sid.slice(3));
+}
diff --git a/dist/dist/esnext/foundation/Form/Form.client.d.ts b/dist/dist/esnext/foundation/Form/Form.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d82b2525133d6de6733c6c312b8ac2aa6c80d54d
--- /dev/null
+++ b/dist/dist/esnext/foundation/Form/Form.client.d.ts
@@ -0,0 +1,11 @@
+import React, { FormEvent } from 'react';
+interface FormProps {
+    action: string;
+    method?: string;
+    children?: Array<React.ReactNode>;
+    onSubmit?: (e: FormEvent<HTMLFormElement>) => void;
+    encType?: string;
+    noValidate?: boolean;
+}
+export declare function Form({ action, method, children, onSubmit, encType, noValidate, ...props }: FormProps): JSX.Element;
+export {};
diff --git a/dist/dist/esnext/foundation/Form/Form.client.js b/dist/dist/esnext/foundation/Form/Form.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..459db0ec54b83827b9362051170ec252ffa271fa
--- /dev/null
+++ b/dist/dist/esnext/foundation/Form/Form.client.js
@@ -0,0 +1,51 @@
+import React, { useCallback, useState } from 'react';
+// @ts-ignore
+import { createFromFetch } from '@shopify/hydrogen/vendor/react-server-dom-vite';
+import { useInternalServerProps } from '../useServerProps/use-server-props.js';
+export function Form({ action, method, children, onSubmit, encType = 'application/x-www-form-urlencoded', noValidate, ...props }) {
+    const { setRscResponseFromApiRoute } = useInternalServerProps();
+    const [_, startTransition] = React.useTransition();
+    const [loading, setLoading] = useState(false);
+    const [error, setError] = useState(null);
+    const submit = useCallback(async (e) => {
+        onSubmit && onSubmit(e);
+        if (e.defaultPrevented)
+            return;
+        setLoading(true);
+        e.preventDefault();
+        const formData = new FormData(e.target);
+        // @ts-expect-error
+        // It's valid to pass a FormData instance to a URLSearchParams constructor
+        // @todo - support multipart forms
+        const formBody = new URLSearchParams(formData);
+        startTransition(() => {
+            fetch(action, {
+                method,
+                headers: {
+                    'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8',
+                    'Hydrogen-Client': 'Form-Action',
+                },
+                body: formBody.toString(),
+            })
+                .then((fetchResponse) => {
+                const rscPathname = fetchResponse.headers.get('Hydrogen-RSC-Pathname');
+                if (!rscPathname)
+                    throw new Error(`The component's \`action\` attribute must point to an API route that responds with a new Request()\nRead more at https://shopify.dev/custom-storefronts/hydrogen/framework/forms`);
+                if (rscPathname !== window.location.pathname) {
+                    window.history.pushState(null, '', rscPathname);
+                }
+                const rscResponse = createFromFetch(Promise.resolve(fetchResponse));
+                setRscResponseFromApiRoute({
+                    url: method + action,
+                    response: rscResponse,
+                });
+                setLoading(false);
+            })
+                .catch((error) => {
+                setError(error);
+                setLoading(false);
+            });
+        });
+    }, [onSubmit, startTransition, action, method, setRscResponseFromApiRoute]);
+    return (React.createElement("form", { action: action, method: method, onSubmit: submit, encType: "application/x-www-form-urlencoded", noValidate: noValidate, ...props }, children instanceof Function ? children({ loading, error }) : children));
+}
diff --git a/dist/dist/esnext/foundation/Head/Head.client.d.ts b/dist/dist/esnext/foundation/Head/Head.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a22ea57b5e9abd14785bca1ce9667c4e50120666
--- /dev/null
+++ b/dist/dist/esnext/foundation/Head/Head.client.d.ts
@@ -0,0 +1,5 @@
+import React from 'react';
+import { HelmetProps as HeadProps } from 'react-helmet-async';
+export declare function Head({ children, ...props }: HeadProps & {
+    children: React.ReactNode;
+}): JSX.Element;
diff --git a/dist/dist/esnext/foundation/Head/Head.client.js b/dist/dist/esnext/foundation/Head/Head.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..694df5772ed28097a5dc2c1d43a9b5d9166e83bb
--- /dev/null
+++ b/dist/dist/esnext/foundation/Head/Head.client.js
@@ -0,0 +1,10 @@
+import React from 'react';
+import { Helmet, HelmetData as HeadData, } from 'react-helmet-async';
+import { useEnvContext } from '../ssr-interop.js';
+const clientHeadData = new HeadData({});
+export function Head({ children, ...props }) {
+    const headData = useEnvContext((req) => req.ctx.head, clientHeadData);
+    return (
+    // @ts-ignore
+    React.createElement(Helmet, { ...props, helmetData: headData }, children));
+}
diff --git a/dist/dist/esnext/foundation/Head/index.d.ts b/dist/dist/esnext/foundation/Head/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..39f1b688d7ad4983e23930e5d697ef4ae1b8a353
--- /dev/null
+++ b/dist/dist/esnext/foundation/Head/index.d.ts
@@ -0,0 +1 @@
+export { Head } from './Head.client.js';
diff --git a/dist/dist/esnext/foundation/Head/index.js b/dist/dist/esnext/foundation/Head/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..39f1b688d7ad4983e23930e5d697ef4ae1b8a353
--- /dev/null
+++ b/dist/dist/esnext/foundation/Head/index.js
@@ -0,0 +1 @@
+export { Head } from './Head.client.js';
diff --git a/dist/dist/esnext/foundation/Html/Html.d.ts b/dist/dist/esnext/foundation/Html/Html.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..55fe4005dc325813d6a1dc228b5c484c6ca7b337
--- /dev/null
+++ b/dist/dist/esnext/foundation/Html/Html.d.ts
@@ -0,0 +1,13 @@
+import { ReactNode } from 'react';
+import type { HelmetData as HeadData } from 'react-helmet-async';
+import { ResolvedHydrogenConfig } from '../../types.js';
+declare type HtmlOptions = {
+    children: ReactNode;
+    template: string;
+    htmlAttrs?: Record<string, string>;
+    bodyAttrs?: Record<string, string>;
+    hydrogenConfig: ResolvedHydrogenConfig;
+};
+export declare function Html({ children, template, htmlAttrs, bodyAttrs, hydrogenConfig, }: HtmlOptions): JSX.Element;
+export declare function applyHtmlHead(html: string, head: HeadData, template: string): string;
+export {};
diff --git a/dist/dist/esnext/foundation/Html/Html.js b/dist/dist/esnext/foundation/Html/Html.js
new file mode 100644
index 0000000000000000000000000000000000000000..c71a48e64652b705f985e028aab356668fcbf8df
--- /dev/null
+++ b/dist/dist/esnext/foundation/Html/Html.js
@@ -0,0 +1,96 @@
+/// <reference types="vite/client" />
+import React from 'react';
+const HTML_ATTR_SEP_RE = /(?<!=)"\s+/gim;
+const getHtmlAttrs = (template) => template.match(/<html\s+([^>]+?)\s*>/s)?.[1] || '';
+const getBodyAttrs = (template) => template.match(/<body\s+([^>]+?)\s*>/s)?.[1] || '';
+const REACT_ATTR_MAP = Object.create(null);
+REACT_ATTR_MAP.class = 'className';
+REACT_ATTR_MAP.style = 'data-style'; // Ignore string styles, it breaks React
+function attrsToProps(attrs) {
+    attrs = attrs?.trim();
+    // Assume all attributes are surrounded by double quotes.
+    return attrs
+        ? Object.fromEntries(attrs.split(HTML_ATTR_SEP_RE).map((attr) => {
+            const [key, value] = attr.replace(/"/g, '').split(/=(.+)/);
+            return [REACT_ATTR_MAP[key.toLowerCase()] || key, value];
+        }))
+        : {};
+}
+function propsToAttrs(props) {
+    return Object.entries(props)
+        .map(([key, value]) => `${key === REACT_ATTR_MAP.class ? 'class' : key}="${value}"`)
+        .join(' ');
+}
+const clientConfigOptions = ['strictMode'];
+export function Html({ children, template, htmlAttrs, bodyAttrs, hydrogenConfig, }) {
+    let head = template.match(/<head>(.+?)<\/head>/s)[1] || '';
+    // @ts-ignore
+    if (import.meta.env.DEV) {
+        // Fix React Refresh for async scripts.
+        // https://github.com/vitejs/vite/issues/6759
+        head =
+            '<script></script>' + // Fix for Firefox: https://bugzilla.mozilla.org/show_bug.cgi?id=1737882
+                head.replace(/>(\s*?import[\s\w]+?['"]\/@react-refresh)/, ' async="">$1');
+    }
+    const clientConfig = {};
+    for (const key of clientConfigOptions) {
+        if (hydrogenConfig[key] != null) {
+            clientConfig[key] = hydrogenConfig[key];
+        }
+    }
+    const clientConfigAttr = Object.keys(clientConfig).length > 0
+        ? JSON.stringify(clientConfig)
+        : undefined;
+    return (React.createElement("html", { ...attrsToProps(getHtmlAttrs(template)), ...htmlAttrs },
+        React.createElement("head", { dangerouslySetInnerHTML: { __html: head } }),
+        React.createElement("body", { ...attrsToProps(getBodyAttrs(template)), ...bodyAttrs },
+            React.createElement("div", { id: "root", "data-client-config": clientConfigAttr }, children))));
+}
+export function applyHtmlHead(html, head, template) {
+    const { bodyAttrs, htmlAttrs, ...headTags } = extractHeadElements(head, template);
+    return html
+        .replace(/<head>(.*?)<\/head>/s, generateHeadTag(headTags))
+        .replace(/<html[^>]*?>/s, htmlAttrs ? `<html ${htmlAttrs}>` : '$&')
+        .replace(/<body[^>]*?>/s, bodyAttrs ? `<body ${bodyAttrs}>` : '$&');
+}
+function extractHeadElements({ context: { helmet } }, template) {
+    // There might be existing attributes in the template that are
+    // duplicated in the helmet. Transform them to props and back
+    // to string attributes to remove duplicates.
+    const htmlUniqueProps = attrsToProps(`${getHtmlAttrs(template)} ${helmet.htmlAttributes}`);
+    const bodyUniqueProps = attrsToProps(`${getBodyAttrs(template)} ${helmet.bodyAttributes}`);
+    return {
+        htmlAttrs: propsToAttrs(htmlUniqueProps),
+        bodyAttrs: propsToAttrs(bodyUniqueProps),
+        base: helmet.base.toString(),
+        link: helmet.link.toString(),
+        meta: helmet.meta.toString(),
+        noscript: helmet.noscript.toString(),
+        script: helmet.script.toString(),
+        style: helmet.style.toString(),
+        title: helmet.title.toString(),
+    };
+}
+/**
+ * Generate the contents of the `head` tag, and update the existing `<title>` tag
+ * if one exists, and if a title is passed.
+ */
+function generateHeadTag({ title, ...rest }) {
+    const headProps = ['base', 'meta', 'style', 'noscript', 'script', 'link'];
+    const otherHeadProps = headProps
+        .map((prop) => rest[prop])
+        .filter(Boolean)
+        .join('\n');
+    return (_outerHtml, innerHtml) => {
+        let headHtml = otherHeadProps + innerHtml;
+        if (title) {
+            if (headHtml.includes('<title>')) {
+                headHtml = headHtml.replace(/(<title>(?:.|\n)*?<\/title>)/, title);
+            }
+            else {
+                headHtml += title;
+            }
+        }
+        return `<head>${headHtml}</head>`;
+    };
+}
diff --git a/dist/dist/esnext/foundation/HydrogenRequest/HydrogenRequest.server.d.ts b/dist/dist/esnext/foundation/HydrogenRequest/HydrogenRequest.server.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5a890c9e285280bbadd72ef13db00296792b1e8d
--- /dev/null
+++ b/dist/dist/esnext/foundation/HydrogenRequest/HydrogenRequest.server.d.ts
@@ -0,0 +1,77 @@
+import type { ShopifyContextServerValue, LocalizationContextValue } from '../ShopifyProvider/types.js';
+import type { QueryCacheControlHeaders } from '../../utilities/log/log-cache-header.js';
+import type { QueryTiming } from '../../utilities/log/log-query-timeline.js';
+import type { ResolvedHydrogenConfig, PreloadOptions, QueryKey, RuntimeContext } from '../../types.js';
+import { HelmetData as HeadData } from 'react-helmet-async';
+import type { SessionSyncApi } from '../session/session-types.js';
+export declare type PreloadQueryEntry = {
+    key: QueryKey;
+    fetcher: (request: HydrogenRequest) => Promise<unknown>;
+    preload?: PreloadOptions;
+};
+export declare type PreloadQueriesByURL = Map<string, PreloadQueryEntry>;
+export declare type AllPreloadQueries = Map<string, PreloadQueriesByURL>;
+export declare type RouterContextData = {
+    routeRendered: boolean;
+    serverProps: Record<string, any>;
+    routeParams: Record<string, string>;
+};
+/**
+ * This augments the `Request` object from the Fetch API:
+ * @see https://developer.mozilla.org/en-US/docs/Web/API/Request
+ *
+ * - Adds a `cookies` map for easy access
+ * - Adds a static constructor to convert a Node.js `IncomingMessage` to a Request.
+ */
+export declare class HydrogenRequest extends Request {
+    /**
+     * A Map of cookies for easy access.
+     */
+    cookies: Map<string, string>;
+    id: string;
+    time: number;
+    /**
+     * Get the canonical URL for the current page, across SSR and RSC requests.
+     */
+    normalizedUrl: string;
+    ctx: {
+        cache: Map<string, any>;
+        head: HeadData;
+        hydrogenConfig?: ResolvedHydrogenConfig;
+        shopifyConfig?: ShopifyContextServerValue;
+        queryCacheControl: Array<QueryCacheControlHeaders>;
+        queryTimings: Array<QueryTiming>;
+        preloadQueries: PreloadQueriesByURL;
+        analyticsData: any;
+        router: RouterContextData;
+        buyerIpHeader?: string;
+        session?: SessionSyncApi;
+        flashSession: Record<string, any>;
+        runtime?: RuntimeContext;
+        scopes: Map<string, Record<string, any>>;
+        localization?: LocalizationContextValue;
+        [key: string]: any;
+        throttledRequests: Record<string, any>;
+    };
+    constructor(input: any);
+    constructor(input: RequestInfo, init?: RequestInit);
+    previouslyLoadedRequest(): boolean;
+    private parseCookies;
+    isRscRequest(): boolean;
+    savePreloadQuery(query: PreloadQueryEntry): void;
+    getPreloadQueries(): PreloadQueriesByURL | undefined;
+    savePreloadQueries(): void;
+    /**
+     * Buyer IP varies by hosting provider and runtime. The developer should provide this
+     * as an argument to the `handleRequest` function for their runtime.
+     * Defaults to `x-forwarded-for` header value.
+     */
+    getBuyerIp(): string | null;
+    /**
+     * Build a `cacheKey` in the form of a `Request` to be used in full-page
+     * caching.
+     * - lockKey generates a placeholder cache key
+     */
+    cacheKey(lockKey?: boolean): Request;
+    formData(): Promise<FormData>;
+}
diff --git a/dist/dist/esnext/foundation/HydrogenRequest/HydrogenRequest.server.js b/dist/dist/esnext/foundation/HydrogenRequest/HydrogenRequest.server.js
new file mode 100644
index 0000000000000000000000000000000000000000..da3d87a627f0e10414698476020af49cd56af9a5
--- /dev/null
+++ b/dist/dist/esnext/foundation/HydrogenRequest/HydrogenRequest.server.js
@@ -0,0 +1,210 @@
+import { getTime } from '../../utilities/timing.js';
+import { hashKey } from '../../utilities/hash.js';
+import { HelmetData as HeadData } from 'react-helmet-async';
+import { RSC_PATHNAME } from '../../constants.js';
+import { parseJSON } from '../../utilities/parse.js';
+let reqCounter = 0; // For debugging
+const generateId = typeof crypto !== 'undefined' &&
+    // @ts-ignore
+    !!crypto.randomUUID
+    ? // @ts-ignore
+        () => crypto.randomUUID()
+    : () => `req${++reqCounter}`;
+// Stores queries by url or '*'
+const preloadCache = new Map();
+const previouslyLoadedUrls = {};
+const PRELOAD_ALL = '*';
+/**
+ * This augments the `Request` object from the Fetch API:
+ * @see https://developer.mozilla.org/en-US/docs/Web/API/Request
+ *
+ * - Adds a `cookies` map for easy access
+ * - Adds a static constructor to convert a Node.js `IncomingMessage` to a Request.
+ */
+export class HydrogenRequest extends Request {
+    /**
+     * A Map of cookies for easy access.
+     */
+    cookies;
+    id;
+    time;
+    /**
+     * Get the canonical URL for the current page, across SSR and RSC requests.
+     */
+    normalizedUrl;
+    // CFW Request has a reserved 'context' property, use 'ctx' instead.
+    ctx;
+    constructor(input, init) {
+        if (input instanceof Request) {
+            super(input, init);
+        }
+        else {
+            super(getUrlFromNodeRequest(input), getInitFromNodeRequest(input));
+        }
+        this.time = getTime();
+        this.id = generateId();
+        this.normalizedUrl = decodeURIComponent(this.isRscRequest() ? normalizeUrl(this.url) : this.url);
+        this.ctx = {
+            cache: new Map(),
+            head: new HeadData({}),
+            router: {
+                routeRendered: false,
+                serverProps: {},
+                routeParams: {},
+            },
+            queryCacheControl: [],
+            queryTimings: [],
+            analyticsData: {
+                url: this.url,
+                normalizedRscUrl: this.normalizedUrl,
+            },
+            preloadQueries: new Map(),
+            scopes: new Map(),
+            flashSession: {},
+            throttledRequests: {},
+        };
+        this.cookies = this.parseCookies();
+    }
+    previouslyLoadedRequest() {
+        if (previouslyLoadedUrls[this.normalizedUrl] > 1)
+            return true;
+        previouslyLoadedUrls[this.normalizedUrl] = previouslyLoadedUrls[this.normalizedUrl]
+            ? 2
+            : 1;
+        return false;
+    }
+    parseCookies() {
+        const cookieString = this.headers.get('cookie') || '';
+        return new Map(cookieString
+            .split(';')
+            .map((chunk) => chunk.trim())
+            .filter((chunk) => chunk !== '')
+            .map((chunk) => chunk.split(/=(.+)/)));
+    }
+    isRscRequest() {
+        const url = new URL(this.url);
+        return url.pathname === RSC_PATHNAME;
+    }
+    savePreloadQuery(query) {
+        if (query.preload === PRELOAD_ALL) {
+            saveToPreloadAllPreload(query);
+        }
+        else {
+            this.ctx.preloadQueries.set(hashKey(query.key), query);
+        }
+    }
+    getPreloadQueries() {
+        if (preloadCache.has(this.normalizedUrl)) {
+            const combinedPreloadQueries = new Map();
+            const urlPreloadCache = preloadCache.get(this.normalizedUrl);
+            mergeMapEntries(combinedPreloadQueries, urlPreloadCache);
+            mergeMapEntries(combinedPreloadQueries, preloadCache.get(PRELOAD_ALL));
+            return combinedPreloadQueries;
+        }
+        else if (preloadCache.has(PRELOAD_ALL)) {
+            return preloadCache.get(PRELOAD_ALL);
+        }
+    }
+    savePreloadQueries() {
+        preloadCache.set(this.normalizedUrl, this.ctx.preloadQueries);
+    }
+    /**
+     * Buyer IP varies by hosting provider and runtime. The developer should provide this
+     * as an argument to the `handleRequest` function for their runtime.
+     * Defaults to `x-forwarded-for` header value.
+     */
+    getBuyerIp() {
+        return this.headers.get(this.ctx.buyerIpHeader ?? 'x-forwarded-for');
+    }
+    /**
+     * Build a `cacheKey` in the form of a `Request` to be used in full-page
+     * caching.
+     * - lockKey generates a placeholder cache key
+     */
+    cacheKey(lockKey = false) {
+        const url = new URL(this.url);
+        if (lockKey) {
+            url.searchParams.set('cache-lock', 'true');
+        }
+        return new Request(url.href, this);
+    }
+    async formData() {
+        // @ts-ignore
+        if (__HYDROGEN_WORKER__ || super.formData)
+            return super.formData();
+        const contentType = this.headers.get('Content-Type') || '';
+        // If mimeTypes essence is "multipart/form-data", then:
+        if (/multipart\/form-data/.test(contentType)) {
+            throw new Error('multipart/form-data not supported');
+        }
+        else if (/application\/x-www-form-urlencoded/.test(contentType)) {
+            // Otherwise, if mimeTypes essence is "application/x-www-form-urlencoded", then:
+            // 1. Let entries be the result of parsing bytes.
+            let entries;
+            try {
+                entries = new URLSearchParams(await this.text());
+            }
+            catch (err) {
+                // istanbul ignore next: Unclear when new URLSearchParams can fail on a string.
+                // 2. If entries is failure, then throw a TypeError.
+                throw new TypeError(undefined, { cause: err });
+            }
+            // 3. Return a new FormData object whose entries are entries.
+            const formData = new FormData();
+            for (const [name, value] of entries) {
+                formData.append(name, value);
+            }
+            return formData;
+        }
+        else {
+            // Otherwise, throw a TypeError.
+            throw new TypeError();
+        }
+    }
+}
+function mergeMapEntries(map1, map2) {
+    map2 && map2.forEach((v, k) => map1.set(k, v));
+}
+function saveToPreloadAllPreload(query) {
+    let setCache = preloadCache.get(PRELOAD_ALL);
+    if (!setCache) {
+        setCache = new Map();
+    }
+    setCache?.set(hashKey(query.key), query);
+    preloadCache.set(PRELOAD_ALL, setCache);
+}
+/**
+ * @see https://github.com/frandiox/vitedge/blob/17f3cd943e86d7c0c71a862985ddd6caa2899425/src/node/utils.js#L19-L24
+ *
+ * Note: Request can sometimes be an instance of Express request, where `originalUrl` is the true source of what the
+ * URL pathname is. We want to use that if it's present, so we union type this to `any`.
+ */
+function getUrlFromNodeRequest(request) {
+    const url = request.originalUrl ?? request.url;
+    if (url && !url.startsWith('/'))
+        return url;
+    // TODO: Find out how to determine https from `request` object without forwarded proto
+    const secure = request.headers['x-forwarded-proto'] === 'https';
+    return new URL(`${secure ? 'https' : 'http'}://${request.headers.host + url}`).toString();
+}
+function getInitFromNodeRequest(request) {
+    const init = {
+        headers: new Headers(request.headers),
+        method: request.method,
+        body: request.method !== 'GET' && request.method !== 'HEAD'
+            ? request.body
+            : undefined,
+    };
+    const remoteAddress = request.socket.remoteAddress;
+    if (!init.headers.has('x-forwarded-for') && remoteAddress) {
+        init.headers.set('x-forwarded-for', remoteAddress);
+    }
+    return init;
+}
+function normalizeUrl(rawUrl) {
+    const url = new URL(rawUrl);
+    const state = parseJSON(url.searchParams.get('state') ?? '');
+    const normalizedUrl = new URL(state?.pathname ?? '', url.origin);
+    normalizedUrl.search = state?.search;
+    return normalizedUrl.toString();
+}
diff --git a/dist/dist/esnext/foundation/HydrogenResponse/HydrogenResponse.server.d.ts b/dist/dist/esnext/foundation/HydrogenResponse/HydrogenResponse.server.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ec050c69c53f6b310838d3991a05819d09cd04f5
--- /dev/null
+++ b/dist/dist/esnext/foundation/HydrogenResponse/HydrogenResponse.server.d.ts
@@ -0,0 +1,23 @@
+import type { CachingStrategy } from '../../types.js';
+import React from 'react';
+export declare class HydrogenResponse extends Response {
+    private wait;
+    private sent;
+    private cacheOptions;
+    status: number;
+    statusText: string;
+    url: string;
+    constructor(url: string, body: any, init: any);
+    markAsSent(): void;
+    /**
+     * Buffer the current response until all queries have resolved,
+     * and prevent it from streaming back early.
+     */
+    doNotStream(): void;
+    canStream(): boolean;
+    cache(options?: CachingStrategy): import("../../types.js").AllCacheOptions;
+    get cacheControlHeader(): string;
+    redirect(location: string, status?: number): React.FunctionComponentElement<{
+        to: string;
+    }>;
+}
diff --git a/dist/dist/esnext/foundation/HydrogenResponse/HydrogenResponse.server.js b/dist/dist/esnext/foundation/HydrogenResponse/HydrogenResponse.server.js
new file mode 100644
index 0000000000000000000000000000000000000000..2d1e3eb04f3f8d3897ba4c98266288eadcfea91d
--- /dev/null
+++ b/dist/dist/esnext/foundation/HydrogenResponse/HydrogenResponse.server.js
@@ -0,0 +1,49 @@
+import { CacheShort, generateCacheControlHeader, } from '../Cache/strategies/index.js';
+import Redirect from '../Redirect/Redirect.client.js';
+import React from 'react';
+import { log } from '../../utilities/log/log.js';
+export class HydrogenResponse extends Response {
+    wait = false;
+    sent = false;
+    cacheOptions = CacheShort();
+    status = 200;
+    statusText = '';
+    url;
+    constructor(url, body, init) {
+        super(body, init);
+        this.url = url;
+    }
+    markAsSent() {
+        this.sent = true;
+    }
+    /**
+     * Buffer the current response until all queries have resolved,
+     * and prevent it from streaming back early.
+     */
+    doNotStream() {
+        if (!this.sent) {
+            this.wait = true;
+        }
+        else {
+            log.warn(`response.doNotStream() failed, the stream has already started on: ${this.url}\nDisabling streaming should always be the first thing in your route server component.`);
+        }
+    }
+    canStream() {
+        return !this.wait;
+    }
+    cache(options) {
+        if (options) {
+            this.cacheOptions = options;
+        }
+        return this.cacheOptions;
+    }
+    get cacheControlHeader() {
+        return generateCacheControlHeader(this.cacheOptions);
+    }
+    redirect(location, status = 307) {
+        this.status = status;
+        this.headers.set('location', location);
+        // in the case of an RSC request, instead render a client component that will redirect
+        return React.createElement(Redirect, { to: location });
+    }
+}
diff --git a/dist/dist/esnext/foundation/MemorySessionStorage/MemorySessionStorage.d.ts b/dist/dist/esnext/foundation/MemorySessionStorage/MemorySessionStorage.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0acb2a6e8bfde300e87bf7457c7e2d53d249cc92
--- /dev/null
+++ b/dist/dist/esnext/foundation/MemorySessionStorage/MemorySessionStorage.d.ts
@@ -0,0 +1,5 @@
+import type { SessionStorageAdapter } from '../session/session-types.js';
+import type { CookieOptions } from '../Cookie/Cookie.js';
+/** The `MemorySessionStorage` component stores session data within Hydrogen runtime memory.
+ */
+export declare const MemorySessionStorage: (name: string, options: CookieOptions) => () => SessionStorageAdapter;
diff --git a/dist/dist/esnext/foundation/MemorySessionStorage/MemorySessionStorage.js b/dist/dist/esnext/foundation/MemorySessionStorage/MemorySessionStorage.js
new file mode 100644
index 0000000000000000000000000000000000000000..cda66170a498d0e2410e25a4432c4789dba8a1e9
--- /dev/null
+++ b/dist/dist/esnext/foundation/MemorySessionStorage/MemorySessionStorage.js
@@ -0,0 +1,53 @@
+import { Cookie } from '../Cookie/Cookie.js';
+import { v4 as uid } from 'uuid';
+/** The `MemorySessionStorage` component stores session data within Hydrogen runtime memory.
+ */
+export const MemorySessionStorage = function (
+/** The name of the cookie stored in the browser. */
+name, 
+/** An optional object to configure [how the cookie is persisted in the browser](https://shopify.dev/api/hydrogen/components/framework/cookie#cookie-options). */
+options) {
+    const sessions = new Map();
+    return function () {
+        const cookie = new Cookie(name, options);
+        return {
+            async get(request) {
+                const sid = cookie.getSessionId(request);
+                let sessionData;
+                if (sid && sessions.has(sid)) {
+                    const { expires, data } = sessions.get(sid);
+                    if (expires < new Date().getTime()) {
+                        sessions.delete(sid);
+                        sessionData = {};
+                    }
+                    else {
+                        sessionData = data;
+                    }
+                }
+                else {
+                    sessionData = {};
+                }
+                return sessionData;
+            },
+            async set(request, value) {
+                let sid = cookie.getSessionId(request);
+                if (!sid) {
+                    sid = uid();
+                }
+                sessions.set(sid, {
+                    data: value,
+                    expires: cookie.expires,
+                });
+                cookie.setSessionid(sid);
+                return cookie.serialize();
+            },
+            async destroy(request) {
+                const sid = cookie.getSessionId(request);
+                if (sid) {
+                    sessions.delete(sid);
+                }
+                return cookie.destroy();
+            },
+        };
+    };
+};
diff --git a/dist/dist/esnext/foundation/Redirect/Redirect.client.d.ts b/dist/dist/esnext/foundation/Redirect/Redirect.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d98a4785f4d87c709944a4753020acbab7d016cb
--- /dev/null
+++ b/dist/dist/esnext/foundation/Redirect/Redirect.client.d.ts
@@ -0,0 +1,5 @@
+declare type RedirectProps = {
+    to: string;
+};
+export default function Redirect({ to }: RedirectProps): null;
+export {};
diff --git a/dist/dist/esnext/foundation/Redirect/Redirect.client.js b/dist/dist/esnext/foundation/Redirect/Redirect.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..2068f202eb732a4bc04a777d0b0d8480401cab8a
--- /dev/null
+++ b/dist/dist/esnext/foundation/Redirect/Redirect.client.js
@@ -0,0 +1,15 @@
+import { useEffect } from 'react';
+import { useNavigate } from '../../foundation/useNavigate/useNavigate.js';
+export default function Redirect({ to }) {
+    const navigate = useNavigate();
+    useEffect(() => {
+        if (to.startsWith('http')) {
+            window.location.href = to;
+        }
+        else {
+            navigate(to);
+        }
+        // eslint-disable-next-line react-hooks/exhaustive-deps
+    }, []);
+    return null;
+}
diff --git a/dist/dist/esnext/foundation/Route/Route.server.d.ts b/dist/dist/esnext/foundation/Route/Route.server.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4751d7bc5da5114e8ef6feb73e82d2fe3d1174f8
--- /dev/null
+++ b/dist/dist/esnext/foundation/Route/Route.server.d.ts
@@ -0,0 +1,12 @@
+import { ReactElement } from 'react';
+export declare type RouteProps = {
+    /** The URL path where the route exists. The path can contain variables. For example, `/products/:handle`. */
+    path: string;
+    /** A reference to a React Server Component that's rendered when the route is active. */
+    page: ReactElement;
+};
+/**
+ * The `Route` component is used to set up a route in Hydrogen that's independent of the file system. Routes are
+ * matched in the order that they're defined.
+ */
+export declare function Route({ path, page }: RouteProps): ReactElement | null;
diff --git a/dist/dist/esnext/foundation/Route/Route.server.js b/dist/dist/esnext/foundation/Route/Route.server.js
new file mode 100644
index 0000000000000000000000000000000000000000..0aa30bb9cf907fa178b363267525f77ef9933005
--- /dev/null
+++ b/dist/dist/esnext/foundation/Route/Route.server.js
@@ -0,0 +1,28 @@
+import React, { cloneElement } from 'react';
+import { useServerRequest } from '../ServerRequestProvider/index.js';
+import { matchPath } from '../../utilities/matchPath.js';
+import { RouteParamsProvider } from '../useRouteParams/RouteParamsProvider.client.js';
+/**
+ * The `Route` component is used to set up a route in Hydrogen that's independent of the file system. Routes are
+ * matched in the order that they're defined.
+ */
+export function Route({ path, page }) {
+    const request = useServerRequest();
+    const { routeRendered, serverProps } = request.ctx.router;
+    if (routeRendered)
+        return null;
+    if (path === '*') {
+        request.ctx.router.routeRendered = true;
+        return cloneElement(page, serverProps);
+    }
+    const match = matchPath(serverProps.pathname, {
+        path,
+        exact: true,
+    });
+    if (match) {
+        request.ctx.router.routeRendered = true;
+        request.ctx.router.routeParams = match.params;
+        return (React.createElement(RouteParamsProvider, { routeParams: match.params, basePath: '/' }, cloneElement(page, { params: match.params || {}, ...serverProps })));
+    }
+    return null;
+}
diff --git a/dist/dist/esnext/foundation/Router/BrowserRouter.client.d.ts b/dist/dist/esnext/foundation/Router/BrowserRouter.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9c357cc02947e3cdc4cb6ca0410ae9353acc336c
--- /dev/null
+++ b/dist/dist/esnext/foundation/Router/BrowserRouter.client.d.ts
@@ -0,0 +1,14 @@
+import { BrowserHistory, Location } from 'history';
+import React, { FC, ReactNode } from 'react';
+declare type RouterContextValue = {
+    history: BrowserHistory;
+    location: Location;
+};
+export declare const RouterContext: React.Context<RouterContextValue | undefined>;
+export declare const BrowserRouter: FC<{
+    history?: BrowserHistory;
+    children: ReactNode;
+}>;
+export declare function useRouter(): RouterContextValue;
+export declare function useLocation(): Location;
+export {};
diff --git a/dist/dist/esnext/foundation/Router/BrowserRouter.client.js b/dist/dist/esnext/foundation/Router/BrowserRouter.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..f7cf0f03dc543f6ac7b0e3433e416c9622adc896
--- /dev/null
+++ b/dist/dist/esnext/foundation/Router/BrowserRouter.client.js
@@ -0,0 +1,144 @@
+import { createBrowserHistory } from 'history';
+import React, { createContext, useContext, useMemo, useState, useEffect, useLayoutEffect, useCallback, } from 'react';
+import { META_ENV_SSR } from '../ssr-interop.js';
+import { useInternalServerProps } from '../useServerProps/use-server-props.js';
+export const RouterContext = createContext(undefined);
+let isFirstLoad = true;
+const positions = {};
+export const BrowserRouter = ({ history: pHistory, children }) => {
+    if (META_ENV_SSR)
+        return React.createElement(React.Fragment, null, children);
+    /* eslint-disable react-hooks/rules-of-hooks */
+    const history = useMemo(() => pHistory || createBrowserHistory(), [pHistory]);
+    const [location, setLocation] = useState(history.location);
+    const [scrollNeedsRestoration, setScrollNeedsRestoration] = useState(false);
+    const { pending, locationServerProps, setLocationServerProps } = useInternalServerProps();
+    useScrollRestoration({
+        location,
+        pending,
+        serverProps: locationServerProps,
+        scrollNeedsRestoration,
+        onFinishNavigating: () => setScrollNeedsRestoration(false),
+    });
+    useLayoutEffect(() => {
+        const unlisten = history.listen(({ location: newLocation, action }) => {
+            positions[location.key] = window.scrollY;
+            setLocationServerProps({
+                pathname: newLocation.pathname,
+                search: newLocation.search,
+            });
+            setLocation(newLocation);
+            const state = (newLocation.state ?? {});
+            /**
+             * "pop" navigations, like forward/backward buttons, always restore scroll position
+             * regardless of what the original forward navigation intent was.
+             */
+            const needsScrollRestoration = action === 'POP' || !!state.scroll;
+            setScrollNeedsRestoration(needsScrollRestoration);
+        });
+        return () => unlisten();
+    }, [
+        history,
+        location,
+        setScrollNeedsRestoration,
+        setLocation,
+        setLocationServerProps,
+    ]);
+    /* eslint-enable react-hooks/rules-of-hooks */
+    return (React.createElement(RouterContext.Provider, { value: {
+            history,
+            location,
+        } }, children));
+};
+export function useRouter() {
+    if (META_ENV_SSR)
+        return { location: {}, history: {} };
+    // eslint-disable-next-line react-hooks/rules-of-hooks
+    const router = useContext(RouterContext);
+    if (router)
+        return router;
+    throw new Error('Router hooks and <Link> component must be used within a <Router> component');
+}
+export function useLocation() {
+    return useRouter().location;
+}
+/**
+ * Run a callback before browser unload.
+ */
+function useBeforeUnload(callback) {
+    React.useEffect(() => {
+        window.addEventListener('beforeunload', callback);
+        return () => {
+            window.removeEventListener('beforeunload', callback);
+        };
+    }, [callback]);
+}
+function useScrollRestoration({ location, pending, serverProps, scrollNeedsRestoration, onFinishNavigating, }) {
+    /**
+     * Browsers have an API for scroll restoration. We wait for the page to load first,
+     * in case the browser is able to restore scroll position automatically, and then
+     * set it to manual mode.
+     */
+    useEffect(() => {
+        window.history.scrollRestoration = 'manual';
+    }, []);
+    /**
+     * If the page is reloading, allow the browser to handle its own scroll restoration.
+     */
+    useBeforeUnload(useCallback(() => {
+        window.history.scrollRestoration = 'auto';
+    }, []));
+    useLayoutEffect(() => {
+        // The app has just loaded
+        if (isFirstLoad || !scrollNeedsRestoration) {
+            isFirstLoad = false;
+            return;
+        }
+        const position = positions[location.key];
+        /**
+         * When serverState gets updated, `pending` is true while the fetch is in progress.
+         * When that resolves, the serverState is updated. We should wait until the internal
+         * location pointer and serverState match, and pending is false, to do any scrolling.
+         */
+        const finishedNavigating = !pending &&
+            location.pathname === serverProps.pathname &&
+            location.search === serverProps.search;
+        if (!finishedNavigating) {
+            return;
+        }
+        // If there is a location hash, scroll to it
+        if (location.hash) {
+            let element;
+            try {
+                element = document.querySelector(location.hash);
+            }
+            catch (err) {
+                // Do nothing, hash may not be a valid selector
+            }
+            if (element) {
+                element.scrollIntoView();
+                onFinishNavigating();
+                return;
+            }
+        }
+        // If we have a matching position, scroll to it
+        if (position) {
+            window.scrollTo(0, position);
+            onFinishNavigating();
+            return;
+        }
+        // Scroll to the top of new pages
+        window.scrollTo(0, 0);
+        onFinishNavigating();
+    }, [
+        location.pathname,
+        location.search,
+        location.hash,
+        location.key,
+        pending,
+        serverProps.pathname,
+        serverProps.search,
+        scrollNeedsRestoration,
+        onFinishNavigating,
+    ]);
+}
diff --git a/dist/dist/esnext/foundation/Router/Router.server.d.ts b/dist/dist/esnext/foundation/Router/Router.server.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f7432de589e666b5f468000c69a5d2dd13d8f048
--- /dev/null
+++ b/dist/dist/esnext/foundation/Router/Router.server.d.ts
@@ -0,0 +1,10 @@
+import { ReactElement } from 'react';
+declare type RouterProps = {
+    /** Any React elements. */
+    children: Array<ReactElement> | ReactElement;
+};
+/**
+ * The `Router` component provides the context for routing in your Hydrogen app.
+ */
+export declare function Router({ children }: RouterProps): ReactElement;
+export {};
diff --git a/dist/dist/esnext/foundation/Router/Router.server.js b/dist/dist/esnext/foundation/Router/Router.server.js
new file mode 100644
index 0000000000000000000000000000000000000000..b620e67dc9bb7353e85079684554ba3d2841a548
--- /dev/null
+++ b/dist/dist/esnext/foundation/Router/Router.server.js
@@ -0,0 +1,8 @@
+import React from 'react';
+import { BrowserRouter } from './BrowserRouter.client.js';
+/**
+ * The `Router` component provides the context for routing in your Hydrogen app.
+ */
+export function Router({ children }) {
+    return React.createElement(BrowserRouter, null, children);
+}
diff --git a/dist/dist/esnext/foundation/ServerPropsProvider/ServerPropsProvider.d.ts b/dist/dist/esnext/foundation/ServerPropsProvider/ServerPropsProvider.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e7c2ad62df727ed6b1b7654914a5685c31414e79
--- /dev/null
+++ b/dist/dist/esnext/foundation/ServerPropsProvider/ServerPropsProvider.d.ts
@@ -0,0 +1,43 @@
+import React, { ReactNode } from 'react';
+declare global {
+    var __HYDROGEN_DEV__: boolean;
+    var __HYDROGEN_TEST__: boolean;
+}
+export interface LocationServerProps {
+    pathname: string;
+    search: string;
+}
+export interface ServerProps {
+    [key: string]: any;
+}
+declare type ServerPropsSetterInput = ((prev: ServerProps) => Partial<ServerProps>) | Partial<ServerProps> | string;
+export interface ServerPropsSetter {
+    (input: ServerPropsSetterInput, propValue?: any): void;
+}
+interface ProposedServerPropsSetter {
+    (input: ServerPropsSetterInput, propValue?: any): LocationServerProps;
+}
+interface BaseServerPropsContextValue {
+    pending: boolean;
+}
+export interface InternalServerPropsContextValue extends BaseServerPropsContextValue {
+    setLocationServerProps: ServerPropsSetter;
+    setServerProps: ServerPropsSetter;
+    serverProps: ServerProps;
+    locationServerProps: LocationServerProps;
+    getProposedLocationServerProps: ProposedServerPropsSetter;
+    setRscResponseFromApiRoute: (response: any) => void;
+}
+export interface ServerPropsContextValue extends BaseServerPropsContextValue {
+    serverProps: ServerProps;
+    setServerProps: ServerPropsSetter;
+}
+export declare const ServerPropsContext: React.Context<InternalServerPropsContextValue>;
+interface ServerPropsProviderProps {
+    initialServerProps: LocationServerProps;
+    setServerPropsForRsc: React.Dispatch<React.SetStateAction<LocationServerProps>>;
+    setRscResponseFromApiRoute: (response: any) => void;
+    children: ReactNode;
+}
+export declare function ServerPropsProvider({ initialServerProps, setServerPropsForRsc, setRscResponseFromApiRoute, children, }: ServerPropsProviderProps): JSX.Element;
+export {};
diff --git a/dist/dist/esnext/foundation/ServerPropsProvider/ServerPropsProvider.js b/dist/dist/esnext/foundation/ServerPropsProvider/ServerPropsProvider.js
new file mode 100644
index 0000000000000000000000000000000000000000..64c8caac81b7be4770b19d547aa32bb3927ee118
--- /dev/null
+++ b/dist/dist/esnext/foundation/ServerPropsProvider/ServerPropsProvider.js
@@ -0,0 +1,65 @@
+import React, { createContext, useMemo, useCallback, useTransition, useState, } from 'react';
+const PRIVATE_PROPS = ['request', 'response'];
+export const ServerPropsContext = createContext(null);
+export function ServerPropsProvider({ initialServerProps, setServerPropsForRsc, setRscResponseFromApiRoute, children, }) {
+    const [locationServerProps, setLocationServerProps] = useState(initialServerProps);
+    const [serverProps, setServerProps] = useState({});
+    const [pending, startTransition] = useTransition();
+    const setServerPropsCallback = useCallback((input, propValue) => {
+        startTransition(() => {
+            setServerProps((prev) => getNewValue(prev, input, propValue));
+            setServerPropsForRsc((prev) => getNewValue(prev, input, propValue));
+        });
+    }, [setServerProps, setServerPropsForRsc]);
+    const setLocationServerPropsCallback = useCallback((input) => {
+        // Flush the existing user server state when location changes, leaving only the persisted state
+        startTransition(() => {
+            setServerPropsForRsc(input);
+            setServerProps({});
+            setLocationServerProps(input);
+        });
+    }, [setServerProps, setServerPropsForRsc, setLocationServerProps]);
+    const getProposedLocationServerPropsCallback = useCallback((input, propValue) => {
+        return getNewValue(locationServerProps, input, propValue);
+    }, [locationServerProps]);
+    function getNewValue(prev, input, propValue) {
+        let newValue;
+        if (typeof input === 'function') {
+            newValue = input(prev);
+        }
+        else if (typeof input === 'string') {
+            newValue = { [input]: propValue };
+        }
+        else {
+            newValue = input;
+        }
+        if (__HYDROGEN_DEV__) {
+            const privateProp = PRIVATE_PROPS.find((prop) => prop in newValue);
+            if (privateProp) {
+                console.warn(`Custom "${privateProp}" property in server state is ignored. Use a different name.`);
+            }
+        }
+        return {
+            ...prev,
+            ...newValue,
+        };
+    }
+    const value = useMemo(() => ({
+        pending,
+        locationServerProps,
+        serverProps,
+        setServerProps: setServerPropsCallback,
+        setLocationServerProps: setLocationServerPropsCallback,
+        getProposedLocationServerProps: getProposedLocationServerPropsCallback,
+        setRscResponseFromApiRoute,
+    }), [
+        pending,
+        locationServerProps,
+        serverProps,
+        setServerPropsCallback,
+        setLocationServerPropsCallback,
+        getProposedLocationServerPropsCallback,
+        setRscResponseFromApiRoute,
+    ]);
+    return (React.createElement(ServerPropsContext.Provider, { value: value }, children));
+}
diff --git a/dist/dist/esnext/foundation/ServerPropsProvider/index.d.ts b/dist/dist/esnext/foundation/ServerPropsProvider/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..acd865d4e04ecda594e4db27c8b7b9c7cd557c9b
--- /dev/null
+++ b/dist/dist/esnext/foundation/ServerPropsProvider/index.d.ts
@@ -0,0 +1 @@
+export { ServerPropsProvider, ServerPropsContext, type ServerProps, type ServerPropsContextValue, } from './ServerPropsProvider.js';
diff --git a/dist/dist/esnext/foundation/ServerPropsProvider/index.js b/dist/dist/esnext/foundation/ServerPropsProvider/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..4882a32291e239ab56cc2720da97d283719e6227
--- /dev/null
+++ b/dist/dist/esnext/foundation/ServerPropsProvider/index.js
@@ -0,0 +1 @@
+export { ServerPropsProvider, ServerPropsContext, } from './ServerPropsProvider.js';
diff --git a/dist/dist/esnext/foundation/ServerRequestProvider/ServerRequestProvider.d.ts b/dist/dist/esnext/foundation/ServerRequestProvider/ServerRequestProvider.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a1d42a4e1ff32eb4a4cfb78d60d08167a4c6955c
--- /dev/null
+++ b/dist/dist/esnext/foundation/ServerRequestProvider/ServerRequestProvider.d.ts
@@ -0,0 +1,23 @@
+import React from 'react';
+import type { HydrogenRequest } from '../HydrogenRequest/HydrogenRequest.server.js';
+import type { QueryKey } from '../../types.js';
+declare type ServerRequestProviderProps = {
+    request: HydrogenRequest;
+    children: React.ReactNode;
+};
+export declare function ServerRequestProvider({ request, children, }: ServerRequestProviderProps): JSX.Element;
+export declare function useServerRequest(): HydrogenRequest;
+declare type RequestCacheResult<T> = {
+    data: T;
+    error?: never;
+} | {
+    data?: never;
+    error: Response | Error;
+};
+/**
+ * Returns data stored in the request cache.
+ * It will throw the promise if data is not ready.
+ */
+export declare function useRequestCacheData<T>(key: QueryKey, fetcher: (request: HydrogenRequest) => T | Promise<T>): RequestCacheResult<T>;
+export declare function preloadRequestCacheData(request: HydrogenRequest): void;
+export {};
diff --git a/dist/dist/esnext/foundation/ServerRequestProvider/ServerRequestProvider.js b/dist/dist/esnext/foundation/ServerRequestProvider/ServerRequestProvider.js
new file mode 100644
index 0000000000000000000000000000000000000000..0ee21d2e9a9dc024e689b2b5128bdfe17207a23e
--- /dev/null
+++ b/dist/dist/esnext/foundation/ServerRequestProvider/ServerRequestProvider.js
@@ -0,0 +1,125 @@
+import React, { createContext, useContext } from 'react';
+import { getTime } from '../../utilities/timing.js';
+import { hashKey } from '../../utilities/hash.js';
+import { collectQueryTimings } from '../../utilities/log/index.js';
+// Context to inject current request in SSR
+const RequestContextSSR = createContext(null);
+// Cache to inject current request in RSC
+function requestCacheRSC() {
+    return new Map();
+}
+requestCacheRSC.key = Symbol.for('HYDROGEN_REQUEST');
+function getInternalReactDispatcher() {
+    return (
+    // @ts-ignore
+    React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
+        .ReactCurrentDispatcher.current || {});
+}
+function isRsc() {
+    // This flag is added by RSC Vite plugin
+    return __HYDROGEN_TEST__ || !!getInternalReactDispatcher().isRsc;
+}
+// Note: use this only during RSC/Flight rendering. The React dispatcher
+// for SSR/Fizz rendering does not implement getCacheForType.
+function getCacheForType(resource) {
+    const dispatcher = getInternalReactDispatcher();
+    // @ts-ignore
+    if (__HYDROGEN_TEST__ && !dispatcher.getCacheForType) {
+        // Jest does not have access to the RSC runtime, mock it here:
+        // @ts-ignore
+        return (globalThis.__jestRscCache ??= resource());
+    }
+    return dispatcher.getCacheForType(resource);
+}
+export function ServerRequestProvider({ request, children, }) {
+    if (isRsc()) {
+        // Save the request object in a React cache that is
+        // scoped to this current rendering.
+        const requestCache = getCacheForType(requestCacheRSC);
+        requestCache.set(requestCacheRSC.key, request);
+        return React.createElement(React.Fragment, null, children);
+    }
+    // Use a normal provider in SSR to make the request object
+    // available in the current rendering.
+    return (React.createElement(RequestContextSSR.Provider, { value: request }, children));
+}
+export function useServerRequest() {
+    const request = isRsc()
+        ? getCacheForType(requestCacheRSC)?.get(requestCacheRSC.key)
+        : useContext(RequestContextSSR); // eslint-disable-line react-hooks/rules-of-hooks
+    if (!request) {
+        if (__HYDROGEN_TEST__) {
+            // Unit tests are not wrapped in ServerRequestProvider.
+            // This mocks it, instead of providing it in every test.
+            return { ctx: {} };
+        }
+        throw new Error('No ServerRequest Context found');
+    }
+    return request;
+}
+/**
+ * Returns data stored in the request cache.
+ * It will throw the promise if data is not ready.
+ */
+export function useRequestCacheData(key, fetcher) {
+    const request = useServerRequest();
+    const cache = request.ctx.cache;
+    const cacheKey = hashKey(key);
+    if (!cache.has(cacheKey)) {
+        let result;
+        let promise;
+        cache.set(cacheKey, () => {
+            if (result !== undefined) {
+                collectQueryTimings(request, key, 'rendered');
+                return result;
+            }
+            if (!promise) {
+                const startApiTime = getTime();
+                const maybePromise = fetcher(request);
+                if (!(maybePromise instanceof Promise)) {
+                    result = { data: maybePromise };
+                    return result;
+                }
+                promise = maybePromise.then((data) => {
+                    result = { data };
+                    collectQueryTimings(request, key, 'resolved', getTime() - startApiTime);
+                }, (error) => (result = { error }));
+            }
+            throw promise;
+        });
+    }
+    // Making sure the promise has returned data because it can be initated by a preload request,
+    // otherwise, we throw the promise
+    const result = cache.get(cacheKey).call();
+    if (result instanceof Promise)
+        throw result;
+    return result;
+}
+export function preloadRequestCacheData(request) {
+    const preloadQueries = request.getPreloadQueries();
+    const { cache } = request.ctx;
+    preloadQueries?.forEach((preloadQuery, cacheKey) => {
+        collectQueryTimings(request, preloadQuery.key, 'preload');
+        if (!cache.has(cacheKey)) {
+            let result;
+            let promise;
+            cache.set(cacheKey, () => {
+                if (result !== undefined) {
+                    collectQueryTimings(request, preloadQuery.key, 'rendered');
+                    return result;
+                }
+                if (!promise) {
+                    const startApiTime = getTime();
+                    promise = preloadQuery.fetcher(request).then((data) => {
+                        result = { data };
+                        collectQueryTimings(request, preloadQuery.key, 'resolved', getTime() - startApiTime);
+                    }, (error) => {
+                        result = { error };
+                    });
+                }
+                return promise;
+            });
+        }
+        cache.get(cacheKey).call();
+    });
+}
diff --git a/dist/dist/esnext/foundation/ServerRequestProvider/index.d.ts b/dist/dist/esnext/foundation/ServerRequestProvider/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5f4344540f8163cde7f60c72f3c42d86ff98eae0
--- /dev/null
+++ b/dist/dist/esnext/foundation/ServerRequestProvider/index.d.ts
@@ -0,0 +1 @@
+export * from './ServerRequestProvider.js';
diff --git a/dist/dist/esnext/foundation/ServerRequestProvider/index.js b/dist/dist/esnext/foundation/ServerRequestProvider/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..5f4344540f8163cde7f60c72f3c42d86ff98eae0
--- /dev/null
+++ b/dist/dist/esnext/foundation/ServerRequestProvider/index.js
@@ -0,0 +1 @@
+export * from './ServerRequestProvider.js';
diff --git a/dist/dist/esnext/foundation/ServerStateProvider/ServerStateProvider.d.ts b/dist/dist/esnext/foundation/ServerStateProvider/ServerStateProvider.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1f283772e3fbd07d5c870f16ae763e2ee443ac48
--- /dev/null
+++ b/dist/dist/esnext/foundation/ServerStateProvider/ServerStateProvider.d.ts
@@ -0,0 +1,30 @@
+import React, { ReactNode } from 'react';
+declare global {
+    var __HYDROGEN_DEV__: boolean;
+}
+export interface ServerState {
+    pathname: string;
+    search: string;
+    [key: string]: any;
+}
+declare type ServerStateSetterInput = ((prev: ServerState) => Partial<ServerState>) | Partial<ServerState> | string;
+export interface ServerStateSetter {
+    (input: ServerStateSetterInput, propValue?: any): void;
+}
+interface ProposedServerStateSetter {
+    (input: ServerStateSetterInput, propValue?: any): ServerState;
+}
+export interface ServerStateContextValue {
+    pending: boolean;
+    serverState: ServerState;
+    setServerState: ServerStateSetter;
+    getProposedServerState: ProposedServerStateSetter;
+}
+export declare const ServerStateContext: React.Context<ServerStateContextValue>;
+interface ServerStateProviderProps {
+    serverState: ServerState;
+    setServerState: React.Dispatch<React.SetStateAction<ServerState>>;
+    children: ReactNode;
+}
+export declare function ServerStateProvider({ serverState, setServerState, children, }: ServerStateProviderProps): JSX.Element;
+export {};
diff --git a/dist/dist/esnext/foundation/ServerStateProvider/ServerStateProvider.js b/dist/dist/esnext/foundation/ServerStateProvider/ServerStateProvider.js
new file mode 100644
index 0000000000000000000000000000000000000000..3350c180c95ee9567b421c64431be9f24b2546a4
--- /dev/null
+++ b/dist/dist/esnext/foundation/ServerStateProvider/ServerStateProvider.js
@@ -0,0 +1,59 @@
+import React, { createContext, useMemo, useCallback, 
+// @ts-ignore
+useTransition, } from 'react';
+const PRIVATE_PROPS = ['request', 'response'];
+export const ServerStateContext = createContext(null);
+export function ServerStateProvider({ serverState, setServerState, children, }) {
+    const [pending, startTransition] = useTransition();
+    const setServerStateCallback = useCallback((input, propValue) => {
+        /**
+         * By wrapping this state change in a transition, React renders the new state
+         * concurrently in a new "tree" instead of Suspending and showing the (blank)
+         * fallback. This is preferred behavior, though we may want to revisit how
+         * we make this decision globally for the developer - and consider providing
+         * the `pending` flag also provided by the hook to display in the UI.
+         */
+        startTransition(() => {
+            return setServerState((prev) => getNewServerState(prev, input, propValue));
+        });
+    }, [setServerState, startTransition]);
+    const getProposedServerStateCallback = useCallback((input, propValue) => {
+        return getNewServerState(serverState, input, propValue);
+    }, [serverState]);
+    function getNewServerState(prev, input, propValue) {
+        let newValue;
+        if (typeof input === 'function') {
+            newValue = input(prev);
+        }
+        else if (typeof input === 'string') {
+            newValue = { [input]: propValue };
+        }
+        else {
+            newValue = input;
+        }
+        if (!newValue)
+            return { ...prev };
+        if (__HYDROGEN_DEV__) {
+            const privateProp = PRIVATE_PROPS.find((prop) => prop in newValue);
+            if (privateProp) {
+                console.warn(`Custom "${privateProp}" property in server state is ignored. Use a different name.`);
+            }
+        }
+        return {
+            ...prev,
+            ...newValue,
+        };
+    }
+    const value = useMemo(() => ({
+        pending,
+        serverState,
+        setServerState: setServerStateCallback,
+        getProposedServerState: getProposedServerStateCallback,
+    }), [
+        serverState,
+        getProposedServerStateCallback,
+        setServerStateCallback,
+        pending,
+    ]);
+    return (React.createElement(ServerStateContext.Provider, { value: value }, children));
+}
diff --git a/dist/dist/esnext/foundation/ShopifyProvider/ShopifyProvider.client.d.ts b/dist/dist/esnext/foundation/ShopifyProvider/ShopifyProvider.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6f37646b165bbf6d3e3d8c1364e49da89ef89b10
--- /dev/null
+++ b/dist/dist/esnext/foundation/ShopifyProvider/ShopifyProvider.client.d.ts
@@ -0,0 +1,9 @@
+import type { ShopifyContextClientValue, LocalizationContextValue } from './types.js';
+import React, { ReactNode } from 'react';
+export declare const ShopifyContext: React.Context<ShopifyContextClientValue | null>;
+export declare const LocalizationContext: React.Context<LocalizationContextValue | null>;
+export declare function ShopifyProviderClient({ children, shopifyConfig, localization, }: {
+    children: ReactNode;
+    shopifyConfig: ShopifyContextClientValue;
+    localization: LocalizationContextValue;
+}): JSX.Element;
diff --git a/dist/dist/esnext/foundation/ShopifyProvider/ShopifyProvider.client.js b/dist/dist/esnext/foundation/ShopifyProvider/ShopifyProvider.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..ab34f4e637977c5f96589011667d481b9fd520c0
--- /dev/null
+++ b/dist/dist/esnext/foundation/ShopifyProvider/ShopifyProvider.client.js
@@ -0,0 +1,10 @@
+import React, { createContext } from 'react';
+export const ShopifyContext = createContext(null);
+export const LocalizationContext = createContext(null);
+export function ShopifyProviderClient({ children, shopifyConfig, localization, }) {
+    if (!shopifyConfig) {
+        throw new Error('The `shopifyConfig` prop should be passed to `ShopifyProvider`');
+    }
+    return (React.createElement(ShopifyContext.Provider, { value: shopifyConfig },
+        React.createElement(LocalizationContext.Provider, { value: localization }, children)));
+}
diff --git a/dist/dist/esnext/foundation/ShopifyProvider/ShopifyProvider.server.d.ts b/dist/dist/esnext/foundation/ShopifyProvider/ShopifyProvider.server.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a73dadc85df680f29304e02314d7c362863a52af
--- /dev/null
+++ b/dist/dist/esnext/foundation/ShopifyProvider/ShopifyProvider.server.d.ts
@@ -0,0 +1,19 @@
+import type { ShopifyProviderProps, LocalizationContextValue } from './types.js';
+import type { CountryCode, LanguageCode } from '../../storefront-api-types.js';
+export declare const CLIENT_CONTEXT_ALLOW_LIST: readonly ["defaultCountryCode", "defaultLanguageCode", "storeDomain", "storefrontToken", "storefrontApiVersion", "storefrontId"];
+export declare const SHOPIFY_PROVIDER_CONTEXT_KEY: unique symbol;
+/**
+ * The `ShopifyProvider` component wraps your entire app and provides support for hooks.
+ * You should place it in your app's entry point component. For example, `<App>`.
+ * If you're using the Hydrogen framework, you don't need to add this provider
+ * because it's automatically wrapped around your app in `renderHydrogen()`.
+ */
+export declare function ShopifyProvider({ 
+/**
+ * Shopify connection information. Defaults to
+ * [the `shopify` property in the `hydrogen.config.js` file](https://shopify.dev/custom-storefronts/hydrogen/framework/hydrogen-config).
+ */
+shopifyConfig, countryCode, languageCode, 
+/** Any `ReactNode` elements. */
+children, }: ShopifyProviderProps): JSX.Element;
+export declare function getLocalizationContextValue(defaultLanguageCode: `${LanguageCode}`, defaultCountryCode: `${CountryCode}`, languageCode?: `${LanguageCode}`, countryCode?: `${CountryCode}`): LocalizationContextValue;
diff --git a/dist/dist/esnext/foundation/ShopifyProvider/ShopifyProvider.server.js b/dist/dist/esnext/foundation/ShopifyProvider/ShopifyProvider.server.js
new file mode 100644
index 0000000000000000000000000000000000000000..bd5fa88f7b910f4e3f18c7c30b20b3d577225c3e
--- /dev/null
+++ b/dist/dist/esnext/foundation/ShopifyProvider/ShopifyProvider.server.js
@@ -0,0 +1,94 @@
+import React, { useMemo } from 'react';
+import { ShopifyProviderClient } from './ShopifyProvider.client.js';
+import { DEFAULT_COUNTRY, DEFAULT_LANGUAGE } from '../constants.js';
+import { useRequestCacheData, useServerRequest, } from '../ServerRequestProvider/index.js';
+import { getOxygenVariable } from '../../utilities/storefrontApi.js';
+import { SHOPIFY_STOREFRONT_ID_VARIABLE } from '../../constants.js';
+import { getLocale } from '../../utilities/locale/index.js';
+export const CLIENT_CONTEXT_ALLOW_LIST = [
+    'defaultCountryCode',
+    'defaultLanguageCode',
+    'storeDomain',
+    'storefrontToken',
+    'storefrontApiVersion',
+    'storefrontId',
+];
+function makeShopifyContext(shopifyConfig) {
+    const countryCode = shopifyConfig.defaultCountryCode ?? DEFAULT_COUNTRY;
+    const languageCode = shopifyConfig.defaultLanguageCode ?? DEFAULT_LANGUAGE;
+    const storefrontId = shopifyConfig.storefrontId ??
+        getOxygenVariable(SHOPIFY_STOREFRONT_ID_VARIABLE);
+    const shopifyProviderServerValue = {
+        defaultCountryCode: countryCode.toUpperCase(),
+        defaultLanguageCode: languageCode.toUpperCase(),
+        storeDomain: shopifyConfig?.storeDomain?.replace(/^https?:\/\//, ''),
+        storefrontToken: shopifyConfig.storefrontToken,
+        storefrontApiVersion: shopifyConfig.storefrontApiVersion,
+        storefrontId,
+        privateStorefrontToken: shopifyConfig.privateStorefrontToken,
+    };
+    return {
+        shopifyProviderServerValue,
+        shopifyProviderClientValue: CLIENT_CONTEXT_ALLOW_LIST.reduce((clientConfigValue, key) => {
+            clientConfigValue[key] = shopifyProviderServerValue[key];
+            return clientConfigValue;
+        }, {}),
+    };
+}
+export const SHOPIFY_PROVIDER_CONTEXT_KEY = Symbol.for('SHOPIFY_PROVIDER_RSC');
+/**
+ * The `ShopifyProvider` component wraps your entire app and provides support for hooks.
+ * You should place it in your app's entry point component. For example, `<App>`.
+ * If you're using the Hydrogen framework, you don't need to add this provider
+ * because it's automatically wrapped around your app in `renderHydrogen()`.
+ */
+export function ShopifyProvider({ 
+/**
+ * Shopify connection information. Defaults to
+ * [the `shopify` property in the `hydrogen.config.js` file](https://shopify.dev/custom-storefronts/hydrogen/framework/hydrogen-config).
+ */
+shopifyConfig, countryCode, languageCode, 
+/** Any `ReactNode` elements. */
+children, }) {
+    const request = useServerRequest();
+    if (!shopifyConfig) {
+        shopifyConfig = request.ctx.hydrogenConfig?.shopify;
+        if (!shopifyConfig) {
+            throw new Error('The `shopifyConfig` prop should be passed to `ShopifyProvider`');
+        }
+    }
+    let actualShopifyConfig;
+    if (typeof shopifyConfig === 'function') {
+        const result = useRequestCacheData(['hydrogen-shopify-config'], () => shopifyConfig(request));
+        if (result.error) {
+            if (result.error instanceof Error) {
+                throw result.error;
+            }
+            throw new Error(`Failed to load Shopify config: ${result.error.statusText}`);
+        }
+        actualShopifyConfig = result.data;
+    }
+    else {
+        actualShopifyConfig = shopifyConfig;
+    }
+    const { shopifyProviderServerValue, shopifyProviderClientValue } = useMemo(() => makeShopifyContext(actualShopifyConfig), [actualShopifyConfig]);
+    const localization = getLocalizationContextValue(shopifyProviderServerValue.defaultLanguageCode, shopifyProviderServerValue.defaultCountryCode, languageCode, countryCode);
+    request.ctx.localization = localization;
+    request.ctx.shopifyConfig = shopifyProviderServerValue;
+    return (React.createElement(ShopifyProviderClient, { shopifyConfig: shopifyProviderClientValue, localization: localization }, children));
+}
+export function getLocalizationContextValue(defaultLanguageCode, defaultCountryCode, languageCode, countryCode) {
+    return useMemo(() => {
+        const runtimeLanguageCode = (languageCode ?? defaultLanguageCode).toUpperCase();
+        const runtimeCountryCode = (countryCode ?? defaultCountryCode).toUpperCase();
+        return {
+            country: {
+                isoCode: runtimeCountryCode,
+            },
+            language: {
+                isoCode: runtimeLanguageCode,
+            },
+            locale: getLocale(runtimeLanguageCode, runtimeCountryCode),
+        };
+    }, [defaultLanguageCode, defaultCountryCode, countryCode, languageCode]);
+}
diff --git a/dist/dist/esnext/foundation/ShopifyProvider/index.d.ts b/dist/dist/esnext/foundation/ShopifyProvider/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..480ea6568c5fe621a02dc2ecdf4c524516557973
--- /dev/null
+++ b/dist/dist/esnext/foundation/ShopifyProvider/index.d.ts
@@ -0,0 +1 @@
+export { ShopifyContext } from './ShopifyProvider.client.js';
diff --git a/dist/dist/esnext/foundation/ShopifyProvider/index.js b/dist/dist/esnext/foundation/ShopifyProvider/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..480ea6568c5fe621a02dc2ecdf4c524516557973
--- /dev/null
+++ b/dist/dist/esnext/foundation/ShopifyProvider/index.js
@@ -0,0 +1 @@
+export { ShopifyContext } from './ShopifyProvider.client.js';
diff --git a/dist/dist/esnext/foundation/ShopifyProvider/types.d.ts b/dist/dist/esnext/foundation/ShopifyProvider/types.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3bb4180b27faf2ce3c9cde4df39641daf0f023ad
--- /dev/null
+++ b/dist/dist/esnext/foundation/ShopifyProvider/types.d.ts
@@ -0,0 +1,35 @@
+import type { CountryCode, LanguageCode } from '../../storefront-api-types.js';
+import type { ReactNode } from 'react';
+import type { ShopifyConfigFetcher, ShopifyConfig } from '../../types.js';
+import type { CLIENT_CONTEXT_ALLOW_LIST } from './ShopifyProvider.server.js';
+export interface ShopifyContextServerValue extends Omit<ShopifyConfig, 'defaultLanguageCode' | 'defaultCountryCode'> {
+    defaultLanguageCode: `${LanguageCode}`;
+    defaultCountryCode: `${CountryCode}`;
+}
+declare type CLIENT_KEYS = typeof CLIENT_CONTEXT_ALLOW_LIST[number];
+export declare type ShopifyContextClientValue = Pick<ShopifyContextServerValue, CLIENT_KEYS>;
+export declare type Locale = string;
+export interface LocalizationContextValue {
+    country: {
+        isoCode: `${CountryCode}`;
+    };
+    language: {
+        isoCode: `${LanguageCode}`;
+    };
+    locale: Locale;
+}
+export declare type ShopifyProviderProps = {
+    /** Shopify connection information. Defaults to the `shopify` property in the `hydrogen.config.js` file. */
+    shopifyConfig?: ShopifyConfig | ShopifyConfigFetcher;
+    /** Any `ReactNode` elements. */
+    children?: ReactNode;
+    /**
+     * Override the `isoCode` to define the active country
+     */
+    countryCode?: `${CountryCode}`;
+    /**
+     * Override the `languageCode` to define the active language
+     */
+    languageCode?: `${LanguageCode}`;
+};
+export {};
diff --git a/dist/dist/esnext/foundation/ShopifyProvider/types.js b/dist/dist/esnext/foundation/ShopifyProvider/types.js
new file mode 100644
index 0000000000000000000000000000000000000000..cb0ff5c3b541f646105198ee23ac0fc3d805023e
--- /dev/null
+++ b/dist/dist/esnext/foundation/ShopifyProvider/types.js
@@ -0,0 +1 @@
+export {};
diff --git a/dist/dist/esnext/foundation/constants.d.ts b/dist/dist/esnext/foundation/constants.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5ab09ffb57d57adeb9c6e1d53bb0274b616397be
--- /dev/null
+++ b/dist/dist/esnext/foundation/constants.d.ts
@@ -0,0 +1,2 @@
+export declare const DEFAULT_COUNTRY = "US";
+export declare const DEFAULT_LANGUAGE = "EN";
diff --git a/dist/dist/esnext/foundation/constants.js b/dist/dist/esnext/foundation/constants.js
new file mode 100644
index 0000000000000000000000000000000000000000..1013bb348c7a2f14ef5b236d9af2b5751501143e
--- /dev/null
+++ b/dist/dist/esnext/foundation/constants.js
@@ -0,0 +1,4 @@
+// Note: do not mix this export with other app-only logic
+// to avoid importing unnecessary code in the plugins.
+export const DEFAULT_COUNTRY = 'US';
+export const DEFAULT_LANGUAGE = 'EN';
diff --git a/dist/dist/esnext/foundation/fetchSync/ResponseSync.d.ts b/dist/dist/esnext/foundation/fetchSync/ResponseSync.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8da9986081d4d9d437d64bf169a3926e7f3d6bd2
--- /dev/null
+++ b/dist/dist/esnext/foundation/fetchSync/ResponseSync.d.ts
@@ -0,0 +1,15 @@
+declare type ResponseSyncInit = [string, ResponseInit, string];
+export declare class ResponseSync extends Response {
+    #private;
+    bodyUsed: boolean;
+    url: string;
+    constructor(init: ResponseSyncInit);
+    text(): string;
+    json(): any;
+    /**
+     * @deprecated Access response properties at the top level instead.
+     */
+    get response(): this;
+    static toSerializable(response: Response): Promise<ResponseSyncInit>;
+}
+export {};
diff --git a/dist/dist/esnext/foundation/fetchSync/ResponseSync.js b/dist/dist/esnext/foundation/fetchSync/ResponseSync.js
new file mode 100644
index 0000000000000000000000000000000000000000..7dd8fc6eb6bd6491b9328540d0cb21dad5adc590
--- /dev/null
+++ b/dist/dist/esnext/foundation/fetchSync/ResponseSync.js
@@ -0,0 +1,50 @@
+import { parseJSON } from '../../utilities/parse.js';
+import { log } from '../../utilities/log/index.js';
+export class ResponseSync extends Response {
+    bodyUsed = true;
+    #text;
+    #json;
+    url;
+    constructor(init) {
+        super(init[0], init[1]);
+        this.#text = init[0];
+        this.url = init[2];
+    }
+    // @ts-expect-error Changing inherited types
+    text() {
+        return this.#text;
+    }
+    json() {
+        try {
+            return (this.#json ??= parseJSON(this.#text));
+        }
+        catch (e) {
+            if (!this.ok) {
+                throw new Error(`Request to ${this.url} failed with ${this.status} and the response body is not parseable.\nMake sure to handle the error state when using fetchSync.`);
+            }
+            else
+                throw e;
+        }
+    }
+    /**
+     * @deprecated Access response properties at the top level instead.
+     */
+    get response() {
+        if (__HYDROGEN_DEV__) {
+            log.warn(`Property 'response' is deprecated from the result of 'fetchSync'.` +
+                ` Access response properties at the top level instead.`);
+        }
+        return this;
+    }
+    static async toSerializable(response) {
+        return [
+            await response.text(),
+            {
+                status: response.status,
+                statusText: response.statusText,
+                headers: Array.from(response.headers.entries()),
+            },
+            response.url,
+        ];
+    }
+}
diff --git a/dist/dist/esnext/foundation/fetchSync/client/fetchSync.d.ts b/dist/dist/esnext/foundation/fetchSync/client/fetchSync.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..94a84fe04c7ce52c8bbae3d25cf5d443222a39e4
--- /dev/null
+++ b/dist/dist/esnext/foundation/fetchSync/client/fetchSync.d.ts
@@ -0,0 +1,10 @@
+import { ResponseSync } from '../ResponseSync.js';
+/**
+ * Fetch a URL for use in a client component Suspense boundary.
+ */
+export declare function fetchSync(url: string, options?: RequestInit): ResponseSync;
+/**
+ * Preload a URL for use in  a client component Suspense boundary.
+ * Useful for placing higher in the tree to avoid waterfalls.
+ */
+export declare function preload(url: string, options?: RequestInit): void;
diff --git a/dist/dist/esnext/foundation/fetchSync/client/fetchSync.js b/dist/dist/esnext/foundation/fetchSync/client/fetchSync.js
new file mode 100644
index 0000000000000000000000000000000000000000..52bea45d8ffbe610bec0e5575e5aabe98dc4492b
--- /dev/null
+++ b/dist/dist/esnext/foundation/fetchSync/client/fetchSync.js
@@ -0,0 +1,23 @@
+import { suspendFunction, preloadFunction } from '../../../utilities/suspense.js';
+import { ResponseSync } from '../ResponseSync.js';
+/**
+ * Fetch a URL for use in a client component Suspense boundary.
+ */
+export function fetchSync(url, options) {
+    const responseSyncInit = suspendFunction([url, options], async () => {
+        const response = await globalThis.fetch(new URL(url, window.location.origin), options);
+        return ResponseSync.toSerializable(response);
+    });
+    return new ResponseSync(responseSyncInit);
+}
+/**
+ * Preload a URL for use in  a client component Suspense boundary.
+ * Useful for placing higher in the tree to avoid waterfalls.
+ */
+export function preload(url, options) {
+    preloadFunction([url, options], async () => {
+        const response = await globalThis.fetch(url, options);
+        const text = await response.text();
+        return [text, response];
+    });
+}
diff --git a/dist/dist/esnext/foundation/fetchSync/server/fetchSync.d.ts b/dist/dist/esnext/foundation/fetchSync/server/fetchSync.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f57c8021af62db95bc135df044750fdc813bfd03
--- /dev/null
+++ b/dist/dist/esnext/foundation/fetchSync/server/fetchSync.d.ts
@@ -0,0 +1,8 @@
+import { type HydrogenUseQueryOptions } from '../../useQuery/index.js';
+import { ResponseSync } from '../ResponseSync.js';
+/**
+ * The `fetchSync` hook makes API requests and is the recommended way to make simple fetch calls on the server and the client.
+ * It's designed similar to the [Web API's `fetch`](https://developer.mozilla.org/en-US/docs/Web/API/fetch), only in a way
+ * that supports [Suspense](https://reactjs.org/docs/concurrent-mode-suspense.html).
+ */
+export declare function fetchSync(url: string, options?: Omit<RequestInit, 'cache'> & HydrogenUseQueryOptions): ResponseSync;
diff --git a/dist/dist/esnext/foundation/fetchSync/server/fetchSync.js b/dist/dist/esnext/foundation/fetchSync/server/fetchSync.js
new file mode 100644
index 0000000000000000000000000000000000000000..4def06e7f92c5b0b0e808b62b6d6d8c4f8e50bdc
--- /dev/null
+++ b/dist/dist/esnext/foundation/fetchSync/server/fetchSync.js
@@ -0,0 +1,26 @@
+import { useQuery } from '../../useQuery/index.js';
+import { useUrl } from '../../useUrl/index.js';
+import { ResponseSync } from '../ResponseSync.js';
+/**
+ * The `fetchSync` hook makes API requests and is the recommended way to make simple fetch calls on the server and the client.
+ * It's designed similar to the [Web API's `fetch`](https://developer.mozilla.org/en-US/docs/Web/API/fetch), only in a way
+ * that supports [Suspense](https://reactjs.org/docs/concurrent-mode-suspense.html).
+ */
+export function fetchSync(url, options) {
+    const { cache, preload, shouldCacheResponse, ...requestInit } = options ?? {};
+    // eslint-disable-next-line react-hooks/rules-of-hooks
+    const { origin } = useUrl();
+    // eslint-disable-next-line react-hooks/rules-of-hooks
+    const { data, error } = useQuery([url, requestInit], async () => {
+        const response = await globalThis.fetch(new URL(url, origin), requestInit);
+        return ResponseSync.toSerializable(response);
+    }, {
+        cache,
+        preload,
+        shouldCacheResponse,
+    });
+    if (error) {
+        throw error;
+    }
+    return new ResponseSync(data);
+}
diff --git a/dist/dist/esnext/foundation/index.d.ts b/dist/dist/esnext/foundation/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6fe6d0a1b49fce556e4b8f28c1381cad13ee8bb6
--- /dev/null
+++ b/dist/dist/esnext/foundation/index.d.ts
@@ -0,0 +1,3 @@
+export { ServerPropsProvider, ServerPropsContext, type ServerProps, type ServerPropsContextValue, } from './ServerPropsProvider/index.js';
+export { useShop } from './useShop/index.js';
+export { useUrl } from './useUrl/index.js';
diff --git a/dist/dist/esnext/foundation/index.js b/dist/dist/esnext/foundation/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..0188e5374d27d892038ea508b127e21fda8f9bae
--- /dev/null
+++ b/dist/dist/esnext/foundation/index.js
@@ -0,0 +1,3 @@
+export { ServerPropsProvider, ServerPropsContext, } from './ServerPropsProvider/index.js';
+export { useShop } from './useShop/index.js';
+export { useUrl } from './useUrl/index.js';
diff --git a/dist/dist/esnext/foundation/runtime.d.ts b/dist/dist/esnext/foundation/runtime.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f83d3308d8d3f6ab9cf0c97b0d89580e87731ea3
--- /dev/null
+++ b/dist/dist/esnext/foundation/runtime.d.ts
@@ -0,0 +1,2 @@
+export declare function setCache(cache?: Cache): void;
+export declare function getCache(): Cache | undefined;
diff --git a/dist/dist/esnext/foundation/runtime.js b/dist/dist/esnext/foundation/runtime.js
new file mode 100644
index 0000000000000000000000000000000000000000..82b5756fc94059fc8a893d1d2c75f1b3c0f8bd83
--- /dev/null
+++ b/dist/dist/esnext/foundation/runtime.js
@@ -0,0 +1,6 @@
+export function setCache(cache) {
+    globalThis.__cache = cache;
+}
+export function getCache() {
+    return globalThis.__cache;
+}
diff --git a/dist/dist/esnext/foundation/session/session-types.d.ts b/dist/dist/esnext/foundation/session/session-types.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5aa3044d0245f35fdb25fec98fab67c5b1030114
--- /dev/null
+++ b/dist/dist/esnext/foundation/session/session-types.d.ts
@@ -0,0 +1,15 @@
+export declare type SessionSyncApi = {
+    get: () => Record<string, string>;
+    set: (data: Record<string, any>) => any;
+};
+export declare type SessionApi = {
+    get: () => Promise<Record<string, string>>;
+    set: (key: string, value: string) => Promise<void>;
+    destroy: () => Promise<void>;
+    getFlash: (key: string) => any;
+};
+export declare type SessionStorageAdapter = {
+    get: (request: Request) => Promise<Record<string, string>>;
+    set: (request: Request, value: Record<string, string>) => Promise<string>;
+    destroy: (request: Request) => Promise<string>;
+};
diff --git a/dist/dist/esnext/foundation/session/session-types.js b/dist/dist/esnext/foundation/session/session-types.js
new file mode 100644
index 0000000000000000000000000000000000000000..cb0ff5c3b541f646105198ee23ac0fc3d805023e
--- /dev/null
+++ b/dist/dist/esnext/foundation/session/session-types.js
@@ -0,0 +1 @@
+export {};
diff --git a/dist/dist/esnext/foundation/session/session.d.ts b/dist/dist/esnext/foundation/session/session.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..10bc96d7d1e1e2c3026d8c65f49bd109a09305f5
--- /dev/null
+++ b/dist/dist/esnext/foundation/session/session.d.ts
@@ -0,0 +1,18 @@
+import { Logger } from '../../utilities/log/index.js';
+import type { HydrogenResponse } from '../HydrogenResponse/HydrogenResponse.server.js';
+import type { HydrogenRequest } from '../HydrogenRequest/HydrogenRequest.server.js';
+import type { SessionStorageAdapter } from './session-types.js';
+export declare function getSyncSessionApi(request: HydrogenRequest, componentResponse: HydrogenResponse, log: Logger, session?: SessionStorageAdapter): {
+    get(): any;
+    set(data: Record<string, any>): any;
+};
+export declare const emptySessionImplementation: (log: Logger) => {
+    getFlash(key: string): Promise<null>;
+    get(): Promise<{}>;
+    set(key: string, value: string): Promise<void>;
+    destroy(): Promise<void>;
+};
+export declare const emptySyncSessionImplementation: (log: Logger) => {
+    get(): {};
+    set(data: Record<string, any>): null;
+};
diff --git a/dist/dist/esnext/foundation/session/session.js b/dist/dist/esnext/foundation/session/session.js
new file mode 100644
index 0000000000000000000000000000000000000000..6b95965d8300389355b97594b369f6dbd06a0d4b
--- /dev/null
+++ b/dist/dist/esnext/foundation/session/session.js
@@ -0,0 +1,53 @@
+import { wrapPromise } from '../../utilities/suspense.js';
+export function getSyncSessionApi(request, componentResponse, log, session) {
+    const sessionPromises = {};
+    return session
+        ? {
+            get() {
+                if (!sessionPromises.getPromise) {
+                    sessionPromises.getPromise = wrapPromise(session.get(request));
+                }
+                return sessionPromises.getPromise.read();
+            },
+            set(data) {
+                if (!sessionPromises.setPromise) {
+                    sessionPromises.setPromise = wrapPromise(session.set(request, data));
+                }
+                const cookie = sessionPromises.setPromise.read();
+                componentResponse.headers.set('Set-Cookie', cookie);
+                return cookie;
+            },
+        }
+        : emptySyncSessionImplementation(log);
+}
+export const emptySessionImplementation = function (log) {
+    return {
+        async getFlash(key) {
+            log.warn('No session adapter has been configured!');
+            return null;
+        },
+        async get() {
+            log.warn('No session adapter has been configured!');
+            return {};
+        },
+        async set(key, value) {
+            log.warn('No session adapter has been configured!');
+        },
+        async destroy() {
+            log.warn('No session adapter has been configured!');
+            return;
+        },
+    };
+};
+export const emptySyncSessionImplementation = function (log) {
+    return {
+        get() {
+            log.warn('No session adapter has been configured!');
+            return {};
+        },
+        set(data) {
+            log.warn('No session adapter has been configured!');
+            return null;
+        },
+    };
+};
diff --git a/dist/dist/esnext/foundation/ssr-interop.d.ts b/dist/dist/esnext/foundation/ssr-interop.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cba3cc10114828bc66358110d9410faf6118794f
--- /dev/null
+++ b/dist/dist/esnext/foundation/ssr-interop.d.ts
@@ -0,0 +1,29 @@
+/**
+ * This file is used for compatibility between browser and server environments.
+ * The browser loads this file as is, without leaking server logic.
+ * In the server, this file is transformed by Vite to inject server logic.
+ * NOTE: Do not remove SSR-prefixed comments in this file.
+ */
+import type { HydrogenRequest } from './HydrogenRequest/HydrogenRequest.server.js';
+export declare const META_ENV_SSR = false;
+declare type ServerGetter<T> = (request: HydrogenRequest) => T;
+/**
+ * Isomorphic hook to access context data. It gives access to the current request
+ * when running on the server, and returns the provided client fallback in the browser.
+ * This can be used in server components (RSC) as a Context/Provider replacement. In client
+ * components, it uses the server getter in SSR and the client fallback in the browser.
+ * @param serverGetter - A function that gets the current server request and returns any
+ * desired request property. It only runs in the server (both in RSC and SSR).
+ * @param clientFallback - An optional raw value or a React.Context to be consumed that will be
+ * returned if the current environment is not the server. Note that, if this is a React.Context,
+ * there must be a React.Provider parent in the app tree.
+ * @returns A value retrieved from the current server request or a fallback value in the client.
+ * The returned type depends on what the server getter returns.
+ * @example
+ * ```js
+ * import {MyClientContext} from './my-client-react-context-provider.js';
+ * useEnvContext(req => req.ctx.myServerContext, MyClientContext)
+ * ```
+ */
+export declare function useEnvContext<T>(serverGetter: ServerGetter<T>, clientFallback?: any): T;
+export {};
diff --git a/dist/dist/esnext/foundation/ssr-interop.js b/dist/dist/esnext/foundation/ssr-interop.js
new file mode 100644
index 0000000000000000000000000000000000000000..930d297872d6feba0755dba823dc338fb707b730
--- /dev/null
+++ b/dist/dist/esnext/foundation/ssr-interop.js
@@ -0,0 +1,35 @@
+/**
+ * This file is used for compatibility between browser and server environments.
+ * The browser loads this file as is, without leaking server logic.
+ * In the server, this file is transformed by Vite to inject server logic.
+ * NOTE: Do not remove SSR-prefixed comments in this file.
+ */
+import { useContext } from 'react';
+//@SSR import {useServerRequest} from './ServerRequestProvider/index.js';
+// This is replaced by Vite to import.meta.env.SSR
+export const META_ENV_SSR = false;
+const reactContextType = Symbol.for('react.context');
+/**
+ * Isomorphic hook to access context data. It gives access to the current request
+ * when running on the server, and returns the provided client fallback in the browser.
+ * This can be used in server components (RSC) as a Context/Provider replacement. In client
+ * components, it uses the server getter in SSR and the client fallback in the browser.
+ * @param serverGetter - A function that gets the current server request and returns any
+ * desired request property. It only runs in the server (both in RSC and SSR).
+ * @param clientFallback - An optional raw value or a React.Context to be consumed that will be
+ * returned if the current environment is not the server. Note that, if this is a React.Context,
+ * there must be a React.Provider parent in the app tree.
+ * @returns A value retrieved from the current server request or a fallback value in the client.
+ * The returned type depends on what the server getter returns.
+ * @example
+ * ```js
+ * import {MyClientContext} from './my-client-react-context-provider.js';
+ * useEnvContext(req => req.ctx.myServerContext, MyClientContext)
+ * ```
+ */
+export function useEnvContext(serverGetter, clientFallback) {
+    //@SSR if (META_ENV_SSR) return serverGetter(useServerRequest());
+    return clientFallback && clientFallback.$$typeof === reactContextType
+        ? useContext(clientFallback) // eslint-disable-line react-hooks/rules-of-hooks
+        : clientFallback;
+}
diff --git a/dist/dist/esnext/foundation/useNavigate/useNavigate.d.ts b/dist/dist/esnext/foundation/useNavigate/useNavigate.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b1f6d7b3cecc8e8d395e14dae74227b4aaa81609
--- /dev/null
+++ b/dist/dist/esnext/foundation/useNavigate/useNavigate.d.ts
@@ -0,0 +1,17 @@
+declare type NavigationOptions = {
+    /** Whether to update the state object or URL of the current history entry. Defaults to false. */
+    replace?: boolean;
+    /** Whether to reload the whole document on navigation. */
+    reloadDocument?: boolean;
+    /** The custom client state with the navigation. */
+    clientState?: any;
+    /** Whether to emulate natural browser behavior and restore scroll position on navigation. Defaults to true. */
+    scroll?: any;
+    basePath?: string;
+};
+/**
+ * The useNavigate hook imperatively navigates between routes.
+ */
+export declare function useNavigate(): (path: string, options?: NavigationOptions) => void;
+export declare function buildPath(basePath: string, path: string): string;
+export {};
diff --git a/dist/dist/esnext/foundation/useNavigate/useNavigate.js b/dist/dist/esnext/foundation/useNavigate/useNavigate.js
new file mode 100644
index 0000000000000000000000000000000000000000..80cb658ec0ac71263fcde56107e925a7e1c5e24f
--- /dev/null
+++ b/dist/dist/esnext/foundation/useNavigate/useNavigate.js
@@ -0,0 +1,39 @@
+import { useRouter } from '../Router/BrowserRouter.client.js';
+import { useBasePath } from '../useRouteParams/RouteParamsProvider.client.js';
+/**
+ * The useNavigate hook imperatively navigates between routes.
+ */
+export function useNavigate() {
+    const router = useRouter();
+    const routeBasePath = useBasePath();
+    return (path, options = { replace: false, reloadDocument: false }) => {
+        path = buildPath(options.basePath ?? routeBasePath, path);
+        const state = {
+            ...options?.clientState,
+            scroll: options?.scroll ?? true,
+        };
+        // @todo wait for RSC and then change focus for a11y?
+        if (options?.replace) {
+            router.history.replace(path, state);
+        }
+        else {
+            router.history.push(path, state);
+        }
+    };
+}
+export function buildPath(basePath, path) {
+    if (path.startsWith('http') || path.startsWith('//'))
+        return path;
+    let builtPath = path;
+    if (basePath !== '/') {
+        const pathFirstChar = path.charAt(0);
+        const basePathLastChar = basePath.charAt(basePath.length - 1);
+        builtPath =
+            pathFirstChar === '/' && basePathLastChar === '/'
+                ? basePath + path.substring(1)
+                : basePathLastChar !== '/' && pathFirstChar !== '/'
+                    ? basePath + '/' + path
+                    : basePath + path;
+    }
+    return builtPath;
+}
diff --git a/dist/dist/esnext/foundation/useQuery/hooks.d.ts b/dist/dist/esnext/foundation/useQuery/hooks.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..461c9fac5174e1469971176cca29a637f2d35dad
--- /dev/null
+++ b/dist/dist/esnext/foundation/useQuery/hooks.d.ts
@@ -0,0 +1,40 @@
+import type { CachingStrategy, PreloadOptions, QueryKey } from '../../types.js';
+export interface HydrogenUseQueryOptions {
+    /** The [caching strategy](https://shopify.dev/custom-storefronts/hydrogen/framework/cache#caching-strategies) to help you
+     * determine which cache control header to set.
+     */
+    cache?: CachingStrategy;
+    /** Whether to [preload the query](https://shopify.dev/custom-storefronts/hydrogen/framework/preloaded-queries).
+     * Defaults to `false`. Specify `true` to preload the query for the URL or `'*'`
+     * to preload the query for all requests.
+     */
+    preload?: PreloadOptions;
+    /** A function that inspects the response body to determine if it should be cached.
+     */
+    shouldCacheResponse?: (body: any) => boolean;
+}
+declare global {
+    var __HYDROGEN_CACHE_ID__: string;
+}
+/**
+ * The `useQuery` hook executes an asynchronous operation like `fetch` in a way that
+ * supports [Suspense](https://reactjs.org/docs/concurrent-mode-suspense.html). You can use this
+ * hook to call any third-party APIs from a server component.
+ *
+ * \> Note:
+ * \> If you're making a simple fetch call on the server, then we recommend using the [`fetchSync`](https://shopify.dev/api/hydrogen/hooks/global/fetchsync) hook instead.
+ */
+export declare function useQuery<T>(
+/** A string or array to uniquely identify the current query. */
+key: QueryKey, 
+/** An asynchronous query function like `fetch` which returns data. */
+queryFn: () => Promise<T>, 
+/** The options to manage the cache behavior of the sub-request. */
+queryOptions?: HydrogenUseQueryOptions): {
+    data?: undefined;
+    error: Error | Response;
+} | {
+    data: T;
+    error?: undefined;
+};
+export declare function shouldPreloadQuery(queryOptions?: HydrogenUseQueryOptions): boolean;
diff --git a/dist/dist/esnext/foundation/useQuery/hooks.js b/dist/dist/esnext/foundation/useQuery/hooks.js
new file mode 100644
index 0000000000000000000000000000000000000000..a76b6b1980a6acb183fd2cc6fdad0ce616d2a6f4
--- /dev/null
+++ b/dist/dist/esnext/foundation/useQuery/hooks.js
@@ -0,0 +1,105 @@
+import { getLoggerWithContext, collectQueryCacheControlHeaders, collectQueryTimings, } from '../../utilities/log/index.js';
+import { deleteItemFromCache, generateSubRequestCacheControlHeader, getItemFromCache, isStale, setItemInCache, } from '../Cache/cache-sub-request.js';
+import { useRequestCacheData, useServerRequest, } from '../ServerRequestProvider/index.js';
+import { CacheShort, NO_STORE } from '../Cache/strategies/index.js';
+/**
+ * The `useQuery` hook executes an asynchronous operation like `fetch` in a way that
+ * supports [Suspense](https://reactjs.org/docs/concurrent-mode-suspense.html). You can use this
+ * hook to call any third-party APIs from a server component.
+ *
+ * \> Note:
+ * \> If you're making a simple fetch call on the server, then we recommend using the [`fetchSync`](https://shopify.dev/api/hydrogen/hooks/global/fetchsync) hook instead.
+ */
+export function useQuery(
+/** A string or array to uniquely identify the current query. */
+key, 
+/** An asynchronous query function like `fetch` which returns data. */
+queryFn, 
+/** The options to manage the cache behavior of the sub-request. */
+queryOptions) {
+    const request = useServerRequest();
+    const withCacheIdKey = [
+        __HYDROGEN_CACHE_ID__,
+        ...(typeof key === 'string' ? [key] : key),
+    ];
+    const fetcher = cachedQueryFnBuilder(withCacheIdKey, queryFn, queryOptions);
+    collectQueryTimings(request, withCacheIdKey, 'requested');
+    if (shouldPreloadQuery(queryOptions)) {
+        request.savePreloadQuery({
+            preload: queryOptions?.preload,
+            key: withCacheIdKey,
+            fetcher,
+        });
+    }
+    return useRequestCacheData(withCacheIdKey, fetcher);
+}
+export function shouldPreloadQuery(queryOptions) {
+    if (!queryOptions)
+        return true;
+    const hasCacheOverride = typeof queryOptions?.cache?.mode !== 'undefined';
+    const hasPreloadOverride = typeof queryOptions?.preload !== 'undefined';
+    const cacheValue = queryOptions?.cache?.mode;
+    const preloadValue = queryOptions?.preload;
+    // If preload is explicitly defined, then it takes precedence
+    if (hasPreloadOverride) {
+        return !!preloadValue;
+    }
+    return hasCacheOverride ? cacheValue !== NO_STORE : true;
+}
+function cachedQueryFnBuilder(key, generateNewOutput, queryOptions) {
+    const resolvedQueryOptions = {
+        ...(queryOptions ?? {}),
+    };
+    const shouldCacheResponse = queryOptions?.shouldCacheResponse ?? (() => true);
+    /**
+     * Attempt to read the query from cache. If it doesn't exist or if it's stale, regenerate it.
+     */
+    async function useCachedQueryFn(request) {
+        const log = getLoggerWithContext(request);
+        const cacheResponse = await getItemFromCache(key);
+        if (cacheResponse) {
+            const [output, response] = cacheResponse;
+            collectQueryCacheControlHeaders(request, key, response.headers.get('cache-control'));
+            /**
+             * Important: Do this async
+             */
+            if (isStale(key, response)) {
+                const lockKey = ['lock', ...(typeof key === 'string' ? [key] : key)];
+                // Run revalidation asynchronously
+                const revalidatingPromise = getItemFromCache(lockKey).then(async (lockExists) => {
+                    if (lockExists)
+                        return;
+                    await setItemInCache(lockKey, true, CacheShort({
+                        maxAge: 10,
+                    }));
+                    try {
+                        const output = await generateNewOutput();
+                        if (shouldCacheResponse(output)) {
+                            await setItemInCache(key, output, resolvedQueryOptions?.cache);
+                        }
+                    }
+                    catch (e) {
+                        log.error(`Error generating async response: ${e.message}`);
+                    }
+                    finally {
+                        await deleteItemFromCache(lockKey);
+                    }
+                });
+                // Asynchronously wait for it in workers
+                request.ctx.runtime?.waitUntil?.(revalidatingPromise);
+            }
+            return output;
+        }
+        const newOutput = await generateNewOutput();
+        /**
+         * Important: Do this async
+         */
+        if (shouldCacheResponse(newOutput)) {
+            const setItemInCachePromise = setItemInCache(key, newOutput, resolvedQueryOptions?.cache);
+            request.ctx.runtime?.waitUntil?.(setItemInCachePromise);
+        }
+        collectQueryCacheControlHeaders(request, key, generateSubRequestCacheControlHeader(resolvedQueryOptions?.cache));
+        return newOutput;
+    }
+    return useCachedQueryFn;
+}
diff --git a/dist/dist/esnext/foundation/useQuery/index.d.ts b/dist/dist/esnext/foundation/useQuery/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..30227ed9e1fca97d9af395b2133edb7b59c4c487
--- /dev/null
+++ b/dist/dist/esnext/foundation/useQuery/index.d.ts
@@ -0,0 +1 @@
+export { useQuery, type HydrogenUseQueryOptions, shouldPreloadQuery, } from './hooks.js';
diff --git a/dist/dist/esnext/foundation/useQuery/index.js b/dist/dist/esnext/foundation/useQuery/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..31bab7b219b5d24a365d2c5edb606dc9721dcf0a
--- /dev/null
+++ b/dist/dist/esnext/foundation/useQuery/index.js
@@ -0,0 +1 @@
+export { useQuery, shouldPreloadQuery, } from './hooks.js';
diff --git a/dist/dist/esnext/foundation/useRequestContext/index.d.ts b/dist/dist/esnext/foundation/useRequestContext/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4c13800a5afd9537aa214b9fbc125d9a38c55892
--- /dev/null
+++ b/dist/dist/esnext/foundation/useRequestContext/index.d.ts
@@ -0,0 +1,15 @@
+declare type ScopedContext = Record<string, any>;
+/**
+ * Provides access to the current request context.
+ * @param scope - An optional string used to scope the request context. It is recommended to
+ * prevent modifying the properties added by other plugins.
+ * @returns A request-scoped object that can be modified to provide and consume information
+ * across different React components in the tree.
+ * @example
+ * ```js
+ * import {useRequestContext} from '@shopify/hydrogen';
+ * useRequestContext('my-plugin-name');
+ * ```
+ */
+export declare function useRequestContext<T extends ScopedContext>(scope?: string): T;
+export {};
diff --git a/dist/dist/esnext/foundation/useRequestContext/index.js b/dist/dist/esnext/foundation/useRequestContext/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..2416942a51c5eda194519eacd50617f90b21a3cc
--- /dev/null
+++ b/dist/dist/esnext/foundation/useRequestContext/index.js
@@ -0,0 +1,23 @@
+import { META_ENV_SSR, useEnvContext } from '../ssr-interop.js';
+/**
+ * Provides access to the current request context.
+ * @param scope - An optional string used to scope the request context. It is recommended to
+ * prevent modifying the properties added by other plugins.
+ * @returns A request-scoped object that can be modified to provide and consume information
+ * across different React components in the tree.
+ * @example
+ * ```js
+ * import {useRequestContext} from '@shopify/hydrogen';
+ * useRequestContext('my-plugin-name');
+ * ```
+ */
+export function useRequestContext(scope = 'default') {
+    if (__HYDROGEN_DEV__ && !META_ENV_SSR) {
+        throw new Error('useRequestContext can only be used in the server');
+    }
+    const scopes = useEnvContext((req) => req.ctx.scopes);
+    if (!scopes.has(scope)) {
+        scopes.set(scope, Object.create(null));
+    }
+    return scopes.get(scope);
+}
diff --git a/dist/dist/esnext/foundation/useRouteParams/RouteParamsProvider.client.d.ts b/dist/dist/esnext/foundation/useRouteParams/RouteParamsProvider.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8f162b42ac8cd008595a13b6dabe9d7bc92b8481
--- /dev/null
+++ b/dist/dist/esnext/foundation/useRouteParams/RouteParamsProvider.client.d.ts
@@ -0,0 +1,13 @@
+import React, { FC, ReactNode } from 'react';
+declare type RouteParamsContextValue = {
+    routeParams: Record<string, string>;
+    basePath: string;
+};
+export declare const RouteParamsContext: React.Context<RouteParamsContextValue>;
+export declare const RouteParamsProvider: FC<{
+    routeParams: Record<string, string>;
+    basePath: string;
+    children: ReactNode;
+}>;
+export declare function useBasePath(): string;
+export {};
diff --git a/dist/dist/esnext/foundation/useRouteParams/RouteParamsProvider.client.js b/dist/dist/esnext/foundation/useRouteParams/RouteParamsProvider.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..0ee5fdac5a78f91087bbb893020bcbf9bef238ee
--- /dev/null
+++ b/dist/dist/esnext/foundation/useRouteParams/RouteParamsProvider.client.js
@@ -0,0 +1,12 @@
+import React, { useContext, createContext } from 'react';
+export const RouteParamsContext = createContext({
+    routeParams: {},
+    basePath: '/',
+});
+export const RouteParamsProvider = ({ children, routeParams, basePath }) => {
+    return (React.createElement(RouteParamsContext.Provider, { value: { routeParams, basePath } }, children));
+};
+export function useBasePath() {
+    const router = useContext(RouteParamsContext);
+    return router.basePath;
+}
diff --git a/dist/dist/esnext/foundation/useRouteParams/useRouteParams.d.ts b/dist/dist/esnext/foundation/useRouteParams/useRouteParams.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b19ea00bf268ffbbe7b97beb7ec28d7d594f98d2
--- /dev/null
+++ b/dist/dist/esnext/foundation/useRouteParams/useRouteParams.d.ts
@@ -0,0 +1,4 @@
+/**
+ *  The `useRouteParams` hook retrieves the parameters of an active route. The hook is available in both server and client components.
+ */
+export declare function useRouteParams(): Record<string, string>;
diff --git a/dist/dist/esnext/foundation/useRouteParams/useRouteParams.js b/dist/dist/esnext/foundation/useRouteParams/useRouteParams.js
new file mode 100644
index 0000000000000000000000000000000000000000..dbd00ac28d6b31901458e6ba7ff18acf08a785d5
--- /dev/null
+++ b/dist/dist/esnext/foundation/useRouteParams/useRouteParams.js
@@ -0,0 +1,9 @@
+import { useEnvContext } from '../ssr-interop.js';
+import { RouteParamsContext } from './RouteParamsProvider.client.js';
+/**
+ *  The `useRouteParams` hook retrieves the parameters of an active route. The hook is available in both server and client components.
+ */
+export function useRouteParams() {
+    const router = useEnvContext((req) => req.ctx.router, RouteParamsContext);
+    return router.routeParams;
+}
diff --git a/dist/dist/esnext/foundation/useServerProps/index.d.ts b/dist/dist/esnext/foundation/useServerProps/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..57dd5a83aee7d690311048457f9e1baa43d83f9f
--- /dev/null
+++ b/dist/dist/esnext/foundation/useServerProps/index.d.ts
@@ -0,0 +1 @@
+export { useServerProps } from './use-server-props.js';
diff --git a/dist/dist/esnext/foundation/useServerProps/index.js b/dist/dist/esnext/foundation/useServerProps/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..57dd5a83aee7d690311048457f9e1baa43d83f9f
--- /dev/null
+++ b/dist/dist/esnext/foundation/useServerProps/index.js
@@ -0,0 +1 @@
+export { useServerProps } from './use-server-props.js';
diff --git a/dist/dist/esnext/foundation/useServerProps/use-server-props.d.ts b/dist/dist/esnext/foundation/useServerProps/use-server-props.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..85cc7c288ff77b180f2c72edf8d0d808cf35b579
--- /dev/null
+++ b/dist/dist/esnext/foundation/useServerProps/use-server-props.d.ts
@@ -0,0 +1,21 @@
+import { ServerPropsContextValue, InternalServerPropsContextValue } from '../ServerPropsProvider/ServerPropsProvider.js';
+/**
+ * The `useServerProps` hook allows you to manage the [server props](https://shopify.dev/custom-storefronts/hydrogen/framework/server-props) passed to your server components when using Hydrogen as a React Server Component framework. The server props get cleared when you navigate from one route to another.
+ *
+ * ## Return value
+ *
+ * The `useServerProps` hook returns an object with the following keys:
+ *
+ * | Key              | Description                                                                            |
+ * | ---------------- | -------------------------------------------------------------------------------------- |
+ * | `serverProps`    | The current server props.                                                              |
+ * | `setServerProps` | A function used to modify server props.                                                |
+ * | `pending`        | Whether a [transition is pending](https://github.com/reactwg/react-18/discussions/41). |
+ *
+ */
+export declare function useServerProps(): ServerPropsContextValue;
+/**
+ * Internal-only hook to manage server state, including to set location server state
+ * @internal
+ */
+export declare function useInternalServerProps(): InternalServerPropsContextValue;
diff --git a/dist/dist/esnext/foundation/useServerProps/use-server-props.js b/dist/dist/esnext/foundation/useServerProps/use-server-props.js
new file mode 100644
index 0000000000000000000000000000000000000000..8e59ff686a8ba41721a90c9e0900fa46f1006c59
--- /dev/null
+++ b/dist/dist/esnext/foundation/useServerProps/use-server-props.js
@@ -0,0 +1,35 @@
+import { useContext } from 'react';
+import { ServerPropsContext, } from '../ServerPropsProvider/ServerPropsProvider.js';
+/**
+ * The `useServerProps` hook allows you to manage the [server props](https://shopify.dev/custom-storefronts/hydrogen/framework/server-props) passed to your server components when using Hydrogen as a React Server Component framework. The server props get cleared when you navigate from one route to another.
+ *
+ * ## Return value
+ *
+ * The `useServerProps` hook returns an object with the following keys:
+ *
+ * | Key              | Description                                                                            |
+ * | ---------------- | -------------------------------------------------------------------------------------- |
+ * | `serverProps`    | The current server props.                                                              |
+ * | `setServerProps` | A function used to modify server props.                                                |
+ * | `pending`        | Whether a [transition is pending](https://github.com/reactwg/react-18/discussions/41). |
+ *
+ */
+export function useServerProps() {
+    const internalServerPropsContext = useContext(ServerPropsContext);
+    if (!internalServerPropsContext) {
+        return {};
+    }
+    return {
+        serverProps: internalServerPropsContext.serverProps,
+        setServerProps: internalServerPropsContext.setServerProps,
+        pending: internalServerPropsContext.pending,
+    };
+}
+/**
+ * Internal-only hook to manage server state, including to set location server state
+ * @internal
+ */
+export function useInternalServerProps() {
+    return (useContext(ServerPropsContext) ??
+        {});
+}
diff --git a/dist/dist/esnext/foundation/useSession/useSession.d.ts b/dist/dist/esnext/foundation/useSession/useSession.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0bf36b41ff64e6ed96470d7e700906f5769f1ae2
--- /dev/null
+++ b/dist/dist/esnext/foundation/useSession/useSession.d.ts
@@ -0,0 +1,3 @@
+/** The `useSession` hook reads session data in server components. */
+export declare const useSession: () => Record<string, string>;
+export declare const useFlashSession: (key: string) => string;
diff --git a/dist/dist/esnext/foundation/useSession/useSession.js b/dist/dist/esnext/foundation/useSession/useSession.js
new file mode 100644
index 0000000000000000000000000000000000000000..a4da698e6e20942c509d5448c908a7931d14e784
--- /dev/null
+++ b/dist/dist/esnext/foundation/useSession/useSession.js
@@ -0,0 +1,20 @@
+import { useServerRequest } from '../ServerRequestProvider/index.js';
+/** The `useSession` hook reads session data in server components. */
+export const useSession = function () {
+    const request = useServerRequest();
+    const session = request.ctx.session?.get() || {};
+    return session;
+};
+export const useFlashSession = function (key) {
+    const request = useServerRequest();
+    const data = request.ctx.session?.get() || {};
+    let value = data[key];
+    if (value) {
+        delete data[key];
+        request.ctx.flashSession[key] = value;
+    }
+    request.ctx.session?.set(data);
+    value = request.ctx.flashSession[key];
+    delete request.ctx.flashSession[key];
+    return value;
+};
diff --git a/dist/dist/esnext/foundation/useShop/index.d.ts b/dist/dist/esnext/foundation/useShop/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..79cae6bfed567ecc2f1c212f9f3174493751d4de
--- /dev/null
+++ b/dist/dist/esnext/foundation/useShop/index.d.ts
@@ -0,0 +1 @@
+export { useShop } from './use-shop.js';
diff --git a/dist/dist/esnext/foundation/useShop/index.js b/dist/dist/esnext/foundation/useShop/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..79cae6bfed567ecc2f1c212f9f3174493751d4de
--- /dev/null
+++ b/dist/dist/esnext/foundation/useShop/index.js
@@ -0,0 +1 @@
+export { useShop } from './use-shop.js';
diff --git a/dist/dist/esnext/foundation/useShop/use-shop.d.ts b/dist/dist/esnext/foundation/useShop/use-shop.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..62cf5c0047fda6bf026c6421638dd7462e3efd15
--- /dev/null
+++ b/dist/dist/esnext/foundation/useShop/use-shop.d.ts
@@ -0,0 +1,6 @@
+/**
+ * The `useShop` hook provides access to values within
+ * [the `shopify` property in the `hydrogen.config.js` file](https://shopify.dev/custom-storefronts/hydrogen/framework/hydrogen-config).
+ * The `useShop` hook must be a descendent of a `ShopifyProvider` component.
+ */
+export declare function useShop(): import("../ShopifyProvider/types.js").ShopifyContextServerValue;
diff --git a/dist/dist/esnext/foundation/useShop/use-shop.js b/dist/dist/esnext/foundation/useShop/use-shop.js
new file mode 100644
index 0000000000000000000000000000000000000000..696ebf355a47faa6ead64ea02af99f477ae42019
--- /dev/null
+++ b/dist/dist/esnext/foundation/useShop/use-shop.js
@@ -0,0 +1,14 @@
+import { ShopifyContext } from '../ShopifyProvider/index.js';
+import { useEnvContext } from '../ssr-interop.js';
+/**
+ * The `useShop` hook provides access to values within
+ * [the `shopify` property in the `hydrogen.config.js` file](https://shopify.dev/custom-storefronts/hydrogen/framework/hydrogen-config).
+ * The `useShop` hook must be a descendent of a `ShopifyProvider` component.
+ */
+export function useShop() {
+    const config = useEnvContext((req) => req.ctx.shopifyConfig, ShopifyContext);
+    if (!config) {
+        throw new Error('No Shopify Context found');
+    }
+    return config;
+}
diff --git a/dist/dist/esnext/foundation/useUrl/index.d.ts b/dist/dist/esnext/foundation/useUrl/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..744b77f4f15a54cf5f0a492c971416e6a89268d2
--- /dev/null
+++ b/dist/dist/esnext/foundation/useUrl/index.d.ts
@@ -0,0 +1 @@
+export { useUrl } from './useUrl.js';
diff --git a/dist/dist/esnext/foundation/useUrl/index.js b/dist/dist/esnext/foundation/useUrl/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..744b77f4f15a54cf5f0a492c971416e6a89268d2
--- /dev/null
+++ b/dist/dist/esnext/foundation/useUrl/index.js
@@ -0,0 +1 @@
+export { useUrl } from './useUrl.js';
diff --git a/dist/dist/esnext/foundation/useUrl/useUrl.d.ts b/dist/dist/esnext/foundation/useUrl/useUrl.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2ff63380c28adfa092f1151e3608e38ff1bc8a9c
--- /dev/null
+++ b/dist/dist/esnext/foundation/useUrl/useUrl.d.ts
@@ -0,0 +1,4 @@
+/**
+ * The `useUrl` hook retrieves the current URL in a server or client component.
+ */
+export declare function useUrl(): URL;
diff --git a/dist/dist/esnext/foundation/useUrl/useUrl.js b/dist/dist/esnext/foundation/useUrl/useUrl.js
new file mode 100644
index 0000000000000000000000000000000000000000..a83960b4027f43350c67c3c69f82e891452374a6
--- /dev/null
+++ b/dist/dist/esnext/foundation/useUrl/useUrl.js
@@ -0,0 +1,29 @@
+import { useContext, useMemo } from 'react';
+import { RSC_PATHNAME } from '../../constants.js';
+import { parseJSON } from '../../utilities/parse.js';
+import { RouterContext } from '../Router/BrowserRouter.client.js';
+import { useEnvContext, META_ENV_SSR } from '../ssr-interop.js';
+/**
+ * The `useUrl` hook retrieves the current URL in a server or client component.
+ */
+export function useUrl() {
+    if (META_ENV_SSR) {
+        const serverUrl = new URL(useEnvContext((req) => req.url) // eslint-disable-line react-hooks/rules-of-hooks
+        );
+        if (serverUrl.pathname === RSC_PATHNAME) {
+            const state = parseJSON(serverUrl.searchParams.get('state') || '{}');
+            const parsedUrl = `${serverUrl.origin}${state.pathname ?? ''}${state.search ?? ''}`;
+            return new URL(parsedUrl);
+        }
+        return new URL(serverUrl);
+    }
+    /**
+     * We return a `URL` object instead of passing through `location` because
+     * the URL object contains important info like hostname, etc.
+     * Note: do not call `useLocation` directly here to avoid throwing errors
+     * when `useUrl` is used outside of a Router component (e.g. in <Seo>).
+     */
+    const location = useContext(RouterContext); // eslint-disable-line react-hooks/rules-of-hooks
+    // eslint-disable-next-line react-hooks/rules-of-hooks
+    return useMemo(() => new URL(window.location.href), [location]); // eslint-disable-line react-hooks/exhaustive-deps
+}
diff --git a/dist/dist/esnext/framework/cache/in-memory.d.ts b/dist/dist/esnext/framework/cache/in-memory.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6ccedcdb2f8a7fda49f6380542054f3bd6d7630b
--- /dev/null
+++ b/dist/dist/esnext/framework/cache/in-memory.d.ts
@@ -0,0 +1,17 @@
+/**
+ * This is a limited implementation of an in-memory cache.
+ * It only supports the `cache-control` header.
+ * It does NOT support `age` or `expires` headers.
+ * @see https://developer.mozilla.org/en-US/docs/Web/API/Cache
+ */
+export declare class InMemoryCache implements Cache {
+    #private;
+    constructor();
+    add(request: RequestInfo): Promise<void>;
+    addAll(requests: RequestInfo[]): Promise<void>;
+    matchAll(request?: RequestInfo, options?: CacheQueryOptions): Promise<readonly Response[]>;
+    put(request: Request, response: Response): Promise<void>;
+    match(request: Request): Promise<Response | undefined>;
+    delete(request: Request): Promise<boolean>;
+    keys(request?: Request): Promise<Request[]>;
+}
diff --git a/dist/dist/esnext/framework/cache/in-memory.js b/dist/dist/esnext/framework/cache/in-memory.js
new file mode 100644
index 0000000000000000000000000000000000000000..51d7033ba3930c24158efa7878c285a91ebf7ebf
--- /dev/null
+++ b/dist/dist/esnext/framework/cache/in-memory.js
@@ -0,0 +1,80 @@
+/**
+ * This is a limited implementation of an in-memory cache.
+ * It only supports the `cache-control` header.
+ * It does NOT support `age` or `expires` headers.
+ * @see https://developer.mozilla.org/en-US/docs/Web/API/Cache
+ */
+export class InMemoryCache {
+    #store;
+    constructor() {
+        this.#store = new Map();
+    }
+    add(request) {
+        throw new Error('Method not implemented. Use `put` instead.');
+    }
+    addAll(requests) {
+        throw new Error('Method not implemented. Use `put` instead.');
+    }
+    matchAll(request, options) {
+        throw new Error('Method not implemented. Use `match` instead.');
+    }
+    async put(request, response) {
+        if (request.method !== 'GET') {
+            throw new TypeError('Cannot cache response to non-GET request.');
+        }
+        if (response.status === 206) {
+            throw new TypeError('Cannot cache response to a range request (206 Partial Content).');
+        }
+        if (response.headers.get('vary')?.includes('*')) {
+            throw new TypeError("Cannot cache response with 'Vary: *' header.");
+        }
+        this.#store.set(request.url, {
+            body: new Uint8Array(await response.arrayBuffer()),
+            status: response.status,
+            headers: [...response.headers],
+            timestamp: Date.now(),
+        });
+    }
+    async match(request) {
+        if (request.method !== 'GET')
+            return;
+        const match = this.#store.get(request.url);
+        if (!match) {
+            return;
+        }
+        const { body, timestamp, ...metadata } = match;
+        const headers = new Headers(metadata.headers);
+        const cacheControl = headers.get('cache-control') || '';
+        const maxAge = parseInt(cacheControl.match(/max-age=(\d+)/)?.[1] || '0', 10);
+        const swr = parseInt(cacheControl.match(/stale-while-revalidate=(\d+)/)?.[1] || '0', 10);
+        const age = (Date.now() - timestamp) / 1000;
+        const isMiss = age > maxAge + swr;
+        if (isMiss) {
+            this.#store.delete(request.url);
+            return;
+        }
+        const isStale = age > maxAge;
+        headers.set('cache', isStale ? 'STALE' : 'HIT');
+        headers.set('date', new Date(timestamp).toUTCString());
+        return new Response(body, {
+            status: metadata.status ?? 200,
+            headers,
+        });
+    }
+    async delete(request) {
+        if (this.#store.has(request.url)) {
+            this.#store.delete(request.url);
+            return true;
+        }
+        return false;
+    }
+    keys(request) {
+        const cacheKeys = [];
+        for (const url of this.#store.keys()) {
+            if (!request || request.url === url) {
+                cacheKeys.push(new Request(url));
+            }
+        }
+        return Promise.resolve(cacheKeys);
+    }
+}
diff --git a/dist/dist/esnext/framework/graphiql.d.ts b/dist/dist/esnext/framework/graphiql.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d834c3428ffae6d3e4886c53d81f5c2fe6ea9789
--- /dev/null
+++ b/dist/dist/esnext/framework/graphiql.d.ts
@@ -0,0 +1 @@
+export declare function graphiqlHtml(shop: string, token: string, apiVersion: string): string;
diff --git a/dist/dist/esnext/framework/graphiql.js b/dist/dist/esnext/framework/graphiql.js
new file mode 100644
index 0000000000000000000000000000000000000000..9b49e238d92df76e864e801a977819712f1ae285
--- /dev/null
+++ b/dist/dist/esnext/framework/graphiql.js
@@ -0,0 +1,34 @@
+export function graphiqlHtml(shop, token, apiVersion) {
+    return `
+<!DOCTYPE html>
+<html>
+<head>
+  <meta charset=utf-8/>
+  <meta name="viewport" content="user-scalable=no, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, minimal-ui">
+  <title>Shopify Storefront API</title>
+  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/graphql-playground-react/build/static/css/index.css" />
+  <link rel="shortcut icon" href="//cdn.jsdelivr.net/npm/graphql-playground-react/build/favicon.png" />
+  <script src="//cdn.jsdelivr.net/npm/graphql-playground-react/build/static/js/middleware.js"></script>
+</head>
+<body>
+  <div id="root"></div>
+  <script>window.addEventListener('load', function (event) {
+    GraphQLPlayground.init(document.getElementById('root'), {
+      endpoint:'https://${shop}/api/${apiVersion}/graphql.json',
+      settings:{
+        'request.globalHeaders': {
+          Accept: 'application/json',
+          'Content-Type': 'application/graphql',
+          'X-Shopify-Storefront-Access-Token': '${token}'
+        }
+      },
+      tabs: [{
+        endpoint: 'https://${shop}/api/${apiVersion}/graphql.json',
+        query: '{ shop { name } }'
+      }]
+    })
+  })</script>
+</body>
+</html>
+`;
+}
diff --git a/dist/dist/esnext/framework/load-config.d.ts b/dist/dist/esnext/framework/load-config.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1c3bc772f84177954216bee2c8776446ebb61780
--- /dev/null
+++ b/dist/dist/esnext/framework/load-config.d.ts
@@ -0,0 +1,5 @@
+export declare function loadConfig(options?: {
+    root: string;
+}): Promise<{
+    configuration: any;
+}>;
diff --git a/dist/dist/esnext/framework/load-config.js b/dist/dist/esnext/framework/load-config.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3ea2b0e044502526a23219cf0710e8fdb4cd129
--- /dev/null
+++ b/dist/dist/esnext/framework/load-config.js
@@ -0,0 +1,7 @@
+// Provide Hydrogen config loader to external tools like the CLI
+import { VIRTUAL_PROXY_HYDROGEN_CONFIG_ID } from './plugins/vite-plugin-hydrogen-virtual-files.js';
+import { viteception } from './viteception.js';
+export async function loadConfig(options = { root: process.cwd() }) {
+    const { loaded } = await viteception([VIRTUAL_PROXY_HYDROGEN_CONFIG_ID], options);
+    return { configuration: loaded[0].default };
+}
diff --git a/dist/dist/esnext/framework/middleware.d.ts b/dist/dist/esnext/framework/middleware.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7d726bd838e2215685d5fec519b7bf40a5e1fc3e
--- /dev/null
+++ b/dist/dist/esnext/framework/middleware.d.ts
@@ -0,0 +1,21 @@
+import type { ShopifyConfig } from '../shared-types.js';
+import type { IncomingMessage, NextFunction } from 'connect';
+import type { ServerResponse } from 'http';
+import type { ViteDevServer } from 'vite';
+declare type HydrogenMiddlewareArgs = {
+    dev?: boolean;
+    indexTemplate: string | ((url: string) => Promise<string>);
+    getServerEntrypoint: () => any;
+    devServer?: ViteDevServer;
+    cache?: Cache;
+};
+export declare function graphiqlMiddleware({ getShopifyConfig, dev, }: {
+    getShopifyConfig: (request: IncomingMessage) => ShopifyConfig | Promise<ShopifyConfig>;
+    dev?: boolean;
+}): (request: IncomingMessage, response: ServerResponse, next: NextFunction) => Promise<void>;
+/**
+ * Provides middleware to Node.js Express-like servers. Used by the Hydrogen
+ * Vite dev server plugin as well as production Node.js implementation.
+ */
+export declare function hydrogenMiddleware({ dev, cache, indexTemplate, getServerEntrypoint, devServer, }: HydrogenMiddlewareArgs): (request: IncomingMessage, response: ServerResponse, next: NextFunction) => Promise<void>;
+export {};
diff --git a/dist/dist/esnext/framework/middleware.js b/dist/dist/esnext/framework/middleware.js
new file mode 100644
index 0000000000000000000000000000000000000000..e09f816a54f4e82645bbd59b76e53e70e8666951
--- /dev/null
+++ b/dist/dist/esnext/framework/middleware.js
@@ -0,0 +1,97 @@
+import { graphiqlHtml } from './graphiql.js';
+export function graphiqlMiddleware({ getShopifyConfig, dev, }) {
+    return async function (request, response, next) {
+        if (dev && isGraphiqlRequest(request)) {
+            const shopifyConfig = await getShopifyConfig(request);
+            return respondWithGraphiql(response, shopifyConfig);
+        }
+        next();
+    };
+}
+let entrypointError = null;
+/**
+ * Provides middleware to Node.js Express-like servers. Used by the Hydrogen
+ * Vite dev server plugin as well as production Node.js implementation.
+ */
+export function hydrogenMiddleware({ dev, cache, indexTemplate, getServerEntrypoint, devServer, }) {
+    if (dev && devServer) {
+        // Store this globally for devtools
+        // @ts-ignore
+        globalThis.__viteDevServer = devServer;
+    }
+    /**
+     * We're running in the Node.js runtime without access to `fetch`,
+     * which is needed for proxy requests and server-side API requests.
+     */
+    const webPolyfills = !globalThis.fetch || !globalThis.ReadableStream
+        ? import('../utilities/web-api-polyfill.js')
+        : undefined;
+    return async function (request, response, next) {
+        try {
+            await webPolyfills;
+            const entrypoint = await Promise.resolve(getServerEntrypoint()).catch((error) => {
+                // Errors are only thrown the first time we try to load the entry point.
+                // After refreshing the browser, this just loads an empty module
+                // and doesn't throw anymore. Store this error in the outer scope
+                // to keep throwing it on refresh until things are fixed.
+                entrypointError = error;
+            });
+            const handleRequest = entrypoint?.default ?? entrypoint;
+            if (typeof handleRequest !== 'function') {
+                if (entrypointError) {
+                    throw entrypointError;
+                }
+                else {
+                    // This means there is no error when loading the entry point but
+                    // we are still not getting a function as the default export.
+                    throw new Error('Something is wrong in your project. Make sure to add "export default renderHydrogen(...)" in your server entry file.');
+                }
+            }
+            entrypointError = null;
+            await handleRequest(request, {
+                dev,
+                cache,
+                indexTemplate,
+                streamableResponse: response,
+            });
+        }
+        catch (e) {
+            if (dev && devServer)
+                devServer.ssrFixStacktrace(e);
+            response.statusCode = 500;
+            /**
+             * Attempt to print the error stack within the template.
+             * This allows the react-refresh plugin and other Vite runtime helpers
+             * to display the error and auto-refresh when the error is fixed, instead
+             * of a white screen that needs a manual refresh.
+             */
+            try {
+                const template = typeof indexTemplate === 'function'
+                    ? await indexTemplate(request.originalUrl ?? request.url ?? '')
+                    : indexTemplate;
+                const html = template.replace(`<div id="root"></div>`, `<div id="root"><pre><code>${e.stack}</code></pre></div>`);
+                response.write(html);
+                next(e);
+            }
+            catch (_e) {
+                // If template loading is the culprit, give up and just return the error stack.
+                response.write(e.stack);
+                next(e);
+            }
+        }
+    };
+}
+/**
+ * /graphiql and /___graphql are supported
+ */
+function isGraphiqlRequest(request) {
+    return /^\/(?:_{3})?graphi?ql/.test(request.url || '');
+}
+async function respondWithGraphiql(response, shopifyConfig) {
+    if (!shopifyConfig) {
+        throw new Error("You must provide a 'shopify' property in your Hydrogen config file");
+    }
+    const { storeDomain, storefrontToken, storefrontApiVersion } = shopifyConfig;
+    response.setHeader('Content-Type', 'text/html');
+    response.end(graphiqlHtml(storeDomain?.replace(/^https?:\/\//, ''), storefrontToken, storefrontApiVersion));
+}
diff --git a/dist/dist/esnext/framework/plugin.d.ts b/dist/dist/esnext/framework/plugin.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2ae5f964222addcd9ab9302d06086359d241179a
--- /dev/null
+++ b/dist/dist/esnext/framework/plugin.d.ts
@@ -0,0 +1,8 @@
+import type { HydrogenVitePluginOptions } from './types.js';
+import type { Plugin } from 'vite';
+declare const hydrogenPlugin: {
+    (pluginOptions?: HydrogenVitePluginOptions): Plugin[];
+    default: any;
+};
+export = hydrogenPlugin;
+export default hydrogenPlugin;
diff --git a/dist/dist/esnext/framework/plugin.js b/dist/dist/esnext/framework/plugin.js
new file mode 100644
index 0000000000000000000000000000000000000000..082dadf7436566220af2f73d5595c7776690b3f8
--- /dev/null
+++ b/dist/dist/esnext/framework/plugin.js
@@ -0,0 +1,35 @@
+import hydrogenConfig from './plugins/vite-plugin-hydrogen-config.js';
+import hydrogenMiddleware from './plugins/vite-plugin-hydrogen-middleware.js';
+import hydrogenClientComponentsCache from './plugins/vite-plugin-hydrogen-client-components-cache.js';
+import hydrogenVirtualFiles from './plugins/vite-plugin-hydrogen-virtual-files.js';
+import platformEntry from './plugins/vite-plugin-platform-entry.js';
+import rsc from './plugins/vite-plugin-hydrogen-rsc.js';
+import ssrInterop from './plugins/vite-plugin-ssr-interop.js';
+import hydrationAutoImport from './plugins/vite-plugin-hydration-auto-import.js';
+import inspect from 'vite-plugin-inspect';
+import react from '@vitejs/plugin-react';
+import cssRsc from './plugins/vite-plugin-css-rsc.js';
+import cssModulesRsc from './plugins/vite-plugin-css-modules-rsc.js';
+import clientImports from './plugins/vite-plugin-client-imports.js';
+import suppressWarnings from './plugins/vite-plugin-hydrogen-suppress-warnings.js';
+import assetsVersion from './plugins/vite-plugin-assets-version.js';
+const hydrogenPlugin = (pluginOptions = {}) => {
+    return [
+        process.env.VITE_INSPECT && inspect(),
+        hydrogenConfig(pluginOptions),
+        hydrogenClientComponentsCache(),
+        clientImports(),
+        hydrogenMiddleware(pluginOptions),
+        hydrogenVirtualFiles(pluginOptions),
+        react(),
+        hydrationAutoImport(),
+        ssrInterop(),
+        pluginOptions.experimental?.css === 'global' ? cssRsc() : cssModulesRsc(),
+        rsc(pluginOptions),
+        platformEntry(),
+        suppressWarnings(),
+        pluginOptions.assetHashVersion &&
+            assetsVersion(pluginOptions.assetHashVersion),
+    ];
+};
+export default hydrogenPlugin; // For ESM
diff --git a/dist/dist/esnext/framework/plugins/vite-plugin-assets-version.d.ts b/dist/dist/esnext/framework/plugins/vite-plugin-assets-version.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..848f1cc417c0a339af61e4fea55c7de93ac4ed01
--- /dev/null
+++ b/dist/dist/esnext/framework/plugins/vite-plugin-assets-version.d.ts
@@ -0,0 +1,2 @@
+import { Plugin } from 'vite';
+export default function assetsVersion(version?: string): Plugin;
diff --git a/dist/dist/esnext/framework/plugins/vite-plugin-assets-version.js b/dist/dist/esnext/framework/plugins/vite-plugin-assets-version.js
new file mode 100644
index 0000000000000000000000000000000000000000..4243e80f6ed02f6baa808162daa74b6d206c5060
--- /dev/null
+++ b/dist/dist/esnext/framework/plugins/vite-plugin-assets-version.js
@@ -0,0 +1,12 @@
+/* -- Plugin notes:
+ * Used to manually change the hash of output chunks (`index.k12dw5q.js`)
+ * when their content have not been updated.
+ */
+export default function assetsVersion(version) {
+    return {
+        name: 'hydrogen:augment-with-version',
+        augmentChunkHash() {
+            return version ?? '';
+        },
+    };
+}
diff --git a/dist/dist/esnext/framework/plugins/vite-plugin-client-imports.d.ts b/dist/dist/esnext/framework/plugins/vite-plugin-client-imports.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ad546c642d55dfff0bf84fd6c2f9382af7bc83fc
--- /dev/null
+++ b/dist/dist/esnext/framework/plugins/vite-plugin-client-imports.d.ts
@@ -0,0 +1,2 @@
+import type { Plugin } from 'vite';
+export default function clientImports(): Plugin;
diff --git a/dist/dist/esnext/framework/plugins/vite-plugin-client-imports.js b/dist/dist/esnext/framework/plugins/vite-plugin-client-imports.js
new file mode 100644
index 0000000000000000000000000000000000000000..0954ae83f2ae66d6850ce4c583e89186642b117d
--- /dev/null
+++ b/dist/dist/esnext/framework/plugins/vite-plugin-client-imports.js
@@ -0,0 +1,28 @@
+/* -- Plugin notes:
+ * This plugin allows to import always from '@shopify/hydrogen' path, instead of
+ * using '@shopify/hydrogen/client' in browser files. It does this by redirecting
+ * the server path to the browser path if the importer file is a client component.
+ */
+export default function clientImports() {
+    return {
+        name: 'hydrogen:client-imports',
+        enforce: 'pre',
+        /**
+         * When importer does not end in `server.jsx`, and source is `@shopify/hydrogen`,
+         * replace with `@shopify/hydrogen/client`. This prevents other server-only imports
+         * from "leaking" into the client bundle.
+         */
+        async resolveId(source, importer, { ssr }) {
+            if (ssr)
+                return;
+            if (/\.server\.(j|t)sx?/.test(importer ?? ''))
+                return;
+            if ('@shopify/hydrogen' !== source)
+                return;
+            const resolution = await this.resolve('@shopify/hydrogen/client', importer, { skipSelf: true });
+            if (resolution) {
+                return resolution.id;
+            }
+        },
+    };
+}
diff --git a/dist/dist/esnext/framework/plugins/vite-plugin-css-modules-rsc.d.ts b/dist/dist/esnext/framework/plugins/vite-plugin-css-modules-rsc.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..971c92ede3e5f5ba9a0ca7506529b7f8718c9e67
--- /dev/null
+++ b/dist/dist/esnext/framework/plugins/vite-plugin-css-modules-rsc.d.ts
@@ -0,0 +1,2 @@
+import type { Plugin } from 'vite';
+export default function cssModulesRsc(): Plugin[];
diff --git a/dist/dist/esnext/framework/plugins/vite-plugin-css-modules-rsc.js b/dist/dist/esnext/framework/plugins/vite-plugin-css-modules-rsc.js
new file mode 100644
index 0000000000000000000000000000000000000000..2ed6dd0fdbbcaec58dd77b4ffb34510bf9f1d35a
--- /dev/null
+++ b/dist/dist/esnext/framework/plugins/vite-plugin-css-modules-rsc.js
@@ -0,0 +1,101 @@
+import { HYDROGEN_DEFAULT_SERVER_ENTRY } from './vite-plugin-hydrogen-middleware.js';
+import MagicString from 'magic-string';
+import path from 'path';
+/* -- Plugin notes:
+ * Old approach to inlining CSS inside server components. This is deprecated.
+ */
+const cssModuleRE = /\.module\.(s?css|sass|less|stylus)/;
+export default function cssModulesRsc() {
+    // 1. Original CSS module: `.myStyle { color: red; }`
+    // 2. CSS module after 'pre' Vite transforms: `.myStyle_hashedXYZ { color: red; }`
+    // 3. CSS module after 'post' Vite transforms: `export const myStyle = 'myStyle_hashedXYZ';`
+    let cssMap = new Map();
+    let config;
+    return [
+        {
+            name: 'css-modules-rsc',
+            configResolved(_config) {
+                config = _config;
+                cssMap = new Map();
+                // Place this plugin before react-refresh to
+                // modify files before JSX is compiled.
+                // @ts-ignore
+                config.plugins.unshift(autoStyleTagPlugin());
+            },
+            transform(code, id) {
+                if (cssModuleRE.test(id)) {
+                    cssMap.set(id, code);
+                }
+            },
+        },
+        {
+            name: 'css-modules-rsc-post',
+            enforce: 'post',
+            transform(code, id) {
+                if (id.includes('.module.') && cssMap.has(id)) {
+                    const isDev = config.command === 'serve';
+                    const key = path.relative(config.root, id.split('?')[0]);
+                    const s = new MagicString(code);
+                    s.prepend((isDev
+                        ? `import {jsxDEV as _jsx} from 'react/jsx-dev-runtime';`
+                        : `import {jsx as _jsx} from 'react/jsx-runtime';`) +
+                        `export const StyleTag = () => _jsx('style', {dangerouslySetInnerHTML: {__html: ${JSON.stringify(cssMap.get(id))}}});` +
+                        `\nStyleTag.key = '${key}';\n`);
+                    s.replace(/export default \{/gs, `export default {\n  StyleTag,`);
+                    return {
+                        code: s.toString(),
+                        map: s.generateMap({ file: id, source: id }),
+                    };
+                }
+            },
+        },
+    ];
+}
+function autoStyleTagPlugin() {
+    return {
+        name: 'css-modules-auto-style-tag',
+        transform(code, id) {
+            id = id.split('?')[0];
+            if (/\.[jt]sx$/.test(id) &&
+                !id.endsWith(HYDROGEN_DEFAULT_SERVER_ENTRY) &&
+                !id.endsWith(path.format({
+                    name: HYDROGEN_DEFAULT_SERVER_ENTRY,
+                    ext: path.extname(id),
+                })) &&
+                cssModuleRE.test(code) &&
+                code.includes('export default')) {
+                const s = new MagicString(code);
+                // 1. Gather style tags in an array
+                let styleCount = 0;
+                s.prepend(`const __styleTags = [];\n`);
+                s.replace(/^import\s+(.+?)\s+from\s+['"]([^'"]+?\.module\.[^'"]+?)['"]/gm, (all, statements, from) => {
+                    if (!cssModuleRE.test(from)) {
+                        return all;
+                    }
+                    if (statements.startsWith('{')) {
+                        // Add default import
+                        const replacement = `__style${styleCount++}, {`;
+                        statements = statements.replace('{', replacement);
+                        all = all.replace('{', replacement);
+                    }
+                    const defaultImport = statements
+                        .split(',')[0]
+                        .replace(/\*\s+as\s+/, '')
+                        .trim();
+                    return all + `; __styleTags.push(${defaultImport}.StyleTag)`;
+                });
+                // 2. Wrap default export in a new component that includes the style tags
+                s.replace(/export default/gm, 'const __defaultExport = ');
+                s.append(`\nconst __ApplyStyleTags = function (props) {\n` +
+                    `  return <>{__styleTags.map(ST => <ST key={ST.key} />)}<__defaultExport {...props} /></>;` +
+                    `\n}\n\n` +
+                    `Object.defineProperty(__ApplyStyleTags, 'name', {value: 'ApplyStyleTags_' + (__defaultExport.name || '')});\n` +
+                    `export default __ApplyStyleTags;`);
+                return {
+                    code: s.toString(),
+                    map: s.generateMap({ file: id, source: id }),
+                };
+            }
+        },
+    };
+}
diff --git a/dist/dist/esnext/framework/plugins/vite-plugin-css-rsc.d.ts b/dist/dist/esnext/framework/plugins/vite-plugin-css-rsc.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e45473f53cd23231607f01340a2dfc8d87eabec6
--- /dev/null
+++ b/dist/dist/esnext/framework/plugins/vite-plugin-css-rsc.d.ts
@@ -0,0 +1,2 @@
+import { type Plugin } from 'vite';
+export default function cssRsc(): Plugin;
diff --git a/dist/dist/esnext/framework/plugins/vite-plugin-css-rsc.js b/dist/dist/esnext/framework/plugins/vite-plugin-css-rsc.js
new file mode 100644
index 0000000000000000000000000000000000000000..c05c8e37c5b1a97112fa090dc4a26422a1060a2e
--- /dev/null
+++ b/dist/dist/esnext/framework/plugins/vite-plugin-css-rsc.js
@@ -0,0 +1,213 @@
+import path from 'path';
+import MagicString from 'magic-string';
+import { normalizePath, } from 'vite';
+const VITE_CSS_CHUNK_NAME = 'style.css';
+const INJECT_STYLES_COMMENT = '<!--__INJECT_STYLES__-->';
+const CSS_EXTENSIONS_RE = /\.(css|sass|scss|stylus|less)(\.|\?|$)/;
+const CSS_MODULES_EXTENSIONS_RE = /\.module\.(css|sass|scss|stylus|less)(\?|$)/;
+const EVENT_CSS_IMPORT = 'hydrogen-css-modules-update-imports';
+const EVENT_CSS_CLASSES = 'hydrogen-css-modules-update-classes';
+const CSS_MODULES_HMR_INJECT = `
+import {createHotContext, injectQuery} from "/@vite/client";
+
+if (!import.meta.hot) {
+  import.meta.hot = createHotContext("/index.html");
+}
+
+import.meta.hot.on('${EVENT_CSS_IMPORT}', ({ids, timestamp}) => {
+  ids.forEach((id) => {
+    import(injectQuery(id, 't=' + timestamp));
+  });
+});
+
+import.meta.hot.on('${EVENT_CSS_CLASSES}', ({replacements}) => {
+  replacements.forEach(([oldClass, newClass]) => {
+    document.querySelectorAll('.' + oldClass).forEach(node => {
+      node.classList.replace(oldClass, newClass);
+    })
+  });
+});
+`;
+// Keep this in the outer scope to share it
+// across client <> server builds.
+let clientBuildPath;
+/* -- Plugin notes:
+ * This plugin collects all the CSS imported in both client and server components and
+ * extracts it in a single stylesheet that is added to the <head>. It does this by:
+ * 1. Removing all the CSS generated during the client build. The client build CSS is a sub-set of the
+ * server build CSS because it can only find CSS imported in client components. This avoids duplicates.
+ * 2. Force Vite to collect CSS in every file during the server build, and emit it as a chunk.
+ * 3. Move the generated CSS chunk in the server build to the client build output as an asset, and link to it in `index.html`.
+ */
+export default function cssRsc() {
+    let config;
+    let server;
+    let isUsingCssModules = false;
+    const hmrCssCopy = new Map();
+    const hmrCssQueue = new Set();
+    return {
+        name: 'hydrogen:css-rsc',
+        enforce: 'post',
+        config() {
+            // Disable CSS code split to avoid preloading styles
+            // that are already included in index.html
+            return { build: { cssCodeSplit: false } };
+        },
+        configResolved(_config) {
+            config = _config;
+        },
+        configureServer(_server) {
+            server = _server;
+        },
+        transform(code, id, options) {
+            if (options?.ssr && id.includes('index.html?raw')) {
+                // Mark the client build index.html to inject styles later
+                const s = new MagicString(code);
+                s.replace('</head>', INJECT_STYLES_COMMENT + '</head>');
+                return {
+                    code: s.toString(),
+                    map: s.generateMap({ file: id, source: id }),
+                };
+            }
+            // Manual HMR for CSS Modules
+            if (server && CSS_MODULES_EXTENSIONS_RE.test(id)) {
+                isUsingCssModules = true;
+                const file = id.split('?')[0];
+                // Note: this "CSS" file is actually JavaScript code.
+                // Get a copy of how this CSS was before the current update
+                const oldCode = hmrCssCopy.get(file);
+                // Save a copy of the current CSS for future updates
+                hmrCssCopy.set(file, code);
+                if (!oldCode || !hmrCssQueue.has(file))
+                    return;
+                hmrCssQueue.delete(file);
+                // Diff old code with new code and use the exported class names as a reference
+                // to find out how the resulting CSS classes are renamed.  With this, we can
+                // update classes in the DOM without requesting a full rendering from the server.
+                // Example:
+                // Previous code => export const red = ".red_k3tz4_module";
+                // New code      => export const red = ".red_t93kw_module";
+                const classRE = /export const (.+?) = "(.+?)"/g;
+                const oldClasses = [...oldCode.matchAll(classRE)];
+                const replacements = [];
+                for (const [, newKey, newClass] of code.matchAll(classRE)) {
+                    const oldClass = oldClasses.find(([, oldKey]) => oldKey === newKey)?.[2];
+                    if (oldClass && oldClass !== newClass) {
+                        replacements.push([oldClass, newClass]);
+                    }
+                }
+                if (replacements.length > 0) {
+                    // This event asks the browser to replace old
+                    // hash-based CSS classes with new ones.
+                    // Example: from `.red_k3tz4_module` to `.red_t93kw_module`
+                    server.ws.send({
+                        type: 'custom',
+                        event: EVENT_CSS_CLASSES,
+                        data: { replacements },
+                    });
+                }
+            }
+        },
+        transformIndexHtml(html, { server }) {
+            // Add discovered styles during dev
+            if (server) {
+                const tags = (isUsingCssModules
+                    ? [
+                        {
+                            tag: 'script',
+                            attrs: { type: 'module' },
+                            children: CSS_MODULES_HMR_INJECT,
+                        },
+                    ]
+                    : []);
+                const foundCssFiles = new Set();
+                for (const [key, value] of server.moduleGraph.idToModuleMap.entries()) {
+                    if (
+                    // Note: Some CSS-in-JS libraries use `.css.js`
+                    // extension and we should match it here:
+                    CSS_EXTENSIONS_RE.test(normalizePath(key).split('/').pop())) {
+                        let { url, file, lastHMRTimestamp, importers } = value;
+                        if (!foundCssFiles.has(file) &&
+                            !Array.from(importers).some((importer) => foundCssFiles.has(importer.file))) {
+                            foundCssFiles.add(file);
+                            // Vite is adding hash and timestamp to the CSS files downloaded
+                            // from client components. Adding the same query string params
+                            // here prevents this file from being downloaded twice.
+                            if (lastHMRTimestamp) {
+                                const timestampQuery = `?t=${lastHMRTimestamp}`;
+                                // The timestamp needs to be the first query string param.
+                                url = url.includes('?')
+                                    ? url.replace('?', timestampQuery + '&')
+                                    : url + timestampQuery;
+                            }
+                            tags.push(value.type === 'css'
+                                ? { tag: 'link', attrs: { rel: 'stylesheet', href: url } }
+                                : { tag: 'script', attrs: { type: 'module', src: url } });
+                        }
+                    }
+                }
+                return tags;
+            }
+        },
+        generateBundle(options, bundle, isWrite) {
+            if (config.build?.ssr) {
+                // -- Server build
+                if (!clientBuildPath) {
+                    // Default value
+                    clientBuildPath = normalizePath(path.resolve(config.root, config.build.outDir, '..', 'client'));
+                }
+                const relativeClientPath = normalizePath(path.relative(normalizePath(path.resolve(config.root, config.build.outDir)), clientBuildPath));
+                let cssAssetFileName = '';
+                const cssAsset = Object.values(bundle).find((file) => file.type === 'asset' && file.name === VITE_CSS_CHUNK_NAME);
+                const outputChunk = Object.values(bundle).find((file) => file.type === 'chunk' && file.isEntry);
+                if (cssAsset) {
+                    cssAssetFileName = cssAsset.fileName;
+                    // Move the CSS file to the client build assets
+                    cssAsset.fileName = normalizePath(path.join(relativeClientPath, cssAsset.fileName));
+                }
+                let assetPrefix = process.env.HYDROGEN_ASSET_BASE_URL || '/';
+                if (!assetPrefix.endsWith('/'))
+                    assetPrefix += '/';
+                // Add a reference to the CSS file in indexTemplate
+                outputChunk.code = outputChunk.code.replace(INJECT_STYLES_COMMENT, cssAssetFileName &&
+                    `<link rel="stylesheet" href="${assetPrefix + cssAssetFileName}">`);
+            }
+            else {
+                // -- Client build
+                // Save outDir from client build in the outer scope
+                // to read it during the server build. The CLI runs Vite in
+                // the same process so the scope is shared across builds.
+                clientBuildPath = normalizePath(path.resolve(config.root, config.build.outDir));
+                const indexHtml = bundle['index.html'];
+                const cssAsset = Object.values(bundle).find((file) => file.type === 'asset' && file.name === VITE_CSS_CHUNK_NAME);
+                if (cssAsset) {
+                    // The client build CSS is incomplete because it only includes
+                    // CSS imported in client components (server components are not
+                    // discovered in this build). Remove it from this build and
+                    // let it be added by the server build after this.
+                    delete bundle[cssAsset.fileName];
+                    indexHtml.source = indexHtml.source.replace(new RegExp(`\\s*<link[^<>]+${cssAsset.fileName.replace('.', '\\.')}.*?>`, ''), '');
+                }
+            }
+        },
+        async handleHotUpdate({ modules, server }) {
+            if (modules.every((m) => CSS_MODULES_EXTENSIONS_RE.test(m.file || ''))) {
+                // Opt-out of Vite's default HMR for CSS Modules, we'll handle this manually
+                const file = modules[0].file;
+                hmrCssQueue.add(file);
+                // This event asks the browser to download fresh CSS files.
+                // Fetching these fresh CSS files will trigger another event
+                // from the `transform` hook to replace classes in the DOM.
+                server.ws.send({
+                    type: 'custom',
+                    event: EVENT_CSS_IMPORT,
+                    data: {
+                        ids: modules.map((m) => m.id),
+                        timestamp: modules[0].lastHMRTimestamp || Date.now(),
+                    },
+                });
+                return [];
+            }
+        },
+    };
+}
diff --git a/dist/dist/esnext/framework/plugins/vite-plugin-hydration-auto-import.d.ts b/dist/dist/esnext/framework/plugins/vite-plugin-hydration-auto-import.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7f9c594a7efd9463aed4f4cfad8321d19b859b6a
--- /dev/null
+++ b/dist/dist/esnext/framework/plugins/vite-plugin-hydration-auto-import.d.ts
@@ -0,0 +1,3 @@
+import { Plugin } from 'vite';
+declare const _default: () => Plugin;
+export default _default;
diff --git a/dist/dist/esnext/framework/plugins/vite-plugin-hydration-auto-import.js b/dist/dist/esnext/framework/plugins/vite-plugin-hydration-auto-import.js
new file mode 100644
index 0000000000000000000000000000000000000000..1cbeb33150325cef75a65de41022f6f15437deae
--- /dev/null
+++ b/dist/dist/esnext/framework/plugins/vite-plugin-hydration-auto-import.js
@@ -0,0 +1,41 @@
+import { normalizePath } from 'vite';
+import path from 'path';
+import MagicString from 'magic-string';
+const HYDROGEN_ENTRY_FILE = 'hydrogen-entry-client.jsx';
+/* -- Plugin notes:
+ * Originally, every Hydrogen app required a `src/entry-client.jsx` file. However, this file
+ * was rarely modified by the user. This plugin provides a virtual file with the same content of
+ * that file, which allows to remove it by default from the file system.
+ * The virtual file created here is imported in `index.html` in a script tag.
+ */
+export default () => {
+    let config;
+    return {
+        name: 'hydrogen:client-hydration-auto-import',
+        enforce: 'pre',
+        configResolved(_config) {
+            config = _config;
+        },
+        resolveId(id, importer) {
+            if ((/^\/?@shopify\/hydrogen\/entry-client$/.test(id) ||
+                id.endsWith(path.sep + HYDROGEN_ENTRY_FILE)) &&
+                normalizePath(importer || '').endsWith('/index.html')) {
+                // Make this virtual import look like a local project file
+                // to enable React Refresh normally.
+                return path.join(config.root, HYDROGEN_ENTRY_FILE + '?virtual');
+            }
+            return null;
+        },
+        load(id) {
+            if (id.includes(HYDROGEN_ENTRY_FILE + '?virtual')) {
+                const code = new MagicString(`import renderHydrogen from '@shopify/hydrogen/entry-client';\n` +
+                    `export default renderHydrogen((props) => props.children);`);
+                return {
+                    code: code.toString(),
+                    map: { mappings: '' },
+                };
+            }
+            return null;
+        },
+    };
+};
diff --git a/dist/dist/esnext/framework/plugins/vite-plugin-hydrogen-client-components-cache.d.ts b/dist/dist/esnext/framework/plugins/vite-plugin-hydrogen-client-components-cache.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..eb868251e80792f8e046f8b42cc6c06746423f70
--- /dev/null
+++ b/dist/dist/esnext/framework/plugins/vite-plugin-hydrogen-client-components-cache.d.ts
@@ -0,0 +1,3 @@
+import { type Plugin } from 'vite';
+declare const _default: () => Plugin;
+export default _default;
diff --git a/dist/dist/esnext/framework/plugins/vite-plugin-hydrogen-client-components-cache.js b/dist/dist/esnext/framework/plugins/vite-plugin-hydrogen-client-components-cache.js
new file mode 100644
index 0000000000000000000000000000000000000000..6255fb81f9aa35aff907d64dd8a808bfbf487afe
--- /dev/null
+++ b/dist/dist/esnext/framework/plugins/vite-plugin-hydrogen-client-components-cache.js
@@ -0,0 +1,36 @@
+import { send } from 'vite';
+/* -- Plugin notes:
+ * This dev server middleware prevents Vite from applying immutable cache control headers to client
+ * components. These client components are part of the user's local source, but since they are
+ * referenced via import globs in the `react-dom-server-vite` NPM package, Vite assumes they
+ * are 3P deps that can be cached. This middleware responds to the requests early with `no-cache`.
+ */
+export default () => {
+    return {
+        name: 'hydrogen:client-components-cache',
+        enforce: 'pre',
+        configureServer(server) {
+            server.middlewares.use(async (req, res, next) => {
+                const url = req.url;
+                try {
+                    if (/\.client\.[jt]sx?\?v=/.test(url) &&
+                        !/\/node_modules\//.test(url)) {
+                        const result = await server.transformRequest(url, { html: false });
+                        if (result) {
+                            return send(req, res, result.code, 'js', {
+                                etag: result.etag,
+                                cacheControl: 'no-cache',
+                                headers: server.config.server.headers,
+                                map: result.map,
+                            });
+                        }
+                    }
+                }
+                catch (e) {
+                    next(e);
+                }
+                next();
+            });
+        },
+    };
+};
diff --git a/dist/dist/esnext/framework/plugins/vite-plugin-hydrogen-config.d.ts b/dist/dist/esnext/framework/plugins/vite-plugin-hydrogen-config.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c5c0c51934b7d3fa465c12503d4e7789ac6f9c90
--- /dev/null
+++ b/dist/dist/esnext/framework/plugins/vite-plugin-hydrogen-config.d.ts
@@ -0,0 +1,4 @@
+import { Plugin } from 'vite';
+import type { HydrogenVitePluginOptions } from '../types.js';
+declare const _default: (pluginOptions: HydrogenVitePluginOptions) => Plugin;
+export default _default;
diff --git a/dist/dist/esnext/framework/plugins/vite-plugin-hydrogen-config.js b/dist/dist/esnext/framework/plugins/vite-plugin-hydrogen-config.js
new file mode 100644
index 0000000000000000000000000000000000000000..698cc0ab443c21b9258d2389f4f17faaa1782c36
--- /dev/null
+++ b/dist/dist/esnext/framework/plugins/vite-plugin-hydrogen-config.js
@@ -0,0 +1,117 @@
+import Crypto from 'crypto';
+/* -- Plugin notes:
+ * Provide configuration options to Vite to ensure Hydrogen is built correctly
+ * for worker environments, using latest ES syntax, and some other requirements.
+ */
+export default (pluginOptions) => {
+    const rollupOptions = {
+        output: {},
+    };
+    const isWorker = Boolean(process.env.WORKER) && process.env.WORKER !== 'undefined';
+    return {
+        name: 'hydrogen:config',
+        config: async (config, env) => {
+            // @ts-ignore
+            const isSsrBuild = env.ssrBuild ?? !!config.build?.ssr;
+            /**
+             * By default, SSR dedupe logic gets bundled which runs `require('module')`.
+             * We don't want this in our workers runtime, because `require` is not supported.
+             */
+            rollupOptions.output = {
+                format: isWorker || !isSsrBuild ? 'es' : 'cjs',
+                inlineDynamicImports: isSsrBuild ? true : undefined,
+            };
+            if (process.env.NODE_ENV !== 'development' && !process.env.LOCAL_DEV) {
+                /**
+                 * Ofuscate production asset name - To prevent ad blocker logics that blocks
+                 * certain files due to how it is named.
+                 */
+                rollupOptions.output = {
+                    ...rollupOptions.output,
+                    chunkFileNames: 'assets/[hash].js',
+                };
+            }
+            return {
+                resolve: {
+                    alias: {
+                        // This library is currently included as a compiled vendor lib, not published yet to NPM
+                        'react-server-dom-vite/client-proxy': require.resolve('@shopify/hydrogen/vendor/react-server-dom-vite/esm/react-server-dom-vite-client-proxy.js'),
+                    },
+                },
+                build: {
+                    minify: config.build?.minify ?? (process.env.LOCAL_DEV ? false : 'esbuild'),
+                    sourcemap: true,
+                    rollupOptions: config.build?.rollupOptions
+                        ? Object.assign(rollupOptions, config.build.rollupOptions)
+                        : rollupOptions,
+                    target: config.build?.ssr
+                        ? isWorker
+                            ? 'es2022' // CFW (Updates weekly to latest V8)
+                            : 'es2020' // Node (Support for v14.19 used in SB)
+                        : 'modules', // Browsers (Vite default value)
+                },
+                ssr: {
+                    /**
+                     * Tell Vite to bundle everything when we're building for Workers.
+                     * Otherwise, bundle RSC plugin as a workaround to apply the vendor alias above.
+                     */
+                    noExternal: isWorker || [
+                        /react-server-dom-vite/,
+                        /@shopify\/hydrogen/,
+                    ],
+                    target: isWorker ? 'webworker' : 'node',
+                },
+                // Reload when updating local Hydrogen lib
+                server: process.env.LOCAL_DEV && {
+                    watch: {
+                        ignored: [
+                            '!**/node_modules/@shopify/hydrogen/**',
+                            '!**/node_modules/@shopify/hydrogen-ui/**',
+                        ],
+                    },
+                },
+                optimizeDeps: {
+                    exclude: [
+                        '@shopify/hydrogen',
+                        '@shopify/hydrogen/client',
+                        '@shopify/hydrogen/entry-client',
+                        '@shopify/hydrogen-ui',
+                    ],
+                    include: [
+                        /**
+                         * Additionally, the following dependencies have trouble loading the
+                         * correct version of the dependency (server vs client). This tells Vite to take the
+                         * server versions and optimize them for ESM.
+                         */
+                        'react-helmet-async',
+                        'react-error-boundary',
+                        /**
+                         * Vite cannot find the following dependencies since they might be
+                         * required in RSC asynchronously. This tells Vite to optimize them
+                         * at server start to avoid posterior page reloads and issues (#429 #430).
+                         */
+                        'react',
+                        'react-dom/client',
+                        'react-server-dom-vite/client-proxy',
+                        // https://github.com/vitejs/vite/issues/6215
+                        'react/jsx-runtime',
+                        // https://github.com/nfriedly/set-cookie-parser/issues/50
+                        'set-cookie-parser',
+                        'undici',
+                        '@xstate/react/fsm',
+                    ],
+                },
+                define: {
+                    __HYDROGEN_DEV__: env.mode !== 'production',
+                    __HYDROGEN_WORKER__: isWorker,
+                    __HYDROGEN_TEST__: false,
+                    __HYDROGEN_CACHE_ID__: pluginOptions.purgeQueryCacheOnBuild
+                        ? `"${Crypto.randomBytes(8).toString('hex').slice(0, 8)}"`
+                        : '"__QUERY_CACHE_ID__"',
+                },
+                envPrefix: ['VITE_', 'PUBLIC_'],
+                base: process.env.HYDROGEN_ASSET_BASE_URL,
+            };
+        },
+    };
+};
diff --git a/dist/dist/esnext/framework/plugins/vite-plugin-hydrogen-middleware.d.ts b/dist/dist/esnext/framework/plugins/vite-plugin-hydrogen-middleware.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1cebff3a4be92f5755255f24790b90deff4593f2
--- /dev/null
+++ b/dist/dist/esnext/framework/plugins/vite-plugin-hydrogen-middleware.d.ts
@@ -0,0 +1,11 @@
+import { Plugin } from 'vite';
+import type { HydrogenVitePluginOptions } from '../types.js';
+export declare const HYDROGEN_DEFAULT_SERVER_ENTRY: string;
+declare const _default: (pluginOptions: HydrogenVitePluginOptions) => Plugin;
+export default _default;
+declare global {
+    var Oxygen: {
+        env: any;
+        [key: string]: any;
+    };
+}
diff --git a/dist/dist/esnext/framework/plugins/vite-plugin-hydrogen-middleware.js b/dist/dist/esnext/framework/plugins/vite-plugin-hydrogen-middleware.js
new file mode 100644
index 0000000000000000000000000000000000000000..d0a2600a30f20e2dab58c09dad5ae2bf8d9c3821
--- /dev/null
+++ b/dist/dist/esnext/framework/plugins/vite-plugin-hydrogen-middleware.js
@@ -0,0 +1,60 @@
+import { loadEnv } from 'vite';
+import bodyParser from 'body-parser';
+import path from 'path';
+import { promises as fs } from 'fs';
+import { hydrogenMiddleware, graphiqlMiddleware } from '../middleware.js';
+import { InMemoryCache } from '../cache/in-memory.js';
+import { VIRTUAL_PROXY_HYDROGEN_CONFIG_ID } from './vite-plugin-hydrogen-virtual-files.js';
+export const HYDROGEN_DEFAULT_SERVER_ENTRY = process.env.HYDROGEN_SERVER_ENTRY || '/src/App.server';
+/* -- Plugin notes:
+ * By adding a middleware to the Vite dev server, we can handle SSR without needing
+ * a custom node script. It works by handling any requests for `text/html` documents,
+ * loading them in an SSR context, rendering them using the `entry-server` endpoint in the
+ * user's project, and injecting the static HTML into the template.
+ */
+export default (pluginOptions) => {
+    return {
+        name: 'hydrogen:middleware',
+        async configureServer(server) {
+            const resolve = (p) => path.resolve(server.config.root, p);
+            async function getIndexTemplate(url) {
+                const indexHtml = await fs.readFile(resolve('index.html'), 'utf-8');
+                return await server.transformIndexHtml(url, indexHtml);
+            }
+            await polyfillOxygenEnv(server.config);
+            // The default vite middleware rewrites the URL `/graphqil` to `/index.html`
+            // By running this middleware first, we avoid that.
+            server.middlewares.use(graphiqlMiddleware({
+                dev: true,
+                getShopifyConfig: async (incomingMessage) => {
+                    const { default: hydrogenConfig } = await server.ssrLoadModule(VIRTUAL_PROXY_HYDROGEN_CONFIG_ID);
+                    // @ts-ignore
+                    const { address = 'localhost', port = '3000' } = server.httpServer?.address() || {};
+                    const url = new URL(`http://${address}:${port}${incomingMessage.url}`);
+                    const request = new Request(url.toString(), {
+                        headers: incomingMessage.headers,
+                    });
+                    // @ts-expect-error Manually set `normalizedUrl` which a developer expects to be available
+                    // via `HydrogenRequest` during production runtime.
+                    request.normalizedUrl = request.url;
+                    const { shopify } = hydrogenConfig;
+                    return typeof shopify === 'function' ? shopify(request) : shopify;
+                },
+            }));
+            server.middlewares.use(bodyParser.raw({ type: '*/*' }));
+            return () => server.middlewares.use(hydrogenMiddleware({
+                dev: true,
+                indexTemplate: getIndexTemplate,
+                getServerEntrypoint: () => server.ssrLoadModule(HYDROGEN_DEFAULT_SERVER_ENTRY),
+                devServer: server,
+                cache: pluginOptions?.devCache
+                    ? new InMemoryCache()
+                    : undefined,
+            }));
+        },
+    };
+};
+async function polyfillOxygenEnv(config) {
+    const env = await loadEnv(config.mode, config.root, '');
+    globalThis.Oxygen = { env };
+}
diff --git a/dist/dist/esnext/framework/plugins/vite-plugin-hydrogen-rsc.d.ts b/dist/dist/esnext/framework/plugins/vite-plugin-hydrogen-rsc.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5d10138c53854afdafd5cb957d418d523bb639c9
--- /dev/null
+++ b/dist/dist/esnext/framework/plugins/vite-plugin-hydrogen-rsc.d.ts
@@ -0,0 +1,2 @@
+import { HydrogenVitePluginOptions } from '../types.js';
+export default function (options?: HydrogenVitePluginOptions): any;
diff --git a/dist/dist/esnext/framework/plugins/vite-plugin-hydrogen-rsc.js b/dist/dist/esnext/framework/plugins/vite-plugin-hydrogen-rsc.js
new file mode 100644
index 0000000000000000000000000000000000000000..eea722adeb8fd3a2525fcda2916845c2e17c29eb
--- /dev/null
+++ b/dist/dist/esnext/framework/plugins/vite-plugin-hydrogen-rsc.js
@@ -0,0 +1,23 @@
+// @ts-ignore
+import reactServerDomVite from '@shopify/hydrogen/vendor/react-server-dom-vite/plugin.js';
+import { HYDROGEN_DEFAULT_SERVER_ENTRY } from './vite-plugin-hydrogen-middleware.js';
+import { VIRTUAL_PROXY_HYDROGEN_ROUTES_ID } from './vite-plugin-hydrogen-virtual-files.js';
+export default function (options) {
+    return reactServerDomVite({
+        serverBuildEntries: [
+            HYDROGEN_DEFAULT_SERVER_ENTRY,
+            VIRTUAL_PROXY_HYDROGEN_ROUTES_ID,
+        ],
+        isServerComponentImporterAllowed(importer, source) {
+            return (
+            // Always allow the entry server (e.g. App.server.jsx) to be imported
+            // in other files such as worker.js or server.js.
+            source.includes(HYDROGEN_DEFAULT_SERVER_ENTRY) ||
+                /(index|provider-helpers|entry-server|testing|hydrogen\.config)\.[jt]s/.test(importer) ||
+                // Support importing server components for testing
+                // TODO: revisit this when RSC splits into two bundles
+                /\.(test|vitest|spec)\.[tj]sx?$/.test(importer));
+        },
+        ...options,
+    });
+}
diff --git a/dist/dist/esnext/framework/plugins/vite-plugin-hydrogen-suppress-warnings.d.ts b/dist/dist/esnext/framework/plugins/vite-plugin-hydrogen-suppress-warnings.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7f9c594a7efd9463aed4f4cfad8321d19b859b6a
--- /dev/null
+++ b/dist/dist/esnext/framework/plugins/vite-plugin-hydrogen-suppress-warnings.d.ts
@@ -0,0 +1,3 @@
+import { Plugin } from 'vite';
+declare const _default: () => Plugin;
+export default _default;
diff --git a/dist/dist/esnext/framework/plugins/vite-plugin-hydrogen-suppress-warnings.js b/dist/dist/esnext/framework/plugins/vite-plugin-hydrogen-suppress-warnings.js
new file mode 100644
index 0000000000000000000000000000000000000000..dff6b53ae17c396118218692c2ad1c7e067feb32
--- /dev/null
+++ b/dist/dist/esnext/framework/plugins/vite-plugin-hydrogen-suppress-warnings.js
@@ -0,0 +1,24 @@
+/* -- Plugin notes:
+ * Vite prints some warnings automatically are not important and
+ * not actionable. We hide them here to prevent confusing devs when
+ * real warnings or errors appear.
+ */
+export default () => {
+    return {
+        name: 'hydrogen:suppress-warnings',
+        configResolved(config) {
+            // TODO: Fix the actual issues that cause these warnings
+            const filterOut = (msg) => msg.startsWith("@shopify/hydrogen doesn't appear to be written in CJS") ||
+                (msg.includes('missing source files') &&
+                    ['kolorist'].some((lib) => msg.includes(lib)));
+            for (const method of ['warn', 'warnOnce']) {
+                const original = config.logger[method];
+                config.logger[method] = (msg, ...args) => {
+                    if (filterOut(msg))
+                        return;
+                    return original(msg, ...args);
+                };
+            }
+        },
+    };
+};
diff --git a/dist/dist/esnext/framework/plugins/vite-plugin-hydrogen-virtual-files.d.ts b/dist/dist/esnext/framework/plugins/vite-plugin-hydrogen-virtual-files.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6198e47e5d9686a3bd6624b4631fa377fd92a7f
--- /dev/null
+++ b/dist/dist/esnext/framework/plugins/vite-plugin-hydrogen-virtual-files.d.ts
@@ -0,0 +1,7 @@
+import { Plugin } from 'vite';
+import type { HydrogenVitePluginOptions } from '../types.js';
+export declare const HYDROGEN_DEFAULT_SERVER_ENTRY: string;
+export declare const VIRTUAL_PROXY_HYDROGEN_CONFIG_ID: string;
+export declare const VIRTUAL_PROXY_HYDROGEN_ROUTES_ID: string;
+declare const _default: (pluginOptions: HydrogenVitePluginOptions) => Plugin;
+export default _default;
diff --git a/dist/dist/esnext/framework/plugins/vite-plugin-hydrogen-virtual-files.js b/dist/dist/esnext/framework/plugins/vite-plugin-hydrogen-virtual-files.js
new file mode 100644
index 0000000000000000000000000000000000000000..bbb45d4e6f56a9b9ec4e92c8e41b72907dc677f7
--- /dev/null
+++ b/dist/dist/esnext/framework/plugins/vite-plugin-hydrogen-virtual-files.js
@@ -0,0 +1,149 @@
+import { normalizePath } from 'vite';
+import path from 'path';
+import { promises as fs } from 'fs';
+import { viteception } from '../viteception.js';
+import MagicString from 'magic-string';
+import { isVite3 } from '../../utilities/vite.js';
+/* -- Plugin notes:
+ * The Hydrogen framework needs to import certain files from the user app, such as
+ * routes and config. A priori, we can't import these files from the framework
+ * because we don't know the user path to write it in an `import * from '...'` statement.
+ * Instead, we import "virtual files" that are resolved by Vite in this plugin.
+ * These virtual files can include the user path and re-export the in-app files.
+ */
+export const HYDROGEN_DEFAULT_SERVER_ENTRY = process.env.HYDROGEN_SERVER_ENTRY || '/src/App.server';
+// The character ":" breaks Vite with Node >= 16.15. Use "_" instead
+const VIRTUAL_PREFIX = 'virtual__';
+const PROXY_PREFIX = 'proxy__';
+const ERROR_FILE = 'error.jsx';
+const VIRTUAL_ERROR_FILE = VIRTUAL_PREFIX + ERROR_FILE;
+const HYDROGEN_CONFIG_ID = 'hydrogen.config.ts';
+const VIRTUAL_HYDROGEN_CONFIG_ID = VIRTUAL_PREFIX + HYDROGEN_CONFIG_ID;
+export const VIRTUAL_PROXY_HYDROGEN_CONFIG_ID = VIRTUAL_PREFIX + PROXY_PREFIX + HYDROGEN_CONFIG_ID;
+const HYDROGEN_ROUTES_ID = 'hydrogen-routes.server.jsx';
+const VIRTUAL_HYDROGEN_ROUTES_ID = VIRTUAL_PREFIX + HYDROGEN_ROUTES_ID;
+export const VIRTUAL_PROXY_HYDROGEN_ROUTES_ID = VIRTUAL_PREFIX + PROXY_PREFIX + HYDROGEN_ROUTES_ID;
+const VIRTUAL_STREAM_ID = 'virtual__stream';
+export default (pluginOptions) => {
+    let config;
+    let server;
+    let resolvedConfigPath;
+    return {
+        name: 'hydrogen:virtual-files',
+        configResolved(_config) {
+            config = _config;
+        },
+        configureServer(_server) {
+            server = _server;
+        },
+        resolveId(source, importer) {
+            if (source === VIRTUAL_HYDROGEN_CONFIG_ID) {
+                return findHydrogenConfigPath(config.root, pluginOptions.configPath).then((hcPath) => {
+                    resolvedConfigPath = normalizePath(hcPath);
+                    // This direct dependency on a real file
+                    // makes HMR work for the virtual module.
+                    return this.resolve(hcPath, importer, { skipSelf: true });
+                });
+            }
+            if ([
+                VIRTUAL_PROXY_HYDROGEN_CONFIG_ID,
+                VIRTUAL_PROXY_HYDROGEN_ROUTES_ID,
+                VIRTUAL_HYDROGEN_ROUTES_ID,
+                VIRTUAL_ERROR_FILE,
+                VIRTUAL_STREAM_ID,
+            ].includes(source)) {
+                // Virtual modules convention
+                // https://vitejs.dev/guide/api-plugin.html#virtual-modules-convention
+                return '\0' + source;
+            }
+        },
+        load(id) {
+            if (id === '\0' + VIRTUAL_STREAM_ID) {
+                return {
+                    code: process.env.WORKER
+                        ? `export default {};`
+                        : `export {default} from 'stream';`,
+                };
+            }
+            // Likely due to a bug in Vite, but virtual modules cannot be loaded
+            // directly using ssrLoadModule from a Vite plugin. It needs to be proxied as follows:
+            if (id === '\0' + VIRTUAL_PROXY_HYDROGEN_CONFIG_ID) {
+                return `import hc from '${VIRTUAL_HYDROGEN_CONFIG_ID}'; export default typeof hc === 'function' ? hc() : hc;`;
+            }
+            if (id === '\0' + VIRTUAL_PROXY_HYDROGEN_ROUTES_ID) {
+                return `import hr from '${VIRTUAL_HYDROGEN_ROUTES_ID}'; export default hr;`;
+            }
+            if (id === '\0' + VIRTUAL_HYDROGEN_ROUTES_ID) {
+                return importHydrogenConfig().then((hc) => {
+                    let routesPath = (typeof hc.routes === 'string' ? hc.routes : hc.routes?.files) ??
+                        '/src/routes';
+                    if (routesPath.startsWith('./')) {
+                        routesPath = routesPath.slice(1);
+                    }
+                    if (!routesPath.includes('*')) {
+                        if (!routesPath.endsWith('/')) {
+                            routesPath += '/';
+                        }
+                        routesPath += '**/*.server.[jt](s|sx)';
+                    }
+                    const [dirPrefix] = routesPath.split('/*');
+                    const importGlob = isVite3
+                        ? `import.meta.glob('${routesPath}', {eager: true})`
+                        : `import.meta.globEager('${routesPath}')`;
+                    let code = `export default {\n  dirPrefix: '${dirPrefix}',\n  basePath: '${hc.routes?.basePath ?? ''}',\n  files: ${importGlob}\n};`;
+                    if (config.command === 'serve') {
+                        // Add dependency on Hydrogen config for HMR
+                        code += `\nimport '${VIRTUAL_HYDROGEN_CONFIG_ID}';`;
+                    }
+                    return { code };
+                });
+            }
+            if (id === '\0' + VIRTUAL_ERROR_FILE) {
+                return importHydrogenConfig().then((hc) => {
+                    const errorPath = hc.serverErrorPage ?? '/src/Error.{jsx,tsx}';
+                    const code = `const errorPage = import.meta.glob("${errorPath}");\n export default Object.values(errorPage)[0];`;
+                    return { code };
+                });
+            }
+        },
+        transform(code, id) {
+            if (id === resolvedConfigPath) {
+                const s = new MagicString(code);
+                // Wrap in function to avoid evaluating `Oxygen.env`
+                // in the config until we have polyfilled it properly.
+                s.replace(/export\s+default\s+(\w+)\s*\(/g, (all, m1) => all.replace(m1, `() => ${m1}`));
+                return {
+                    code: s.toString(),
+                    map: s.generateMap({ file: id, source: id }),
+                };
+            }
+        },
+    };
+    async function importHydrogenConfig() {
+        if (server) {
+            const loaded = await server.ssrLoadModule(VIRTUAL_PROXY_HYDROGEN_CONFIG_ID);
+            return loaded.default;
+        }
+        const { loaded } = await viteception([VIRTUAL_PROXY_HYDROGEN_CONFIG_ID], {
+            root: config.root,
+        });
+        return loaded[0].default;
+    }
+};
+async function findHydrogenConfigPath(root, userProvidedPath) {
+    let configPath = userProvidedPath;
+    if (!configPath) {
+        // Find the config file in the project root
+        const files = await fs.readdir(root);
+        configPath = files.find((file) => /^hydrogen\.config\.[jt]s$/.test(file));
+    }
+    if (configPath) {
+        configPath = normalizePath(configPath);
+        if (!configPath.startsWith('/'))
+            configPath = path.resolve(root, configPath);
+    }
+    return (configPath ||
+        require.resolve(
+        // eslint-disable-next-line node/no-missing-require
+        '@shopify/hydrogen/utilities/empty-hydrogen-config'));
+}
diff --git a/dist/dist/esnext/framework/plugins/vite-plugin-platform-entry.d.ts b/dist/dist/esnext/framework/plugins/vite-plugin-platform-entry.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7f9c594a7efd9463aed4f4cfad8321d19b859b6a
--- /dev/null
+++ b/dist/dist/esnext/framework/plugins/vite-plugin-platform-entry.d.ts
@@ -0,0 +1,3 @@
+import { Plugin } from 'vite';
+declare const _default: () => Plugin;
+export default _default;
diff --git a/dist/dist/esnext/framework/plugins/vite-plugin-platform-entry.js b/dist/dist/esnext/framework/plugins/vite-plugin-platform-entry.js
new file mode 100644
index 0000000000000000000000000000000000000000..42094516da2c9abdfb505036cb4a6b032e7e4651
--- /dev/null
+++ b/dist/dist/esnext/framework/plugins/vite-plugin-platform-entry.js
@@ -0,0 +1,112 @@
+import { normalizePath } from 'vite';
+import { HYDROGEN_DEFAULT_SERVER_ENTRY } from './vite-plugin-hydrogen-middleware.js';
+import MagicString from 'magic-string';
+import path from 'path';
+import fs from 'fs';
+import fastGlob from 'fast-glob';
+import { isVite3 } from '../../utilities/vite.js';
+const SSR_BUNDLE_NAME = 'index.js';
+// Keep this in the outer scope to share it
+// across client <> server builds.
+let clientBuildPath;
+/* -- Plugin notes:
+ * This plugin simplifies the way a platform entry file imports user files. This is
+ * needed to write generic integrations with different platform providers.
+ *
+ * Instead of using relative paths:
+ * `import handleRequest from '../../<arbitrary_path>/src/App.server';`
+ * `import indexTemplate from '../../<arbitrary_path>/dist/client/index.html?raw';`
+ *
+ *  It allows importing from a known static path which dynamically resolves the user files:
+ * `import {handleRequest, indexTemplate} from '@shopify/hydrogen/platforms';`
+ *
+ */
+export default () => {
+    let config;
+    let isESM;
+    return {
+        name: 'hydrogen:platform-entry',
+        enforce: 'pre',
+        configResolved(_config) {
+            config = _config;
+            if (config.build.ssr) {
+                const { output = {} } = config.build.rollupOptions || {};
+                const { format = isVite3 ? 'es' : '' } = (Array.isArray(output) ? output[0] : output) || {};
+                isESM = Boolean(process.env.WORKER) || ['es', 'esm'].includes(format);
+            }
+        },
+        resolveId(source, importer) {
+            if (normalizePath(source).includes('/hydrogen/platforms/')) {
+                const hydrogenPath = path.dirname(require.resolve('@shopify/hydrogen/package.json'));
+                const platformEntryName = source.split(path.sep).pop() || '';
+                const platformEntryPath = path.resolve(hydrogenPath, 'dist', 'esnext', 'platforms', platformEntryName);
+                return this.resolve(platformEntryPath, importer, {
+                    skipSelf: true,
+                });
+            }
+            return null;
+        },
+        async transform(code, id, options) {
+            if (config.command === 'build' &&
+                options?.ssr &&
+                /\/hydrogen\/.+platforms\/virtual\./.test(normalizePath(id))) {
+                const ms = new MagicString(code);
+                ms.replace('__HYDROGEN_ENTRY__', HYDROGEN_DEFAULT_SERVER_ENTRY);
+                if (!clientBuildPath) {
+                    // Default value
+                    clientBuildPath = normalizePath(path.resolve(config.root, config.build.outDir, '..', 'client'));
+                }
+                ms.replace('__HYDROGEN_HTML_TEMPLATE__', normalizePath(path.resolve(clientBuildPath, 'index.html')));
+                ms.replace('__HYDROGEN_RELATIVE_CLIENT_BUILD__', normalizePath(path.relative(normalizePath(path.resolve(config.root, config.build.outDir)), clientBuildPath)));
+                const files = clientBuildPath
+                    ? (await fastGlob('**/*', {
+                        cwd: clientBuildPath,
+                        ignore: ['**/index.html', `**/${config.build.assetsDir}/**`],
+                    })).map((file) => '/' + file)
+                    : [];
+                ms.replace("\\['__HYDROGEN_ASSETS__'\\]", JSON.stringify(files));
+                ms.replace('__HYDROGEN_ASSETS_DIR__', config.build.assetsDir);
+                ms.replace('__HYDROGEN_ASSETS_BASE_URL__', (process.env.HYDROGEN_ASSET_BASE_URL || '').replace(/\/$/, ''));
+                // Remove the poison pill
+                ms.replace('throw', '//');
+                return {
+                    code: ms.toString(),
+                    map: ms.generateMap({ file: id, source: id }),
+                };
+            }
+        },
+        buildEnd(err) {
+            if (!err && !config.build.ssr && config.command === 'build') {
+                // Save outDir from client build in the outer scope in order
+                // to read it during the server build. The CLI runs Vite in
+                // the same process so the scope is shared across builds.
+                clientBuildPath = normalizePath(path.resolve(config.root, config.build.outDir));
+            }
+        },
+        generateBundle(options, bundle) {
+            if (config.build.ssr) {
+                const [key, value] = Object.entries(bundle).find(([, value]) => value.type === 'chunk' && value.isEntry);
+                delete bundle[key];
+                value.fileName = SSR_BUNDLE_NAME;
+                bundle[SSR_BUNDLE_NAME] = value;
+                // This ensures the file has a proper
+                // default export instead of exporting an
+                // object containing a 'default' property.
+                if (value.type === 'chunk' && !isESM) {
+                    value.code += `\nmodule.exports = exports.default || exports;`;
+                }
+            }
+        },
+        writeBundle(options) {
+            if (config.build.ssr && options.dir) {
+                const mainFile = `./${SSR_BUNDLE_NAME}`;
+                const packageJson = {
+                    type: isESM ? 'module' : 'commonjs',
+                    main: mainFile,
+                    exports: { '.': mainFile, [mainFile]: mainFile },
+                };
+                fs.writeFileSync(path.join(options.dir, 'package.json'), JSON.stringify(packageJson, null, 2), 'utf-8');
+            }
+        },
+    };
+};
diff --git a/dist/dist/esnext/framework/plugins/vite-plugin-ssr-interop.d.ts b/dist/dist/esnext/framework/plugins/vite-plugin-ssr-interop.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..708d7b02ccf399b3059c199e4662d7ec69934559
--- /dev/null
+++ b/dist/dist/esnext/framework/plugins/vite-plugin-ssr-interop.d.ts
@@ -0,0 +1,3 @@
+import type { Plugin } from 'vite';
+declare const _default: () => Plugin;
+export default _default;
diff --git a/dist/dist/esnext/framework/plugins/vite-plugin-ssr-interop.js b/dist/dist/esnext/framework/plugins/vite-plugin-ssr-interop.js
new file mode 100644
index 0000000000000000000000000000000000000000..31608772112cf9e043654426d08c2d03e33b2e02
--- /dev/null
+++ b/dist/dist/esnext/framework/plugins/vite-plugin-ssr-interop.js
@@ -0,0 +1,20 @@
+/* -- Plugin notes:
+ * This plugin makes sure we don't leak server logic to the browser when importing
+ * the `useEnvContext` utility.
+ */
+export default () => {
+    return {
+        name: 'hydrogen:ssr-interop',
+        enforce: 'pre',
+        transform(code, id, options = {}) {
+            if (options.ssr && id.includes('foundation/ssr-interop')) {
+                return {
+                    code: code
+                        .replace(/(\s*META_ENV_SSR\s*=\s*)false/, '$1import.meta.env.SSR')
+                        .replace(/\/\/@SSR\s*/g, ''),
+                    map: { mappings: '' },
+                };
+            }
+        },
+    };
+};
diff --git a/dist/dist/esnext/framework/types.d.ts b/dist/dist/esnext/framework/types.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e243fcae576ee86e0d09a4b840644f82d3dcb402
--- /dev/null
+++ b/dist/dist/esnext/framework/types.d.ts
@@ -0,0 +1,20 @@
+export interface HydrogenVitePluginOptions {
+    devCache?: boolean;
+    purgeQueryCacheOnBuild?: boolean;
+    configPath?: string;
+    optimizeBoundaries?: boolean | 'build';
+    assetHashVersion?: string;
+    /**
+     * Experimental features
+     */
+    experimental?: {
+        /**
+         * CSS compatibility with React Server Components.
+         * - `global` inlines all the styles in the DOM and works for all types of CSS.
+         * - `modules-only` inlines the styles in RSC responses and only works for CSS Modules.
+         * @defaultValue `modules-only`
+         * @experimental
+         */
+        css: 'global' | 'modules-only';
+    };
+}
diff --git a/dist/dist/esnext/framework/types.js b/dist/dist/esnext/framework/types.js
new file mode 100644
index 0000000000000000000000000000000000000000..cb0ff5c3b541f646105198ee23ac0fc3d805023e
--- /dev/null
+++ b/dist/dist/esnext/framework/types.js
@@ -0,0 +1 @@
+export {};
diff --git a/dist/dist/esnext/framework/viteception.d.ts b/dist/dist/esnext/framework/viteception.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8f00f7f7045b5c5fa532fd37fa67fb07971b0fb1
--- /dev/null
+++ b/dist/dist/esnext/framework/viteception.d.ts
@@ -0,0 +1,5 @@
+import { InlineConfig } from 'vite';
+export declare function viteception(paths: string[], options?: InlineConfig): Promise<{
+    server: import("vite").ViteDevServer;
+    loaded: Record<string, any>[];
+}>;
diff --git a/dist/dist/esnext/framework/viteception.js b/dist/dist/esnext/framework/viteception.js
new file mode 100644
index 0000000000000000000000000000000000000000..57716cf047b1470e756e2a7e9ee1647661ecb1e9
--- /dev/null
+++ b/dist/dist/esnext/framework/viteception.js
@@ -0,0 +1,22 @@
+import { createServer } from 'vite';
+import { isVite3 } from '../utilities/vite.js';
+export async function viteception(paths, options) {
+    const isWorker = process.env.WORKER;
+    delete process.env.WORKER;
+    const server = await createServer({
+        clearScreen: false,
+        server: {
+            middlewareMode: isVite3 ? true : 'ssr',
+            hmr: false,
+        },
+        // @ts-ignore
+        appType: 'custom',
+        ...options,
+    });
+    if (isWorker) {
+        process.env.WORKER = isWorker;
+    }
+    const loaded = await Promise.all(paths.map((path) => server.ssrLoadModule(path)));
+    await server.close();
+    return { server, loaded };
+}
diff --git a/dist/dist/esnext/hooks/index.d.ts b/dist/dist/esnext/hooks/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..25ae90552bdbcb6857cd7ced6a7826c41973313d
--- /dev/null
+++ b/dist/dist/esnext/hooks/index.d.ts
@@ -0,0 +1,6 @@
+export { useProductOptions } from './useProductOptions/index.js';
+export * from './useProductOptions/types.js';
+export { useMoney } from './useMoney/index.js';
+export { useMeasurement } from './useMeasurement/index.js';
+export { useLoadScript } from './useLoadScript/index.js';
+export { useLocalization } from './useLocalization/useLocalization.js';
diff --git a/dist/dist/esnext/hooks/index.js b/dist/dist/esnext/hooks/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..25ae90552bdbcb6857cd7ced6a7826c41973313d
--- /dev/null
+++ b/dist/dist/esnext/hooks/index.js
@@ -0,0 +1,6 @@
+export { useProductOptions } from './useProductOptions/index.js';
+export * from './useProductOptions/types.js';
+export { useMoney } from './useMoney/index.js';
+export { useMeasurement } from './useMeasurement/index.js';
+export { useLoadScript } from './useLoadScript/index.js';
+export { useLocalization } from './useLocalization/useLocalization.js';
diff --git a/dist/dist/esnext/hooks/useCart/index.d.ts b/dist/dist/esnext/hooks/useCart/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..45fff8ccefd1b2a1099533e1a374fe9cfae68569
--- /dev/null
+++ b/dist/dist/esnext/hooks/useCart/index.d.ts
@@ -0,0 +1 @@
+export { useCart } from './useCart.js';
diff --git a/dist/dist/esnext/hooks/useCart/index.js b/dist/dist/esnext/hooks/useCart/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..45fff8ccefd1b2a1099533e1a374fe9cfae68569
--- /dev/null
+++ b/dist/dist/esnext/hooks/useCart/index.js
@@ -0,0 +1 @@
+export { useCart } from './useCart.js';
diff --git a/dist/dist/esnext/hooks/useCart/useCart.d.ts b/dist/dist/esnext/hooks/useCart/useCart.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2365e47f289fae2cb204f8714814c2597635b2f7
--- /dev/null
+++ b/dist/dist/esnext/hooks/useCart/useCart.d.ts
@@ -0,0 +1,4 @@
+/**
+ * The `useCart` hook provides access to the cart object. It must be a descendent of a `CartProvider` component.
+ */
+export declare function useCart(): import("../../client.js").CartWithActions;
diff --git a/dist/dist/esnext/hooks/useCart/useCart.js b/dist/dist/esnext/hooks/useCart/useCart.js
new file mode 100644
index 0000000000000000000000000000000000000000..f2c42f83ba23c5d6d5b9790fe54cf51e25a42f2f
--- /dev/null
+++ b/dist/dist/esnext/hooks/useCart/useCart.js
@@ -0,0 +1,12 @@
+import React from 'react';
+import { CartContext } from '../../components/CartProvider/context.js';
+/**
+ * The `useCart` hook provides access to the cart object. It must be a descendent of a `CartProvider` component.
+ */
+export function useCart() {
+    const context = React.useContext(CartContext);
+    if (!context) {
+        throw new Error('Expected a Cart Context, but no Cart Context was found');
+    }
+    return context;
+}
diff --git a/dist/dist/esnext/hooks/useCartLine/index.d.ts b/dist/dist/esnext/hooks/useCartLine/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6593c9c87ae2ec1cb9142450a2a7e6221c8d9a79
--- /dev/null
+++ b/dist/dist/esnext/hooks/useCartLine/index.d.ts
@@ -0,0 +1 @@
+export { useCartLine } from './useCartLine.js';
diff --git a/dist/dist/esnext/hooks/useCartLine/index.js b/dist/dist/esnext/hooks/useCartLine/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..6593c9c87ae2ec1cb9142450a2a7e6221c8d9a79
--- /dev/null
+++ b/dist/dist/esnext/hooks/useCartLine/index.js
@@ -0,0 +1 @@
+export { useCartLine } from './useCartLine.js';
diff --git a/dist/dist/esnext/hooks/useCartLine/useCartLine.d.ts b/dist/dist/esnext/hooks/useCartLine/useCartLine.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..965eadfb82b3e16b5041bfb4fc0582c589aad92d
--- /dev/null
+++ b/dist/dist/esnext/hooks/useCartLine/useCartLine.d.ts
@@ -0,0 +1,39 @@
+/**
+ * The `useCartLine` hook provides access to the cart line object. It must be a descendent of a `CartProvider` component.
+ */
+export declare function useCartLine(): {
+    __typename?: "CartLine" | undefined;
+} & Pick<import("../../storefront-api-types.js").CartLine, "id" | "quantity"> & {
+    attributes: ({
+        __typename?: "Attribute" | undefined;
+    } & Pick<import("../../storefront-api-types.js").Attribute, "key" | "value">)[];
+    cost: {
+        __typename?: "CartLineCost" | undefined;
+    } & {
+        totalAmount: {
+            __typename?: "MoneyV2" | undefined;
+        } & Pick<import("../../storefront-api-types.js").MoneyV2, "currencyCode" | "amount">;
+        compareAtAmountPerQuantity?: import("../../storefront-api-types.js").Maybe<{
+            __typename?: "MoneyV2" | undefined;
+        } & Pick<import("../../storefront-api-types.js").MoneyV2, "currencyCode" | "amount">> | undefined;
+    };
+    merchandise: {
+        __typename?: "ProductVariant" | undefined;
+    } & Pick<import("../../storefront-api-types.js").ProductVariant, "id" | "title" | "availableForSale" | "requiresShipping"> & {
+        compareAtPriceV2?: import("../../storefront-api-types.js").Maybe<{
+            __typename?: "MoneyV2" | undefined;
+        } & Pick<import("../../storefront-api-types.js").MoneyV2, "currencyCode" | "amount">> | undefined;
+        priceV2: {
+            __typename?: "MoneyV2" | undefined;
+        } & Pick<import("../../storefront-api-types.js").MoneyV2, "currencyCode" | "amount">;
+        image?: import("../../storefront-api-types.js").Maybe<{
+            __typename?: "Image" | undefined;
+        } & Pick<import("../../storefront-api-types.js").Image, "id" | "height" | "width" | "url" | "altText">> | undefined;
+        product: {
+            __typename?: "Product" | undefined;
+        } & Pick<import("../../storefront-api-types.js").Product, "title" | "handle">;
+        selectedOptions: ({
+            __typename?: "SelectedOption" | undefined;
+        } & Pick<import("../../storefront-api-types.js").SelectedOption, "name" | "value">)[];
+    };
+};
diff --git a/dist/dist/esnext/hooks/useCartLine/useCartLine.js b/dist/dist/esnext/hooks/useCartLine/useCartLine.js
new file mode 100644
index 0000000000000000000000000000000000000000..49dc87c356f9547d86d4945db6b18a26cb29fed2
--- /dev/null
+++ b/dist/dist/esnext/hooks/useCartLine/useCartLine.js
@@ -0,0 +1,12 @@
+import { useContext } from 'react';
+import { CartLineContext } from '../../components/CartLineProvider/context.js';
+/**
+ * The `useCartLine` hook provides access to the cart line object. It must be a descendent of a `CartProvider` component.
+ */
+export function useCartLine() {
+    const context = useContext(CartLineContext);
+    if (context == null) {
+        throw new Error('Expected a cart line context but none was found');
+    }
+    return context;
+}
diff --git a/dist/dist/esnext/hooks/useDelay/useDelay.d.ts b/dist/dist/esnext/hooks/useDelay/useDelay.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f3c461a5bbc84fba7bb9471cbe419d7c3ae35e88
--- /dev/null
+++ b/dist/dist/esnext/hooks/useDelay/useDelay.d.ts
@@ -0,0 +1 @@
+export declare const useDelay: (data: unknown, time: number) => unknown;
diff --git a/dist/dist/esnext/hooks/useDelay/useDelay.js b/dist/dist/esnext/hooks/useDelay/useDelay.js
new file mode 100644
index 0000000000000000000000000000000000000000..f9747acfe9b399bf6e5235f8130e03d7091aab2b
--- /dev/null
+++ b/dist/dist/esnext/hooks/useDelay/useDelay.js
@@ -0,0 +1,17 @@
+import { useServerRequest } from '../../foundation/ServerRequestProvider/index.js';
+import { wrapPromise } from '../../utilities/index.js';
+import { log } from '../../utilities/log/log.js';
+export const useDelay = function (data, time) {
+    if (!__HYDROGEN_DEV__) {
+        log.warn(new Error('The `useDelay` hook introduces an artificial delay that should not be used in production!').stack);
+        return data;
+    }
+    // eslint-disable-next-line react-hooks/rules-of-hooks
+    const serverRequest = useServerRequest();
+    const key = JSON.stringify(data);
+    if (!serverRequest.ctx.throttledRequests[key]) {
+        serverRequest.ctx.throttledRequests[key] = wrapPromise(new Promise((resolve) => setTimeout(resolve, time)));
+    }
+    serverRequest.ctx.throttledRequests[key].read();
+    return data;
+};
diff --git a/dist/dist/esnext/hooks/useLoadScript/index.d.ts b/dist/dist/esnext/hooks/useLoadScript/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..801c6c7e07c79ef8f08764302c0206983fb27f67
--- /dev/null
+++ b/dist/dist/esnext/hooks/useLoadScript/index.d.ts
@@ -0,0 +1 @@
+export { useLoadScript } from './useLoadScript.client.js';
diff --git a/dist/dist/esnext/hooks/useLoadScript/index.js b/dist/dist/esnext/hooks/useLoadScript/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..801c6c7e07c79ef8f08764302c0206983fb27f67
--- /dev/null
+++ b/dist/dist/esnext/hooks/useLoadScript/index.js
@@ -0,0 +1 @@
+export { useLoadScript } from './useLoadScript.client.js';
diff --git a/dist/dist/esnext/hooks/useLoadScript/useLoadScript.client.d.ts b/dist/dist/esnext/hooks/useLoadScript/useLoadScript.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..147f18e4ea02ebb7ba02f8a051d0501fab8811c7
--- /dev/null
+++ b/dist/dist/esnext/hooks/useLoadScript/useLoadScript.client.d.ts
@@ -0,0 +1,8 @@
+import { loadScript } from '../../utilities/load_script.js';
+declare type LoadScriptParams = Parameters<typeof loadScript>;
+/**
+ * The `useLoadScript` hook loads an external script tag on the client-side.
+ */
+export declare function useLoadScript(url: LoadScriptParams[0], options?: LoadScriptParams[1]): ScriptState;
+declare type ScriptState = 'loading' | 'done' | 'error';
+export {};
diff --git a/dist/dist/esnext/hooks/useLoadScript/useLoadScript.client.js b/dist/dist/esnext/hooks/useLoadScript/useLoadScript.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..4f7b56db9dde24e2e970c81d92d44ab9dd4b6ce3
--- /dev/null
+++ b/dist/dist/esnext/hooks/useLoadScript/useLoadScript.client.js
@@ -0,0 +1,23 @@
+import { loadScript } from '../../utilities/load_script.js';
+import { useState, useEffect } from 'react';
+/**
+ * The `useLoadScript` hook loads an external script tag on the client-side.
+ */
+export function useLoadScript(url, options) {
+    const [status, setStatus] = useState('loading');
+    const stringifiedOptions = JSON.stringify(options);
+    useEffect(() => {
+        async function loadScriptWrapper() {
+            try {
+                setStatus('loading');
+                await loadScript(url, options);
+                setStatus('done');
+            }
+            catch (error) {
+                setStatus('error');
+            }
+        }
+        loadScriptWrapper();
+    }, [url, stringifiedOptions, options]);
+    return status;
+}
diff --git a/dist/dist/esnext/hooks/useLocalization/useLocalization.d.ts b/dist/dist/esnext/hooks/useLocalization/useLocalization.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..907b81aa899e8cfa86a5d749e9844f6e7d17bfde
--- /dev/null
+++ b/dist/dist/esnext/hooks/useLocalization/useLocalization.d.ts
@@ -0,0 +1,4 @@
+import type { Locale, LocalizationContextValue } from '../../foundation/ShopifyProvider/types.js';
+export declare function useLocalization(): LocalizationContextValue & {
+    locale: Locale;
+};
diff --git a/dist/dist/esnext/hooks/useLocalization/useLocalization.js b/dist/dist/esnext/hooks/useLocalization/useLocalization.js
new file mode 100644
index 0000000000000000000000000000000000000000..d6642b9b6ace0eae8ce55020f404780d691e2f42
--- /dev/null
+++ b/dist/dist/esnext/hooks/useLocalization/useLocalization.js
@@ -0,0 +1,9 @@
+import { LocalizationContext } from '../../foundation/ShopifyProvider/ShopifyProvider.client.js';
+import { useEnvContext } from '../../foundation/ssr-interop.js';
+export function useLocalization() {
+    const localization = useEnvContext((req) => req.ctx.localization, LocalizationContext);
+    if (localization == null) {
+        throw new Error('No Localization Context available');
+    }
+    return localization;
+}
diff --git a/dist/dist/esnext/hooks/useMeasurement/hooks.d.ts b/dist/dist/esnext/hooks/useMeasurement/hooks.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9b3b3524b640cf36443203dd7a973850d6694045
--- /dev/null
+++ b/dist/dist/esnext/hooks/useMeasurement/hooks.d.ts
@@ -0,0 +1,9 @@
+import { Measurement } from '../../types.js';
+export interface UseMeasurementValue {
+    localizedString: string;
+    amount?: string;
+    unitName?: string;
+    parts: Intl.NumberFormatPart[];
+    original: Measurement;
+}
+export declare function useMeasurement(measurement: Measurement, options?: Omit<Intl.NumberFormatOptions, 'unit'>): UseMeasurementValue;
diff --git a/dist/dist/esnext/hooks/useMeasurement/hooks.js b/dist/dist/esnext/hooks/useMeasurement/hooks.js
new file mode 100644
index 0000000000000000000000000000000000000000..2cc399dd7e580f5bc6f28992932aecb8c4f9b823
--- /dev/null
+++ b/dist/dist/esnext/hooks/useMeasurement/hooks.js
@@ -0,0 +1,13 @@
+import { useMemo } from 'react';
+import { useLocalization } from '../useLocalization/useLocalization.js';
+import { getMeasurementAsParts, getMeasurementAsString, } from '../../utilities/index.js';
+export function useMeasurement(measurement, options = {}) {
+    const { locale } = useLocalization();
+    return useMemo(() => {
+        return {
+            localizedString: getMeasurementAsString(measurement, locale, options),
+            parts: getMeasurementAsParts(measurement, locale, options),
+            original: measurement,
+        };
+    }, [locale, measurement, options]);
+}
diff --git a/dist/dist/esnext/hooks/useMeasurement/index.d.ts b/dist/dist/esnext/hooks/useMeasurement/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8df1b2959bf4221262db787b45b22a9464003e92
--- /dev/null
+++ b/dist/dist/esnext/hooks/useMeasurement/index.d.ts
@@ -0,0 +1 @@
+export { useMeasurement } from './hooks.js';
diff --git a/dist/dist/esnext/hooks/useMeasurement/index.js b/dist/dist/esnext/hooks/useMeasurement/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..8df1b2959bf4221262db787b45b22a9464003e92
--- /dev/null
+++ b/dist/dist/esnext/hooks/useMeasurement/index.js
@@ -0,0 +1 @@
+export { useMeasurement } from './hooks.js';
diff --git a/dist/dist/esnext/hooks/useMoney/hooks.d.ts b/dist/dist/esnext/hooks/useMoney/hooks.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5cab35dc69d03d4c733b34552b21ed56bc782837
--- /dev/null
+++ b/dist/dist/esnext/hooks/useMoney/hooks.d.ts
@@ -0,0 +1,54 @@
+import { CurrencyCode, MoneyV2 } from '../../storefront-api-types.js';
+export declare type UseMoneyValue = {
+    /**
+     * The currency code from the `MoneyV2` object.
+     */
+    currencyCode: CurrencyCode;
+    /**
+     * The name for the currency code, returned by `Intl.NumberFormat`.
+     */
+    currencyName?: string;
+    /**
+     * The currency symbol returned by `Intl.NumberFormat`.
+     */
+    currencySymbol?: string;
+    /**
+     * The currency narrow symbol returned by `Intl.NumberFormat`.
+     */
+    currencyNarrowSymbol?: string;
+    /**
+     * The localized amount, without any currency symbols or non-number types from the `Intl.NumberFormat.formatToParts` parts.
+     */
+    amount: string;
+    /**
+     * All parts returned by `Intl.NumberFormat.formatToParts`.
+     */
+    parts: Intl.NumberFormatPart[];
+    /**
+     * A string returned by `new Intl.NumberFormat` for the amount and currency code,
+     * using the `locale` value in the [`LocalizationProvider` component](https://shopify.dev/api/hydrogen/components/localization/localizationprovider).
+     */
+    localizedString: string;
+    /**
+     * The `MoneyV2` object provided as an argument to the hook.
+     */
+    original: MoneyV2;
+    /**
+     * A string with trailing zeros removed from the fractional part, if any exist. If there are no trailing zeros, then the fractional part remains.
+     * For example, `$640.00` turns into `$640`.
+     * `$640.42` remains `$640.42`.
+     */
+    withoutTrailingZeros: string;
+    /**
+     * A string without currency and without trailing zeros removed from the fractional part, if any exist. If there are no trailing zeros, then the fractional part remains.
+     * For example, `$640.00` turns into `640`.
+     * `$640.42` turns into `640.42`.
+     */
+    withoutTrailingZerosAndCurrency: string;
+};
+/**
+ * The `useMoney` hook takes a [MoneyV2 object](https://shopify.dev/api/storefront/reference/common-objects/moneyv2) and returns a
+ * default-formatted string of the amount with the correct currency indicator, along with some of the parts provided by
+ * [Intl.NumberFormat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat).
+ */
+export declare function useMoney(money: MoneyV2): UseMoneyValue;
diff --git a/dist/dist/esnext/hooks/useMoney/hooks.js b/dist/dist/esnext/hooks/useMoney/hooks.js
new file mode 100644
index 0000000000000000000000000000000000000000..0078301c55cf420ad6f9971c2cf1186a151a69ca
--- /dev/null
+++ b/dist/dist/esnext/hooks/useMoney/hooks.js
@@ -0,0 +1,80 @@
+import { useMemo } from 'react';
+import { useLocalization } from '../useLocalization/useLocalization.js';
+/**
+ * The `useMoney` hook takes a [MoneyV2 object](https://shopify.dev/api/storefront/reference/common-objects/moneyv2) and returns a
+ * default-formatted string of the amount with the correct currency indicator, along with some of the parts provided by
+ * [Intl.NumberFormat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat).
+ */
+export function useMoney(money) {
+    const { locale } = useLocalization();
+    const amount = parseFloat(money.amount);
+    const options = useMemo(() => ({
+        style: 'currency',
+        currency: money.currencyCode,
+    }), [money.currencyCode]);
+    const defaultFormatter = useLazyFormatter(locale, options);
+    const nameFormatter = useLazyFormatter(locale, {
+        ...options,
+        currencyDisplay: 'name',
+    });
+    const narrowSymbolFormatter = useLazyFormatter(locale, {
+        ...options,
+        currencyDisplay: 'narrowSymbol',
+    });
+    const withoutTrailingZerosFormatter = useLazyFormatter(locale, {
+        ...options,
+        minimumFractionDigits: 0,
+        maximumFractionDigits: 0,
+    });
+    const withoutCurrencyFormatter = useLazyFormatter(locale);
+    const withoutTrailingZerosOrCurrencyFormatter = useLazyFormatter(locale, {
+        minimumFractionDigits: 0,
+        maximumFractionDigits: 0,
+    });
+    const isPartCurrency = (part) => part.type === 'currency';
+    // By wrapping these properties in functions, we only
+    // create formatters if they are going to be used.
+    const lazyFormatters = useMemo(() => ({
+        original: () => money,
+        currencyCode: () => money.currencyCode,
+        localizedString: () => defaultFormatter().format(amount),
+        parts: () => defaultFormatter().formatToParts(amount),
+        withoutTrailingZeros: () => amount % 1 === 0
+            ? withoutTrailingZerosFormatter().format(amount)
+            : defaultFormatter().format(amount),
+        withoutTrailingZerosAndCurrency: () => amount % 1 === 0
+            ? withoutTrailingZerosOrCurrencyFormatter().format(amount)
+            : withoutCurrencyFormatter().format(amount),
+        currencyName: () => nameFormatter().formatToParts(amount).find(isPartCurrency)?.value ??
+            money.currencyCode,
+        currencySymbol: () => defaultFormatter().formatToParts(amount).find(isPartCurrency)?.value ??
+            money.currencyCode,
+        currencyNarrowSymbol: () => narrowSymbolFormatter().formatToParts(amount).find(isPartCurrency)
+            ?.value ?? '',
+        amount: () => defaultFormatter()
+            .formatToParts(amount)
+            .filter((part) => ['decimal', 'fraction', 'group', 'integer', 'literal'].includes(part.type))
+            .map((part) => part.value)
+            .join(''),
+    }), [
+        money,
+        amount,
+        nameFormatter,
+        defaultFormatter,
+        narrowSymbolFormatter,
+        withoutCurrencyFormatter,
+        withoutTrailingZerosFormatter,
+        withoutTrailingZerosOrCurrencyFormatter,
+    ]);
+    // Call functions automatically when the properties are accessed
+    // to keep these functions as an implementation detail.
+    return useMemo(() => new Proxy(lazyFormatters, {
+        get: (target, key) => Reflect.get(target, key)?.call(null),
+    }), [lazyFormatters]);
+}
+function useLazyFormatter(locale, options) {
+    return useMemo(() => {
+        let memoized;
+        return () => (memoized ??= new Intl.NumberFormat(locale, options));
+    }, [locale, options]);
+}
diff --git a/dist/dist/esnext/hooks/useMoney/index.d.ts b/dist/dist/esnext/hooks/useMoney/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a9979f46648558241d863997546669234cf8f31b
--- /dev/null
+++ b/dist/dist/esnext/hooks/useMoney/index.d.ts
@@ -0,0 +1 @@
+export { useMoney } from './hooks.js';
diff --git a/dist/dist/esnext/hooks/useMoney/index.js b/dist/dist/esnext/hooks/useMoney/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..a9979f46648558241d863997546669234cf8f31b
--- /dev/null
+++ b/dist/dist/esnext/hooks/useMoney/index.js
@@ -0,0 +1 @@
+export { useMoney } from './hooks.js';
diff --git a/dist/dist/esnext/hooks/useProductOptions/helpers.d.ts b/dist/dist/esnext/hooks/useProductOptions/helpers.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..70b9b1933dca8aeb2e826f7d60ed6d9748141d3d
--- /dev/null
+++ b/dist/dist/esnext/hooks/useProductOptions/helpers.d.ts
@@ -0,0 +1,6 @@
+import { SelectedOptions, OptionWithValues } from './types.js';
+import type { ProductVariant as ProductVariantType } from '../../storefront-api-types.js';
+import type { PartialDeep } from 'type-fest';
+export declare function getAllOptionValues(variants: ProductVariantType[], option: string): string[];
+export declare function getSelectedVariant(variants: PartialDeep<ProductVariantType>[], choices: SelectedOptions): PartialDeep<ProductVariantType> | undefined;
+export declare function getOptions(variants: PartialDeep<ProductVariantType>[]): OptionWithValues[];
diff --git a/dist/dist/esnext/hooks/useProductOptions/helpers.js b/dist/dist/esnext/hooks/useProductOptions/helpers.js
new file mode 100644
index 0000000000000000000000000000000000000000..49a76dbd3d2d10b5ca8ef4a8695ebc32fa3de29f
--- /dev/null
+++ b/dist/dist/esnext/hooks/useProductOptions/helpers.js
@@ -0,0 +1,36 @@
+export function getAllOptionValues(variants, option) {
+    return Array.from(new Set(variants.map((variant) => variant.selectedOptions.find((selection) => selection.name == option)
+        .value)));
+}
+export function getSelectedVariant(variants, choices) {
+    /**
+     * Ensure the user has selected all the required options, not just some.
+     */
+    if (!variants.length ||
+        variants?.[0]?.selectedOptions?.length !== Object.keys(choices).length) {
+        return;
+    }
+    return variants?.find((variant) => {
+        return Object.entries(choices).every(([name, value]) => {
+            return variant?.selectedOptions?.some((option) => option?.name === name && option?.value === value);
+        });
+    });
+}
+export function getOptions(variants) {
+    const map = variants.reduce((memo, variant) => {
+        if (!variant.selectedOptions) {
+            throw new Error(`'getOptions' requires 'variant.selectedOptions'`);
+        }
+        variant?.selectedOptions?.forEach((opt) => {
+            memo[opt?.name ?? ''] = memo[opt?.name ?? ''] || new Set();
+            memo[opt?.name ?? ''].add(opt?.value ?? '');
+        });
+        return memo;
+    }, {});
+    return Object.keys(map).map((option) => {
+        return {
+            name: option,
+            values: Array.from(map[option]),
+        };
+    });
+}
diff --git a/dist/dist/esnext/hooks/useProductOptions/index.d.ts b/dist/dist/esnext/hooks/useProductOptions/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2b516407aad8221954707793f9a3cab4fbeacab5
--- /dev/null
+++ b/dist/dist/esnext/hooks/useProductOptions/index.d.ts
@@ -0,0 +1,2 @@
+export { useProductOptions } from './useProductOptions.client.js';
+export * from './types.js';
diff --git a/dist/dist/esnext/hooks/useProductOptions/index.js b/dist/dist/esnext/hooks/useProductOptions/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..2b516407aad8221954707793f9a3cab4fbeacab5
--- /dev/null
+++ b/dist/dist/esnext/hooks/useProductOptions/index.js
@@ -0,0 +1,2 @@
+export { useProductOptions } from './useProductOptions.client.js';
+export * from './types.js';
diff --git a/dist/dist/esnext/hooks/useProductOptions/types.d.ts b/dist/dist/esnext/hooks/useProductOptions/types.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..381e4753b17195deebb1614d44dee765744b33d6
--- /dev/null
+++ b/dist/dist/esnext/hooks/useProductOptions/types.d.ts
@@ -0,0 +1,44 @@
+import type { SelectedOption as SelectedOptionType, ProductVariant as ProductVariantType, ProductVariantConnection, SellingPlan as SellingPlanType, SellingPlanAllocation as SellingPlanAllocationType, SellingPlanGroup as SellingPlanGroupType, SellingPlanGroupConnection } from '../../storefront-api-types.js';
+import type { PartialDeep } from 'type-fest';
+export declare type SelectedOptions = {
+    [key: string]: string;
+};
+export declare type SelectVariantCallback = (variant: ProductVariantType | null) => void;
+export declare type SelectOptionCallback = (name: SelectedOptionType['name'], value: SelectedOptionType['value']) => void;
+export declare type SelectOptionsCallback = (options: SelectedOptions) => void;
+export declare type OptionsInStockCallback = (name: SelectedOptionType['name'], value: SelectedOptionType['value']) => boolean;
+export declare type SelectedSellingPlanCallback = (sellingPlan: SellingPlanType) => void;
+export interface OptionWithValues {
+    name: SelectedOptionType['name'];
+    values: SelectedOptionType['value'][];
+}
+export declare type ProductOptionsHookValue = PartialDeep<{
+    /** An array of the variant `nodes` from the `VariantConnection`. */
+    variants: ProductVariantType[];
+    variantsConnection?: ProductVariantConnection;
+    /** An array of the product's options and values. */
+    options: OptionWithValues[];
+    /** The selected variant. */
+    selectedVariant?: ProductVariantType | null;
+    selectedOptions: SelectedOptions;
+    /** The selected selling plan. */
+    selectedSellingPlan?: SellingPlanType;
+    /** The selected selling plan allocation. */
+    selectedSellingPlanAllocation?: SellingPlanAllocationType;
+    /** The selling plan groups. */
+    sellingPlanGroups?: (Omit<SellingPlanGroupType, 'sellingPlans'> & {
+        sellingPlans: SellingPlanType[];
+    })[];
+    sellingPlanGroupsConnection?: SellingPlanGroupConnection;
+}> & {
+    /** A callback to set the selected variant to the variant passed as an argument. */
+    setSelectedVariant: SelectVariantCallback;
+    /** A callback to set the selected option. */
+    setSelectedOption: SelectOptionCallback;
+    /** A callback to set multiple selected options at once. */
+    setSelectedOptions: SelectOptionsCallback;
+    /** A callback to set the selected selling plan to the one passed as an argument. */
+    setSelectedSellingPlan: SelectedSellingPlanCallback;
+    /** A callback that returns a boolean indicating if the option is in stock. */
+    isOptionInStock: OptionsInStockCallback;
+};
diff --git a/dist/dist/esnext/hooks/useProductOptions/types.js b/dist/dist/esnext/hooks/useProductOptions/types.js
new file mode 100644
index 0000000000000000000000000000000000000000..cb0ff5c3b541f646105198ee23ac0fc3d805023e
--- /dev/null
+++ b/dist/dist/esnext/hooks/useProductOptions/types.js
@@ -0,0 +1 @@
+export {};
diff --git a/dist/dist/esnext/hooks/useProductOptions/useProductOptions.client.d.ts b/dist/dist/esnext/hooks/useProductOptions/useProductOptions.client.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b5e442b4818b88de53120ff103a83d654afec528
--- /dev/null
+++ b/dist/dist/esnext/hooks/useProductOptions/useProductOptions.client.d.ts
@@ -0,0 +1 @@
+export declare function useProductOptions(): import("./types.js").ProductOptionsHookValue;
diff --git a/dist/dist/esnext/hooks/useProductOptions/useProductOptions.client.js b/dist/dist/esnext/hooks/useProductOptions/useProductOptions.client.js
new file mode 100644
index 0000000000000000000000000000000000000000..2421a56a882859b19f840c03302caef573a02ef1
--- /dev/null
+++ b/dist/dist/esnext/hooks/useProductOptions/useProductOptions.client.js
@@ -0,0 +1,9 @@
+import { useContext } from 'react';
+import { ProductOptionsContext } from '../../components/ProductOptionsProvider/context.js';
+export function useProductOptions() {
+    const context = useContext(ProductOptionsContext);
+    if (!context) {
+        throw new Error(`'useProductOptions' must be a child of <ProductOptionsProvider/>`);
+    }
+    return context;
+}
diff --git a/dist/dist/esnext/hooks/useShopQuery/hooks.d.ts b/dist/dist/esnext/hooks/useShopQuery/hooks.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..77d6232829fbc69e2de6f3835c1869a5085d127c
--- /dev/null
+++ b/dist/dist/esnext/hooks/useShopQuery/hooks.d.ts
@@ -0,0 +1,28 @@
+import type { CachingStrategy, PreloadOptions } from '../../types.js';
+export interface UseShopQueryResponse<T> {
+    /** The data returned by the query. */
+    data: T;
+    errors: any;
+}
+/**
+ * The `useShopQuery` hook allows you to make server-only GraphQL queries to the Storefront API. It must be a descendent of a `ShopifyProvider` component.
+ */
+export declare function useShopQuery<T>({ query, variables, cache, preload, }: {
+    /** A string of the GraphQL query.
+     * If no query is provided, useShopQuery will make no calls to the Storefront API.
+     */
+    query?: string;
+    /** An object of the variables for the GraphQL query. */
+    variables?: Record<string, any>;
+    /** The [caching strategy](https://shopify.dev/custom-storefronts/hydrogen/framework/cache#caching-strategies) to
+     * help you determine which cache control header to set.
+     */
+    cache?: CachingStrategy;
+    /** A string corresponding to a valid locale identifier like `en-us` used to make the request. */
+    locale?: string;
+    /** Whether to[preload the query](https://shopify.dev/custom-storefronts/hydrogen/framework/preloaded-queries).
+     * Defaults to `false`. Specify `true` to preload the query for the URL or `'*'`
+     * to preload the query for all requests.
+     */
+    preload?: PreloadOptions;
+}): UseShopQueryResponse<T>;
diff --git a/dist/dist/esnext/hooks/useShopQuery/hooks.js b/dist/dist/esnext/hooks/useShopQuery/hooks.js
new file mode 100644
index 0000000000000000000000000000000000000000..e7b84102e5b8709dff466adc88404db852df541a
--- /dev/null
+++ b/dist/dist/esnext/hooks/useShopQuery/hooks.js
@@ -0,0 +1,183 @@
+import { useShop } from '../../foundation/useShop/index.js';
+import { getLoggerWithContext } from '../../utilities/log/index.js';
+import { graphqlRequestBody } from '../../utilities/index.js';
+import { useServerRequest } from '../../foundation/ServerRequestProvider/index.js';
+import { injectGraphQLTracker } from '../../utilities/graphql-tracker.js';
+import { sendMessageToClient } from '../../utilities/devtools.js';
+import { fetchSync } from '../../foundation/fetchSync/server/fetchSync.js';
+import { META_ENV_SSR } from '../../foundation/ssr-interop.js';
+import { getStorefrontApiRequestHeaders } from '../../utilities/storefrontApi.js';
+import { parseJSON } from '../../utilities/parse.js';
+// Check if the response body has GraphQL errors
+// https://spec.graphql.org/June2018/#sec-Response-Format
+const shouldCacheResponse = ([body]) => {
+    try {
+        return !parseJSON(body)?.errors;
+    }
+    catch {
+        // If we can't parse the response, then assume
+        // an error and don't cache the response
+        return false;
+    }
+};
+/**
+ * The `useShopQuery` hook allows you to make server-only GraphQL queries to the Storefront API. It must be a descendent of a `ShopifyProvider` component.
+ */
+export function useShopQuery({ query, variables = {}, cache, preload = false, }) {
+    /**
+     * If no query is passed, we no-op here to allow developers to obey the Rules of Hooks.
+     */
+    if (!query) {
+        return { data: undefined, errors: undefined };
+    }
+    if (!META_ENV_SSR) {
+        throw new Error('Shopify Storefront API requests should only be made from the server.');
+    }
+    const serverRequest = useServerRequest(); // eslint-disable-line react-hooks/rules-of-hooks
+    const log = getLoggerWithContext(serverRequest);
+    const body = query ? graphqlRequestBody(query, variables) : '';
+    const { url, requestInit } = useCreateShopRequest(body); // eslint-disable-line react-hooks/rules-of-hooks
+    let text;
+    let data;
+    let useQueryError;
+    let response = null;
+    try {
+        response = fetchSync(url, {
+            ...requestInit,
+            cache,
+            preload,
+            shouldCacheResponse,
+        });
+        text = response.text();
+        try {
+            data = response.json();
+        }
+        catch (error) {
+            if (response.headers.get('content-length')) {
+                useQueryError = new Error(`Unable to parse response (x-request-id: ${response.headers.get('x-request-id')}):\n${text}`);
+            }
+            else {
+                useQueryError = new Error(`${response.status} ${response.statusText} (x-request-id: ${response.headers.get('x-request-id')})`);
+            }
+        }
+    }
+    catch (error) {
+        // Pass-through thrown promise for Suspense functionality
+        if (error?.then) {
+            throw error;
+        }
+        useQueryError = error;
+    }
+    /**
+     * The fetch request itself failed, so we handle that differently than a GraphQL error
+     */
+    if (useQueryError) {
+        const errorMessage = createErrorMessage(useQueryError);
+        log.error(errorMessage);
+        log.error(useQueryError);
+        if (__HYDROGEN_DEV__ && !__HYDROGEN_TEST__) {
+            throw new Error(errorMessage);
+        }
+        else {
+            // in non-dev environments, we probably don't want super-detailed error messages for the user
+            throw new Error(`The fetch attempt failed; there was an issue connecting to the data source.`);
+        }
+    }
+    /**
+     * GraphQL errors get printed to the console but ultimately
+     * get returned to the consumer.
+     */
+    if (data?.errors) {
+        const errors = Array.isArray(data.errors) ? data.errors : [data.errors];
+        const requestId = response?.headers?.get('x-request-id') ?? '';
+        for (const error of errors) {
+            if (__HYDROGEN_DEV__ && !__HYDROGEN_TEST__) {
+                throw new Error(`Storefront API GraphQL Error: ${error.message}.\nRequest id: ${requestId}`);
+            }
+            else {
+                log.error('Storefront API GraphQL Error', error, 'Storefront API GraphQL request id', requestId);
+            }
+        }
+        log.error(`Storefront API GraphQL error count: ${errors.length}`);
+    }
+    if (__HYDROGEN_DEV__ &&
+        (log.options().showUnusedQueryProperties ||
+            serverRequest.ctx.hydrogenConfig?.__EXPERIMENTAL__devTools) &&
+        query &&
+        data?.data) {
+        const fileLine = new Error('').stack
+            ?.split('\n')
+            .find((line) => line.includes('.server.'));
+        const [, functionName, fileName] = fileLine?.match(/^\s*at (\w+) \(([^)]+)\)/) || [];
+        injectGraphQLTracker({
+            query,
+            data,
+            onUnusedData: ({ queryName, properties }) => {
+                const footer = `Examine the list of fields above to confirm that they are being used.\n`;
+                const header = `Potentially overfetching fields in GraphQL query.\n`;
+                let info = `Query \`${queryName}\``;
+                if (fileName) {
+                    info += ` in file \`${fileName}\` (function \`${functionName}\`)`;
+                }
+                const n = 6;
+                const shouldTrim = properties.length > n + 1;
+                const shownProperties = shouldTrim
+                    ? properties.slice(0, n)
+                    : properties;
+                const hiddenInfo = shouldTrim
+                    ? `  ...and ${properties.length - shownProperties.length} more\n`
+                    : '';
+                const warning = header +
+                    info +
+                    `:\n ${shownProperties.join(`\n `)}\n` +
+                    hiddenInfo +
+                    footer;
+                if (log.options().showUnusedQueryProperties) {
+                    log.warn(warning);
+                    sendMessageToClient('browser-console', { type: 'warn', data: warning });
+                }
+                if (serverRequest.ctx.hydrogenConfig?.__EXPERIMENTAL__devTools) {
+                    sendMessageToClient('dev-tools', { type: 'warn', data: warning });
+                }
+            },
+        });
+    }
+    return data;
+}
+function useCreateShopRequest(body) {
+    const { storeDomain, storefrontToken, storefrontApiVersion, storefrontId, privateStorefrontToken, } = useShop();
+    const request = useServerRequest();
+    const buyerIp = request.getBuyerIp();
+    const extraHeaders = getStorefrontApiRequestHeaders({
+        buyerIp,
+        publicStorefrontToken: storefrontToken,
+        privateStorefrontToken,
+        storefrontId,
+    });
+    return {
+        key: [storeDomain, storefrontApiVersion, body],
+        url: `https://${storeDomain}/api/${storefrontApiVersion}/graphql.json`,
+        requestInit: {
+            body,
+            method: 'POST',
+            headers: {
+                'X-SDK-Variant': 'hydrogen',
+                'X-SDK-Version': storefrontApiVersion,
+                'content-type': 'application/json',
+                ...extraHeaders,
+            },
+        },
+    };
+}
+function createErrorMessage(fetchError) {
+    if (fetchError instanceof Response) {
+        return `An error occurred while fetching from the Storefront API. ${
+        // 403s to the SF API (almost?) always mean that your Shopify credentials are bad/wrong
+        fetchError.status === 403
+            ? `You may have a bad value in 'hydrogen.config.js'`
+            : `${fetchError.statusText}`}`;
+    }
+    else {
+        return `Failed to connect to the Storefront API: ${fetchError.message}`;
+    }
+}
diff --git a/dist/dist/esnext/hooks/useShopQuery/index.d.ts b/dist/dist/esnext/hooks/useShopQuery/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6d4aba434e129fc75f2900bc45ac670283d0e22a
--- /dev/null
+++ b/dist/dist/esnext/hooks/useShopQuery/index.d.ts
@@ -0,0 +1 @@
+export { useShopQuery, type UseShopQueryResponse } from './hooks.js';
diff --git a/dist/dist/esnext/hooks/useShopQuery/index.js b/dist/dist/esnext/hooks/useShopQuery/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..cc1780ae697f02698d21e2379d5f61d71f37c463
--- /dev/null
+++ b/dist/dist/esnext/hooks/useShopQuery/index.js
@@ -0,0 +1 @@
+export { useShopQuery } from './hooks.js';
diff --git a/dist/dist/esnext/index.d.ts b/dist/dist/esnext/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c449c4192155dec1a1fd7a4aeadcd5f4c298aadf
--- /dev/null
+++ b/dist/dist/esnext/index.d.ts
@@ -0,0 +1,44 @@
+/**
+ * Export all client components from here to ensure they're available in both import
+ * paths. This is because we transform `@shopify/hydrogen` to `@shopify/hydrogen/client`
+ * inside client components during the client build only, but when the same components
+ * run during SSR, they reference this path.
+ */
+export * from './client.js';
+/**
+ * The following are exported from this file because they are intended to be available
+ * *only* on the server.
+ */
+export { ServerPropsProvider, ServerPropsContext, type ServerProps, type ServerPropsContextValue, } from './foundation/ServerPropsProvider/index.js';
+export { useShop } from './foundation/useShop/index.js';
+export { useUrl } from './foundation/useUrl/index.js';
+export { useShopQuery, type UseShopQueryResponse, } from './hooks/useShopQuery/index.js';
+export { useQuery, type HydrogenUseQueryOptions, } from './foundation/useQuery/hooks.js';
+export { useServerProps } from './foundation/useServerProps/index.js';
+export { FileRoutes } from './foundation/FileRoutes/FileRoutes.server.js';
+export { Route } from './foundation/Route/Route.server.js';
+export { Router } from './foundation/Router/Router.server.js';
+export { log, type Logger } from './utilities/log/index.js';
+export { LocalizationProvider } from './components/LocalizationProvider/LocalizationProvider.server.js';
+export { ShopifyProvider } from './foundation/ShopifyProvider/ShopifyProvider.server.js';
+export { generateCacheControlHeader, CacheNone, CacheShort, CacheLong, CacheCustom, } from './foundation/Cache/strategies/index.js';
+export { useRequestContext } from './foundation/useRequestContext/index.js';
+export { useServerAnalytics } from './foundation/Analytics/hook.js';
+export { ShopifyAnalytics } from './foundation/Analytics/connectors/Shopify/ShopifyAnalytics.server.js';
+export { ShopifyAnalyticsConstants } from './foundation/Analytics/connectors/Shopify/const.js';
+export { useSession } from './foundation/useSession/useSession.js';
+export { Cookie } from './foundation/Cookie/Cookie.js';
+export { useDelay } from './hooks/useDelay/useDelay.js';
+/**
+ * Export server-only CartQuery here instead of `CartProvider.client` to prevent
+ * it from being bundled with other client components
+ */
+export { CartQuery } from './components/CartProvider/cart-queries.js';
+/**
+ * Override the client version of `fetchSync` with the server version.
+ */
+export { fetchSync } from './foundation/fetchSync/server/fetchSync.js';
+export { type HydrogenRequest } from './foundation/HydrogenRequest/HydrogenRequest.server.js';
+export { type HydrogenResponse } from './foundation/HydrogenResponse/HydrogenResponse.server.js';
+export { type HydrogenRouteProps, type CachingStrategy } from './types.js';
+export { type ResourceGetter as HydrogenApiRoute, RequestOptions as HydrogenApiRouteOptions, } from './utilities/apiRoutes.js';
diff --git a/dist/dist/esnext/index.js b/dist/dist/esnext/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..0793768b1f96c9484c0b591bf2e34d704f246b0e
--- /dev/null
+++ b/dist/dist/esnext/index.js
@@ -0,0 +1,40 @@
+/**
+ * Export all client components from here to ensure they're available in both import
+ * paths. This is because we transform `@shopify/hydrogen` to `@shopify/hydrogen/client`
+ * inside client components during the client build only, but when the same components
+ * run during SSR, they reference this path.
+ */
+export * from './client.js';
+/**
+ * The following are exported from this file because they are intended to be available
+ * *only* on the server.
+ */
+export { ServerPropsProvider, ServerPropsContext, } from './foundation/ServerPropsProvider/index.js';
+export { useShop } from './foundation/useShop/index.js';
+export { useUrl } from './foundation/useUrl/index.js';
+export { useShopQuery, } from './hooks/useShopQuery/index.js';
+export { useQuery, } from './foundation/useQuery/hooks.js';
+export { useServerProps } from './foundation/useServerProps/index.js';
+export { FileRoutes } from './foundation/FileRoutes/FileRoutes.server.js';
+export { Route } from './foundation/Route/Route.server.js';
+export { Router } from './foundation/Router/Router.server.js';
+export { log } from './utilities/log/index.js';
+export { LocalizationProvider } from './components/LocalizationProvider/LocalizationProvider.server.js';
+export { ShopifyProvider } from './foundation/ShopifyProvider/ShopifyProvider.server.js';
+export { generateCacheControlHeader, CacheNone, CacheShort, CacheLong, CacheCustom, } from './foundation/Cache/strategies/index.js';
+export { useRequestContext } from './foundation/useRequestContext/index.js';
+export { useServerAnalytics } from './foundation/Analytics/hook.js';
+export { ShopifyAnalytics } from './foundation/Analytics/connectors/Shopify/ShopifyAnalytics.server.js';
+export { ShopifyAnalyticsConstants } from './foundation/Analytics/connectors/Shopify/const.js';
+export { useSession } from './foundation/useSession/useSession.js';
+export { Cookie } from './foundation/Cookie/Cookie.js';
+export { useDelay } from './hooks/useDelay/useDelay.js';
+/**
+ * Export server-only CartQuery here instead of `CartProvider.client` to prevent
+ * it from being bundled with other client components
+ */
+export { CartQuery } from './components/CartProvider/cart-queries.js';
+/**
+ * Override the client version of `fetchSync` with the server version.
+ */
+export { fetchSync } from './foundation/fetchSync/server/fetchSync.js';
diff --git a/dist/dist/esnext/node.d.ts b/dist/dist/esnext/node.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7841fb64efe07de29a381a176aa39cbafc15a457
--- /dev/null
+++ b/dist/dist/esnext/node.d.ts
@@ -0,0 +1 @@
+export { FileSessionStorage } from './foundation/FileSessionStorage/FileSessionStorage.js';
diff --git a/dist/dist/esnext/node.js b/dist/dist/esnext/node.js
new file mode 100644
index 0000000000000000000000000000000000000000..7841fb64efe07de29a381a176aa39cbafc15a457
--- /dev/null
+++ b/dist/dist/esnext/node.js
@@ -0,0 +1 @@
+export { FileSessionStorage } from './foundation/FileSessionStorage/FileSessionStorage.js';
diff --git a/dist/dist/esnext/platforms/index.d.ts b/dist/dist/esnext/platforms/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4958425f87488b92949be5b36554bbb9d74869fb
--- /dev/null
+++ b/dist/dist/esnext/platforms/index.d.ts
@@ -0,0 +1 @@
+export * from './virtual.js';
diff --git a/dist/dist/esnext/platforms/index.js b/dist/dist/esnext/platforms/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..4958425f87488b92949be5b36554bbb9d74869fb
--- /dev/null
+++ b/dist/dist/esnext/platforms/index.js
@@ -0,0 +1 @@
+export * from './virtual.js';
diff --git a/dist/dist/esnext/platforms/node.d.ts b/dist/dist/esnext/platforms/node.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..43e842edd0556bb8dab8c2ecaa7c5cdaa34c629c
--- /dev/null
+++ b/dist/dist/esnext/platforms/node.d.ts
@@ -0,0 +1,9 @@
+import '../utilities/web-api-polyfill.js';
+import connect from 'connect';
+declare type CreateServerOptions = {
+    cache?: Cache;
+};
+export declare function createServer({ cache, }?: CreateServerOptions): Promise<{
+    app: connect.Server;
+}>;
+export {};
diff --git a/dist/dist/esnext/platforms/node.js b/dist/dist/esnext/platforms/node.js
new file mode 100644
index 0000000000000000000000000000000000000000..35105bdfd02e3a5ded0033f2862aaa2b18137962
--- /dev/null
+++ b/dist/dist/esnext/platforms/node.js
@@ -0,0 +1,35 @@
+import '../utilities/web-api-polyfill.js';
+import path from 'path';
+import { handleRequest, indexTemplate, relativeClientBuildPath, } from './virtual.js';
+import { hydrogenMiddleware } from '../framework/middleware.js';
+// @ts-ignore
+import serveStatic from 'serve-static';
+// @ts-ignore
+import compression from 'compression';
+import bodyParser from 'body-parser';
+import connect from 'connect';
+import { InMemoryCache } from '../framework/cache/in-memory.js';
+export async function createServer({ cache = new InMemoryCache(), } = {}) {
+    // @ts-ignore
+    globalThis.Oxygen = { env: process.env };
+    const app = connect();
+    app.use(compression());
+    app.use(serveStatic(path.resolve(__dirname, relativeClientBuildPath), {
+        index: false,
+    }));
+    app.use(bodyParser.raw({ type: '*/*' }));
+    app.use(hydrogenMiddleware({
+        getServerEntrypoint: () => handleRequest,
+        indexTemplate,
+        cache,
+    }));
+    return { app };
+}
+if (require.main === module) {
+    createServer().then(({ app }) => {
+        const port = process.env.PORT || 8080;
+        app.listen(port, () => {
+            console.log(`Hydrogen server running at http://localhost:${port}`);
+        });
+    });
+}
diff --git a/dist/dist/esnext/platforms/virtual.d.ts b/dist/dist/esnext/platforms/virtual.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..22c1788e0d93b2772e4ea8bebfd7ec870e8ba9ce
--- /dev/null
+++ b/dist/dist/esnext/platforms/virtual.d.ts
@@ -0,0 +1,8 @@
+import type { RequestHandler } from '../shared-types.js';
+export declare const handleRequest: RequestHandler;
+export { default as indexTemplate } from '__HYDROGEN_HTML_TEMPLATE__?raw';
+export declare const assets: Set<string>;
+export declare const assetPrefix: string;
+export declare const isAsset: (pathname?: string) => boolean;
+export declare const relativeClientBuildPath: string;
+export declare const assetBasePath: string;
diff --git a/dist/dist/esnext/platforms/virtual.js b/dist/dist/esnext/platforms/virtual.js
new file mode 100644
index 0000000000000000000000000000000000000000..6810ecba280872c5e03f90216653600d9ad4a960
--- /dev/null
+++ b/dist/dist/esnext/platforms/virtual.js
@@ -0,0 +1,12 @@
+// This file is modified by Vite at build time
+// with user project information and re-exports it.
+// @ts-ignore
+import appEntry from '__HYDROGEN_ENTRY__';
+export const handleRequest = appEntry;
+export { default as indexTemplate } from '__HYDROGEN_HTML_TEMPLATE__?raw';
+export const assets = new Set(['__HYDROGEN_ASSETS__']);
+export const assetPrefix = '/__HYDROGEN_ASSETS_DIR__/';
+export const isAsset = (pathname = '') => pathname.startsWith(assetPrefix) || assets.has(pathname);
+export const relativeClientBuildPath = '__HYDROGEN_RELATIVE_CLIENT_BUILD__';
+export const assetBasePath = '__HYDROGEN_ASSETS_BASE_URL__';
+throw new Error('This file must be overwritten in a Vite plugin');
diff --git a/dist/dist/esnext/platforms/worker-event.d.ts b/dist/dist/esnext/platforms/worker-event.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cb0ff5c3b541f646105198ee23ac0fc3d805023e
--- /dev/null
+++ b/dist/dist/esnext/platforms/worker-event.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/dist/dist/esnext/platforms/worker-event.js b/dist/dist/esnext/platforms/worker-event.js
new file mode 100644
index 0000000000000000000000000000000000000000..486c1bfb3d2e2611a4455d34e3cd0ac690e10816
--- /dev/null
+++ b/dist/dist/esnext/platforms/worker-event.js
@@ -0,0 +1,3 @@
+import moduleEntry from './worker.js';
+// @ts-ignore
+addEventListener('fetch', (event) => event.respondWith(moduleEntry.fetch(event.request, globalThis, event)));
diff --git a/dist/dist/esnext/platforms/worker.d.ts b/dist/dist/esnext/platforms/worker.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4240a2915345787120275576822d8024915a8ab3
--- /dev/null
+++ b/dist/dist/esnext/platforms/worker.d.ts
@@ -0,0 +1,14 @@
+declare global {
+    var globalThis: {
+        Oxygen: {
+            env: any;
+        };
+        [key: string]: any;
+    };
+}
+declare const _default: {
+    fetch(request: Request, env: unknown, context: {
+        waitUntil: (promise: Promise<any>) => void;
+    }): Promise<Response>;
+};
+export default _default;
diff --git a/dist/dist/esnext/platforms/worker.js b/dist/dist/esnext/platforms/worker.js
new file mode 100644
index 0000000000000000000000000000000000000000..8562a6ac41ed0d2f90944360ee2bc1d053f29a5d
--- /dev/null
+++ b/dist/dist/esnext/platforms/worker.js
@@ -0,0 +1,25 @@
+import { handleRequest, indexTemplate, isAsset, assetBasePath, } from './virtual.js';
+export default {
+    async fetch(request, env, context) {
+        // Proxy assets to the CDN. This should be removed
+        // once the proxy is implemented in Oxygen itself.
+        const url = new URL(request.url);
+        if (assetBasePath && isAsset(url.pathname)) {
+            return fetch(request.url.replace(url.origin, assetBasePath), request);
+        }
+        if (!globalThis.Oxygen) {
+            globalThis.Oxygen = { env };
+        }
+        try {
+            return (await handleRequest(request, {
+                indexTemplate,
+                cache: await caches.open('oxygen'),
+                context,
+                buyerIpHeader: 'oxygen-buyer-ip',
+            }));
+        }
+        catch (error) {
+            return new Response(error.message || error.toString(), { status: 500 });
+        }
+    },
+};
diff --git a/dist/dist/esnext/shared-types.d.ts b/dist/dist/esnext/shared-types.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d25b7aed00ca4126e25a75d453ecfdbb23ead712
--- /dev/null
+++ b/dist/dist/esnext/shared-types.d.ts
@@ -0,0 +1,31 @@
+/// <reference types="node" />
+import type { IncomingMessage, ServerResponse } from 'http';
+import type { SessionStorageAdapter } from './foundation/session/session-types';
+export interface RuntimeContext {
+    waitUntil: (fn: Promise<any>) => void;
+}
+export interface RequestHandlerOptions {
+    indexTemplate: string | ((url: string) => Promise<string | {
+        default: string;
+    }>);
+    cache?: Cache;
+    streamableResponse?: ServerResponse;
+    dev?: boolean;
+    context?: RuntimeContext;
+    nonce?: string;
+    buyerIpHeader?: string;
+    sessionApi?: SessionStorageAdapter;
+    headers?: Headers;
+}
+export interface RequestHandler {
+    (request: Request | IncomingMessage, options: RequestHandlerOptions): Promise<Response | undefined>;
+}
+export declare type ShopifyConfig = {
+    defaultLanguageCode?: string;
+    defaultCountryCode?: string;
+    storeDomain: string;
+    storefrontToken: string;
+    storefrontApiVersion: string;
+    privateStorefrontToken?: string;
+    storefrontId?: string;
+};
diff --git a/dist/dist/esnext/shared-types.js b/dist/dist/esnext/shared-types.js
new file mode 100644
index 0000000000000000000000000000000000000000..f4782a8e47129a57dcac9561fc7996131a14d7b1
--- /dev/null
+++ b/dist/dist/esnext/shared-types.js
@@ -0,0 +1,4 @@
+// These types are shared in ESM and CJS builds.
+// Do not import anything from subfolders here to avoid
+// affecting the files generated in the CJS build.
+export {};
diff --git a/dist/dist/esnext/storefront-api-types.d.ts b/dist/dist/esnext/storefront-api-types.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a652423c884ed2b3859c8f12dc853a7da5ea7d98
--- /dev/null
+++ b/dist/dist/esnext/storefront-api-types.d.ts
@@ -0,0 +1,6326 @@
+/**
+ * THIS FILE IS AUTO-GENERATED, DO NOT EDIT
+ * Based on Storefront API 2022-07
+ * If changes need to happen to the types defined in this file, then generally the Storefront API needs to update, and then you can run `yarn graphql-types`
+ * Except custom Scalars, which are defined in the `codegen.yml` file
+ */
+export declare type Maybe<T> = T | null;
+export declare type InputMaybe<T> = Maybe<T>;
+export declare type Exact<T extends {
+    [key: string]: unknown;
+}> = {
+    [K in keyof T]: T[K];
+};
+export declare type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
+    [SubKey in K]?: Maybe<T[SubKey]>;
+};
+export declare type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
+    [SubKey in K]: Maybe<T[SubKey]>;
+};
+/** All built-in and custom scalars, mapped to their actual values */
+export declare type Scalars = {
+    ID: string;
+    String: string;
+    Boolean: boolean;
+    Int: number;
+    Float: number;
+    /**
+     * A string containing a hexadecimal representation of a color.
+     *
+     * For example, "#6A8D48".
+     *
+     */
+    Color: string;
+    /**
+     * Represents an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)-encoded date and time string.
+     * For example, 3:50 pm on September 7, 2019 in the time zone of UTC (Coordinated Universal Time) is
+     * represented as `"2019-09-07T15:50:00Z`".
+     *
+     */
+    DateTime: string;
+    /**
+     * A signed decimal number, which supports arbitrary precision and is serialized as a string.
+     *
+     * Example values: `"29.99"`, `"29.999"`.
+     *
+     */
+    Decimal: string;
+    /**
+     * A string containing HTML code. Refer to the [HTML spec](https://html.spec.whatwg.org/#elements-3) for a
+     * complete list of HTML elements.
+     *
+     * Example value: `"<p>Grey cotton knit sweater.</p>"`.
+     *
+     */
+    HTML: string;
+    /**
+     * A [JSON](https://www.json.org/json-en.html) object.
+     *
+     * Example value:
+     * `{
+     *   "product": {
+     *     "id": "gid://shopify/Product/1346443542550",
+     *     "title": "White T-shirt",
+     *     "options": [{
+     *       "name": "Size",
+     *       "values": ["M", "L"]
+     *     }]
+     *   }
+     * }`
+     *
+     */
+    JSON: unknown;
+    /**
+     * Represents an [RFC 3986](https://datatracker.ietf.org/doc/html/rfc3986) and
+     * [RFC 3987](https://datatracker.ietf.org/doc/html/rfc3987)-compliant URI string.
+     *
+     * For example, `"https://johns-apparel.myshopify.com"` is a valid URL. It includes a scheme (`https`) and a host
+     * (`johns-apparel.myshopify.com`).
+     *
+     */
+    URL: string;
+    /**
+     * An unsigned 64-bit integer. Represents whole numeric values between 0 and 2^64 - 1 encoded as a string of base-10 digits.
+     *
+     * Example value: `"50"`.
+     *
+     */
+    UnsignedInt64: string;
+};
+/**
+ * A version of the API, as defined by [Shopify API versioning](https://shopify.dev/api/usage/versioning).
+ * Versions are commonly referred to by their handle (for example, `2021-10`).
+ *
+ */
+export declare type ApiVersion = {
+    __typename?: 'ApiVersion';
+    /** The human-readable name of the version. */
+    displayName: Scalars['String'];
+    /** The unique identifier of an ApiVersion. All supported API versions have a date-based (YYYY-MM) or `unstable` handle. */
+    handle: Scalars['String'];
+    /** Whether the version is actively supported by Shopify. Supported API versions are guaranteed to be stable. Unsupported API versions include unstable, release candidate, and end-of-life versions that are marked as unsupported. For more information, refer to [Versioning](https://shopify.dev/api/usage/versioning). */
+    supported: Scalars['Boolean'];
+};
+/** Details about the gift card used on the checkout. */
+export declare type AppliedGiftCard = Node & {
+    __typename?: 'AppliedGiftCard';
+    /** The amount that was taken from the gift card by applying it. */
+    amountUsed: MoneyV2;
+    /**
+     * The amount that was taken from the gift card by applying it.
+     * @deprecated Use `amountUsed` instead.
+     */
+    amountUsedV2: MoneyV2;
+    /** The amount left on the gift card. */
+    balance: MoneyV2;
+    /**
+     * The amount left on the gift card.
+     * @deprecated Use `balance` instead.
+     */
+    balanceV2: MoneyV2;
+    /** A globally-unique identifier. */
+    id: Scalars['ID'];
+    /** The last characters of the gift card. */
+    lastCharacters: Scalars['String'];
+    /** The amount that was applied to the checkout in its currency. */
+    presentmentAmountUsed: MoneyV2;
+};
+/** An article in an online store blog. */
+export declare type Article = HasMetafields & Node & OnlineStorePublishable & {
+    __typename?: 'Article';
+    /**
+     * The article's author.
+     * @deprecated Use `authorV2` instead.
+     */
+    author: ArticleAuthor;
+    /** The article's author. */
+    authorV2?: Maybe<ArticleAuthor>;
+    /** The blog that the article belongs to. */
+    blog: Blog;
+    /** List of comments posted on the article. */
+    comments: CommentConnection;
+    /** Stripped content of the article, single line with HTML tags removed. */
+    content: Scalars['String'];
+    /** The content of the article, complete with HTML formatting. */
+    contentHtml: Scalars['HTML'];
+    /** Stripped excerpt of the article, single line with HTML tags removed. */
+    excerpt?: Maybe<Scalars['String']>;
+    /** The excerpt of the article, complete with HTML formatting. */
+    excerptHtml?: Maybe<Scalars['HTML']>;
+    /**
+     * A human-friendly unique string for the Article automatically generated from its title.
+     *
+     */
+    handle: Scalars['String'];
+    /** A globally-unique identifier. */
+    id: Scalars['ID'];
+    /** The image associated with the article. */
+    image?: Maybe<Image>;
+    /** Returns a metafield found by namespace and key. */
+    metafield?: Maybe<Metafield>;
+    /**
+     * The metafields associated with the resource matching the supplied list of namespaces and keys.
+     *
+     */
+    metafields: Array<Maybe<Metafield>>;
+    /** The URL used for viewing the resource on the shop's Online Store. Returns `null` if the resource is currently not published to the Online Store sales channel. */
+    onlineStoreUrl?: Maybe<Scalars['URL']>;
+    /** The date and time when the article was published. */
+    publishedAt: Scalars['DateTime'];
+    /** The articles SEO information. */
+    seo?: Maybe<Seo>;
+    /** A categorization that a article can be tagged with. */
+    tags: Array<Scalars['String']>;
+    /** The articles name. */
+    title: Scalars['String'];
+};
+/** An article in an online store blog. */
+export declare type ArticleCommentsArgs = {
+    after?: InputMaybe<Scalars['String']>;
+    before?: InputMaybe<Scalars['String']>;
+    first?: InputMaybe<Scalars['Int']>;
+    last?: InputMaybe<Scalars['Int']>;
+    reverse?: InputMaybe<Scalars['Boolean']>;
+};
+/** An article in an online store blog. */
+export declare type ArticleContentArgs = {
+    truncateAt?: InputMaybe<Scalars['Int']>;
+};
+/** An article in an online store blog. */
+export declare type ArticleExcerptArgs = {
+    truncateAt?: InputMaybe<Scalars['Int']>;
+};
+/** An article in an online store blog. */
+export declare type ArticleMetafieldArgs = {
+    key: Scalars['String'];
+    namespace: Scalars['String'];
+};
+/** An article in an online store blog. */
+export declare type ArticleMetafieldsArgs = {
+    identifiers: Array<HasMetafieldsIdentifier>;
+};
+/** The author of an article. */
+export declare type ArticleAuthor = {
+    __typename?: 'ArticleAuthor';
+    /** The author's bio. */
+    bio?: Maybe<Scalars['String']>;
+    /** The authors email. */
+    email: Scalars['String'];
+    /** The author's first name. */
+    firstName: Scalars['String'];
+    /** The author's last name. */
+    lastName: Scalars['String'];
+    /** The author's full name. */
+    name: Scalars['String'];
+};
+/**
+ * An auto-generated type for paginating through multiple Articles.
+ *
+ */
+export declare type ArticleConnection = {
+    __typename?: 'ArticleConnection';
+    /** A list of edges. */
+    edges: Array<ArticleEdge>;
+    /** A list of the nodes contained in ArticleEdge. */
+    nodes: Array<Article>;
+    /** Information to aid in pagination. */
+    pageInfo: PageInfo;
+};
+/**
+ * An auto-generated type which holds one Article and a cursor during pagination.
+ *
+ */
+export declare type ArticleEdge = {
+    __typename?: 'ArticleEdge';
+    /** A cursor for use in pagination. */
+    cursor: Scalars['String'];
+    /** The item at the end of ArticleEdge. */
+    node: Article;
+};
+/** The set of valid sort keys for the Article query. */
+export declare enum ArticleSortKeys {
+    /** Sort by the `author` value. */
+    Author = "AUTHOR",
+    /** Sort by the `blog_title` value. */
+    BlogTitle = "BLOG_TITLE",
+    /** Sort by the `id` value. */
+    Id = "ID",
+    /** Sort by the `published_at` value. */
+    PublishedAt = "PUBLISHED_AT",
+    /**
+     * Sort by relevance to the search terms when the `query` parameter is specified on the connection.
+     * Don't use this sort key when no search query is specified.
+     *
+     */
+    Relevance = "RELEVANCE",
+    /** Sort by the `title` value. */
+    Title = "TITLE",
+    /** Sort by the `updated_at` value. */
+    UpdatedAt = "UPDATED_AT"
+}
+/** Represents a generic custom attribute. */
+export declare type Attribute = {
+    __typename?: 'Attribute';
+    /** Key or name of the attribute. */
+    key: Scalars['String'];
+    /** Value of the attribute. */
+    value?: Maybe<Scalars['String']>;
+};
+/** Specifies the input fields required for an attribute. */
+export declare type AttributeInput = {
+    /** Key or name of the attribute. */
+    key: Scalars['String'];
+    /** Value of the attribute. */
+    value: Scalars['String'];
+};
+/**
+ * Automatic discount applications capture the intentions of a discount that was automatically applied.
+ *
+ */
+export declare type AutomaticDiscountApplication = DiscountApplication & {
+    __typename?: 'AutomaticDiscountApplication';
+    /** The method by which the discount's value is allocated to its entitled items. */
+    allocationMethod: DiscountApplicationAllocationMethod;
+    /** Which lines of targetType that the discount is allocated over. */
+    targetSelection: DiscountApplicationTargetSelection;
+    /** The type of line that the discount is applicable towards. */
+    targetType: DiscountApplicationTargetType;
+    /** The title of the application. */
+    title: Scalars['String'];
+    /** The value of the discount application. */
+    value: PricingValue;
+};
+/** A collection of available shipping rates for a checkout. */
+export declare type AvailableShippingRates = {
+    __typename?: 'AvailableShippingRates';
+    /**
+     * Whether or not the shipping rates are ready.
+     * The `shippingRates` field is `null` when this value is `false`.
+     * This field should be polled until its value becomes `true`.
+     *
+     */
+    ready: Scalars['Boolean'];
+    /** The fetched shipping rates. `null` until the `ready` field is `true`. */
+    shippingRates?: Maybe<Array<ShippingRate>>;
+};
+/** An online store blog. */
+export declare type Blog = HasMetafields & Node & OnlineStorePublishable & {
+    __typename?: 'Blog';
+    /** Find an article by its handle. */
+    articleByHandle?: Maybe<Article>;
+    /** List of the blog's articles. */
+    articles: ArticleConnection;
+    /** The authors who have contributed to the blog. */
+    authors: Array<ArticleAuthor>;
+    /**
+     * A human-friendly unique string for the Blog automatically generated from its title.
+     *
+     */
+    handle: Scalars['String'];
+    /** A globally-unique identifier. */
+    id: Scalars['ID'];
+    /** Returns a metafield found by namespace and key. */
+    metafield?: Maybe<Metafield>;
+    /**
+     * The metafields associated with the resource matching the supplied list of namespaces and keys.
+     *
+     */
+    metafields: Array<Maybe<Metafield>>;
+    /** The URL used for viewing the resource on the shop's Online Store. Returns `null` if the resource is currently not published to the Online Store sales channel. */
+    onlineStoreUrl?: Maybe<Scalars['URL']>;
+    /** The blog's SEO information. */
+    seo?: Maybe<Seo>;
+    /** The blogss title. */
+    title: Scalars['String'];
+};
+/** An online store blog. */
+export declare type BlogArticleByHandleArgs = {
+    handle: Scalars['String'];
+};
+/** An online store blog. */
+export declare type BlogArticlesArgs = {
+    after?: InputMaybe<Scalars['String']>;
+    before?: InputMaybe<Scalars['String']>;
+    first?: InputMaybe<Scalars['Int']>;
+    last?: InputMaybe<Scalars['Int']>;
+    query?: InputMaybe<Scalars['String']>;
+    reverse?: InputMaybe<Scalars['Boolean']>;
+    sortKey?: InputMaybe<ArticleSortKeys>;
+};
+/** An online store blog. */
+export declare type BlogMetafieldArgs = {
+    key: Scalars['String'];
+    namespace: Scalars['String'];
+};
+/** An online store blog. */
+export declare type BlogMetafieldsArgs = {
+    identifiers: Array<HasMetafieldsIdentifier>;
+};
+/**
+ * An auto-generated type for paginating through multiple Blogs.
+ *
+ */
+export declare type BlogConnection = {
+    __typename?: 'BlogConnection';
+    /** A list of edges. */
+    edges: Array<BlogEdge>;
+    /** A list of the nodes contained in BlogEdge. */
+    nodes: Array<Blog>;
+    /** Information to aid in pagination. */
+    pageInfo: PageInfo;
+};
+/**
+ * An auto-generated type which holds one Blog and a cursor during pagination.
+ *
+ */
+export declare type BlogEdge = {
+    __typename?: 'BlogEdge';
+    /** A cursor for use in pagination. */
+    cursor: Scalars['String'];
+    /** The item at the end of BlogEdge. */
+    node: Blog;
+};
+/** The set of valid sort keys for the Blog query. */
+export declare enum BlogSortKeys {
+    /** Sort by the `handle` value. */
+    Handle = "HANDLE",
+    /** Sort by the `id` value. */
+    Id = "ID",
+    /**
+     * Sort by relevance to the search terms when the `query` parameter is specified on the connection.
+     * Don't use this sort key when no search query is specified.
+     *
+     */
+    Relevance = "RELEVANCE",
+    /** Sort by the `title` value. */
+    Title = "TITLE"
+}
+/**
+ * The store's branding configuration.
+ *
+ */
+export declare type Brand = {
+    __typename?: 'Brand';
+    /** The colors of the store's brand. */
+    colors: BrandColors;
+    /** The store's cover image. */
+    coverImage?: Maybe<MediaImage>;
+    /** The store's default logo. */
+    logo?: Maybe<MediaImage>;
+    /** The store's short description. */
+    shortDescription?: Maybe<Scalars['String']>;
+    /** The store's slogan. */
+    slogan?: Maybe<Scalars['String']>;
+    /** The store's preferred logo for square UI elements. */
+    squareLogo?: Maybe<MediaImage>;
+};
+/**
+ * A group of related colors for the shop's brand.
+ *
+ */
+export declare type BrandColorGroup = {
+    __typename?: 'BrandColorGroup';
+    /** The background color. */
+    background?: Maybe<Scalars['Color']>;
+    /** The foreground color. */
+    foreground?: Maybe<Scalars['Color']>;
+};
+/**
+ * The colors of the shop's brand.
+ *
+ */
+export declare type BrandColors = {
+    __typename?: 'BrandColors';
+    /** The shop's primary brand colors. */
+    primary: Array<BrandColorGroup>;
+    /** The shop's secondary brand colors. */
+    secondary: Array<BrandColorGroup>;
+};
+/** Card brand, such as Visa or Mastercard, which can be used for payments. */
+export declare enum CardBrand {
+    /** American Express. */
+    AmericanExpress = "AMERICAN_EXPRESS",
+    /** Diners Club. */
+    DinersClub = "DINERS_CLUB",
+    /** Discover. */
+    Discover = "DISCOVER",
+    /** JCB. */
+    Jcb = "JCB",
+    /** Mastercard. */
+    Mastercard = "MASTERCARD",
+    /** Visa. */
+    Visa = "VISA"
+}
+/**
+ * A cart represents the merchandise that a buyer intends to purchase,
+ * and the estimated cost associated with the cart. Learn how to
+ * [interact with a cart](https://shopify.dev/custom-storefronts/internationalization/international-pricing)
+ * during a customer's session.
+ *
+ */
+export declare type Cart = Node & {
+    __typename?: 'Cart';
+    /** An attribute associated with the cart. */
+    attribute?: Maybe<Attribute>;
+    /** The attributes associated with the cart. Attributes are represented as key-value pairs. */
+    attributes: Array<Attribute>;
+    /** Information about the buyer that is interacting with the cart. */
+    buyerIdentity: CartBuyerIdentity;
+    /** The URL of the checkout for the cart. */
+    checkoutUrl: Scalars['URL'];
+    /** The estimated costs that the buyer will pay at checkout. The costs are subject to change and changes will be reflected at checkout. The `cost` field uses the `buyerIdentity` field to determine [international pricing](https://shopify.dev/custom-storefronts/internationalization/international-pricing). */
+    cost: CartCost;
+    /** The date and time when the cart was created. */
+    createdAt: Scalars['DateTime'];
+    /**
+     * The delivery groups available for the cart, based on the buyer identity default
+     * delivery address preference or the default address of the logged-in customer.
+     *
+     */
+    deliveryGroups: CartDeliveryGroupConnection;
+    /** The discounts that have been applied to the entire cart. */
+    discountAllocations: Array<CartAutomaticDiscountAllocation | CartCodeDiscountAllocation | CartCustomDiscountAllocation>;
+    /**
+     * The case-insensitive discount codes that the customer added at checkout.
+     *
+     */
+    discountCodes: Array<CartDiscountCode>;
+    /**
+     * The estimated costs that the buyer will pay at checkout.
+     * The estimated costs are subject to change and changes will be reflected at checkout.
+     * The `estimatedCost` field uses the `buyerIdentity` field to determine
+     * [international pricing](https://shopify.dev/custom-storefronts/internationalization/international-pricing).
+     *
+     * @deprecated Use `cost` instead.
+     */
+    estimatedCost: CartEstimatedCost;
+    /** A globally-unique identifier. */
+    id: Scalars['ID'];
+    /** A list of lines containing information about the items the customer intends to purchase. */
+    lines: CartLineConnection;
+    /** A note that is associated with the cart. For example, the note can be a personalized message to the buyer. */
+    note?: Maybe<Scalars['String']>;
+    /** The total number of items in the cart. */
+    totalQuantity: Scalars['Int'];
+    /** The date and time when the cart was updated. */
+    updatedAt: Scalars['DateTime'];
+};
+/**
+ * A cart represents the merchandise that a buyer intends to purchase,
+ * and the estimated cost associated with the cart. Learn how to
+ * [interact with a cart](https://shopify.dev/custom-storefronts/internationalization/international-pricing)
+ * during a customer's session.
+ *
+ */
+export declare type CartAttributeArgs = {
+    key: Scalars['String'];
+};
+/**
+ * A cart represents the merchandise that a buyer intends to purchase,
+ * and the estimated cost associated with the cart. Learn how to
+ * [interact with a cart](https://shopify.dev/custom-storefronts/internationalization/international-pricing)
+ * during a customer's session.
+ *
+ */
+export declare type CartDeliveryGroupsArgs = {
+    after?: InputMaybe<Scalars['String']>;
+    before?: InputMaybe<Scalars['String']>;
+    first?: InputMaybe<Scalars['Int']>;
+    last?: InputMaybe<Scalars['Int']>;
+    reverse?: InputMaybe<Scalars['Boolean']>;
+};
+/**
+ * A cart represents the merchandise that a buyer intends to purchase,
+ * and the estimated cost associated with the cart. Learn how to
+ * [interact with a cart](https://shopify.dev/custom-storefronts/internationalization/international-pricing)
+ * during a customer's session.
+ *
+ */
+export declare type CartLinesArgs = {
+    after?: InputMaybe<Scalars['String']>;
+    before?: InputMaybe<Scalars['String']>;
+    first?: InputMaybe<Scalars['Int']>;
+    last?: InputMaybe<Scalars['Int']>;
+    reverse?: InputMaybe<Scalars['Boolean']>;
+};
+/** Return type for `cartAttributesUpdate` mutation. */
+export declare type CartAttributesUpdatePayload = {
+    __typename?: 'CartAttributesUpdatePayload';
+    /** The updated cart. */
+    cart?: Maybe<Cart>;
+    /** The list of errors that occurred from executing the mutation. */
+    userErrors: Array<CartUserError>;
+};
+/** The discounts automatically applied to the cart line based on prerequisites that have been met. */
+export declare type CartAutomaticDiscountAllocation = CartDiscountAllocation & {
+    __typename?: 'CartAutomaticDiscountAllocation';
+    /** The discounted amount that has been applied to the cart line. */
+    discountedAmount: MoneyV2;
+    /** The title of the allocated discount. */
+    title: Scalars['String'];
+};
+/** Represents information about the buyer that is interacting with the cart. */
+export declare type CartBuyerIdentity = {
+    __typename?: 'CartBuyerIdentity';
+    /** The country where the buyer is located. */
+    countryCode?: Maybe<CountryCode>;
+    /** The customer account associated with the cart. */
+    customer?: Maybe<Customer>;
+    /**
+     * An ordered set of delivery addresses tied to the buyer that is interacting with the cart.
+     * The rank of the preferences is determined by the order of the addresses in the array. Preferences
+     * can be used to populate relevant fields in the checkout flow.
+     *
+     */
+    deliveryAddressPreferences: Array<DeliveryAddress>;
+    /** The email address of the buyer that is interacting with the cart. */
+    email?: Maybe<Scalars['String']>;
+    /** The phone number of the buyer that is interacting with the cart. */
+    phone?: Maybe<Scalars['String']>;
+};
+/**
+ * Specifies the input fields to update the buyer information associated with a cart.
+ * Buyer identity is used to determine
+ * [international pricing](https://shopify.dev/custom-storefronts/internationalization/international-pricing)
+ * and should match the customer's shipping address.
+ *
+ */
+export declare type CartBuyerIdentityInput = {
+    /** The country where the buyer is located. */
+    countryCode?: InputMaybe<CountryCode>;
+    /** The access token used to identify the customer associated with the cart. */
+    customerAccessToken?: InputMaybe<Scalars['String']>;
+    /**
+     * An ordered set of delivery addresses tied to the buyer that is interacting with the cart.
+     * The rank of the preferences is determined by the order of the addresses in the array. Preferences
+     * can be used to populate relevant fields in the checkout flow.
+     *
+     */
+    deliveryAddressPreferences?: InputMaybe<Array<DeliveryAddressInput>>;
+    /** The email address of the buyer that is interacting with the cart. */
+    email?: InputMaybe<Scalars['String']>;
+    /** The phone number of the buyer that is interacting with the cart. */
+    phone?: InputMaybe<Scalars['String']>;
+};
+/** Return type for `cartBuyerIdentityUpdate` mutation. */
+export declare type CartBuyerIdentityUpdatePayload = {
+    __typename?: 'CartBuyerIdentityUpdatePayload';
+    /** The updated cart. */
+    cart?: Maybe<Cart>;
+    /** The list of errors that occurred from executing the mutation. */
+    userErrors: Array<CartUserError>;
+};
+/** The discount that has been applied to the cart line using a discount code. */
+export declare type CartCodeDiscountAllocation = CartDiscountAllocation & {
+    __typename?: 'CartCodeDiscountAllocation';
+    /** The code used to apply the discount. */
+    code: Scalars['String'];
+    /** The discounted amount that has been applied to the cart line. */
+    discountedAmount: MoneyV2;
+};
+/**
+ * The costs that the buyer will pay at checkout.
+ * The cart cost uses [`CartBuyerIdentity`](https://shopify.dev/api/storefront/reference/cart/cartbuyeridentity) to determine
+ * [international pricing](https://shopify.dev/custom-storefronts/internationalization/international-pricing).
+ *
+ */
+export declare type CartCost = {
+    __typename?: 'CartCost';
+    /** The estimated amount, before taxes and discounts, for the customer to pay at checkout. The checkout charge amount doesn't include any deferred payments that'll be paid at a later date. If the cart has no deferred payments, then the checkout charge amount is equivalent to `subtotalAmount`. */
+    checkoutChargeAmount: MoneyV2;
+    /** The amount, before taxes and cart-level discounts, for the customer to pay. */
+    subtotalAmount: MoneyV2;
+    /** Whether the subtotal amount is estimated. */
+    subtotalAmountEstimated: Scalars['Boolean'];
+    /** The total amount for the customer to pay. */
+    totalAmount: MoneyV2;
+    /** Whether the total amount is estimated. */
+    totalAmountEstimated: Scalars['Boolean'];
+    /** The duty amount for the customer to pay at checkout. */
+    totalDutyAmount?: Maybe<MoneyV2>;
+    /** Whether the total duty amount is estimated. */
+    totalDutyAmountEstimated: Scalars['Boolean'];
+    /** The tax amount for the customer to pay at checkout. */
+    totalTaxAmount?: Maybe<MoneyV2>;
+    /** Whether the total tax amount is estimated. */
+    totalTaxAmountEstimated: Scalars['Boolean'];
+};
+/** Return type for `cartCreate` mutation. */
+export declare type CartCreatePayload = {
+    __typename?: 'CartCreatePayload';
+    /** The new cart. */
+    cart?: Maybe<Cart>;
+    /** The list of errors that occurred from executing the mutation. */
+    userErrors: Array<CartUserError>;
+};
+/** The discounts automatically applied to the cart line based on prerequisites that have been met. */
+export declare type CartCustomDiscountAllocation = CartDiscountAllocation & {
+    __typename?: 'CartCustomDiscountAllocation';
+    /** The discounted amount that has been applied to the cart line. */
+    discountedAmount: MoneyV2;
+    /** The title of the allocated discount. */
+    title: Scalars['String'];
+};
+/** Information about the options available for one or more line items to be delivered to a specific address. */
+export declare type CartDeliveryGroup = {
+    __typename?: 'CartDeliveryGroup';
+    /** A list of cart lines for the delivery group. */
+    cartLines: CartLineConnection;
+    /** The destination address for the delivery group. */
+    deliveryAddress: MailingAddress;
+    /** The delivery options available for the delivery group. */
+    deliveryOptions: Array<CartDeliveryOption>;
+    /** The ID for the delivery group. */
+    id: Scalars['ID'];
+    /** The selected delivery option for the delivery group. */
+    selectedDeliveryOption?: Maybe<CartDeliveryOption>;
+};
+/** Information about the options available for one or more line items to be delivered to a specific address. */
+export declare type CartDeliveryGroupCartLinesArgs = {
+    after?: InputMaybe<Scalars['String']>;
+    before?: InputMaybe<Scalars['String']>;
+    first?: InputMaybe<Scalars['Int']>;
+    last?: InputMaybe<Scalars['Int']>;
+    reverse?: InputMaybe<Scalars['Boolean']>;
+};
+/**
+ * An auto-generated type for paginating through multiple CartDeliveryGroups.
+ *
+ */
+export declare type CartDeliveryGroupConnection = {
+    __typename?: 'CartDeliveryGroupConnection';
+    /** A list of edges. */
+    edges: Array<CartDeliveryGroupEdge>;
+    /** A list of the nodes contained in CartDeliveryGroupEdge. */
+    nodes: Array<CartDeliveryGroup>;
+    /** Information to aid in pagination. */
+    pageInfo: PageInfo;
+};
+/**
+ * An auto-generated type which holds one CartDeliveryGroup and a cursor during pagination.
+ *
+ */
+export declare type CartDeliveryGroupEdge = {
+    __typename?: 'CartDeliveryGroupEdge';
+    /** A cursor for use in pagination. */
+    cursor: Scalars['String'];
+    /** The item at the end of CartDeliveryGroupEdge. */
+    node: CartDeliveryGroup;
+};
+/** Information about a delivery option. */
+export declare type CartDeliveryOption = {
+    __typename?: 'CartDeliveryOption';
+    /** The code of the delivery option. */
+    code?: Maybe<Scalars['String']>;
+    /** The method for the delivery option. */
+    deliveryMethodType: DeliveryMethodType;
+    /** The description of the delivery option. */
+    description?: Maybe<Scalars['String']>;
+    /** The estimated cost for the delivery option. */
+    estimatedCost: MoneyV2;
+    /** The unique identifier of the delivery option. */
+    handle: Scalars['String'];
+    /** The title of the delivery option. */
+    title?: Maybe<Scalars['String']>;
+};
+/** The discounts that have been applied to the cart line. */
+export declare type CartDiscountAllocation = {
+    /** The discounted amount that has been applied to the cart line. */
+    discountedAmount: MoneyV2;
+};
+/** The discount codes applied to the cart. */
+export declare type CartDiscountCode = {
+    __typename?: 'CartDiscountCode';
+    /** Whether the discount code is applicable to the cart's current contents. */
+    applicable: Scalars['Boolean'];
+    /** The code for the discount. */
+    code: Scalars['String'];
+};
+/** Return type for `cartDiscountCodesUpdate` mutation. */
+export declare type CartDiscountCodesUpdatePayload = {
+    __typename?: 'CartDiscountCodesUpdatePayload';
+    /** The updated cart. */
+    cart?: Maybe<Cart>;
+    /** The list of errors that occurred from executing the mutation. */
+    userErrors: Array<CartUserError>;
+};
+/** Possible error codes that can be returned by `CartUserError`. */
+export declare enum CartErrorCode {
+    /** The input value is invalid. */
+    Invalid = "INVALID",
+    /** Merchandise line was not found in cart. */
+    InvalidMerchandiseLine = "INVALID_MERCHANDISE_LINE",
+    /** The input value should be less than the maximum value allowed. */
+    LessThan = "LESS_THAN",
+    /** Missing discount code. */
+    MissingDiscountCode = "MISSING_DISCOUNT_CODE",
+    /** Missing note. */
+    MissingNote = "MISSING_NOTE"
+}
+/**
+ * The estimated costs that the buyer will pay at checkout.
+ * The estimated cost uses
+ * [`CartBuyerIdentity`](https://shopify.dev/api/storefront/reference/cart/cartbuyeridentity)
+ * to determine
+ * [international pricing](https://shopify.dev/custom-storefronts/internationalization/international-pricing).
+ *
+ */
+export declare type CartEstimatedCost = {
+    __typename?: 'CartEstimatedCost';
+    /** The estimated amount, before taxes and discounts, for the customer to pay at checkout. The checkout charge amount doesn't include any deferred payments that'll be paid at a later date. If the cart has no deferred payments, then the checkout charge amount is equivalent to`subtotal_amount`. */
+    checkoutChargeAmount: MoneyV2;
+    /** The estimated amount, before taxes and discounts, for the customer to pay. */
+    subtotalAmount: MoneyV2;
+    /** The estimated total amount for the customer to pay. */
+    totalAmount: MoneyV2;
+    /** The estimated duty amount for the customer to pay at checkout. */
+    totalDutyAmount?: Maybe<MoneyV2>;
+    /** The estimated tax amount for the customer to pay at checkout. */
+    totalTaxAmount?: Maybe<MoneyV2>;
+};
+/** Specifies the input fields to create a cart. */
+export declare type CartInput = {
+    /** An array of key-value pairs that contains additional information about the cart. */
+    attributes?: InputMaybe<Array<AttributeInput>>;
+    /**
+     * The customer associated with the cart. Used to determine [international pricing]
+     * (https://shopify.dev/custom-storefronts/internationalization/international-pricing).
+     * Buyer identity should match the customer's shipping address.
+     *
+     */
+    buyerIdentity?: InputMaybe<CartBuyerIdentityInput>;
+    /**
+     * The case-insensitive discount codes that the customer added at checkout.
+     *
+     */
+    discountCodes?: InputMaybe<Array<Scalars['String']>>;
+    /** A list of merchandise lines to add to the cart. */
+    lines?: InputMaybe<Array<CartLineInput>>;
+    /** A note that is associated with the cart. For example, the note can be a personalized message to the buyer. */
+    note?: InputMaybe<Scalars['String']>;
+};
+/** Represents information about the merchandise in the cart. */
+export declare type CartLine = Node & {
+    __typename?: 'CartLine';
+    /** An attribute associated with the cart line. */
+    attribute?: Maybe<Attribute>;
+    /** The attributes associated with the cart line. Attributes are represented as key-value pairs. */
+    attributes: Array<Attribute>;
+    /** The cost of the merchandise that the buyer will pay for at checkout. The costs are subject to change and changes will be reflected at checkout. */
+    cost: CartLineCost;
+    /** The discounts that have been applied to the cart line. */
+    discountAllocations: Array<CartAutomaticDiscountAllocation | CartCodeDiscountAllocation | CartCustomDiscountAllocation>;
+    /**
+     * The estimated cost of the merchandise that the buyer will pay for at checkout. The estimated costs are subject to change and changes will be reflected at checkout.
+     * @deprecated Use `cost` instead.
+     */
+    estimatedCost: CartLineEstimatedCost;
+    /** A globally-unique identifier. */
+    id: Scalars['ID'];
+    /** The merchandise that the buyer intends to purchase. */
+    merchandise: Merchandise;
+    /** The quantity of the merchandise that the customer intends to purchase. */
+    quantity: Scalars['Int'];
+    /** The selling plan associated with the cart line and the effect that each selling plan has on variants when they're purchased. */
+    sellingPlanAllocation?: Maybe<SellingPlanAllocation>;
+};
+/** Represents information about the merchandise in the cart. */
+export declare type CartLineAttributeArgs = {
+    key: Scalars['String'];
+};
+/**
+ * An auto-generated type for paginating through multiple CartLines.
+ *
+ */
+export declare type CartLineConnection = {
+    __typename?: 'CartLineConnection';
+    /** A list of edges. */
+    edges: Array<CartLineEdge>;
+    /** A list of the nodes contained in CartLineEdge. */
+    nodes: Array<CartLine>;
+    /** Information to aid in pagination. */
+    pageInfo: PageInfo;
+};
+/** The cost of the merchandise line that the buyer will pay at checkout. */
+export declare type CartLineCost = {
+    __typename?: 'CartLineCost';
+    /** The amount of the merchandise line. */
+    amountPerQuantity: MoneyV2;
+    /** The compare at amount of the merchandise line. */
+    compareAtAmountPerQuantity?: Maybe<MoneyV2>;
+    /** The cost of the merchandise line before line-level discounts. */
+    subtotalAmount: MoneyV2;
+    /** The total cost of the merchandise line. */
+    totalAmount: MoneyV2;
+};
+/**
+ * An auto-generated type which holds one CartLine and a cursor during pagination.
+ *
+ */
+export declare type CartLineEdge = {
+    __typename?: 'CartLineEdge';
+    /** A cursor for use in pagination. */
+    cursor: Scalars['String'];
+    /** The item at the end of CartLineEdge. */
+    node: CartLine;
+};
+/** The estimated cost of the merchandise line that the buyer will pay at checkout. */
+export declare type CartLineEstimatedCost = {
+    __typename?: 'CartLineEstimatedCost';
+    /** The amount of the merchandise line. */
+    amount: MoneyV2;
+    /** The compare at amount of the merchandise line. */
+    compareAtAmount?: Maybe<MoneyV2>;
+    /** The estimated cost of the merchandise line before discounts. */
+    subtotalAmount: MoneyV2;
+    /** The estimated total cost of the merchandise line. */
+    totalAmount: MoneyV2;
+};
+/** Specifies the input fields to create a merchandise line on a cart. */
+export declare type CartLineInput = {
+    /** An array of key-value pairs that contains additional information about the merchandise line. */
+    attributes?: InputMaybe<Array<AttributeInput>>;
+    /** The identifier of the merchandise that the buyer intends to purchase. */
+    merchandiseId: Scalars['ID'];
+    /** The quantity of the merchandise. */
+    quantity?: InputMaybe<Scalars['Int']>;
+    /** The identifier of the selling plan that the merchandise is being purchased with. */
+    sellingPlanId?: InputMaybe<Scalars['ID']>;
+};
+/** Specifies the input fields to update a line item on a cart. */
+export declare type CartLineUpdateInput = {
+    /** An array of key-value pairs that contains additional information about the merchandise line. */
+    attributes?: InputMaybe<Array<AttributeInput>>;
+    /** The identifier of the merchandise line. */
+    id: Scalars['ID'];
+    /** The identifier of the merchandise for the line item. */
+    merchandiseId?: InputMaybe<Scalars['ID']>;
+    /** The quantity of the line item. */
+    quantity?: InputMaybe<Scalars['Int']>;
+    /** The identifier of the selling plan that the merchandise is being purchased with. */
+    sellingPlanId?: InputMaybe<Scalars['ID']>;
+};
+/** Return type for `cartLinesAdd` mutation. */
+export declare type CartLinesAddPayload = {
+    __typename?: 'CartLinesAddPayload';
+    /** The updated cart. */
+    cart?: Maybe<Cart>;
+    /** The list of errors that occurred from executing the mutation. */
+    userErrors: Array<CartUserError>;
+};
+/** Return type for `cartLinesRemove` mutation. */
+export declare type CartLinesRemovePayload = {
+    __typename?: 'CartLinesRemovePayload';
+    /** The updated cart. */
+    cart?: Maybe<Cart>;
+    /** The list of errors that occurred from executing the mutation. */
+    userErrors: Array<CartUserError>;
+};
+/** Return type for `cartLinesUpdate` mutation. */
+export declare type CartLinesUpdatePayload = {
+    __typename?: 'CartLinesUpdatePayload';
+    /** The updated cart. */
+    cart?: Maybe<Cart>;
+    /** The list of errors that occurred from executing the mutation. */
+    userErrors: Array<CartUserError>;
+};
+/** Return type for `cartNoteUpdate` mutation. */
+export declare type CartNoteUpdatePayload = {
+    __typename?: 'CartNoteUpdatePayload';
+    /** The updated cart. */
+    cart?: Maybe<Cart>;
+    /** The list of errors that occurred from executing the mutation. */
+    userErrors: Array<CartUserError>;
+};
+/**
+ * The input fields for updating the selected delivery options for a delivery group.
+ *
+ */
+export declare type CartSelectedDeliveryOptionInput = {
+    /** The ID of the cart delivery group. */
+    deliveryGroupId: Scalars['ID'];
+    /** The handle of the selected delivery option. */
+    deliveryOptionHandle: Scalars['String'];
+};
+/** Return type for `cartSelectedDeliveryOptionsUpdate` mutation. */
+export declare type CartSelectedDeliveryOptionsUpdatePayload = {
+    __typename?: 'CartSelectedDeliveryOptionsUpdatePayload';
+    /** The updated cart. */
+    cart?: Maybe<Cart>;
+    /** The list of errors that occurred from executing the mutation. */
+    userErrors: Array<CartUserError>;
+};
+/** Represents an error that happens during execution of a cart mutation. */
+export declare type CartUserError = DisplayableError & {
+    __typename?: 'CartUserError';
+    /** The error code. */
+    code?: Maybe<CartErrorCode>;
+    /** The path to the input field that caused the error. */
+    field?: Maybe<Array<Scalars['String']>>;
+    /** The error message. */
+    message: Scalars['String'];
+};
+/** A container for all the information required to checkout items and pay. */
+export declare type Checkout = Node & {
+    __typename?: 'Checkout';
+    /** The gift cards used on the checkout. */
+    appliedGiftCards: Array<AppliedGiftCard>;
+    /**
+     * The available shipping rates for this Checkout.
+     * Should only be used when checkout `requiresShipping` is `true` and
+     * the shipping address is valid.
+     *
+     */
+    availableShippingRates?: Maybe<AvailableShippingRates>;
+    /** The identity of the customer associated with the checkout. */
+    buyerIdentity: CheckoutBuyerIdentity;
+    /** The date and time when the checkout was completed. */
+    completedAt?: Maybe<Scalars['DateTime']>;
+    /** The date and time when the checkout was created. */
+    createdAt: Scalars['DateTime'];
+    /** The currency code for the checkout. */
+    currencyCode: CurrencyCode;
+    /** A list of extra information that is added to the checkout. */
+    customAttributes: Array<Attribute>;
+    /** Discounts that have been applied on the checkout. */
+    discountApplications: DiscountApplicationConnection;
+    /** The email attached to this checkout. */
+    email?: Maybe<Scalars['String']>;
+    /** A globally-unique identifier. */
+    id: Scalars['ID'];
+    /** A list of line item objects, each one containing information about an item in the checkout. */
+    lineItems: CheckoutLineItemConnection;
+    /** The sum of all the prices of all the items in the checkout. Duties, taxes, shipping and discounts excluded. */
+    lineItemsSubtotalPrice: MoneyV2;
+    /** The note associated with the checkout. */
+    note?: Maybe<Scalars['String']>;
+    /** The resulting order from a paid checkout. */
+    order?: Maybe<Order>;
+    /** The Order Status Page for this Checkout, null when checkout is not completed. */
+    orderStatusUrl?: Maybe<Scalars['URL']>;
+    /** The amount left to be paid. This is equal to the cost of the line items, taxes, and shipping, minus discounts and gift cards. */
+    paymentDue: MoneyV2;
+    /**
+     * The amount left to be paid. This is equal to the cost of the line items, duties, taxes, and shipping, minus discounts and gift cards.
+     * @deprecated Use `paymentDue` instead.
+     */
+    paymentDueV2: MoneyV2;
+    /**
+     * Whether or not the Checkout is ready and can be completed. Checkouts may
+     * have asynchronous operations that can take time to finish. If you want
+     * to complete a checkout or ensure all the fields are populated and up to
+     * date, polling is required until the value is true.
+     *
+     */
+    ready: Scalars['Boolean'];
+    /** States whether or not the fulfillment requires shipping. */
+    requiresShipping: Scalars['Boolean'];
+    /** The shipping address to where the line items will be shipped. */
+    shippingAddress?: Maybe<MailingAddress>;
+    /**
+     * The discounts that have been allocated onto the shipping line by discount applications.
+     *
+     */
+    shippingDiscountAllocations: Array<DiscountAllocation>;
+    /** Once a shipping rate is selected by the customer it is transitioned to a `shipping_line` object. */
+    shippingLine?: Maybe<ShippingRate>;
+    /** The price at checkout before shipping and taxes. */
+    subtotalPrice: MoneyV2;
+    /**
+     * The price at checkout before duties, shipping, and taxes.
+     * @deprecated Use `subtotalPrice` instead.
+     */
+    subtotalPriceV2: MoneyV2;
+    /** Whether the checkout is tax exempt. */
+    taxExempt: Scalars['Boolean'];
+    /** Whether taxes are included in the line item and shipping line prices. */
+    taxesIncluded: Scalars['Boolean'];
+    /** The sum of all the duties applied to the line items in the checkout. */
+    totalDuties?: Maybe<MoneyV2>;
+    /** The sum of all the prices of all the items in the checkout, including taxes and duties. */
+    totalPrice: MoneyV2;
+    /**
+     * The sum of all the prices of all the items in the checkout, including taxes and duties.
+     * @deprecated Use `totalPrice` instead.
+     */
+    totalPriceV2: MoneyV2;
+    /** The sum of all the taxes applied to the line items and shipping lines in the checkout. */
+    totalTax: MoneyV2;
+    /**
+     * The sum of all the taxes applied to the line items and shipping lines in the checkout.
+     * @deprecated Use `totalTax` instead.
+     */
+    totalTaxV2: MoneyV2;
+    /** The date and time when the checkout was last updated. */
+    updatedAt: Scalars['DateTime'];
+    /** The url pointing to the checkout accessible from the web. */
+    webUrl: Scalars['URL'];
+};
+/** A container for all the information required to checkout items and pay. */
+export declare type CheckoutDiscountApplicationsArgs = {
+    after?: InputMaybe<Scalars['String']>;
+    before?: InputMaybe<Scalars['String']>;
+    first?: InputMaybe<Scalars['Int']>;
+    last?: InputMaybe<Scalars['Int']>;
+    reverse?: InputMaybe<Scalars['Boolean']>;
+};
+/** A container for all the information required to checkout items and pay. */
+export declare type CheckoutLineItemsArgs = {
+    after?: InputMaybe<Scalars['String']>;
+    before?: InputMaybe<Scalars['String']>;
+    first?: InputMaybe<Scalars['Int']>;
+    last?: InputMaybe<Scalars['Int']>;
+    reverse?: InputMaybe<Scalars['Boolean']>;
+};
+/** Specifies the fields required to update a checkout's attributes. */
+export declare type CheckoutAttributesUpdateV2Input = {
+    /**
+     * Allows setting partial addresses on a Checkout, skipping the full validation of attributes.
+     * The required attributes are city, province, and country.
+     * Full validation of the addresses is still done at completion time. Defaults to `false` with
+     * each operation.
+     *
+     */
+    allowPartialAddresses?: InputMaybe<Scalars['Boolean']>;
+    /** A list of extra information that is added to the checkout. */
+    customAttributes?: InputMaybe<Array<AttributeInput>>;
+    /** The text of an optional note that a shop owner can attach to the checkout. */
+    note?: InputMaybe<Scalars['String']>;
+};
+/** Return type for `checkoutAttributesUpdateV2` mutation. */
+export declare type CheckoutAttributesUpdateV2Payload = {
+    __typename?: 'CheckoutAttributesUpdateV2Payload';
+    /** The updated checkout object. */
+    checkout?: Maybe<Checkout>;
+    /** The list of errors that occurred from executing the mutation. */
+    checkoutUserErrors: Array<CheckoutUserError>;
+    /**
+     * The list of errors that occurred from executing the mutation.
+     * @deprecated Use `checkoutUserErrors` instead.
+     */
+    userErrors: Array<UserError>;
+};
+/** The identity of the customer associated with the checkout. */
+export declare type CheckoutBuyerIdentity = {
+    __typename?: 'CheckoutBuyerIdentity';
+    /** The country code for the checkout. For example, `CA`. */
+    countryCode?: Maybe<CountryCode>;
+};
+/** Specifies the identity of the customer associated with the checkout. */
+export declare type CheckoutBuyerIdentityInput = {
+    /**
+     * The country code of one of the shop's
+     * [enabled countries](https://help.shopify.com/en/manual/payments/shopify-payments/multi-currency/setup).
+     * For example, `CA`. Including this field creates a checkout in the specified country's currency.
+     *
+     */
+    countryCode: CountryCode;
+};
+/** Return type for `checkoutCompleteFree` mutation. */
+export declare type CheckoutCompleteFreePayload = {
+    __typename?: 'CheckoutCompleteFreePayload';
+    /** The updated checkout object. */
+    checkout?: Maybe<Checkout>;
+    /** The list of errors that occurred from executing the mutation. */
+    checkoutUserErrors: Array<CheckoutUserError>;
+    /**
+     * The list of errors that occurred from executing the mutation.
+     * @deprecated Use `checkoutUserErrors` instead.
+     */
+    userErrors: Array<UserError>;
+};
+/** Return type for `checkoutCompleteWithCreditCardV2` mutation. */
+export declare type CheckoutCompleteWithCreditCardV2Payload = {
+    __typename?: 'CheckoutCompleteWithCreditCardV2Payload';
+    /** The checkout on which the payment was applied. */
+    checkout?: Maybe<Checkout>;
+    /** The list of errors that occurred from executing the mutation. */
+    checkoutUserErrors: Array<CheckoutUserError>;
+    /** A representation of the attempted payment. */
+    payment?: Maybe<Payment>;
+    /**
+     * The list of errors that occurred from executing the mutation.
+     * @deprecated Use `checkoutUserErrors` instead.
+     */
+    userErrors: Array<UserError>;
+};
+/** Return type for `checkoutCompleteWithTokenizedPaymentV3` mutation. */
+export declare type CheckoutCompleteWithTokenizedPaymentV3Payload = {
+    __typename?: 'CheckoutCompleteWithTokenizedPaymentV3Payload';
+    /** The checkout on which the payment was applied. */
+    checkout?: Maybe<Checkout>;
+    /** The list of errors that occurred from executing the mutation. */
+    checkoutUserErrors: Array<CheckoutUserError>;
+    /** A representation of the attempted payment. */
+    payment?: Maybe<Payment>;
+    /**
+     * The list of errors that occurred from executing the mutation.
+     * @deprecated Use `checkoutUserErrors` instead.
+     */
+    userErrors: Array<UserError>;
+};
+/** Specifies the fields required to create a checkout. */
+export declare type CheckoutCreateInput = {
+    /**
+     * Allows setting partial addresses on a Checkout, skipping the full validation of attributes.
+     * The required attributes are city, province, and country.
+     * Full validation of addresses is still done at completion time. Defaults to `null`.
+     *
+     */
+    allowPartialAddresses?: InputMaybe<Scalars['Boolean']>;
+    /** The identity of the customer associated with the checkout. */
+    buyerIdentity?: InputMaybe<CheckoutBuyerIdentityInput>;
+    /** A list of extra information that is added to the checkout. */
+    customAttributes?: InputMaybe<Array<AttributeInput>>;
+    /** The email with which the customer wants to checkout. */
+    email?: InputMaybe<Scalars['String']>;
+    /** A list of line item objects, each one containing information about an item in the checkout. */
+    lineItems?: InputMaybe<Array<CheckoutLineItemInput>>;
+    /** The text of an optional note that a shop owner can attach to the checkout. */
+    note?: InputMaybe<Scalars['String']>;
+    /** The shipping address to where the line items will be shipped. */
+    shippingAddress?: InputMaybe<MailingAddressInput>;
+};
+/** Return type for `checkoutCreate` mutation. */
+export declare type CheckoutCreatePayload = {
+    __typename?: 'CheckoutCreatePayload';
+    /** The new checkout object. */
+    checkout?: Maybe<Checkout>;
+    /** The list of errors that occurred from executing the mutation. */
+    checkoutUserErrors: Array<CheckoutUserError>;
+    /** The checkout queue token. Available only to selected stores. */
+    queueToken?: Maybe<Scalars['String']>;
+    /**
+     * The list of errors that occurred from executing the mutation.
+     * @deprecated Use `checkoutUserErrors` instead.
+     */
+    userErrors: Array<UserError>;
+};
+/** Return type for `checkoutCustomerAssociateV2` mutation. */
+export declare type CheckoutCustomerAssociateV2Payload = {
+    __typename?: 'CheckoutCustomerAssociateV2Payload';
+    /** The updated checkout object. */
+    checkout?: Maybe<Checkout>;
+    /** The list of errors that occurred from executing the mutation. */
+    checkoutUserErrors: Array<CheckoutUserError>;
+    /** The associated customer object. */
+    customer?: Maybe<Customer>;
+    /**
+     * The list of errors that occurred from executing the mutation.
+     * @deprecated Use `checkoutUserErrors` instead.
+     */
+    userErrors: Array<UserError>;
+};
+/** Return type for `checkoutCustomerDisassociateV2` mutation. */
+export declare type CheckoutCustomerDisassociateV2Payload = {
+    __typename?: 'CheckoutCustomerDisassociateV2Payload';
+    /** The updated checkout object. */
+    checkout?: Maybe<Checkout>;
+    /** The list of errors that occurred from executing the mutation. */
+    checkoutUserErrors: Array<CheckoutUserError>;
+    /**
+     * The list of errors that occurred from executing the mutation.
+     * @deprecated Use `checkoutUserErrors` instead.
+     */
+    userErrors: Array<UserError>;
+};
+/** Return type for `checkoutDiscountCodeApplyV2` mutation. */
+export declare type CheckoutDiscountCodeApplyV2Payload = {
+    __typename?: 'CheckoutDiscountCodeApplyV2Payload';
+    /** The updated checkout object. */
+    checkout?: Maybe<Checkout>;
+    /** The list of errors that occurred from executing the mutation. */
+    checkoutUserErrors: Array<CheckoutUserError>;
+    /**
+     * The list of errors that occurred from executing the mutation.
+     * @deprecated Use `checkoutUserErrors` instead.
+     */
+    userErrors: Array<UserError>;
+};
+/** Return type for `checkoutDiscountCodeRemove` mutation. */
+export declare type CheckoutDiscountCodeRemovePayload = {
+    __typename?: 'CheckoutDiscountCodeRemovePayload';
+    /** The updated checkout object. */
+    checkout?: Maybe<Checkout>;
+    /** The list of errors that occurred from executing the mutation. */
+    checkoutUserErrors: Array<CheckoutUserError>;
+    /**
+     * The list of errors that occurred from executing the mutation.
+     * @deprecated Use `checkoutUserErrors` instead.
+     */
+    userErrors: Array<UserError>;
+};
+/** Return type for `checkoutEmailUpdateV2` mutation. */
+export declare type CheckoutEmailUpdateV2Payload = {
+    __typename?: 'CheckoutEmailUpdateV2Payload';
+    /** The checkout object with the updated email. */
+    checkout?: Maybe<Checkout>;
+    /** The list of errors that occurred from executing the mutation. */
+    checkoutUserErrors: Array<CheckoutUserError>;
+    /**
+     * The list of errors that occurred from executing the mutation.
+     * @deprecated Use `checkoutUserErrors` instead.
+     */
+    userErrors: Array<UserError>;
+};
+/** Possible error codes that can be returned by `CheckoutUserError`. */
+export declare enum CheckoutErrorCode {
+    /** Checkout is already completed. */
+    AlreadyCompleted = "ALREADY_COMPLETED",
+    /** Input email contains an invalid domain name. */
+    BadDomain = "BAD_DOMAIN",
+    /** The input value is blank. */
+    Blank = "BLANK",
+    /** Cart does not meet discount requirements notice. */
+    CartDoesNotMeetDiscountRequirementsNotice = "CART_DOES_NOT_MEET_DISCOUNT_REQUIREMENTS_NOTICE",
+    /** Customer already used once per customer discount notice. */
+    CustomerAlreadyUsedOncePerCustomerDiscountNotice = "CUSTOMER_ALREADY_USED_ONCE_PER_CUSTOMER_DISCOUNT_NOTICE",
+    /** Discount already applied. */
+    DiscountAlreadyApplied = "DISCOUNT_ALREADY_APPLIED",
+    /** Discount disabled. */
+    DiscountDisabled = "DISCOUNT_DISABLED",
+    /** Discount expired. */
+    DiscountExpired = "DISCOUNT_EXPIRED",
+    /** Discount limit reached. */
+    DiscountLimitReached = "DISCOUNT_LIMIT_REACHED",
+    /** Discount not found. */
+    DiscountNotFound = "DISCOUNT_NOT_FOUND",
+    /** Checkout is already completed. */
+    Empty = "EMPTY",
+    /** Queue token has expired. */
+    ExpiredQueueToken = "EXPIRED_QUEUE_TOKEN",
+    /** Gift card has already been applied. */
+    GiftCardAlreadyApplied = "GIFT_CARD_ALREADY_APPLIED",
+    /** Gift card code is invalid. */
+    GiftCardCodeInvalid = "GIFT_CARD_CODE_INVALID",
+    /** Gift card currency does not match checkout currency. */
+    GiftCardCurrencyMismatch = "GIFT_CARD_CURRENCY_MISMATCH",
+    /** Gift card has no funds left. */
+    GiftCardDepleted = "GIFT_CARD_DEPLETED",
+    /** Gift card is disabled. */
+    GiftCardDisabled = "GIFT_CARD_DISABLED",
+    /** Gift card is expired. */
+    GiftCardExpired = "GIFT_CARD_EXPIRED",
+    /** Gift card was not found. */
+    GiftCardNotFound = "GIFT_CARD_NOT_FOUND",
+    /** Gift card cannot be applied to a checkout that contains a gift card. */
+    GiftCardUnusable = "GIFT_CARD_UNUSABLE",
+    /** The input value should be greater than or equal to the minimum value allowed. */
+    GreaterThanOrEqualTo = "GREATER_THAN_OR_EQUAL_TO",
+    /** Higher value discount applied. */
+    HigherValueDiscountApplied = "HIGHER_VALUE_DISCOUNT_APPLIED",
+    /** The input value is invalid. */
+    Invalid = "INVALID",
+    /** Cannot specify country and presentment currency code. */
+    InvalidCountryAndCurrency = "INVALID_COUNTRY_AND_CURRENCY",
+    /** Input Zip is invalid for country provided. */
+    InvalidForCountry = "INVALID_FOR_COUNTRY",
+    /** Input Zip is invalid for country and province provided. */
+    InvalidForCountryAndProvince = "INVALID_FOR_COUNTRY_AND_PROVINCE",
+    /** Invalid province in country. */
+    InvalidProvinceInCountry = "INVALID_PROVINCE_IN_COUNTRY",
+    /** Queue token is invalid. */
+    InvalidQueueToken = "INVALID_QUEUE_TOKEN",
+    /** Invalid region in country. */
+    InvalidRegionInCountry = "INVALID_REGION_IN_COUNTRY",
+    /** Invalid state in country. */
+    InvalidStateInCountry = "INVALID_STATE_IN_COUNTRY",
+    /** The input value should be less than the maximum value allowed. */
+    LessThan = "LESS_THAN",
+    /** The input value should be less than or equal to the maximum value allowed. */
+    LessThanOrEqualTo = "LESS_THAN_OR_EQUAL_TO",
+    /** Line item was not found in checkout. */
+    LineItemNotFound = "LINE_ITEM_NOT_FOUND",
+    /** Checkout is locked. */
+    Locked = "LOCKED",
+    /** Maximum number of discount codes limit reached. */
+    MaximumDiscountCodeLimitReached = "MAXIMUM_DISCOUNT_CODE_LIMIT_REACHED",
+    /** Missing payment input. */
+    MissingPaymentInput = "MISSING_PAYMENT_INPUT",
+    /** Not enough in stock. */
+    NotEnoughInStock = "NOT_ENOUGH_IN_STOCK",
+    /** Input value is not supported. */
+    NotSupported = "NOT_SUPPORTED",
+    /** The input value needs to be blank. */
+    Present = "PRESENT",
+    /** Shipping rate expired. */
+    ShippingRateExpired = "SHIPPING_RATE_EXPIRED",
+    /** Throttled during checkout. */
+    ThrottledDuringCheckout = "THROTTLED_DURING_CHECKOUT",
+    /** The input value is too long. */
+    TooLong = "TOO_LONG",
+    /** The amount of the payment does not match the value to be paid. */
+    TotalPriceMismatch = "TOTAL_PRICE_MISMATCH",
+    /** Unable to apply discount. */
+    UnableToApply = "UNABLE_TO_APPLY"
+}
+/** Return type for `checkoutGiftCardRemoveV2` mutation. */
+export declare type CheckoutGiftCardRemoveV2Payload = {
+    __typename?: 'CheckoutGiftCardRemoveV2Payload';
+    /** The updated checkout object. */
+    checkout?: Maybe<Checkout>;
+    /** The list of errors that occurred from executing the mutation. */
+    checkoutUserErrors: Array<CheckoutUserError>;
+    /**
+     * The list of errors that occurred from executing the mutation.
+     * @deprecated Use `checkoutUserErrors` instead.
+     */
+    userErrors: Array<UserError>;
+};
+/** Return type for `checkoutGiftCardsAppend` mutation. */
+export declare type CheckoutGiftCardsAppendPayload = {
+    __typename?: 'CheckoutGiftCardsAppendPayload';
+    /** The updated checkout object. */
+    checkout?: Maybe<Checkout>;
+    /** The list of errors that occurred from executing the mutation. */
+    checkoutUserErrors: Array<CheckoutUserError>;
+    /**
+     * The list of errors that occurred from executing the mutation.
+     * @deprecated Use `checkoutUserErrors` instead.
+     */
+    userErrors: Array<UserError>;
+};
+/** A single line item in the checkout, grouped by variant and attributes. */
+export declare type CheckoutLineItem = Node & {
+    __typename?: 'CheckoutLineItem';
+    /** Extra information in the form of an array of Key-Value pairs about the line item. */
+    customAttributes: Array<Attribute>;
+    /** The discounts that have been allocated onto the checkout line item by discount applications. */
+    discountAllocations: Array<DiscountAllocation>;
+    /** A globally-unique identifier. */
+    id: Scalars['ID'];
+    /** The quantity of the line item. */
+    quantity: Scalars['Int'];
+    /** Title of the line item. Defaults to the product's title. */
+    title: Scalars['String'];
+    /** Unit price of the line item. */
+    unitPrice?: Maybe<MoneyV2>;
+    /** Product variant of the line item. */
+    variant?: Maybe<ProductVariant>;
+};
+/**
+ * An auto-generated type for paginating through multiple CheckoutLineItems.
+ *
+ */
+export declare type CheckoutLineItemConnection = {
+    __typename?: 'CheckoutLineItemConnection';
+    /** A list of edges. */
+    edges: Array<CheckoutLineItemEdge>;
+    /** A list of the nodes contained in CheckoutLineItemEdge. */
+    nodes: Array<CheckoutLineItem>;
+    /** Information to aid in pagination. */
+    pageInfo: PageInfo;
+};
+/**
+ * An auto-generated type which holds one CheckoutLineItem and a cursor during pagination.
+ *
+ */
+export declare type CheckoutLineItemEdge = {
+    __typename?: 'CheckoutLineItemEdge';
+    /** A cursor for use in pagination. */
+    cursor: Scalars['String'];
+    /** The item at the end of CheckoutLineItemEdge. */
+    node: CheckoutLineItem;
+};
+/** Specifies the input fields to create a line item on a checkout. */
+export declare type CheckoutLineItemInput = {
+    /** Extra information in the form of an array of Key-Value pairs about the line item. */
+    customAttributes?: InputMaybe<Array<AttributeInput>>;
+    /** The quantity of the line item. */
+    quantity: Scalars['Int'];
+    /** The identifier of the product variant for the line item. */
+    variantId: Scalars['ID'];
+};
+/** Specifies the input fields to update a line item on the checkout. */
+export declare type CheckoutLineItemUpdateInput = {
+    /** Extra information in the form of an array of Key-Value pairs about the line item. */
+    customAttributes?: InputMaybe<Array<AttributeInput>>;
+    /** The identifier of the line item. */
+    id?: InputMaybe<Scalars['ID']>;
+    /** The quantity of the line item. */
+    quantity?: InputMaybe<Scalars['Int']>;
+    /** The variant identifier of the line item. */
+    variantId?: InputMaybe<Scalars['ID']>;
+};
+/** Return type for `checkoutLineItemsAdd` mutation. */
+export declare type CheckoutLineItemsAddPayload = {
+    __typename?: 'CheckoutLineItemsAddPayload';
+    /** The updated checkout object. */
+    checkout?: Maybe<Checkout>;
+    /** The list of errors that occurred from executing the mutation. */
+    checkoutUserErrors: Array<CheckoutUserError>;
+    /**
+     * The list of errors that occurred from executing the mutation.
+     * @deprecated Use `checkoutUserErrors` instead.
+     */
+    userErrors: Array<UserError>;
+};
+/** Return type for `checkoutLineItemsRemove` mutation. */
+export declare type CheckoutLineItemsRemovePayload = {
+    __typename?: 'CheckoutLineItemsRemovePayload';
+    /** The updated checkout object. */
+    checkout?: Maybe<Checkout>;
+    /** The list of errors that occurred from executing the mutation. */
+    checkoutUserErrors: Array<CheckoutUserError>;
+    /**
+     * The list of errors that occurred from executing the mutation.
+     * @deprecated Use `checkoutUserErrors` instead.
+     */
+    userErrors: Array<UserError>;
+};
+/** Return type for `checkoutLineItemsReplace` mutation. */
+export declare type CheckoutLineItemsReplacePayload = {
+    __typename?: 'CheckoutLineItemsReplacePayload';
+    /** The updated checkout object. */
+    checkout?: Maybe<Checkout>;
+    /** The list of errors that occurred from executing the mutation. */
+    userErrors: Array<CheckoutUserError>;
+};
+/** Return type for `checkoutLineItemsUpdate` mutation. */
+export declare type CheckoutLineItemsUpdatePayload = {
+    __typename?: 'CheckoutLineItemsUpdatePayload';
+    /** The updated checkout object. */
+    checkout?: Maybe<Checkout>;
+    /** The list of errors that occurred from executing the mutation. */
+    checkoutUserErrors: Array<CheckoutUserError>;
+    /**
+     * The list of errors that occurred from executing the mutation.
+     * @deprecated Use `checkoutUserErrors` instead.
+     */
+    userErrors: Array<UserError>;
+};
+/** Return type for `checkoutShippingAddressUpdateV2` mutation. */
+export declare type CheckoutShippingAddressUpdateV2Payload = {
+    __typename?: 'CheckoutShippingAddressUpdateV2Payload';
+    /** The updated checkout object. */
+    checkout?: Maybe<Checkout>;
+    /** The list of errors that occurred from executing the mutation. */
+    checkoutUserErrors: Array<CheckoutUserError>;
+    /**
+     * The list of errors that occurred from executing the mutation.
+     * @deprecated Use `checkoutUserErrors` instead.
+     */
+    userErrors: Array<UserError>;
+};
+/** Return type for `checkoutShippingLineUpdate` mutation. */
+export declare type CheckoutShippingLineUpdatePayload = {
+    __typename?: 'CheckoutShippingLineUpdatePayload';
+    /** The updated checkout object. */
+    checkout?: Maybe<Checkout>;
+    /** The list of errors that occurred from executing the mutation. */
+    checkoutUserErrors: Array<CheckoutUserError>;
+    /**
+     * The list of errors that occurred from executing the mutation.
+     * @deprecated Use `checkoutUserErrors` instead.
+     */
+    userErrors: Array<UserError>;
+};
+/** Represents an error that happens during execution of a checkout mutation. */
+export declare type CheckoutUserError = DisplayableError & {
+    __typename?: 'CheckoutUserError';
+    /** The error code. */
+    code?: Maybe<CheckoutErrorCode>;
+    /** The path to the input field that caused the error. */
+    field?: Maybe<Array<Scalars['String']>>;
+    /** The error message. */
+    message: Scalars['String'];
+};
+/** A collection represents a grouping of products that a shop owner can create to organize them or make their shops easier to browse. */
+export declare type Collection = HasMetafields & Node & OnlineStorePublishable & {
+    __typename?: 'Collection';
+    /** Stripped description of the collection, single line with HTML tags removed. */
+    description: Scalars['String'];
+    /** The description of the collection, complete with HTML formatting. */
+    descriptionHtml: Scalars['HTML'];
+    /**
+     * A human-friendly unique string for the collection automatically generated from its title.
+     * Limit of 255 characters.
+     *
+     */
+    handle: Scalars['String'];
+    /** A globally-unique identifier. */
+    id: Scalars['ID'];
+    /** Image associated with the collection. */
+    image?: Maybe<Image>;
+    /** Returns a metafield found by namespace and key. */
+    metafield?: Maybe<Metafield>;
+    /**
+     * The metafields associated with the resource matching the supplied list of namespaces and keys.
+     *
+     */
+    metafields: Array<Maybe<Metafield>>;
+    /** The URL used for viewing the resource on the shop's Online Store. Returns `null` if the resource is currently not published to the Online Store sales channel. */
+    onlineStoreUrl?: Maybe<Scalars['URL']>;
+    /** List of products in the collection. */
+    products: ProductConnection;
+    /** The collection's SEO information. */
+    seo: Seo;
+    /** The collections name. Limit of 255 characters. */
+    title: Scalars['String'];
+    /** The date and time when the collection was last modified. */
+    updatedAt: Scalars['DateTime'];
+};
+/** A collection represents a grouping of products that a shop owner can create to organize them or make their shops easier to browse. */
+export declare type CollectionDescriptionArgs = {
+    truncateAt?: InputMaybe<Scalars['Int']>;
+};
+/** A collection represents a grouping of products that a shop owner can create to organize them or make their shops easier to browse. */
+export declare type CollectionMetafieldArgs = {
+    key: Scalars['String'];
+    namespace: Scalars['String'];
+};
+/** A collection represents a grouping of products that a shop owner can create to organize them or make their shops easier to browse. */
+export declare type CollectionMetafieldsArgs = {
+    identifiers: Array<HasMetafieldsIdentifier>;
+};
+/** A collection represents a grouping of products that a shop owner can create to organize them or make their shops easier to browse. */
+export declare type CollectionProductsArgs = {
+    after?: InputMaybe<Scalars['String']>;
+    before?: InputMaybe<Scalars['String']>;
+    filters?: InputMaybe<Array<ProductFilter>>;
+    first?: InputMaybe<Scalars['Int']>;
+    last?: InputMaybe<Scalars['Int']>;
+    reverse?: InputMaybe<Scalars['Boolean']>;
+    sortKey?: InputMaybe<ProductCollectionSortKeys>;
+};
+/**
+ * An auto-generated type for paginating through multiple Collections.
+ *
+ */
+export declare type CollectionConnection = {
+    __typename?: 'CollectionConnection';
+    /** A list of edges. */
+    edges: Array<CollectionEdge>;
+    /** A list of the nodes contained in CollectionEdge. */
+    nodes: Array<Collection>;
+    /** Information to aid in pagination. */
+    pageInfo: PageInfo;
+};
+/**
+ * An auto-generated type which holds one Collection and a cursor during pagination.
+ *
+ */
+export declare type CollectionEdge = {
+    __typename?: 'CollectionEdge';
+    /** A cursor for use in pagination. */
+    cursor: Scalars['String'];
+    /** The item at the end of CollectionEdge. */
+    node: Collection;
+};
+/** The set of valid sort keys for the Collection query. */
+export declare enum CollectionSortKeys {
+    /** Sort by the `id` value. */
+    Id = "ID",
+    /**
+     * Sort by relevance to the search terms when the `query` parameter is specified on the connection.
+     * Don't use this sort key when no search query is specified.
+     *
+     */
+    Relevance = "RELEVANCE",
+    /** Sort by the `title` value. */
+    Title = "TITLE",
+    /** Sort by the `updated_at` value. */
+    UpdatedAt = "UPDATED_AT"
+}
+/** A comment on an article. */
+export declare type Comment = Node & {
+    __typename?: 'Comment';
+    /** The comments author. */
+    author: CommentAuthor;
+    /** Stripped content of the comment, single line with HTML tags removed. */
+    content: Scalars['String'];
+    /** The content of the comment, complete with HTML formatting. */
+    contentHtml: Scalars['HTML'];
+    /** A globally-unique identifier. */
+    id: Scalars['ID'];
+};
+/** A comment on an article. */
+export declare type CommentContentArgs = {
+    truncateAt?: InputMaybe<Scalars['Int']>;
+};
+/** The author of a comment. */
+export declare type CommentAuthor = {
+    __typename?: 'CommentAuthor';
+    /** The author's email. */
+    email: Scalars['String'];
+    /** The authors name. */
+    name: Scalars['String'];
+};
+/**
+ * An auto-generated type for paginating through multiple Comments.
+ *
+ */
+export declare type CommentConnection = {
+    __typename?: 'CommentConnection';
+    /** A list of edges. */
+    edges: Array<CommentEdge>;
+    /** A list of the nodes contained in CommentEdge. */
+    nodes: Array<Comment>;
+    /** Information to aid in pagination. */
+    pageInfo: PageInfo;
+};
+/**
+ * An auto-generated type which holds one Comment and a cursor during pagination.
+ *
+ */
+export declare type CommentEdge = {
+    __typename?: 'CommentEdge';
+    /** A cursor for use in pagination. */
+    cursor: Scalars['String'];
+    /** The item at the end of CommentEdge. */
+    node: Comment;
+};
+/** A country. */
+export declare type Country = {
+    __typename?: 'Country';
+    /** The languages available for the country. */
+    availableLanguages: Array<Language>;
+    /** The currency of the country. */
+    currency: Currency;
+    /** The ISO code of the country. */
+    isoCode: CountryCode;
+    /** The name of the country. */
+    name: Scalars['String'];
+    /** The unit system used in the country. */
+    unitSystem: UnitSystem;
+};
+/**
+ * The code designating a country/region, which generally follows ISO 3166-1 alpha-2 guidelines.
+ * If a territory doesn't have a country code value in the `CountryCode` enum, then it might be considered a subdivision
+ * of another country. For example, the territories associated with Spain are represented by the country code `ES`,
+ * and the territories associated with the United States of America are represented by the country code `US`.
+ *
+ */
+export declare enum CountryCode {
+    /** Ascension Island. */
+    Ac = "AC",
+    /** Andorra. */
+    Ad = "AD",
+    /** United Arab Emirates. */
+    Ae = "AE",
+    /** Afghanistan. */
+    Af = "AF",
+    /** Antigua & Barbuda. */
+    Ag = "AG",
+    /** Anguilla. */
+    Ai = "AI",
+    /** Albania. */
+    Al = "AL",
+    /** Armenia. */
+    Am = "AM",
+    /** Netherlands Antilles. */
+    An = "AN",
+    /** Angola. */
+    Ao = "AO",
+    /** Argentina. */
+    Ar = "AR",
+    /** Austria. */
+    At = "AT",
+    /** Australia. */
+    Au = "AU",
+    /** Aruba. */
+    Aw = "AW",
+    /** land Islands. */
+    Ax = "AX",
+    /** Azerbaijan. */
+    Az = "AZ",
+    /** Bosnia & Herzegovina. */
+    Ba = "BA",
+    /** Barbados. */
+    Bb = "BB",
+    /** Bangladesh. */
+    Bd = "BD",
+    /** Belgium. */
+    Be = "BE",
+    /** Burkina Faso. */
+    Bf = "BF",
+    /** Bulgaria. */
+    Bg = "BG",
+    /** Bahrain. */
+    Bh = "BH",
+    /** Burundi. */
+    Bi = "BI",
+    /** Benin. */
+    Bj = "BJ",
+    /** St. Barthlemy. */
+    Bl = "BL",
+    /** Bermuda. */
+    Bm = "BM",
+    /** Brunei. */
+    Bn = "BN",
+    /** Bolivia. */
+    Bo = "BO",
+    /** Caribbean Netherlands. */
+    Bq = "BQ",
+    /** Brazil. */
+    Br = "BR",
+    /** Bahamas. */
+    Bs = "BS",
+    /** Bhutan. */
+    Bt = "BT",
+    /** Bouvet Island. */
+    Bv = "BV",
+    /** Botswana. */
+    Bw = "BW",
+    /** Belarus. */
+    By = "BY",
+    /** Belize. */
+    Bz = "BZ",
+    /** Canada. */
+    Ca = "CA",
+    /** Cocos (Keeling) Islands. */
+    Cc = "CC",
+    /** Congo - Kinshasa. */
+    Cd = "CD",
+    /** Central African Republic. */
+    Cf = "CF",
+    /** Congo - Brazzaville. */
+    Cg = "CG",
+    /** Switzerland. */
+    Ch = "CH",
+    /** Cte dIvoire. */
+    Ci = "CI",
+    /** Cook Islands. */
+    Ck = "CK",
+    /** Chile. */
+    Cl = "CL",
+    /** Cameroon. */
+    Cm = "CM",
+    /** China. */
+    Cn = "CN",
+    /** Colombia. */
+    Co = "CO",
+    /** Costa Rica. */
+    Cr = "CR",
+    /** Cuba. */
+    Cu = "CU",
+    /** Cape Verde. */
+    Cv = "CV",
+    /** Curaao. */
+    Cw = "CW",
+    /** Christmas Island. */
+    Cx = "CX",
+    /** Cyprus. */
+    Cy = "CY",
+    /** Czechia. */
+    Cz = "CZ",
+    /** Germany. */
+    De = "DE",
+    /** Djibouti. */
+    Dj = "DJ",
+    /** Denmark. */
+    Dk = "DK",
+    /** Dominica. */
+    Dm = "DM",
+    /** Dominican Republic. */
+    Do = "DO",
+    /** Algeria. */
+    Dz = "DZ",
+    /** Ecuador. */
+    Ec = "EC",
+    /** Estonia. */
+    Ee = "EE",
+    /** Egypt. */
+    Eg = "EG",
+    /** Western Sahara. */
+    Eh = "EH",
+    /** Eritrea. */
+    Er = "ER",
+    /** Spain. */
+    Es = "ES",
+    /** Ethiopia. */
+    Et = "ET",
+    /** Finland. */
+    Fi = "FI",
+    /** Fiji. */
+    Fj = "FJ",
+    /** Falkland Islands. */
+    Fk = "FK",
+    /** Faroe Islands. */
+    Fo = "FO",
+    /** France. */
+    Fr = "FR",
+    /** Gabon. */
+    Ga = "GA",
+    /** United Kingdom. */
+    Gb = "GB",
+    /** Grenada. */
+    Gd = "GD",
+    /** Georgia. */
+    Ge = "GE",
+    /** French Guiana. */
+    Gf = "GF",
+    /** Guernsey. */
+    Gg = "GG",
+    /** Ghana. */
+    Gh = "GH",
+    /** Gibraltar. */
+    Gi = "GI",
+    /** Greenland. */
+    Gl = "GL",
+    /** Gambia. */
+    Gm = "GM",
+    /** Guinea. */
+    Gn = "GN",
+    /** Guadeloupe. */
+    Gp = "GP",
+    /** Equatorial Guinea. */
+    Gq = "GQ",
+    /** Greece. */
+    Gr = "GR",
+    /** South Georgia & South Sandwich Islands. */
+    Gs = "GS",
+    /** Guatemala. */
+    Gt = "GT",
+    /** Guinea-Bissau. */
+    Gw = "GW",
+    /** Guyana. */
+    Gy = "GY",
+    /** Hong Kong SAR. */
+    Hk = "HK",
+    /** Heard & McDonald Islands. */
+    Hm = "HM",
+    /** Honduras. */
+    Hn = "HN",
+    /** Croatia. */
+    Hr = "HR",
+    /** Haiti. */
+    Ht = "HT",
+    /** Hungary. */
+    Hu = "HU",
+    /** Indonesia. */
+    Id = "ID",
+    /** Ireland. */
+    Ie = "IE",
+    /** Israel. */
+    Il = "IL",
+    /** Isle of Man. */
+    Im = "IM",
+    /** India. */
+    In = "IN",
+    /** British Indian Ocean Territory. */
+    Io = "IO",
+    /** Iraq. */
+    Iq = "IQ",
+    /** Iran. */
+    Ir = "IR",
+    /** Iceland. */
+    Is = "IS",
+    /** Italy. */
+    It = "IT",
+    /** Jersey. */
+    Je = "JE",
+    /** Jamaica. */
+    Jm = "JM",
+    /** Jordan. */
+    Jo = "JO",
+    /** Japan. */
+    Jp = "JP",
+    /** Kenya. */
+    Ke = "KE",
+    /** Kyrgyzstan. */
+    Kg = "KG",
+    /** Cambodia. */
+    Kh = "KH",
+    /** Kiribati. */
+    Ki = "KI",
+    /** Comoros. */
+    Km = "KM",
+    /** St. Kitts & Nevis. */
+    Kn = "KN",
+    /** North Korea. */
+    Kp = "KP",
+    /** South Korea. */
+    Kr = "KR",
+    /** Kuwait. */
+    Kw = "KW",
+    /** Cayman Islands. */
+    Ky = "KY",
+    /** Kazakhstan. */
+    Kz = "KZ",
+    /** Laos. */
+    La = "LA",
+    /** Lebanon. */
+    Lb = "LB",
+    /** St. Lucia. */
+    Lc = "LC",
+    /** Liechtenstein. */
+    Li = "LI",
+    /** Sri Lanka. */
+    Lk = "LK",
+    /** Liberia. */
+    Lr = "LR",
+    /** Lesotho. */
+    Ls = "LS",
+    /** Lithuania. */
+    Lt = "LT",
+    /** Luxembourg. */
+    Lu = "LU",
+    /** Latvia. */
+    Lv = "LV",
+    /** Libya. */
+    Ly = "LY",
+    /** Morocco. */
+    Ma = "MA",
+    /** Monaco. */
+    Mc = "MC",
+    /** Moldova. */
+    Md = "MD",
+    /** Montenegro. */
+    Me = "ME",
+    /** St. Martin. */
+    Mf = "MF",
+    /** Madagascar. */
+    Mg = "MG",
+    /** North Macedonia. */
+    Mk = "MK",
+    /** Mali. */
+    Ml = "ML",
+    /** Myanmar (Burma). */
+    Mm = "MM",
+    /** Mongolia. */
+    Mn = "MN",
+    /** Macao SAR. */
+    Mo = "MO",
+    /** Martinique. */
+    Mq = "MQ",
+    /** Mauritania. */
+    Mr = "MR",
+    /** Montserrat. */
+    Ms = "MS",
+    /** Malta. */
+    Mt = "MT",
+    /** Mauritius. */
+    Mu = "MU",
+    /** Maldives. */
+    Mv = "MV",
+    /** Malawi. */
+    Mw = "MW",
+    /** Mexico. */
+    Mx = "MX",
+    /** Malaysia. */
+    My = "MY",
+    /** Mozambique. */
+    Mz = "MZ",
+    /** Namibia. */
+    Na = "NA",
+    /** New Caledonia. */
+    Nc = "NC",
+    /** Niger. */
+    Ne = "NE",
+    /** Norfolk Island. */
+    Nf = "NF",
+    /** Nigeria. */
+    Ng = "NG",
+    /** Nicaragua. */
+    Ni = "NI",
+    /** Netherlands. */
+    Nl = "NL",
+    /** Norway. */
+    No = "NO",
+    /** Nepal. */
+    Np = "NP",
+    /** Nauru. */
+    Nr = "NR",
+    /** Niue. */
+    Nu = "NU",
+    /** New Zealand. */
+    Nz = "NZ",
+    /** Oman. */
+    Om = "OM",
+    /** Panama. */
+    Pa = "PA",
+    /** Peru. */
+    Pe = "PE",
+    /** French Polynesia. */
+    Pf = "PF",
+    /** Papua New Guinea. */
+    Pg = "PG",
+    /** Philippines. */
+    Ph = "PH",
+    /** Pakistan. */
+    Pk = "PK",
+    /** Poland. */
+    Pl = "PL",
+    /** St. Pierre & Miquelon. */
+    Pm = "PM",
+    /** Pitcairn Islands. */
+    Pn = "PN",
+    /** Palestinian Territories. */
+    Ps = "PS",
+    /** Portugal. */
+    Pt = "PT",
+    /** Paraguay. */
+    Py = "PY",
+    /** Qatar. */
+    Qa = "QA",
+    /** Runion. */
+    Re = "RE",
+    /** Romania. */
+    Ro = "RO",
+    /** Serbia. */
+    Rs = "RS",
+    /** Russia. */
+    Ru = "RU",
+    /** Rwanda. */
+    Rw = "RW",
+    /** Saudi Arabia. */
+    Sa = "SA",
+    /** Solomon Islands. */
+    Sb = "SB",
+    /** Seychelles. */
+    Sc = "SC",
+    /** Sudan. */
+    Sd = "SD",
+    /** Sweden. */
+    Se = "SE",
+    /** Singapore. */
+    Sg = "SG",
+    /** St. Helena. */
+    Sh = "SH",
+    /** Slovenia. */
+    Si = "SI",
+    /** Svalbard & Jan Mayen. */
+    Sj = "SJ",
+    /** Slovakia. */
+    Sk = "SK",
+    /** Sierra Leone. */
+    Sl = "SL",
+    /** San Marino. */
+    Sm = "SM",
+    /** Senegal. */
+    Sn = "SN",
+    /** Somalia. */
+    So = "SO",
+    /** Suriname. */
+    Sr = "SR",
+    /** South Sudan. */
+    Ss = "SS",
+    /** So Tom & Prncipe. */
+    St = "ST",
+    /** El Salvador. */
+    Sv = "SV",
+    /** Sint Maarten. */
+    Sx = "SX",
+    /** Syria. */
+    Sy = "SY",
+    /** Eswatini. */
+    Sz = "SZ",
+    /** Tristan da Cunha. */
+    Ta = "TA",
+    /** Turks & Caicos Islands. */
+    Tc = "TC",
+    /** Chad. */
+    Td = "TD",
+    /** French Southern Territories. */
+    Tf = "TF",
+    /** Togo. */
+    Tg = "TG",
+    /** Thailand. */
+    Th = "TH",
+    /** Tajikistan. */
+    Tj = "TJ",
+    /** Tokelau. */
+    Tk = "TK",
+    /** Timor-Leste. */
+    Tl = "TL",
+    /** Turkmenistan. */
+    Tm = "TM",
+    /** Tunisia. */
+    Tn = "TN",
+    /** Tonga. */
+    To = "TO",
+    /** Turkey. */
+    Tr = "TR",
+    /** Trinidad & Tobago. */
+    Tt = "TT",
+    /** Tuvalu. */
+    Tv = "TV",
+    /** Taiwan. */
+    Tw = "TW",
+    /** Tanzania. */
+    Tz = "TZ",
+    /** Ukraine. */
+    Ua = "UA",
+    /** Uganda. */
+    Ug = "UG",
+    /** U.S. Outlying Islands. */
+    Um = "UM",
+    /** United States. */
+    Us = "US",
+    /** Uruguay. */
+    Uy = "UY",
+    /** Uzbekistan. */
+    Uz = "UZ",
+    /** Vatican City. */
+    Va = "VA",
+    /** St. Vincent & Grenadines. */
+    Vc = "VC",
+    /** Venezuela. */
+    Ve = "VE",
+    /** British Virgin Islands. */
+    Vg = "VG",
+    /** Vietnam. */
+    Vn = "VN",
+    /** Vanuatu. */
+    Vu = "VU",
+    /** Wallis & Futuna. */
+    Wf = "WF",
+    /** Samoa. */
+    Ws = "WS",
+    /** Kosovo. */
+    Xk = "XK",
+    /** Yemen. */
+    Ye = "YE",
+    /** Mayotte. */
+    Yt = "YT",
+    /** South Africa. */
+    Za = "ZA",
+    /** Zambia. */
+    Zm = "ZM",
+    /** Zimbabwe. */
+    Zw = "ZW",
+    /** Unknown Region. */
+    Zz = "ZZ"
+}
+/** Credit card information used for a payment. */
+export declare type CreditCard = {
+    __typename?: 'CreditCard';
+    /** The brand of the credit card. */
+    brand?: Maybe<Scalars['String']>;
+    /** The expiry month of the credit card. */
+    expiryMonth?: Maybe<Scalars['Int']>;
+    /** The expiry year of the credit card. */
+    expiryYear?: Maybe<Scalars['Int']>;
+    /** The credit card's BIN number. */
+    firstDigits?: Maybe<Scalars['String']>;
+    /** The first name of the card holder. */
+    firstName?: Maybe<Scalars['String']>;
+    /** The last 4 digits of the credit card. */
+    lastDigits?: Maybe<Scalars['String']>;
+    /** The last name of the card holder. */
+    lastName?: Maybe<Scalars['String']>;
+    /** The masked credit card number with only the last 4 digits displayed. */
+    maskedNumber?: Maybe<Scalars['String']>;
+};
+/**
+ * Specifies the fields required to complete a checkout with
+ * a Shopify vaulted credit card payment.
+ *
+ */
+export declare type CreditCardPaymentInputV2 = {
+    /** The billing address for the payment. */
+    billingAddress: MailingAddressInput;
+    /** A unique client generated key used to avoid duplicate charges. When a duplicate payment is found, the original is returned instead of creating a new one. For more information, refer to [Idempotent requests](https://shopify.dev/api/usage/idempotent-requests). */
+    idempotencyKey: Scalars['String'];
+    /** The amount and currency of the payment. */
+    paymentAmount: MoneyInput;
+    /** Executes the payment in test mode if possible. Defaults to `false`. */
+    test?: InputMaybe<Scalars['Boolean']>;
+    /** The ID returned by Shopify's Card Vault. */
+    vaultId: Scalars['String'];
+};
+/** The part of the image that should remain after cropping. */
+export declare enum CropRegion {
+    /** Keep the bottom of the image. */
+    Bottom = "BOTTOM",
+    /** Keep the center of the image. */
+    Center = "CENTER",
+    /** Keep the left of the image. */
+    Left = "LEFT",
+    /** Keep the right of the image. */
+    Right = "RIGHT",
+    /** Keep the top of the image. */
+    Top = "TOP"
+}
+/** A currency. */
+export declare type Currency = {
+    __typename?: 'Currency';
+    /** The ISO code of the currency. */
+    isoCode: CurrencyCode;
+    /** The name of the currency. */
+    name: Scalars['String'];
+    /** The symbol of the currency. */
+    symbol: Scalars['String'];
+};
+/**
+ * The three-letter currency codes that represent the world currencies used in stores. These include standard ISO 4217 codes, legacy codes,
+ * and non-standard codes.
+ *
+ */
+export declare enum CurrencyCode {
+    /** United Arab Emirates Dirham (AED). */
+    Aed = "AED",
+    /** Afghan Afghani (AFN). */
+    Afn = "AFN",
+    /** Albanian Lek (ALL). */
+    All = "ALL",
+    /** Armenian Dram (AMD). */
+    Amd = "AMD",
+    /** Netherlands Antillean Guilder. */
+    Ang = "ANG",
+    /** Angolan Kwanza (AOA). */
+    Aoa = "AOA",
+    /** Argentine Pesos (ARS). */
+    Ars = "ARS",
+    /** Australian Dollars (AUD). */
+    Aud = "AUD",
+    /** Aruban Florin (AWG). */
+    Awg = "AWG",
+    /** Azerbaijani Manat (AZN). */
+    Azn = "AZN",
+    /** Bosnia and Herzegovina Convertible Mark (BAM). */
+    Bam = "BAM",
+    /** Barbadian Dollar (BBD). */
+    Bbd = "BBD",
+    /** Bangladesh Taka (BDT). */
+    Bdt = "BDT",
+    /** Bulgarian Lev (BGN). */
+    Bgn = "BGN",
+    /** Bahraini Dinar (BHD). */
+    Bhd = "BHD",
+    /** Burundian Franc (BIF). */
+    Bif = "BIF",
+    /** Bermudian Dollar (BMD). */
+    Bmd = "BMD",
+    /** Brunei Dollar (BND). */
+    Bnd = "BND",
+    /** Bolivian Boliviano (BOB). */
+    Bob = "BOB",
+    /** Brazilian Real (BRL). */
+    Brl = "BRL",
+    /** Bahamian Dollar (BSD). */
+    Bsd = "BSD",
+    /** Bhutanese Ngultrum (BTN). */
+    Btn = "BTN",
+    /** Botswana Pula (BWP). */
+    Bwp = "BWP",
+    /** Belarusian Ruble (BYN). */
+    Byn = "BYN",
+    /** Belarusian Ruble (BYR). */
+    Byr = "BYR",
+    /** Belize Dollar (BZD). */
+    Bzd = "BZD",
+    /** Canadian Dollars (CAD). */
+    Cad = "CAD",
+    /** Congolese franc (CDF). */
+    Cdf = "CDF",
+    /** Swiss Francs (CHF). */
+    Chf = "CHF",
+    /** Chilean Peso (CLP). */
+    Clp = "CLP",
+    /** Chinese Yuan Renminbi (CNY). */
+    Cny = "CNY",
+    /** Colombian Peso (COP). */
+    Cop = "COP",
+    /** Costa Rican Colones (CRC). */
+    Crc = "CRC",
+    /** Cape Verdean escudo (CVE). */
+    Cve = "CVE",
+    /** Czech Koruny (CZK). */
+    Czk = "CZK",
+    /** Djiboutian Franc (DJF). */
+    Djf = "DJF",
+    /** Danish Kroner (DKK). */
+    Dkk = "DKK",
+    /** Dominican Peso (DOP). */
+    Dop = "DOP",
+    /** Algerian Dinar (DZD). */
+    Dzd = "DZD",
+    /** Egyptian Pound (EGP). */
+    Egp = "EGP",
+    /** Eritrean Nakfa (ERN). */
+    Ern = "ERN",
+    /** Ethiopian Birr (ETB). */
+    Etb = "ETB",
+    /** Euro (EUR). */
+    Eur = "EUR",
+    /** Fijian Dollars (FJD). */
+    Fjd = "FJD",
+    /** Falkland Islands Pounds (FKP). */
+    Fkp = "FKP",
+    /** United Kingdom Pounds (GBP). */
+    Gbp = "GBP",
+    /** Georgian Lari (GEL). */
+    Gel = "GEL",
+    /** Ghanaian Cedi (GHS). */
+    Ghs = "GHS",
+    /** Gibraltar Pounds (GIP). */
+    Gip = "GIP",
+    /** Gambian Dalasi (GMD). */
+    Gmd = "GMD",
+    /** Guinean Franc (GNF). */
+    Gnf = "GNF",
+    /** Guatemalan Quetzal (GTQ). */
+    Gtq = "GTQ",
+    /** Guyanese Dollar (GYD). */
+    Gyd = "GYD",
+    /** Hong Kong Dollars (HKD). */
+    Hkd = "HKD",
+    /** Honduran Lempira (HNL). */
+    Hnl = "HNL",
+    /** Croatian Kuna (HRK). */
+    Hrk = "HRK",
+    /** Haitian Gourde (HTG). */
+    Htg = "HTG",
+    /** Hungarian Forint (HUF). */
+    Huf = "HUF",
+    /** Indonesian Rupiah (IDR). */
+    Idr = "IDR",
+    /** Israeli New Shekel (NIS). */
+    Ils = "ILS",
+    /** Indian Rupees (INR). */
+    Inr = "INR",
+    /** Iraqi Dinar (IQD). */
+    Iqd = "IQD",
+    /** Iranian Rial (IRR). */
+    Irr = "IRR",
+    /** Icelandic Kronur (ISK). */
+    Isk = "ISK",
+    /** Jersey Pound. */
+    Jep = "JEP",
+    /** Jamaican Dollars (JMD). */
+    Jmd = "JMD",
+    /** Jordanian Dinar (JOD). */
+    Jod = "JOD",
+    /** Japanese Yen (JPY). */
+    Jpy = "JPY",
+    /** Kenyan Shilling (KES). */
+    Kes = "KES",
+    /** Kyrgyzstani Som (KGS). */
+    Kgs = "KGS",
+    /** Cambodian Riel. */
+    Khr = "KHR",
+    /** Kiribati Dollar (KID). */
+    Kid = "KID",
+    /** Comorian Franc (KMF). */
+    Kmf = "KMF",
+    /** South Korean Won (KRW). */
+    Krw = "KRW",
+    /** Kuwaiti Dinar (KWD). */
+    Kwd = "KWD",
+    /** Cayman Dollars (KYD). */
+    Kyd = "KYD",
+    /** Kazakhstani Tenge (KZT). */
+    Kzt = "KZT",
+    /** Laotian Kip (LAK). */
+    Lak = "LAK",
+    /** Lebanese Pounds (LBP). */
+    Lbp = "LBP",
+    /** Sri Lankan Rupees (LKR). */
+    Lkr = "LKR",
+    /** Liberian Dollar (LRD). */
+    Lrd = "LRD",
+    /** Lesotho Loti (LSL). */
+    Lsl = "LSL",
+    /** Lithuanian Litai (LTL). */
+    Ltl = "LTL",
+    /** Latvian Lati (LVL). */
+    Lvl = "LVL",
+    /** Libyan Dinar (LYD). */
+    Lyd = "LYD",
+    /** Moroccan Dirham. */
+    Mad = "MAD",
+    /** Moldovan Leu (MDL). */
+    Mdl = "MDL",
+    /** Malagasy Ariary (MGA). */
+    Mga = "MGA",
+    /** Macedonia Denar (MKD). */
+    Mkd = "MKD",
+    /** Burmese Kyat (MMK). */
+    Mmk = "MMK",
+    /** Mongolian Tugrik. */
+    Mnt = "MNT",
+    /** Macanese Pataca (MOP). */
+    Mop = "MOP",
+    /** Mauritanian Ouguiya (MRU). */
+    Mru = "MRU",
+    /** Mauritian Rupee (MUR). */
+    Mur = "MUR",
+    /** Maldivian Rufiyaa (MVR). */
+    Mvr = "MVR",
+    /** Malawian Kwacha (MWK). */
+    Mwk = "MWK",
+    /** Mexican Pesos (MXN). */
+    Mxn = "MXN",
+    /** Malaysian Ringgits (MYR). */
+    Myr = "MYR",
+    /** Mozambican Metical. */
+    Mzn = "MZN",
+    /** Namibian Dollar. */
+    Nad = "NAD",
+    /** Nigerian Naira (NGN). */
+    Ngn = "NGN",
+    /** Nicaraguan Crdoba (NIO). */
+    Nio = "NIO",
+    /** Norwegian Kroner (NOK). */
+    Nok = "NOK",
+    /** Nepalese Rupee (NPR). */
+    Npr = "NPR",
+    /** New Zealand Dollars (NZD). */
+    Nzd = "NZD",
+    /** Omani Rial (OMR). */
+    Omr = "OMR",
+    /** Panamian Balboa (PAB). */
+    Pab = "PAB",
+    /** Peruvian Nuevo Sol (PEN). */
+    Pen = "PEN",
+    /** Papua New Guinean Kina (PGK). */
+    Pgk = "PGK",
+    /** Philippine Peso (PHP). */
+    Php = "PHP",
+    /** Pakistani Rupee (PKR). */
+    Pkr = "PKR",
+    /** Polish Zlotych (PLN). */
+    Pln = "PLN",
+    /** Paraguayan Guarani (PYG). */
+    Pyg = "PYG",
+    /** Qatari Rial (QAR). */
+    Qar = "QAR",
+    /** Romanian Lei (RON). */
+    Ron = "RON",
+    /** Serbian dinar (RSD). */
+    Rsd = "RSD",
+    /** Russian Rubles (RUB). */
+    Rub = "RUB",
+    /** Rwandan Franc (RWF). */
+    Rwf = "RWF",
+    /** Saudi Riyal (SAR). */
+    Sar = "SAR",
+    /** Solomon Islands Dollar (SBD). */
+    Sbd = "SBD",
+    /** Seychellois Rupee (SCR). */
+    Scr = "SCR",
+    /** Sudanese Pound (SDG). */
+    Sdg = "SDG",
+    /** Swedish Kronor (SEK). */
+    Sek = "SEK",
+    /** Singapore Dollars (SGD). */
+    Sgd = "SGD",
+    /** Saint Helena Pounds (SHP). */
+    Shp = "SHP",
+    /** Sierra Leonean Leone (SLL). */
+    Sll = "SLL",
+    /** Somali Shilling (SOS). */
+    Sos = "SOS",
+    /** Surinamese Dollar (SRD). */
+    Srd = "SRD",
+    /** South Sudanese Pound (SSP). */
+    Ssp = "SSP",
+    /** Sao Tome And Principe Dobra (STD). */
+    Std = "STD",
+    /** Sao Tome And Principe Dobra (STN). */
+    Stn = "STN",
+    /** Syrian Pound (SYP). */
+    Syp = "SYP",
+    /** Swazi Lilangeni (SZL). */
+    Szl = "SZL",
+    /** Thai baht (THB). */
+    Thb = "THB",
+    /** Tajikistani Somoni (TJS). */
+    Tjs = "TJS",
+    /** Turkmenistani Manat (TMT). */
+    Tmt = "TMT",
+    /** Tunisian Dinar (TND). */
+    Tnd = "TND",
+    /** Tongan Pa'anga (TOP). */
+    Top = "TOP",
+    /** Turkish Lira (TRY). */
+    Try = "TRY",
+    /** Trinidad and Tobago Dollars (TTD). */
+    Ttd = "TTD",
+    /** Taiwan Dollars (TWD). */
+    Twd = "TWD",
+    /** Tanzanian Shilling (TZS). */
+    Tzs = "TZS",
+    /** Ukrainian Hryvnia (UAH). */
+    Uah = "UAH",
+    /** Ugandan Shilling (UGX). */
+    Ugx = "UGX",
+    /** United States Dollars (USD). */
+    Usd = "USD",
+    /** Uruguayan Pesos (UYU). */
+    Uyu = "UYU",
+    /** Uzbekistan som (UZS). */
+    Uzs = "UZS",
+    /** Venezuelan Bolivares (VED). */
+    Ved = "VED",
+    /** Venezuelan Bolivares (VEF). */
+    Vef = "VEF",
+    /** Venezuelan Bolivares (VES). */
+    Ves = "VES",
+    /** Vietnamese ng (VND). */
+    Vnd = "VND",
+    /** Vanuatu Vatu (VUV). */
+    Vuv = "VUV",
+    /** Samoan Tala (WST). */
+    Wst = "WST",
+    /** Central African CFA Franc (XAF). */
+    Xaf = "XAF",
+    /** East Caribbean Dollar (XCD). */
+    Xcd = "XCD",
+    /** West African CFA franc (XOF). */
+    Xof = "XOF",
+    /** CFP Franc (XPF). */
+    Xpf = "XPF",
+    /** Unrecognized currency. */
+    Xxx = "XXX",
+    /** Yemeni Rial (YER). */
+    Yer = "YER",
+    /** South African Rand (ZAR). */
+    Zar = "ZAR",
+    /** Zambian Kwacha (ZMW). */
+    Zmw = "ZMW"
+}
+/** A customer represents a customer account with the shop. Customer accounts store contact information for the customer, saving logged-in customers the trouble of having to provide it at every checkout. */
+export declare type Customer = HasMetafields & {
+    __typename?: 'Customer';
+    /** Indicates whether the customer has consented to be sent marketing material via email. */
+    acceptsMarketing: Scalars['Boolean'];
+    /** A list of addresses for the customer. */
+    addresses: MailingAddressConnection;
+    /** The date and time when the customer was created. */
+    createdAt: Scalars['DateTime'];
+    /** The customers default address. */
+    defaultAddress?: Maybe<MailingAddress>;
+    /** The customers name, email or phone number. */
+    displayName: Scalars['String'];
+    /** The customers email address. */
+    email?: Maybe<Scalars['String']>;
+    /** The customers first name. */
+    firstName?: Maybe<Scalars['String']>;
+    /** A unique identifier for the customer. */
+    id: Scalars['ID'];
+    /** The customer's most recently updated, incomplete checkout. */
+    lastIncompleteCheckout?: Maybe<Checkout>;
+    /** The customers last name. */
+    lastName?: Maybe<Scalars['String']>;
+    /** Returns a metafield found by namespace and key. */
+    metafield?: Maybe<Metafield>;
+    /**
+     * The metafields associated with the resource matching the supplied list of namespaces and keys.
+     *
+     */
+    metafields: Array<Maybe<Metafield>>;
+    /** The number of orders that the customer has made at the store in their lifetime. */
+    numberOfOrders: Scalars['UnsignedInt64'];
+    /** The orders associated with the customer. */
+    orders: OrderConnection;
+    /** The customers phone number. */
+    phone?: Maybe<Scalars['String']>;
+    /**
+     * A comma separated list of tags that have been added to the customer.
+     * Additional access scope required: unauthenticated_read_customer_tags.
+     *
+     */
+    tags: Array<Scalars['String']>;
+    /** The date and time when the customer information was updated. */
+    updatedAt: Scalars['DateTime'];
+};
+/** A customer represents a customer account with the shop. Customer accounts store contact information for the customer, saving logged-in customers the trouble of having to provide it at every checkout. */
+export declare type CustomerAddressesArgs = {
+    after?: InputMaybe<Scalars['String']>;
+    before?: InputMaybe<Scalars['String']>;
+    first?: InputMaybe<Scalars['Int']>;
+    last?: InputMaybe<Scalars['Int']>;
+    reverse?: InputMaybe<Scalars['Boolean']>;
+};
+/** A customer represents a customer account with the shop. Customer accounts store contact information for the customer, saving logged-in customers the trouble of having to provide it at every checkout. */
+export declare type CustomerMetafieldArgs = {
+    key: Scalars['String'];
+    namespace: Scalars['String'];
+};
+/** A customer represents a customer account with the shop. Customer accounts store contact information for the customer, saving logged-in customers the trouble of having to provide it at every checkout. */
+export declare type CustomerMetafieldsArgs = {
+    identifiers: Array<HasMetafieldsIdentifier>;
+};
+/** A customer represents a customer account with the shop. Customer accounts store contact information for the customer, saving logged-in customers the trouble of having to provide it at every checkout. */
+export declare type CustomerOrdersArgs = {
+    after?: InputMaybe<Scalars['String']>;
+    before?: InputMaybe<Scalars['String']>;
+    first?: InputMaybe<Scalars['Int']>;
+    last?: InputMaybe<Scalars['Int']>;
+    query?: InputMaybe<Scalars['String']>;
+    reverse?: InputMaybe<Scalars['Boolean']>;
+    sortKey?: InputMaybe<OrderSortKeys>;
+};
+/** A CustomerAccessToken represents the unique token required to make modifications to the customer object. */
+export declare type CustomerAccessToken = {
+    __typename?: 'CustomerAccessToken';
+    /** The customers access token. */
+    accessToken: Scalars['String'];
+    /** The date and time when the customer access token expires. */
+    expiresAt: Scalars['DateTime'];
+};
+/** Specifies the input fields required to create a customer access token. */
+export declare type CustomerAccessTokenCreateInput = {
+    /** The email associated to the customer. */
+    email: Scalars['String'];
+    /** The login password to be used by the customer. */
+    password: Scalars['String'];
+};
+/** Return type for `customerAccessTokenCreate` mutation. */
+export declare type CustomerAccessTokenCreatePayload = {
+    __typename?: 'CustomerAccessTokenCreatePayload';
+    /** The newly created customer access token object. */
+    customerAccessToken?: Maybe<CustomerAccessToken>;
+    /** The list of errors that occurred from executing the mutation. */
+    customerUserErrors: Array<CustomerUserError>;
+    /**
+     * The list of errors that occurred from executing the mutation.
+     * @deprecated Use `customerUserErrors` instead.
+     */
+    userErrors: Array<UserError>;
+};
+/** Return type for `customerAccessTokenCreateWithMultipass` mutation. */
+export declare type CustomerAccessTokenCreateWithMultipassPayload = {
+    __typename?: 'CustomerAccessTokenCreateWithMultipassPayload';
+    /** An access token object associated with the customer. */
+    customerAccessToken?: Maybe<CustomerAccessToken>;
+    /** The list of errors that occurred from executing the mutation. */
+    customerUserErrors: Array<CustomerUserError>;
+};
+/** Return type for `customerAccessTokenDelete` mutation. */
+export declare type CustomerAccessTokenDeletePayload = {
+    __typename?: 'CustomerAccessTokenDeletePayload';
+    /** The destroyed access token. */
+    deletedAccessToken?: Maybe<Scalars['String']>;
+    /** ID of the destroyed customer access token. */
+    deletedCustomerAccessTokenId?: Maybe<Scalars['String']>;
+    /** The list of errors that occurred from executing the mutation. */
+    userErrors: Array<UserError>;
+};
+/** Return type for `customerAccessTokenRenew` mutation. */
+export declare type CustomerAccessTokenRenewPayload = {
+    __typename?: 'CustomerAccessTokenRenewPayload';
+    /** The renewed customer access token object. */
+    customerAccessToken?: Maybe<CustomerAccessToken>;
+    /** The list of errors that occurred from executing the mutation. */
+    userErrors: Array<UserError>;
+};
+/** Return type for `customerActivateByUrl` mutation. */
+export declare type CustomerActivateByUrlPayload = {
+    __typename?: 'CustomerActivateByUrlPayload';
+    /** The customer that was activated. */
+    customer?: Maybe<Customer>;
+    /** A new customer access token for the customer. */
+    customerAccessToken?: Maybe<CustomerAccessToken>;
+    /** The list of errors that occurred from executing the mutation. */
+    customerUserErrors: Array<CustomerUserError>;
+};
+/** Specifies the input fields required to activate a customer. */
+export declare type CustomerActivateInput = {
+    /** The activation token required to activate the customer. */
+    activationToken: Scalars['String'];
+    /** New password that will be set during activation. */
+    password: Scalars['String'];
+};
+/** Return type for `customerActivate` mutation. */
+export declare type CustomerActivatePayload = {
+    __typename?: 'CustomerActivatePayload';
+    /** The customer object. */
+    customer?: Maybe<Customer>;
+    /** A newly created customer access token object for the customer. */
+    customerAccessToken?: Maybe<CustomerAccessToken>;
+    /** The list of errors that occurred from executing the mutation. */
+    customerUserErrors: Array<CustomerUserError>;
+    /**
+     * The list of errors that occurred from executing the mutation.
+     * @deprecated Use `customerUserErrors` instead.
+     */
+    userErrors: Array<UserError>;
+};
+/** Return type for `customerAddressCreate` mutation. */
+export declare type CustomerAddressCreatePayload = {
+    __typename?: 'CustomerAddressCreatePayload';
+    /** The new customer address object. */
+    customerAddress?: Maybe<MailingAddress>;
+    /** The list of errors that occurred from executing the mutation. */
+    customerUserErrors: Array<CustomerUserError>;
+    /**
+     * The list of errors that occurred from executing the mutation.
+     * @deprecated Use `customerUserErrors` instead.
+     */
+    userErrors: Array<UserError>;
+};
+/** Return type for `customerAddressDelete` mutation. */
+export declare type CustomerAddressDeletePayload = {
+    __typename?: 'CustomerAddressDeletePayload';
+    /** The list of errors that occurred from executing the mutation. */
+    customerUserErrors: Array<CustomerUserError>;
+    /** ID of the deleted customer address. */
+    deletedCustomerAddressId?: Maybe<Scalars['String']>;
+    /**
+     * The list of errors that occurred from executing the mutation.
+     * @deprecated Use `customerUserErrors` instead.
+     */
+    userErrors: Array<UserError>;
+};
+/** Return type for `customerAddressUpdate` mutation. */
+export declare type CustomerAddressUpdatePayload = {
+    __typename?: 'CustomerAddressUpdatePayload';
+    /** The customers updated mailing address. */
+    customerAddress?: Maybe<MailingAddress>;
+    /** The list of errors that occurred from executing the mutation. */
+    customerUserErrors: Array<CustomerUserError>;
+    /**
+     * The list of errors that occurred from executing the mutation.
+     * @deprecated Use `customerUserErrors` instead.
+     */
+    userErrors: Array<UserError>;
+};
+/** The fields required to create a new customer. */
+export declare type CustomerCreateInput = {
+    /** Indicates whether the customer has consented to be sent marketing material via email. */
+    acceptsMarketing?: InputMaybe<Scalars['Boolean']>;
+    /** The customers email. */
+    email: Scalars['String'];
+    /** The customers first name. */
+    firstName?: InputMaybe<Scalars['String']>;
+    /** The customers last name. */
+    lastName?: InputMaybe<Scalars['String']>;
+    /** The login password used by the customer. */
+    password: Scalars['String'];
+    /**
+     * A unique phone number for the customer.
+     *
+     * Formatted using E.164 standard. For example, _+16135551111_.
+     *
+     */
+    phone?: InputMaybe<Scalars['String']>;
+};
+/** Return type for `customerCreate` mutation. */
+export declare type CustomerCreatePayload = {
+    __typename?: 'CustomerCreatePayload';
+    /** The created customer object. */
+    customer?: Maybe<Customer>;
+    /** The list of errors that occurred from executing the mutation. */
+    customerUserErrors: Array<CustomerUserError>;
+    /**
+     * The list of errors that occurred from executing the mutation.
+     * @deprecated Use `customerUserErrors` instead.
+     */
+    userErrors: Array<UserError>;
+};
+/** Return type for `customerDefaultAddressUpdate` mutation. */
+export declare type CustomerDefaultAddressUpdatePayload = {
+    __typename?: 'CustomerDefaultAddressUpdatePayload';
+    /** The updated customer object. */
+    customer?: Maybe<Customer>;
+    /** The list of errors that occurred from executing the mutation. */
+    customerUserErrors: Array<CustomerUserError>;
+    /**
+     * The list of errors that occurred from executing the mutation.
+     * @deprecated Use `customerUserErrors` instead.
+     */
+    userErrors: Array<UserError>;
+};
+/** Possible error codes that can be returned by `CustomerUserError`. */
+export declare enum CustomerErrorCode {
+    /** Customer already enabled. */
+    AlreadyEnabled = "ALREADY_ENABLED",
+    /** Input email contains an invalid domain name. */
+    BadDomain = "BAD_DOMAIN",
+    /** The input value is blank. */
+    Blank = "BLANK",
+    /** Input contains HTML tags. */
+    ContainsHtmlTags = "CONTAINS_HTML_TAGS",
+    /** Input contains URL. */
+    ContainsUrl = "CONTAINS_URL",
+    /** Customer is disabled. */
+    CustomerDisabled = "CUSTOMER_DISABLED",
+    /** The input value is invalid. */
+    Invalid = "INVALID",
+    /** Multipass token is not valid. */
+    InvalidMultipassRequest = "INVALID_MULTIPASS_REQUEST",
+    /** Address does not exist. */
+    NotFound = "NOT_FOUND",
+    /** Input password starts or ends with whitespace. */
+    PasswordStartsOrEndsWithWhitespace = "PASSWORD_STARTS_OR_ENDS_WITH_WHITESPACE",
+    /** The input value is already taken. */
+    Taken = "TAKEN",
+    /** Invalid activation token. */
+    TokenInvalid = "TOKEN_INVALID",
+    /** The input value is too long. */
+    TooLong = "TOO_LONG",
+    /** The input value is too short. */
+    TooShort = "TOO_SHORT",
+    /** Unidentified customer. */
+    UnidentifiedCustomer = "UNIDENTIFIED_CUSTOMER"
+}
+/** Return type for `customerRecover` mutation. */
+export declare type CustomerRecoverPayload = {
+    __typename?: 'CustomerRecoverPayload';
+    /** The list of errors that occurred from executing the mutation. */
+    customerUserErrors: Array<CustomerUserError>;
+    /**
+     * The list of errors that occurred from executing the mutation.
+     * @deprecated Use `customerUserErrors` instead.
+     */
+    userErrors: Array<UserError>;
+};
+/** Return type for `customerResetByUrl` mutation. */
+export declare type CustomerResetByUrlPayload = {
+    __typename?: 'CustomerResetByUrlPayload';
+    /** The customer object which was reset. */
+    customer?: Maybe<Customer>;
+    /** A newly created customer access token object for the customer. */
+    customerAccessToken?: Maybe<CustomerAccessToken>;
+    /** The list of errors that occurred from executing the mutation. */
+    customerUserErrors: Array<CustomerUserError>;
+    /**
+     * The list of errors that occurred from executing the mutation.
+     * @deprecated Use `customerUserErrors` instead.
+     */
+    userErrors: Array<UserError>;
+};
+/** Specifies the fields required to reset a customers password. */
+export declare type CustomerResetInput = {
+    /** New password that will be set as part of the reset password process. */
+    password: Scalars['String'];
+    /** The reset token required to reset the customers password. */
+    resetToken: Scalars['String'];
+};
+/** Return type for `customerReset` mutation. */
+export declare type CustomerResetPayload = {
+    __typename?: 'CustomerResetPayload';
+    /** The customer object which was reset. */
+    customer?: Maybe<Customer>;
+    /** A newly created customer access token object for the customer. */
+    customerAccessToken?: Maybe<CustomerAccessToken>;
+    /** The list of errors that occurred from executing the mutation. */
+    customerUserErrors: Array<CustomerUserError>;
+    /**
+     * The list of errors that occurred from executing the mutation.
+     * @deprecated Use `customerUserErrors` instead.
+     */
+    userErrors: Array<UserError>;
+};
+/** Specifies the fields required to update the Customer information. */
+export declare type CustomerUpdateInput = {
+    /** Indicates whether the customer has consented to be sent marketing material via email. */
+    acceptsMarketing?: InputMaybe<Scalars['Boolean']>;
+    /** The customers email. */
+    email?: InputMaybe<Scalars['String']>;
+    /** The customers first name. */
+    firstName?: InputMaybe<Scalars['String']>;
+    /** The customers last name. */
+    lastName?: InputMaybe<Scalars['String']>;
+    /** The login password used by the customer. */
+    password?: InputMaybe<Scalars['String']>;
+    /**
+     * A unique phone number for the customer.
+     *
+     * Formatted using E.164 standard. For example, _+16135551111_. To remove the phone number, specify `null`.
+     *
+     */
+    phone?: InputMaybe<Scalars['String']>;
+};
+/** Return type for `customerUpdate` mutation. */
+export declare type CustomerUpdatePayload = {
+    __typename?: 'CustomerUpdatePayload';
+    /** The updated customer object. */
+    customer?: Maybe<Customer>;
+    /**
+     * The newly created customer access token. If the customer's password is updated, all previous access tokens
+     * (including the one used to perform this mutation) become invalid, and a new token is generated.
+     *
+     */
+    customerAccessToken?: Maybe<CustomerAccessToken>;
+    /** The list of errors that occurred from executing the mutation. */
+    customerUserErrors: Array<CustomerUserError>;
+    /**
+     * The list of errors that occurred from executing the mutation.
+     * @deprecated Use `customerUserErrors` instead.
+     */
+    userErrors: Array<UserError>;
+};
+/** Represents an error that happens during execution of a customer mutation. */
+export declare type CustomerUserError = DisplayableError & {
+    __typename?: 'CustomerUserError';
+    /** The error code. */
+    code?: Maybe<CustomerErrorCode>;
+    /** The path to the input field that caused the error. */
+    field?: Maybe<Array<Scalars['String']>>;
+    /** The error message. */
+    message: Scalars['String'];
+};
+/** A delivery address of the buyer that is interacting with the cart. */
+export declare type DeliveryAddress = MailingAddress;
+/**
+ * The input fields for delivery address preferences.
+ *
+ */
+export declare type DeliveryAddressInput = {
+    /** A delivery address preference of a buyer that is interacting with the cart. */
+    deliveryAddress?: InputMaybe<MailingAddressInput>;
+};
+/** List of different delivery method types. */
+export declare enum DeliveryMethodType {
+    /** Local Delivery. */
+    Local = "LOCAL",
+    /** None. */
+    None = "NONE",
+    /** Shipping to a Pickup Point. */
+    PickupPoint = "PICKUP_POINT",
+    /** Local Pickup. */
+    PickUp = "PICK_UP",
+    /** Retail. */
+    Retail = "RETAIL",
+    /** Shipping. */
+    Shipping = "SHIPPING"
+}
+/** Digital wallet, such as Apple Pay, which can be used for accelerated checkouts. */
+export declare enum DigitalWallet {
+    /** Android Pay. */
+    AndroidPay = "ANDROID_PAY",
+    /** Apple Pay. */
+    ApplePay = "APPLE_PAY",
+    /** Google Pay. */
+    GooglePay = "GOOGLE_PAY",
+    /** Shopify Pay. */
+    ShopifyPay = "SHOPIFY_PAY"
+}
+/**
+ * An amount discounting the line that has been allocated by a discount.
+ *
+ */
+export declare type DiscountAllocation = {
+    __typename?: 'DiscountAllocation';
+    /** Amount of discount allocated. */
+    allocatedAmount: MoneyV2;
+    /** The discount this allocated amount originated from. */
+    discountApplication: AutomaticDiscountApplication | DiscountCodeApplication | ManualDiscountApplication | ScriptDiscountApplication;
+};
+/**
+ * Discount applications capture the intentions of a discount source at
+ * the time of application.
+ *
+ */
+export declare type DiscountApplication = {
+    /** The method by which the discount's value is allocated to its entitled items. */
+    allocationMethod: DiscountApplicationAllocationMethod;
+    /** Which lines of targetType that the discount is allocated over. */
+    targetSelection: DiscountApplicationTargetSelection;
+    /** The type of line that the discount is applicable towards. */
+    targetType: DiscountApplicationTargetType;
+    /** The value of the discount application. */
+    value: PricingValue;
+};
+/** The method by which the discount's value is allocated onto its entitled lines. */
+export declare enum DiscountApplicationAllocationMethod {
+    /** The value is spread across all entitled lines. */
+    Across = "ACROSS",
+    /** The value is applied onto every entitled line. */
+    Each = "EACH",
+    /** The value is specifically applied onto a particular line. */
+    One = "ONE"
+}
+/**
+ * An auto-generated type for paginating through multiple DiscountApplications.
+ *
+ */
+export declare type DiscountApplicationConnection = {
+    __typename?: 'DiscountApplicationConnection';
+    /** A list of edges. */
+    edges: Array<DiscountApplicationEdge>;
+    /** A list of the nodes contained in DiscountApplicationEdge. */
+    nodes: Array<AutomaticDiscountApplication | DiscountCodeApplication | ManualDiscountApplication | ScriptDiscountApplication>;
+    /** Information to aid in pagination. */
+    pageInfo: PageInfo;
+};
+/**
+ * An auto-generated type which holds one DiscountApplication and a cursor during pagination.
+ *
+ */
+export declare type DiscountApplicationEdge = {
+    __typename?: 'DiscountApplicationEdge';
+    /** A cursor for use in pagination. */
+    cursor: Scalars['String'];
+    /** The item at the end of DiscountApplicationEdge. */
+    node: AutomaticDiscountApplication | DiscountCodeApplication | ManualDiscountApplication | ScriptDiscountApplication;
+};
+/**
+ * The lines on the order to which the discount is applied, of the type defined by
+ * the discount application's `targetType`. For example, the value `ENTITLED`, combined with a `targetType` of
+ * `LINE_ITEM`, applies the discount on all line items that are entitled to the discount.
+ * The value `ALL`, combined with a `targetType` of `SHIPPING_LINE`, applies the discount on all shipping lines.
+ *
+ */
+export declare enum DiscountApplicationTargetSelection {
+    /** The discount is allocated onto all the lines. */
+    All = "ALL",
+    /** The discount is allocated onto only the lines that it's entitled for. */
+    Entitled = "ENTITLED",
+    /** The discount is allocated onto explicitly chosen lines. */
+    Explicit = "EXPLICIT"
+}
+/**
+ * The type of line (i.e. line item or shipping line) on an order that the discount is applicable towards.
+ *
+ */
+export declare enum DiscountApplicationTargetType {
+    /** The discount applies onto line items. */
+    LineItem = "LINE_ITEM",
+    /** The discount applies onto shipping lines. */
+    ShippingLine = "SHIPPING_LINE"
+}
+/**
+ * Discount code applications capture the intentions of a discount code at
+ * the time that it is applied.
+ *
+ */
+export declare type DiscountCodeApplication = DiscountApplication & {
+    __typename?: 'DiscountCodeApplication';
+    /** The method by which the discount's value is allocated to its entitled items. */
+    allocationMethod: DiscountApplicationAllocationMethod;
+    /** Specifies whether the discount code was applied successfully. */
+    applicable: Scalars['Boolean'];
+    /** The string identifying the discount code that was used at the time of application. */
+    code: Scalars['String'];
+    /** Which lines of targetType that the discount is allocated over. */
+    targetSelection: DiscountApplicationTargetSelection;
+    /** The type of line that the discount is applicable towards. */
+    targetType: DiscountApplicationTargetType;
+    /** The value of the discount application. */
+    value: PricingValue;
+};
+/** Represents an error in the input of a mutation. */
+export declare type DisplayableError = {
+    /** The path to the input field that caused the error. */
+    field?: Maybe<Array<Scalars['String']>>;
+    /** The error message. */
+    message: Scalars['String'];
+};
+/** Represents a web address. */
+export declare type Domain = {
+    __typename?: 'Domain';
+    /** The host name of the domain (eg: `example.com`). */
+    host: Scalars['String'];
+    /** Whether SSL is enabled or not. */
+    sslEnabled: Scalars['Boolean'];
+    /** The URL of the domain (eg: `https://example.com`). */
+    url: Scalars['URL'];
+};
+/** Represents a video hosted outside of Shopify. */
+export declare type ExternalVideo = Media & Node & {
+    __typename?: 'ExternalVideo';
+    /** A word or phrase to share the nature or contents of a media. */
+    alt?: Maybe<Scalars['String']>;
+    /** The embed URL of the video for the respective host. */
+    embedUrl: Scalars['URL'];
+    /**
+     * The URL.
+     * @deprecated Use `originUrl` instead.
+     */
+    embeddedUrl: Scalars['URL'];
+    /** The host of the external video. */
+    host: MediaHost;
+    /** A globally-unique identifier. */
+    id: Scalars['ID'];
+    /** The media content type. */
+    mediaContentType: MediaContentType;
+    /** The origin URL of the video on the respective host. */
+    originUrl: Scalars['URL'];
+    /** The preview image for the media. */
+    previewImage?: Maybe<Image>;
+};
+/** A filter that is supported on the parent field. */
+export declare type Filter = {
+    __typename?: 'Filter';
+    /** A unique identifier. */
+    id: Scalars['String'];
+    /** A human-friendly string for this filter. */
+    label: Scalars['String'];
+    /** An enumeration that denotes the type of data this filter represents. */
+    type: FilterType;
+    /** The list of values for this filter. */
+    values: Array<FilterValue>;
+};
+/**
+ * The type of data that the filter group represents.
+ *
+ * For more information, refer to [Filter products in a collection with the Storefront API]
+ * (https://shopify.dev/custom-storefronts/products-collections/filter-products).
+ *
+ */
+export declare enum FilterType {
+    /** A boolean value. */
+    Boolean = "BOOLEAN",
+    /** A list of selectable values. */
+    List = "LIST",
+    /** A range of prices. */
+    PriceRange = "PRICE_RANGE"
+}
+/** A selectable value within a filter. */
+export declare type FilterValue = {
+    __typename?: 'FilterValue';
+    /** The number of results that match this filter value. */
+    count: Scalars['Int'];
+    /** A unique identifier. */
+    id: Scalars['String'];
+    /**
+     * An input object that can be used to filter by this value on the parent field.
+     *
+     * The value is provided as a helper for building dynamic filtering UI. For example, if you have a list of selected `FilterValue` objects, you can combine their respective `input` values to use in a subsequent query.
+     *
+     */
+    input: Scalars['JSON'];
+    /** A human-friendly string for this filter value. */
+    label: Scalars['String'];
+};
+/** Represents a single fulfillment in an order. */
+export declare type Fulfillment = {
+    __typename?: 'Fulfillment';
+    /** List of the fulfillment's line items. */
+    fulfillmentLineItems: FulfillmentLineItemConnection;
+    /** The name of the tracking company. */
+    trackingCompany?: Maybe<Scalars['String']>;
+    /**
+     * Tracking information associated with the fulfillment,
+     * such as the tracking number and tracking URL.
+     *
+     */
+    trackingInfo: Array<FulfillmentTrackingInfo>;
+};
+/** Represents a single fulfillment in an order. */
+export declare type FulfillmentFulfillmentLineItemsArgs = {
+    after?: InputMaybe<Scalars['String']>;
+    before?: InputMaybe<Scalars['String']>;
+    first?: InputMaybe<Scalars['Int']>;
+    last?: InputMaybe<Scalars['Int']>;
+    reverse?: InputMaybe<Scalars['Boolean']>;
+};
+/** Represents a single fulfillment in an order. */
+export declare type FulfillmentTrackingInfoArgs = {
+    first?: InputMaybe<Scalars['Int']>;
+};
+/** Represents a single line item in a fulfillment. There is at most one fulfillment line item for each order line item. */
+export declare type FulfillmentLineItem = {
+    __typename?: 'FulfillmentLineItem';
+    /** The associated order's line item. */
+    lineItem: OrderLineItem;
+    /** The amount fulfilled in this fulfillment. */
+    quantity: Scalars['Int'];
+};
+/**
+ * An auto-generated type for paginating through multiple FulfillmentLineItems.
+ *
+ */
+export declare type FulfillmentLineItemConnection = {
+    __typename?: 'FulfillmentLineItemConnection';
+    /** A list of edges. */
+    edges: Array<FulfillmentLineItemEdge>;
+    /** A list of the nodes contained in FulfillmentLineItemEdge. */
+    nodes: Array<FulfillmentLineItem>;
+    /** Information to aid in pagination. */
+    pageInfo: PageInfo;
+};
+/**
+ * An auto-generated type which holds one FulfillmentLineItem and a cursor during pagination.
+ *
+ */
+export declare type FulfillmentLineItemEdge = {
+    __typename?: 'FulfillmentLineItemEdge';
+    /** A cursor for use in pagination. */
+    cursor: Scalars['String'];
+    /** The item at the end of FulfillmentLineItemEdge. */
+    node: FulfillmentLineItem;
+};
+/** Tracking information associated with the fulfillment. */
+export declare type FulfillmentTrackingInfo = {
+    __typename?: 'FulfillmentTrackingInfo';
+    /** The tracking number of the fulfillment. */
+    number?: Maybe<Scalars['String']>;
+    /** The URL to track the fulfillment. */
+    url?: Maybe<Scalars['URL']>;
+};
+/** The generic file resource lets you manage files in a merchants store. Generic files include any file that doesnt fit into a designated type such as image or video. Example: PDF, JSON. */
+export declare type GenericFile = Node & {
+    __typename?: 'GenericFile';
+    /** A word or phrase to indicate the contents of a file. */
+    alt?: Maybe<Scalars['String']>;
+    /** A globally-unique identifier. */
+    id: Scalars['ID'];
+    /** The MIME type of the file. */
+    mimeType?: Maybe<Scalars['String']>;
+    /** The size of the original file in bytes. */
+    originalFileSize?: Maybe<Scalars['Int']>;
+    /** The preview image for the file. */
+    previewImage?: Maybe<Image>;
+    /** The URL of the file. */
+    url?: Maybe<Scalars['URL']>;
+};
+/** Used to specify a geographical location. */
+export declare type GeoCoordinateInput = {
+    /** The coordinate's latitude value. */
+    latitude: Scalars['Float'];
+    /** The coordinate's longitude value. */
+    longitude: Scalars['Float'];
+};
+/** Represents information about the metafields associated to the specified resource. */
+export declare type HasMetafields = {
+    /** Returns a metafield found by namespace and key. */
+    metafield?: Maybe<Metafield>;
+    /**
+     * The metafields associated with the resource matching the supplied list of namespaces and keys.
+     *
+     */
+    metafields: Array<Maybe<Metafield>>;
+};
+/** Represents information about the metafields associated to the specified resource. */
+export declare type HasMetafieldsMetafieldArgs = {
+    key: Scalars['String'];
+    namespace: Scalars['String'];
+};
+/** Represents information about the metafields associated to the specified resource. */
+export declare type HasMetafieldsMetafieldsArgs = {
+    identifiers: Array<HasMetafieldsIdentifier>;
+};
+/** Identifies a metafield on an owner resource by namespace and key. */
+export declare type HasMetafieldsIdentifier = {
+    /** The identifier for the metafield. */
+    key: Scalars['String'];
+    /** A container for a set of metafields. */
+    namespace: Scalars['String'];
+};
+/** Represents an image resource. */
+export declare type Image = {
+    __typename?: 'Image';
+    /** A word or phrase to share the nature or contents of an image. */
+    altText?: Maybe<Scalars['String']>;
+    /** The original height of the image in pixels. Returns `null` if the image is not hosted by Shopify. */
+    height?: Maybe<Scalars['Int']>;
+    /** A unique identifier for the image. */
+    id?: Maybe<Scalars['ID']>;
+    /**
+     * The location of the original image as a URL.
+     *
+     * If there are any existing transformations in the original source URL, they will remain and not be stripped.
+     *
+     * @deprecated Use `url` instead.
+     */
+    originalSrc: Scalars['URL'];
+    /**
+     * The location of the image as a URL.
+     * @deprecated Use `url` instead.
+     */
+    src: Scalars['URL'];
+    /**
+     * The location of the transformed image as a URL.
+     *
+     * All transformation arguments are considered "best-effort". If they can be applied to an image, they will be.
+     * Otherwise any transformations which an image type does not support will be ignored.
+     *
+     * @deprecated Use `url(transform:)` instead
+     */
+    transformedSrc: Scalars['URL'];
+    /**
+     * The location of the image as a URL.
+     *
+     * If no transform options are specified, then the original image will be preserved including any pre-applied transforms.
+     *
+     * All transformation options are considered "best-effort". Any transformation that the original image type doesn't support will be ignored.
+     *
+     * If you need multiple variations of the same image, then you can use [GraphQL aliases](https://graphql.org/learn/queries/#aliases).
+     *
+     */
+    url: Scalars['URL'];
+    /** The original width of the image in pixels. Returns `null` if the image is not hosted by Shopify. */
+    width?: Maybe<Scalars['Int']>;
+};
+/** Represents an image resource. */
+export declare type ImageTransformedSrcArgs = {
+    crop?: InputMaybe<CropRegion>;
+    maxHeight?: InputMaybe<Scalars['Int']>;
+    maxWidth?: InputMaybe<Scalars['Int']>;
+    preferredContentType?: InputMaybe<ImageContentType>;
+    scale?: InputMaybe<Scalars['Int']>;
+};
+/** Represents an image resource. */
+export declare type ImageUrlArgs = {
+    transform?: InputMaybe<ImageTransformInput>;
+};
+/**
+ * An auto-generated type for paginating through multiple Images.
+ *
+ */
+export declare type ImageConnection = {
+    __typename?: 'ImageConnection';
+    /** A list of edges. */
+    edges: Array<ImageEdge>;
+    /** A list of the nodes contained in ImageEdge. */
+    nodes: Array<Image>;
+    /** Information to aid in pagination. */
+    pageInfo: PageInfo;
+};
+/** List of supported image content types. */
+export declare enum ImageContentType {
+    /** A JPG image. */
+    Jpg = "JPG",
+    /** A PNG image. */
+    Png = "PNG",
+    /** A WEBP image. */
+    Webp = "WEBP"
+}
+/**
+ * An auto-generated type which holds one Image and a cursor during pagination.
+ *
+ */
+export declare type ImageEdge = {
+    __typename?: 'ImageEdge';
+    /** A cursor for use in pagination. */
+    cursor: Scalars['String'];
+    /** The item at the end of ImageEdge. */
+    node: Image;
+};
+/**
+ * The available options for transforming an image.
+ *
+ * All transformation options are considered best effort. Any transformation that the original image type doesn't support will be ignored.
+ *
+ */
+export declare type ImageTransformInput = {
+    /**
+     * The region of the image to remain after cropping.
+     * Must be used in conjunction with the `maxWidth` and/or `maxHeight` fields, where the `maxWidth` and `maxHeight` aren't equal.
+     * The `crop` argument should coincide with the smaller value. A smaller `maxWidth` indicates a `LEFT` or `RIGHT` crop, while
+     * a smaller `maxHeight` indicates a `TOP` or `BOTTOM` crop. For example, `{ maxWidth: 5, maxHeight: 10, crop: LEFT }` will result
+     * in an image with a width of 5 and height of 10, where the right side of the image is removed.
+     *
+     */
+    crop?: InputMaybe<CropRegion>;
+    /**
+     * Image height in pixels between 1 and 5760.
+     *
+     */
+    maxHeight?: InputMaybe<Scalars['Int']>;
+    /**
+     * Image width in pixels between 1 and 5760.
+     *
+     */
+    maxWidth?: InputMaybe<Scalars['Int']>;
+    /**
+     * Convert the source image into the preferred content type.
+     * Supported conversions: `.svg` to `.png`, any file type to `.jpg`, and any file type to `.webp`.
+     *
+     */
+    preferredContentType?: InputMaybe<ImageContentType>;
+    /**
+     * Image size multiplier for high-resolution retina displays. Must be within 1..3.
+     *
+     */
+    scale?: InputMaybe<Scalars['Int']>;
+};
+/** A language. */
+export declare type Language = {
+    __typename?: 'Language';
+    /** The name of the language in the language itself. If the language uses capitalization, it is capitalized for a mid-sentence position. */
+    endonymName: Scalars['String'];
+    /** The ISO code. */
+    isoCode: LanguageCode;
+    /** The name of the language in the current language. */
+    name: Scalars['String'];
+};
+/** ISO 639-1 language codes supported by Shopify. */
+export declare enum LanguageCode {
+    /** Afrikaans. */
+    Af = "AF",
+    /** Akan. */
+    Ak = "AK",
+    /** Amharic. */
+    Am = "AM",
+    /** Arabic. */
+    Ar = "AR",
+    /** Assamese. */
+    As = "AS",
+    /** Azerbaijani. */
+    Az = "AZ",
+    /** Belarusian. */
+    Be = "BE",
+    /** Bulgarian. */
+    Bg = "BG",
+    /** Bambara. */
+    Bm = "BM",
+    /** Bangla. */
+    Bn = "BN",
+    /** Tibetan. */
+    Bo = "BO",
+    /** Breton. */
+    Br = "BR",
+    /** Bosnian. */
+    Bs = "BS",
+    /** Catalan. */
+    Ca = "CA",
+    /** Chechen. */
+    Ce = "CE",
+    /** Czech. */
+    Cs = "CS",
+    /** Church Slavic. */
+    Cu = "CU",
+    /** Welsh. */
+    Cy = "CY",
+    /** Danish. */
+    Da = "DA",
+    /** German. */
+    De = "DE",
+    /** Dzongkha. */
+    Dz = "DZ",
+    /** Ewe. */
+    Ee = "EE",
+    /** Greek. */
+    El = "EL",
+    /** English. */
+    En = "EN",
+    /** Esperanto. */
+    Eo = "EO",
+    /** Spanish. */
+    Es = "ES",
+    /** Estonian. */
+    Et = "ET",
+    /** Basque. */
+    Eu = "EU",
+    /** Persian. */
+    Fa = "FA",
+    /** Fulah. */
+    Ff = "FF",
+    /** Finnish. */
+    Fi = "FI",
+    /** Faroese. */
+    Fo = "FO",
+    /** French. */
+    Fr = "FR",
+    /** Western Frisian. */
+    Fy = "FY",
+    /** Irish. */
+    Ga = "GA",
+    /** Scottish Gaelic. */
+    Gd = "GD",
+    /** Galician. */
+    Gl = "GL",
+    /** Gujarati. */
+    Gu = "GU",
+    /** Manx. */
+    Gv = "GV",
+    /** Hausa. */
+    Ha = "HA",
+    /** Hebrew. */
+    He = "HE",
+    /** Hindi. */
+    Hi = "HI",
+    /** Croatian. */
+    Hr = "HR",
+    /** Hungarian. */
+    Hu = "HU",
+    /** Armenian. */
+    Hy = "HY",
+    /** Interlingua. */
+    Ia = "IA",
+    /** Indonesian. */
+    Id = "ID",
+    /** Igbo. */
+    Ig = "IG",
+    /** Sichuan Yi. */
+    Ii = "II",
+    /** Icelandic. */
+    Is = "IS",
+    /** Italian. */
+    It = "IT",
+    /** Japanese. */
+    Ja = "JA",
+    /** Javanese. */
+    Jv = "JV",
+    /** Georgian. */
+    Ka = "KA",
+    /** Kikuyu. */
+    Ki = "KI",
+    /** Kazakh. */
+    Kk = "KK",
+    /** Kalaallisut. */
+    Kl = "KL",
+    /** Khmer. */
+    Km = "KM",
+    /** Kannada. */
+    Kn = "KN",
+    /** Korean. */
+    Ko = "KO",
+    /** Kashmiri. */
+    Ks = "KS",
+    /** Kurdish. */
+    Ku = "KU",
+    /** Cornish. */
+    Kw = "KW",
+    /** Kyrgyz. */
+    Ky = "KY",
+    /** Luxembourgish. */
+    Lb = "LB",
+    /** Ganda. */
+    Lg = "LG",
+    /** Lingala. */
+    Ln = "LN",
+    /** Lao. */
+    Lo = "LO",
+    /** Lithuanian. */
+    Lt = "LT",
+    /** Luba-Katanga. */
+    Lu = "LU",
+    /** Latvian. */
+    Lv = "LV",
+    /** Malagasy. */
+    Mg = "MG",
+    /** Mori. */
+    Mi = "MI",
+    /** Macedonian. */
+    Mk = "MK",
+    /** Malayalam. */
+    Ml = "ML",
+    /** Mongolian. */
+    Mn = "MN",
+    /** Marathi. */
+    Mr = "MR",
+    /** Malay. */
+    Ms = "MS",
+    /** Maltese. */
+    Mt = "MT",
+    /** Burmese. */
+    My = "MY",
+    /** Norwegian (Bokml). */
+    Nb = "NB",
+    /** North Ndebele. */
+    Nd = "ND",
+    /** Nepali. */
+    Ne = "NE",
+    /** Dutch. */
+    Nl = "NL",
+    /** Norwegian Nynorsk. */
+    Nn = "NN",
+    /** Norwegian. */
+    No = "NO",
+    /** Oromo. */
+    Om = "OM",
+    /** Odia. */
+    Or = "OR",
+    /** Ossetic. */
+    Os = "OS",
+    /** Punjabi. */
+    Pa = "PA",
+    /** Polish. */
+    Pl = "PL",
+    /** Pashto. */
+    Ps = "PS",
+    /** Portuguese. */
+    Pt = "PT",
+    /** Portuguese (Brazil). */
+    PtBr = "PT_BR",
+    /** Portuguese (Portugal). */
+    PtPt = "PT_PT",
+    /** Quechua. */
+    Qu = "QU",
+    /** Romansh. */
+    Rm = "RM",
+    /** Rundi. */
+    Rn = "RN",
+    /** Romanian. */
+    Ro = "RO",
+    /** Russian. */
+    Ru = "RU",
+    /** Kinyarwanda. */
+    Rw = "RW",
+    /** Sindhi. */
+    Sd = "SD",
+    /** Northern Sami. */
+    Se = "SE",
+    /** Sango. */
+    Sg = "SG",
+    /** Sinhala. */
+    Si = "SI",
+    /** Slovak. */
+    Sk = "SK",
+    /** Slovenian. */
+    Sl = "SL",
+    /** Shona. */
+    Sn = "SN",
+    /** Somali. */
+    So = "SO",
+    /** Albanian. */
+    Sq = "SQ",
+    /** Serbian. */
+    Sr = "SR",
+    /** Sundanese. */
+    Su = "SU",
+    /** Swedish. */
+    Sv = "SV",
+    /** Swahili. */
+    Sw = "SW",
+    /** Tamil. */
+    Ta = "TA",
+    /** Telugu. */
+    Te = "TE",
+    /** Tajik. */
+    Tg = "TG",
+    /** Thai. */
+    Th = "TH",
+    /** Tigrinya. */
+    Ti = "TI",
+    /** Turkmen. */
+    Tk = "TK",
+    /** Tongan. */
+    To = "TO",
+    /** Turkish. */
+    Tr = "TR",
+    /** Tatar. */
+    Tt = "TT",
+    /** Uyghur. */
+    Ug = "UG",
+    /** Ukrainian. */
+    Uk = "UK",
+    /** Urdu. */
+    Ur = "UR",
+    /** Uzbek. */
+    Uz = "UZ",
+    /** Vietnamese. */
+    Vi = "VI",
+    /** Volapk. */
+    Vo = "VO",
+    /** Wolof. */
+    Wo = "WO",
+    /** Xhosa. */
+    Xh = "XH",
+    /** Yiddish. */
+    Yi = "YI",
+    /** Yoruba. */
+    Yo = "YO",
+    /** Chinese. */
+    Zh = "ZH",
+    /** Chinese (Simplified). */
+    ZhCn = "ZH_CN",
+    /** Chinese (Traditional). */
+    ZhTw = "ZH_TW",
+    /** Zulu. */
+    Zu = "ZU"
+}
+/** Information about the localized experiences configured for the shop. */
+export declare type Localization = {
+    __typename?: 'Localization';
+    /** The list of countries with enabled localized experiences. */
+    availableCountries: Array<Country>;
+    /** The list of languages available for the active country. */
+    availableLanguages: Array<Language>;
+    /** The country of the active localized experience. Use the `@inContext` directive to change this value. */
+    country: Country;
+    /** The language of the active localized experience. Use the `@inContext` directive to change this value. */
+    language: Language;
+};
+/** Represents a location where product inventory is held. */
+export declare type Location = Node & {
+    __typename?: 'Location';
+    /** The address of the location. */
+    address: LocationAddress;
+    /** A globally-unique identifier. */
+    id: Scalars['ID'];
+    /** The name of the location. */
+    name: Scalars['String'];
+};
+/**
+ * Represents the address of a location.
+ *
+ */
+export declare type LocationAddress = {
+    __typename?: 'LocationAddress';
+    /** The first line of the address for the location. */
+    address1?: Maybe<Scalars['String']>;
+    /** The second line of the address for the location. */
+    address2?: Maybe<Scalars['String']>;
+    /** The city of the location. */
+    city?: Maybe<Scalars['String']>;
+    /** The country of the location. */
+    country?: Maybe<Scalars['String']>;
+    /** The country code of the location. */
+    countryCode?: Maybe<Scalars['String']>;
+    /** A formatted version of the address for the location. */
+    formatted: Array<Scalars['String']>;
+    /** The latitude coordinates of the location. */
+    latitude?: Maybe<Scalars['Float']>;
+    /** The longitude coordinates of the location. */
+    longitude?: Maybe<Scalars['Float']>;
+    /** The phone number of the location. */
+    phone?: Maybe<Scalars['String']>;
+    /** The province of the location. */
+    province?: Maybe<Scalars['String']>;
+    /**
+     * The code for the province, state, or district of the address of the location.
+     *
+     */
+    provinceCode?: Maybe<Scalars['String']>;
+    /** The ZIP code of the location. */
+    zip?: Maybe<Scalars['String']>;
+};
+/**
+ * An auto-generated type for paginating through multiple Locations.
+ *
+ */
+export declare type LocationConnection = {
+    __typename?: 'LocationConnection';
+    /** A list of edges. */
+    edges: Array<LocationEdge>;
+    /** A list of the nodes contained in LocationEdge. */
+    nodes: Array<Location>;
+    /** Information to aid in pagination. */
+    pageInfo: PageInfo;
+};
+/**
+ * An auto-generated type which holds one Location and a cursor during pagination.
+ *
+ */
+export declare type LocationEdge = {
+    __typename?: 'LocationEdge';
+    /** A cursor for use in pagination. */
+    cursor: Scalars['String'];
+    /** The item at the end of LocationEdge. */
+    node: Location;
+};
+/** The set of valid sort keys for the Location query. */
+export declare enum LocationSortKeys {
+    /** Sort by the `city` value. */
+    City = "CITY",
+    /** Sort by the `distance` value. */
+    Distance = "DISTANCE",
+    /** Sort by the `id` value. */
+    Id = "ID",
+    /** Sort by the `name` value. */
+    Name = "NAME"
+}
+/** Represents a mailing address for customers and shipping. */
+export declare type MailingAddress = Node & {
+    __typename?: 'MailingAddress';
+    /** The first line of the address. Typically the street address or PO Box number. */
+    address1?: Maybe<Scalars['String']>;
+    /**
+     * The second line of the address. Typically the number of the apartment, suite, or unit.
+     *
+     */
+    address2?: Maybe<Scalars['String']>;
+    /**
+     * The name of the city, district, village, or town.
+     *
+     */
+    city?: Maybe<Scalars['String']>;
+    /**
+     * The name of the customer's company or organization.
+     *
+     */
+    company?: Maybe<Scalars['String']>;
+    /**
+     * The name of the country.
+     *
+     */
+    country?: Maybe<Scalars['String']>;
+    /**
+     * The two-letter code for the country of the address.
+     *
+     * For example, US.
+     *
+     * @deprecated Use `countryCodeV2` instead.
+     */
+    countryCode?: Maybe<Scalars['String']>;
+    /**
+     * The two-letter code for the country of the address.
+     *
+     * For example, US.
+     *
+     */
+    countryCodeV2?: Maybe<CountryCode>;
+    /** The first name of the customer. */
+    firstName?: Maybe<Scalars['String']>;
+    /** A formatted version of the address, customized by the provided arguments. */
+    formatted: Array<Scalars['String']>;
+    /** A comma-separated list of the values for city, province, and country. */
+    formattedArea?: Maybe<Scalars['String']>;
+    /** A globally-unique identifier. */
+    id: Scalars['ID'];
+    /** The last name of the customer. */
+    lastName?: Maybe<Scalars['String']>;
+    /** The latitude coordinate of the customer address. */
+    latitude?: Maybe<Scalars['Float']>;
+    /** The longitude coordinate of the customer address. */
+    longitude?: Maybe<Scalars['Float']>;
+    /**
+     * The full name of the customer, based on firstName and lastName.
+     *
+     */
+    name?: Maybe<Scalars['String']>;
+    /**
+     * A unique phone number for the customer.
+     *
+     * Formatted using E.164 standard. For example, _+16135551111_.
+     *
+     */
+    phone?: Maybe<Scalars['String']>;
+    /** The region of the address, such as the province, state, or district. */
+    province?: Maybe<Scalars['String']>;
+    /**
+     * The two-letter code for the region.
+     *
+     * For example, ON.
+     *
+     */
+    provinceCode?: Maybe<Scalars['String']>;
+    /** The zip or postal code of the address. */
+    zip?: Maybe<Scalars['String']>;
+};
+/** Represents a mailing address for customers and shipping. */
+export declare type MailingAddressFormattedArgs = {
+    withCompany?: InputMaybe<Scalars['Boolean']>;
+    withName?: InputMaybe<Scalars['Boolean']>;
+};
+/**
+ * An auto-generated type for paginating through multiple MailingAddresses.
+ *
+ */
+export declare type MailingAddressConnection = {
+    __typename?: 'MailingAddressConnection';
+    /** A list of edges. */
+    edges: Array<MailingAddressEdge>;
+    /** A list of the nodes contained in MailingAddressEdge. */
+    nodes: Array<MailingAddress>;
+    /** Information to aid in pagination. */
+    pageInfo: PageInfo;
+};
+/**
+ * An auto-generated type which holds one MailingAddress and a cursor during pagination.
+ *
+ */
+export declare type MailingAddressEdge = {
+    __typename?: 'MailingAddressEdge';
+    /** A cursor for use in pagination. */
+    cursor: Scalars['String'];
+    /** The item at the end of MailingAddressEdge. */
+    node: MailingAddress;
+};
+/** Specifies the fields accepted to create or update a mailing address. */
+export declare type MailingAddressInput = {
+    /**
+     * The first line of the address. Typically the street address or PO Box number.
+     *
+     */
+    address1?: InputMaybe<Scalars['String']>;
+    /**
+     * The second line of the address. Typically the number of the apartment, suite, or unit.
+     *
+     */
+    address2?: InputMaybe<Scalars['String']>;
+    /**
+     * The name of the city, district, village, or town.
+     *
+     */
+    city?: InputMaybe<Scalars['String']>;
+    /**
+     * The name of the customer's company or organization.
+     *
+     */
+    company?: InputMaybe<Scalars['String']>;
+    /** The name of the country. */
+    country?: InputMaybe<Scalars['String']>;
+    /** The first name of the customer. */
+    firstName?: InputMaybe<Scalars['String']>;
+    /** The last name of the customer. */
+    lastName?: InputMaybe<Scalars['String']>;
+    /**
+     * A unique phone number for the customer.
+     *
+     * Formatted using E.164 standard. For example, _+16135551111_.
+     *
+     */
+    phone?: InputMaybe<Scalars['String']>;
+    /** The region of the address, such as the province, state, or district. */
+    province?: InputMaybe<Scalars['String']>;
+    /** The zip or postal code of the address. */
+    zip?: InputMaybe<Scalars['String']>;
+};
+/**
+ * Manual discount applications capture the intentions of a discount that was manually created.
+ *
+ */
+export declare type ManualDiscountApplication = DiscountApplication & {
+    __typename?: 'ManualDiscountApplication';
+    /** The method by which the discount's value is allocated to its entitled items. */
+    allocationMethod: DiscountApplicationAllocationMethod;
+    /** The description of the application. */
+    description?: Maybe<Scalars['String']>;
+    /** Which lines of targetType that the discount is allocated over. */
+    targetSelection: DiscountApplicationTargetSelection;
+    /** The type of line that the discount is applicable towards. */
+    targetType: DiscountApplicationTargetType;
+    /** The title of the application. */
+    title: Scalars['String'];
+    /** The value of the discount application. */
+    value: PricingValue;
+};
+/** Represents a media interface. */
+export declare type Media = {
+    /** A word or phrase to share the nature or contents of a media. */
+    alt?: Maybe<Scalars['String']>;
+    /** The media content type. */
+    mediaContentType: MediaContentType;
+    /** The preview image for the media. */
+    previewImage?: Maybe<Image>;
+};
+/**
+ * An auto-generated type for paginating through multiple Media.
+ *
+ */
+export declare type MediaConnection = {
+    __typename?: 'MediaConnection';
+    /** A list of edges. */
+    edges: Array<MediaEdge>;
+    /** A list of the nodes contained in MediaEdge. */
+    nodes: Array<ExternalVideo | MediaImage | Model3d | Video>;
+    /** Information to aid in pagination. */
+    pageInfo: PageInfo;
+};
+/** The possible content types for a media object. */
+export declare enum MediaContentType {
+    /** An externally hosted video. */
+    ExternalVideo = "EXTERNAL_VIDEO",
+    /** A Shopify hosted image. */
+    Image = "IMAGE",
+    /** A 3d model. */
+    Model_3D = "MODEL_3D",
+    /** A Shopify hosted video. */
+    Video = "VIDEO"
+}
+/**
+ * An auto-generated type which holds one Media and a cursor during pagination.
+ *
+ */
+export declare type MediaEdge = {
+    __typename?: 'MediaEdge';
+    /** A cursor for use in pagination. */
+    cursor: Scalars['String'];
+    /** The item at the end of MediaEdge. */
+    node: ExternalVideo | MediaImage | Model3d | Video;
+};
+/** Host for a Media Resource. */
+export declare enum MediaHost {
+    /** Host for Vimeo embedded videos. */
+    Vimeo = "VIMEO",
+    /** Host for YouTube embedded videos. */
+    Youtube = "YOUTUBE"
+}
+/** Represents a Shopify hosted image. */
+export declare type MediaImage = Media & Node & {
+    __typename?: 'MediaImage';
+    /** A word or phrase to share the nature or contents of a media. */
+    alt?: Maybe<Scalars['String']>;
+    /** A globally-unique identifier. */
+    id: Scalars['ID'];
+    /** The image for the media. */
+    image?: Maybe<Image>;
+    /** The media content type. */
+    mediaContentType: MediaContentType;
+    /** The preview image for the media. */
+    previewImage?: Maybe<Image>;
+};
+/**
+ * A menu used for navigation within a storefront.
+ *
+ */
+export declare type Menu = Node & {
+    __typename?: 'Menu';
+    /** The menu's handle. */
+    handle: Scalars['String'];
+    /** A globally-unique identifier. */
+    id: Scalars['ID'];
+    /** The menu's child items. */
+    items: Array<MenuItem>;
+    /** The count of items on the menu. */
+    itemsCount: Scalars['Int'];
+    /** The menu's title. */
+    title: Scalars['String'];
+};
+/**
+ * A menu item within a parent menu.
+ *
+ */
+export declare type MenuItem = Node & {
+    __typename?: 'MenuItem';
+    /** A globally-unique identifier. */
+    id: Scalars['ID'];
+    /** The menu item's child items. */
+    items: Array<MenuItem>;
+    /** The ID of the linked resource. */
+    resourceId?: Maybe<Scalars['ID']>;
+    /** The menu item's tags to filter a collection. */
+    tags: Array<Scalars['String']>;
+    /** The menu item's title. */
+    title: Scalars['String'];
+    /** The menu item's type. */
+    type: MenuItemType;
+    /** The menu item's URL. */
+    url?: Maybe<Scalars['URL']>;
+};
+/** A menu item type. */
+export declare enum MenuItemType {
+    /** An article link. */
+    Article = "ARTICLE",
+    /** A blog link. */
+    Blog = "BLOG",
+    /** A catalog link. */
+    Catalog = "CATALOG",
+    /** A collection link. */
+    Collection = "COLLECTION",
+    /** A collection link. */
+    Collections = "COLLECTIONS",
+    /** A frontpage link. */
+    Frontpage = "FRONTPAGE",
+    /** An http link. */
+    Http = "HTTP",
+    /** A page link. */
+    Page = "PAGE",
+    /** A product link. */
+    Product = "PRODUCT",
+    /** A search link. */
+    Search = "SEARCH",
+    /** A shop policy link. */
+    ShopPolicy = "SHOP_POLICY"
+}
+/** The merchandise to be purchased at checkout. */
+export declare type Merchandise = ProductVariant;
+/**
+ * Metafields represent custom metadata attached to a resource. Metafields can be sorted into namespaces and are
+ * comprised of keys, values, and value types.
+ *
+ */
+export declare type Metafield = Node & {
+    __typename?: 'Metafield';
+    /** The date and time when the storefront metafield was created. */
+    createdAt: Scalars['DateTime'];
+    /** The description of a metafield. */
+    description?: Maybe<Scalars['String']>;
+    /** A globally-unique identifier. */
+    id: Scalars['ID'];
+    /** The key name for a metafield. */
+    key: Scalars['String'];
+    /** The namespace for a metafield. */
+    namespace: Scalars['String'];
+    /** The parent object that the metafield belongs to. */
+    parentResource: MetafieldParentResource;
+    /** Returns a reference object if the metafield definition's type is a resource reference. */
+    reference?: Maybe<MetafieldReference>;
+    /** A list of reference objects if the metafield's type is a resource reference list. */
+    references?: Maybe<MetafieldReferenceConnection>;
+    /**
+     * The type name of the metafield.
+     * See the list of [supported types](https://shopify.dev/apps/metafields/definitions/types).
+     *
+     */
+    type: Scalars['String'];
+    /** The date and time when the storefront metafield was updated. */
+    updatedAt: Scalars['DateTime'];
+    /** The value of a metafield. */
+    value: Scalars['String'];
+};
+/**
+ * Metafields represent custom metadata attached to a resource. Metafields can be sorted into namespaces and are
+ * comprised of keys, values, and value types.
+ *
+ */
+export declare type MetafieldReferencesArgs = {
+    after?: InputMaybe<Scalars['String']>;
+    before?: InputMaybe<Scalars['String']>;
+    first?: InputMaybe<Scalars['Int']>;
+    last?: InputMaybe<Scalars['Int']>;
+};
+/**
+ * A filter used to view a subset of products in a collection matching a specific metafield value.
+ *
+ * Only the following metafield types are currently supported:
+ * - `number_integer`
+ * - `number_decimal`
+ * - `single_line_text_field`
+ * - `boolean` as of 2022-04.
+ *
+ */
+export declare type MetafieldFilter = {
+    /** The key of the metafield to filter on. */
+    key: Scalars['String'];
+    /** The namespace of the metafield to filter on. */
+    namespace: Scalars['String'];
+    /** The value of the metafield. */
+    value: Scalars['String'];
+};
+/** A resource that the metafield belongs to. */
+export declare type MetafieldParentResource = Article | Blog | Collection | Customer | Order | Page | Product | ProductVariant | Shop;
+/**
+ * Returns the resource which is being referred to by a metafield.
+ *
+ */
+export declare type MetafieldReference = Collection | GenericFile | MediaImage | Page | Product | ProductVariant | Video;
+/**
+ * An auto-generated type for paginating through multiple MetafieldReferences.
+ *
+ */
+export declare type MetafieldReferenceConnection = {
+    __typename?: 'MetafieldReferenceConnection';
+    /** A list of edges. */
+    edges: Array<MetafieldReferenceEdge>;
+    /** A list of the nodes contained in MetafieldReferenceEdge. */
+    nodes: Array<MetafieldReference>;
+    /** Information to aid in pagination. */
+    pageInfo: PageInfo;
+};
+/**
+ * An auto-generated type which holds one MetafieldReference and a cursor during pagination.
+ *
+ */
+export declare type MetafieldReferenceEdge = {
+    __typename?: 'MetafieldReferenceEdge';
+    /** A cursor for use in pagination. */
+    cursor: Scalars['String'];
+    /** The item at the end of MetafieldReferenceEdge. */
+    node: MetafieldReference;
+};
+/** Represents a Shopify hosted 3D model. */
+export declare type Model3d = Media & Node & {
+    __typename?: 'Model3d';
+    /** A word or phrase to share the nature or contents of a media. */
+    alt?: Maybe<Scalars['String']>;
+    /** A globally-unique identifier. */
+    id: Scalars['ID'];
+    /** The media content type. */
+    mediaContentType: MediaContentType;
+    /** The preview image for the media. */
+    previewImage?: Maybe<Image>;
+    /** The sources for a 3d model. */
+    sources: Array<Model3dSource>;
+};
+/** Represents a source for a Shopify hosted 3d model. */
+export declare type Model3dSource = {
+    __typename?: 'Model3dSource';
+    /** The filesize of the 3d model. */
+    filesize: Scalars['Int'];
+    /** The format of the 3d model. */
+    format: Scalars['String'];
+    /** The MIME type of the 3d model. */
+    mimeType: Scalars['String'];
+    /** The URL of the 3d model. */
+    url: Scalars['String'];
+};
+/** Specifies the fields for a monetary value with currency. */
+export declare type MoneyInput = {
+    /** Decimal money amount. */
+    amount: Scalars['Decimal'];
+    /** Currency of the money. */
+    currencyCode: CurrencyCode;
+};
+/**
+ * A monetary value with currency.
+ *
+ */
+export declare type MoneyV2 = {
+    __typename?: 'MoneyV2';
+    /** Decimal money amount. */
+    amount: Scalars['Decimal'];
+    /** Currency of the money. */
+    currencyCode: CurrencyCode;
+};
+/** The schemas entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start. */
+export declare type Mutation = {
+    __typename?: 'Mutation';
+    /** Updates the attributes on a cart. */
+    cartAttributesUpdate?: Maybe<CartAttributesUpdatePayload>;
+    /**
+     * Updates customer information associated with a cart.
+     * Buyer identity is used to determine
+     * [international pricing](https://shopify.dev/custom-storefronts/internationalization/international-pricing)
+     * and should match the customer's shipping address.
+     *
+     */
+    cartBuyerIdentityUpdate?: Maybe<CartBuyerIdentityUpdatePayload>;
+    /** Creates a new cart. */
+    cartCreate?: Maybe<CartCreatePayload>;
+    /** Updates the discount codes applied to the cart. */
+    cartDiscountCodesUpdate?: Maybe<CartDiscountCodesUpdatePayload>;
+    /** Adds a merchandise line to the cart. */
+    cartLinesAdd?: Maybe<CartLinesAddPayload>;
+    /** Removes one or more merchandise lines from the cart. */
+    cartLinesRemove?: Maybe<CartLinesRemovePayload>;
+    /** Updates one or more merchandise lines on a cart. */
+    cartLinesUpdate?: Maybe<CartLinesUpdatePayload>;
+    /** Updates the note on the cart. */
+    cartNoteUpdate?: Maybe<CartNoteUpdatePayload>;
+    /** Update the selected delivery options for a delivery group. */
+    cartSelectedDeliveryOptionsUpdate?: Maybe<CartSelectedDeliveryOptionsUpdatePayload>;
+    /** Updates the attributes of a checkout if `allowPartialAddresses` is `true`. */
+    checkoutAttributesUpdateV2?: Maybe<CheckoutAttributesUpdateV2Payload>;
+    /** Completes a checkout without providing payment information. You can use this mutation for free items or items whose purchase price is covered by a gift card. */
+    checkoutCompleteFree?: Maybe<CheckoutCompleteFreePayload>;
+    /** Completes a checkout using a credit card token from Shopify's card vault. Before you can complete checkouts using CheckoutCompleteWithCreditCardV2, you need to  [_request payment processing_](https://shopify.dev/apps/channels/getting-started#request-payment-processing). */
+    checkoutCompleteWithCreditCardV2?: Maybe<CheckoutCompleteWithCreditCardV2Payload>;
+    /** Completes a checkout with a tokenized payment. */
+    checkoutCompleteWithTokenizedPaymentV3?: Maybe<CheckoutCompleteWithTokenizedPaymentV3Payload>;
+    /** Creates a new checkout. */
+    checkoutCreate?: Maybe<CheckoutCreatePayload>;
+    /** Associates a customer to the checkout. */
+    checkoutCustomerAssociateV2?: Maybe<CheckoutCustomerAssociateV2Payload>;
+    /** Disassociates the current checkout customer from the checkout. */
+    checkoutCustomerDisassociateV2?: Maybe<CheckoutCustomerDisassociateV2Payload>;
+    /** Applies a discount to an existing checkout using a discount code. */
+    checkoutDiscountCodeApplyV2?: Maybe<CheckoutDiscountCodeApplyV2Payload>;
+    /** Removes the applied discounts from an existing checkout. */
+    checkoutDiscountCodeRemove?: Maybe<CheckoutDiscountCodeRemovePayload>;
+    /** Updates the email on an existing checkout. */
+    checkoutEmailUpdateV2?: Maybe<CheckoutEmailUpdateV2Payload>;
+    /** Removes an applied gift card from the checkout. */
+    checkoutGiftCardRemoveV2?: Maybe<CheckoutGiftCardRemoveV2Payload>;
+    /** Appends gift cards to an existing checkout. */
+    checkoutGiftCardsAppend?: Maybe<CheckoutGiftCardsAppendPayload>;
+    /** Adds a list of line items to a checkout. */
+    checkoutLineItemsAdd?: Maybe<CheckoutLineItemsAddPayload>;
+    /** Removes line items from an existing checkout. */
+    checkoutLineItemsRemove?: Maybe<CheckoutLineItemsRemovePayload>;
+    /** Sets a list of line items to a checkout. */
+    checkoutLineItemsReplace?: Maybe<CheckoutLineItemsReplacePayload>;
+    /** Updates line items on a checkout. */
+    checkoutLineItemsUpdate?: Maybe<CheckoutLineItemsUpdatePayload>;
+    /** Updates the shipping address of an existing checkout. */
+    checkoutShippingAddressUpdateV2?: Maybe<CheckoutShippingAddressUpdateV2Payload>;
+    /** Updates the shipping lines on an existing checkout. */
+    checkoutShippingLineUpdate?: Maybe<CheckoutShippingLineUpdatePayload>;
+    /**
+     * Creates a customer access token.
+     * The customer access token is required to modify the customer object in any way.
+     *
+     */
+    customerAccessTokenCreate?: Maybe<CustomerAccessTokenCreatePayload>;
+    /**
+     * Creates a customer access token using a
+     * [multipass token](https://shopify.dev/api/multipass) instead of email and
+     * password. A customer record is created if the customer doesn't exist. If a customer
+     * record already exists but the record is disabled, then the customer record is enabled.
+     *
+     */
+    customerAccessTokenCreateWithMultipass?: Maybe<CustomerAccessTokenCreateWithMultipassPayload>;
+    /** Permanently destroys a customer access token. */
+    customerAccessTokenDelete?: Maybe<CustomerAccessTokenDeletePayload>;
+    /**
+     * Renews a customer access token.
+     *
+     * Access token renewal must happen *before* a token expires.
+     * If a token has already expired, a new one should be created instead via `customerAccessTokenCreate`.
+     *
+     */
+    customerAccessTokenRenew?: Maybe<CustomerAccessTokenRenewPayload>;
+    /** Activates a customer. */
+    customerActivate?: Maybe<CustomerActivatePayload>;
+    /** Activates a customer with the activation url received from `customerCreate`. */
+    customerActivateByUrl?: Maybe<CustomerActivateByUrlPayload>;
+    /** Creates a new address for a customer. */
+    customerAddressCreate?: Maybe<CustomerAddressCreatePayload>;
+    /** Permanently deletes the address of an existing customer. */
+    customerAddressDelete?: Maybe<CustomerAddressDeletePayload>;
+    /** Updates the address of an existing customer. */
+    customerAddressUpdate?: Maybe<CustomerAddressUpdatePayload>;
+    /** Creates a new customer. */
+    customerCreate?: Maybe<CustomerCreatePayload>;
+    /** Updates the default address of an existing customer. */
+    customerDefaultAddressUpdate?: Maybe<CustomerDefaultAddressUpdatePayload>;
+    /**
+     * Sends a reset password email to the customer. The reset password
+     * email contains a reset password URL and token that you can pass to
+     * the [`customerResetByUrl`](https://shopify.dev/api/storefront/latest/mutations/customerResetByUrl) or
+     * [`customerReset`](https://shopify.dev/api/storefront/latest/mutations/customerReset) mutation to reset the
+     * customer password.
+     *
+     * This mutation is throttled by IP. With authenticated access,
+     * a value provided to
+     * you can provide a [`Shopify-Storefront-Buyer-IP`](https://shopify.dev/api/usage/authentication#optional-ip-header) instead of the request IP.
+     * instead of the request IP.
+     *
+     * Ensure that the value provided to
+     * `Shopify-Storefront-Buyer-IP` is trusted. Unthrottled access to this
+     * mutation presents a security risk.
+     *
+     */
+    customerRecover?: Maybe<CustomerRecoverPayload>;
+    /**
+     * "Resets a customers password with the token received from a reset password email. You can send a reset password email with the [`customerRecover`](https://shopify.dev/api/storefront/latest/mutations/customerRecover) mutation."
+     *
+     */
+    customerReset?: Maybe<CustomerResetPayload>;
+    /**
+     * "Resets a customers password with the reset password URL received from a reset password email. You can send a reset password email with the [`customerRecover`](https://shopify.dev/api/storefront/latest/mutations/customerRecover) mutation."
+     *
+     */
+    customerResetByUrl?: Maybe<CustomerResetByUrlPayload>;
+    /** Updates an existing customer. */
+    customerUpdate?: Maybe<CustomerUpdatePayload>;
+};
+/** The schemas entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start. */
+export declare type MutationCartAttributesUpdateArgs = {
+    attributes: Array<AttributeInput>;
+    cartId: Scalars['ID'];
+};
+/** The schemas entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start. */
+export declare type MutationCartBuyerIdentityUpdateArgs = {
+    buyerIdentity: CartBuyerIdentityInput;
+    cartId: Scalars['ID'];
+};
+/** The schemas entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start. */
+export declare type MutationCartCreateArgs = {
+    input?: InputMaybe<CartInput>;
+};
+/** The schemas entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start. */
+export declare type MutationCartDiscountCodesUpdateArgs = {
+    cartId: Scalars['ID'];
+    discountCodes?: InputMaybe<Array<Scalars['String']>>;
+};
+/** The schemas entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start. */
+export declare type MutationCartLinesAddArgs = {
+    cartId: Scalars['ID'];
+    lines: Array<CartLineInput>;
+};
+/** The schemas entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start. */
+export declare type MutationCartLinesRemoveArgs = {
+    cartId: Scalars['ID'];
+    lineIds: Array<Scalars['ID']>;
+};
+/** The schemas entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start. */
+export declare type MutationCartLinesUpdateArgs = {
+    cartId: Scalars['ID'];
+    lines: Array<CartLineUpdateInput>;
+};
+/** The schemas entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start. */
+export declare type MutationCartNoteUpdateArgs = {
+    cartId: Scalars['ID'];
+    note?: InputMaybe<Scalars['String']>;
+};
+/** The schemas entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start. */
+export declare type MutationCartSelectedDeliveryOptionsUpdateArgs = {
+    cartId: Scalars['ID'];
+    selectedDeliveryOptions: Array<CartSelectedDeliveryOptionInput>;
+};
+/** The schemas entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start. */
+export declare type MutationCheckoutAttributesUpdateV2Args = {
+    checkoutId: Scalars['ID'];
+    input: CheckoutAttributesUpdateV2Input;
+};
+/** The schemas entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start. */
+export declare type MutationCheckoutCompleteFreeArgs = {
+    checkoutId: Scalars['ID'];
+};
+/** The schemas entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start. */
+export declare type MutationCheckoutCompleteWithCreditCardV2Args = {
+    checkoutId: Scalars['ID'];
+    payment: CreditCardPaymentInputV2;
+};
+/** The schemas entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start. */
+export declare type MutationCheckoutCompleteWithTokenizedPaymentV3Args = {
+    checkoutId: Scalars['ID'];
+    payment: TokenizedPaymentInputV3;
+};
+/** The schemas entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start. */
+export declare type MutationCheckoutCreateArgs = {
+    input: CheckoutCreateInput;
+    queueToken?: InputMaybe<Scalars['String']>;
+};
+/** The schemas entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start. */
+export declare type MutationCheckoutCustomerAssociateV2Args = {
+    checkoutId: Scalars['ID'];
+    customerAccessToken: Scalars['String'];
+};
+/** The schemas entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start. */
+export declare type MutationCheckoutCustomerDisassociateV2Args = {
+    checkoutId: Scalars['ID'];
+};
+/** The schemas entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start. */
+export declare type MutationCheckoutDiscountCodeApplyV2Args = {
+    checkoutId: Scalars['ID'];
+    discountCode: Scalars['String'];
+};
+/** The schemas entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start. */
+export declare type MutationCheckoutDiscountCodeRemoveArgs = {
+    checkoutId: Scalars['ID'];
+};
+/** The schemas entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start. */
+export declare type MutationCheckoutEmailUpdateV2Args = {
+    checkoutId: Scalars['ID'];
+    email: Scalars['String'];
+};
+/** The schemas entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start. */
+export declare type MutationCheckoutGiftCardRemoveV2Args = {
+    appliedGiftCardId: Scalars['ID'];
+    checkoutId: Scalars['ID'];
+};
+/** The schemas entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start. */
+export declare type MutationCheckoutGiftCardsAppendArgs = {
+    checkoutId: Scalars['ID'];
+    giftCardCodes: Array<Scalars['String']>;
+};
+/** The schemas entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start. */
+export declare type MutationCheckoutLineItemsAddArgs = {
+    checkoutId: Scalars['ID'];
+    lineItems: Array<CheckoutLineItemInput>;
+};
+/** The schemas entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start. */
+export declare type MutationCheckoutLineItemsRemoveArgs = {
+    checkoutId: Scalars['ID'];
+    lineItemIds: Array<Scalars['ID']>;
+};
+/** The schemas entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start. */
+export declare type MutationCheckoutLineItemsReplaceArgs = {
+    checkoutId: Scalars['ID'];
+    lineItems: Array<CheckoutLineItemInput>;
+};
+/** The schemas entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start. */
+export declare type MutationCheckoutLineItemsUpdateArgs = {
+    checkoutId: Scalars['ID'];
+    lineItems: Array<CheckoutLineItemUpdateInput>;
+};
+/** The schemas entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start. */
+export declare type MutationCheckoutShippingAddressUpdateV2Args = {
+    checkoutId: Scalars['ID'];
+    shippingAddress: MailingAddressInput;
+};
+/** The schemas entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start. */
+export declare type MutationCheckoutShippingLineUpdateArgs = {
+    checkoutId: Scalars['ID'];
+    shippingRateHandle: Scalars['String'];
+};
+/** The schemas entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start. */
+export declare type MutationCustomerAccessTokenCreateArgs = {
+    input: CustomerAccessTokenCreateInput;
+};
+/** The schemas entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start. */
+export declare type MutationCustomerAccessTokenCreateWithMultipassArgs = {
+    multipassToken: Scalars['String'];
+};
+/** The schemas entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start. */
+export declare type MutationCustomerAccessTokenDeleteArgs = {
+    customerAccessToken: Scalars['String'];
+};
+/** The schemas entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start. */
+export declare type MutationCustomerAccessTokenRenewArgs = {
+    customerAccessToken: Scalars['String'];
+};
+/** The schemas entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start. */
+export declare type MutationCustomerActivateArgs = {
+    id: Scalars['ID'];
+    input: CustomerActivateInput;
+};
+/** The schemas entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start. */
+export declare type MutationCustomerActivateByUrlArgs = {
+    activationUrl: Scalars['URL'];
+    password: Scalars['String'];
+};
+/** The schemas entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start. */
+export declare type MutationCustomerAddressCreateArgs = {
+    address: MailingAddressInput;
+    customerAccessToken: Scalars['String'];
+};
+/** The schemas entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start. */
+export declare type MutationCustomerAddressDeleteArgs = {
+    customerAccessToken: Scalars['String'];
+    id: Scalars['ID'];
+};
+/** The schemas entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start. */
+export declare type MutationCustomerAddressUpdateArgs = {
+    address: MailingAddressInput;
+    customerAccessToken: Scalars['String'];
+    id: Scalars['ID'];
+};
+/** The schemas entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start. */
+export declare type MutationCustomerCreateArgs = {
+    input: CustomerCreateInput;
+};
+/** The schemas entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start. */
+export declare type MutationCustomerDefaultAddressUpdateArgs = {
+    addressId: Scalars['ID'];
+    customerAccessToken: Scalars['String'];
+};
+/** The schemas entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start. */
+export declare type MutationCustomerRecoverArgs = {
+    email: Scalars['String'];
+};
+/** The schemas entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start. */
+export declare type MutationCustomerResetArgs = {
+    id: Scalars['ID'];
+    input: CustomerResetInput;
+};
+/** The schemas entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start. */
+export declare type MutationCustomerResetByUrlArgs = {
+    password: Scalars['String'];
+    resetUrl: Scalars['URL'];
+};
+/** The schemas entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start. */
+export declare type MutationCustomerUpdateArgs = {
+    customer: CustomerUpdateInput;
+    customerAccessToken: Scalars['String'];
+};
+/**
+ * An object with an ID field to support global identification, in accordance with the
+ * [Relay specification](https://relay.dev/graphql/objectidentification.htm#sec-Node-Interface).
+ * This interface is used by the [node](https://shopify.dev/api/admin-graphql/unstable/queries/node)
+ * and [nodes](https://shopify.dev/api/admin-graphql/unstable/queries/nodes) queries.
+ *
+ */
+export declare type Node = {
+    /** A globally-unique identifier. */
+    id: Scalars['ID'];
+};
+/** Represents a resource that can be published to the Online Store sales channel. */
+export declare type OnlineStorePublishable = {
+    /** The URL used for viewing the resource on the shop's Online Store. Returns `null` if the resource is currently not published to the Online Store sales channel. */
+    onlineStoreUrl?: Maybe<Scalars['URL']>;
+};
+/** An order is a customers completed request to purchase one or more products from a shop. An order is created when a customer completes the checkout process, during which time they provides an email address, billing address and payment information. */
+export declare type Order = HasMetafields & Node & {
+    __typename?: 'Order';
+    /** The reason for the order's cancellation. Returns `null` if the order wasn't canceled. */
+    cancelReason?: Maybe<OrderCancelReason>;
+    /** The date and time when the order was canceled. Returns null if the order wasn't canceled. */
+    canceledAt?: Maybe<Scalars['DateTime']>;
+    /** The code of the currency used for the payment. */
+    currencyCode: CurrencyCode;
+    /** The subtotal of line items and their discounts, excluding line items that have been removed. Does not contain order-level discounts, duties, shipping costs, or shipping discounts. Taxes are not included unless the order is a taxes-included order. */
+    currentSubtotalPrice: MoneyV2;
+    /** The total cost of duties for the order, including refunds. */
+    currentTotalDuties?: Maybe<MoneyV2>;
+    /** The total amount of the order, including duties, taxes and discounts, minus amounts for line items that have been removed. */
+    currentTotalPrice: MoneyV2;
+    /** The total of all taxes applied to the order, excluding taxes for returned line items. */
+    currentTotalTax: MoneyV2;
+    /** The locale code in which this specific order happened. */
+    customerLocale?: Maybe<Scalars['String']>;
+    /** The unique URL that the customer can use to access the order. */
+    customerUrl?: Maybe<Scalars['URL']>;
+    /** Discounts that have been applied on the order. */
+    discountApplications: DiscountApplicationConnection;
+    /** Whether the order has had any edits applied or not. */
+    edited: Scalars['Boolean'];
+    /** The customer's email address. */
+    email?: Maybe<Scalars['String']>;
+    /** The financial status of the order. */
+    financialStatus?: Maybe<OrderFinancialStatus>;
+    /** The fulfillment status for the order. */
+    fulfillmentStatus: OrderFulfillmentStatus;
+    /** A globally-unique identifier. */
+    id: Scalars['ID'];
+    /** List of the orders line items. */
+    lineItems: OrderLineItemConnection;
+    /** Returns a metafield found by namespace and key. */
+    metafield?: Maybe<Metafield>;
+    /**
+     * The metafields associated with the resource matching the supplied list of namespaces and keys.
+     *
+     */
+    metafields: Array<Maybe<Metafield>>;
+    /**
+     * Unique identifier for the order that appears on the order.
+     * For example, _#1000_ or _Store1001.
+     *
+     */
+    name: Scalars['String'];
+    /** A unique numeric identifier for the order for use by shop owner and customer. */
+    orderNumber: Scalars['Int'];
+    /** The total cost of duties charged at checkout. */
+    originalTotalDuties?: Maybe<MoneyV2>;
+    /** The total price of the order before any applied edits. */
+    originalTotalPrice: MoneyV2;
+    /** The customer's phone number for receiving SMS notifications. */
+    phone?: Maybe<Scalars['String']>;
+    /**
+     * The date and time when the order was imported.
+     * This value can be set to dates in the past when importing from other systems.
+     * If no value is provided, it will be auto-generated based on current date and time.
+     *
+     */
+    processedAt: Scalars['DateTime'];
+    /** The address to where the order will be shipped. */
+    shippingAddress?: Maybe<MailingAddress>;
+    /**
+     * The discounts that have been allocated onto the shipping line by discount applications.
+     *
+     */
+    shippingDiscountAllocations: Array<DiscountAllocation>;
+    /** The unique URL for the order's status page. */
+    statusUrl: Scalars['URL'];
+    /** Price of the order before shipping and taxes. */
+    subtotalPrice?: Maybe<MoneyV2>;
+    /**
+     * Price of the order before duties, shipping and taxes.
+     * @deprecated Use `subtotalPrice` instead.
+     */
+    subtotalPriceV2?: Maybe<MoneyV2>;
+    /** List of the orders successful fulfillments. */
+    successfulFulfillments?: Maybe<Array<Fulfillment>>;
+    /** The sum of all the prices of all the items in the order, duties, taxes and discounts included (must be positive). */
+    totalPrice: MoneyV2;
+    /**
+     * The sum of all the prices of all the items in the order, duties, taxes and discounts included (must be positive).
+     * @deprecated Use `totalPrice` instead.
+     */
+    totalPriceV2: MoneyV2;
+    /** The total amount that has been refunded. */
+    totalRefunded: MoneyV2;
+    /**
+     * The total amount that has been refunded.
+     * @deprecated Use `totalRefunded` instead.
+     */
+    totalRefundedV2: MoneyV2;
+    /** The total cost of shipping. */
+    totalShippingPrice: MoneyV2;
+    /**
+     * The total cost of shipping.
+     * @deprecated Use `totalShippingPrice` instead.
+     */
+    totalShippingPriceV2: MoneyV2;
+    /** The total cost of taxes. */
+    totalTax?: Maybe<MoneyV2>;
+    /**
+     * The total cost of taxes.
+     * @deprecated Use `totalTax` instead.
+     */
+    totalTaxV2?: Maybe<MoneyV2>;
+};
+/** An order is a customers completed request to purchase one or more products from a shop. An order is created when a customer completes the checkout process, during which time they provides an email address, billing address and payment information. */
+export declare type OrderDiscountApplicationsArgs = {
+    after?: InputMaybe<Scalars['String']>;
+    before?: InputMaybe<Scalars['String']>;
+    first?: InputMaybe<Scalars['Int']>;
+    last?: InputMaybe<Scalars['Int']>;
+    reverse?: InputMaybe<Scalars['Boolean']>;
+};
+/** An order is a customers completed request to purchase one or more products from a shop. An order is created when a customer completes the checkout process, during which time they provides an email address, billing address and payment information. */
+export declare type OrderLineItemsArgs = {
+    after?: InputMaybe<Scalars['String']>;
+    before?: InputMaybe<Scalars['String']>;
+    first?: InputMaybe<Scalars['Int']>;
+    last?: InputMaybe<Scalars['Int']>;
+    reverse?: InputMaybe<Scalars['Boolean']>;
+};
+/** An order is a customers completed request to purchase one or more products from a shop. An order is created when a customer completes the checkout process, during which time they provides an email address, billing address and payment information. */
+export declare type OrderMetafieldArgs = {
+    key: Scalars['String'];
+    namespace: Scalars['String'];
+};
+/** An order is a customers completed request to purchase one or more products from a shop. An order is created when a customer completes the checkout process, during which time they provides an email address, billing address and payment information. */
+export declare type OrderMetafieldsArgs = {
+    identifiers: Array<HasMetafieldsIdentifier>;
+};
+/** An order is a customers completed request to purchase one or more products from a shop. An order is created when a customer completes the checkout process, during which time they provides an email address, billing address and payment information. */
+export declare type OrderSuccessfulFulfillmentsArgs = {
+    first?: InputMaybe<Scalars['Int']>;
+};
+/** Represents the reason for the order's cancellation. */
+export declare enum OrderCancelReason {
+    /** The customer wanted to cancel the order. */
+    Customer = "CUSTOMER",
+    /** Payment was declined. */
+    Declined = "DECLINED",
+    /** The order was fraudulent. */
+    Fraud = "FRAUD",
+    /** There was insufficient inventory. */
+    Inventory = "INVENTORY",
+    /** The order was canceled for an unlisted reason. */
+    Other = "OTHER"
+}
+/**
+ * An auto-generated type for paginating through multiple Orders.
+ *
+ */
+export declare type OrderConnection = {
+    __typename?: 'OrderConnection';
+    /** A list of edges. */
+    edges: Array<OrderEdge>;
+    /** A list of the nodes contained in OrderEdge. */
+    nodes: Array<Order>;
+    /** Information to aid in pagination. */
+    pageInfo: PageInfo;
+    /** The total count of Orders. */
+    totalCount: Scalars['UnsignedInt64'];
+};
+/**
+ * An auto-generated type which holds one Order and a cursor during pagination.
+ *
+ */
+export declare type OrderEdge = {
+    __typename?: 'OrderEdge';
+    /** A cursor for use in pagination. */
+    cursor: Scalars['String'];
+    /** The item at the end of OrderEdge. */
+    node: Order;
+};
+/** Represents the order's current financial status. */
+export declare enum OrderFinancialStatus {
+    /** Displayed as **Authorized**. */
+    Authorized = "AUTHORIZED",
+    /** Displayed as **Paid**. */
+    Paid = "PAID",
+    /** Displayed as **Partially paid**. */
+    PartiallyPaid = "PARTIALLY_PAID",
+    /** Displayed as **Partially refunded**. */
+    PartiallyRefunded = "PARTIALLY_REFUNDED",
+    /** Displayed as **Pending**. */
+    Pending = "PENDING",
+    /** Displayed as **Refunded**. */
+    Refunded = "REFUNDED",
+    /** Displayed as **Voided**. */
+    Voided = "VOIDED"
+}
+/** Represents the order's aggregated fulfillment status for display purposes. */
+export declare enum OrderFulfillmentStatus {
+    /** Displayed as **Fulfilled**. All of the items in the order have been fulfilled. */
+    Fulfilled = "FULFILLED",
+    /** Displayed as **In progress**. Some of the items in the order have been fulfilled, or a request for fulfillment has been sent to the fulfillment service. */
+    InProgress = "IN_PROGRESS",
+    /** Displayed as **On hold**. All of the unfulfilled items in this order are on hold. */
+    OnHold = "ON_HOLD",
+    /** Displayed as **Open**. None of the items in the order have been fulfilled. Replaced by "UNFULFILLED" status. */
+    Open = "OPEN",
+    /** Displayed as **Partially fulfilled**. Some of the items in the order have been fulfilled. */
+    PartiallyFulfilled = "PARTIALLY_FULFILLED",
+    /** Displayed as **Pending fulfillment**. A request for fulfillment of some items awaits a response from the fulfillment service. Replaced by "IN_PROGRESS" status. */
+    PendingFulfillment = "PENDING_FULFILLMENT",
+    /** Displayed as **Restocked**. All of the items in the order have been restocked. Replaced by "UNFULFILLED" status. */
+    Restocked = "RESTOCKED",
+    /** Displayed as **Scheduled**. All of the unfulfilled items in this order are scheduled for fulfillment at later time. */
+    Scheduled = "SCHEDULED",
+    /** Displayed as **Unfulfilled**. None of the items in the order have been fulfilled. */
+    Unfulfilled = "UNFULFILLED"
+}
+/** Represents a single line in an order. There is one line item for each distinct product variant. */
+export declare type OrderLineItem = {
+    __typename?: 'OrderLineItem';
+    /** The number of entries associated to the line item minus the items that have been removed. */
+    currentQuantity: Scalars['Int'];
+    /** List of custom attributes associated to the line item. */
+    customAttributes: Array<Attribute>;
+    /** The discounts that have been allocated onto the order line item by discount applications. */
+    discountAllocations: Array<DiscountAllocation>;
+    /** The total price of the line item, including discounts, and displayed in the presentment currency. */
+    discountedTotalPrice: MoneyV2;
+    /** The total price of the line item, not including any discounts. The total price is calculated using the original unit price multiplied by the quantity, and it is displayed in the presentment currency. */
+    originalTotalPrice: MoneyV2;
+    /** The number of products variants associated to the line item. */
+    quantity: Scalars['Int'];
+    /** The title of the product combined with title of the variant. */
+    title: Scalars['String'];
+    /** The product variant object associated to the line item. */
+    variant?: Maybe<ProductVariant>;
+};
+/**
+ * An auto-generated type for paginating through multiple OrderLineItems.
+ *
+ */
+export declare type OrderLineItemConnection = {
+    __typename?: 'OrderLineItemConnection';
+    /** A list of edges. */
+    edges: Array<OrderLineItemEdge>;
+    /** A list of the nodes contained in OrderLineItemEdge. */
+    nodes: Array<OrderLineItem>;
+    /** Information to aid in pagination. */
+    pageInfo: PageInfo;
+};
+/**
+ * An auto-generated type which holds one OrderLineItem and a cursor during pagination.
+ *
+ */
+export declare type OrderLineItemEdge = {
+    __typename?: 'OrderLineItemEdge';
+    /** A cursor for use in pagination. */
+    cursor: Scalars['String'];
+    /** The item at the end of OrderLineItemEdge. */
+    node: OrderLineItem;
+};
+/** The set of valid sort keys for the Order query. */
+export declare enum OrderSortKeys {
+    /** Sort by the `id` value. */
+    Id = "ID",
+    /** Sort by the `processed_at` value. */
+    ProcessedAt = "PROCESSED_AT",
+    /**
+     * Sort by relevance to the search terms when the `query` parameter is specified on the connection.
+     * Don't use this sort key when no search query is specified.
+     *
+     */
+    Relevance = "RELEVANCE",
+    /** Sort by the `total_price` value. */
+    TotalPrice = "TOTAL_PRICE"
+}
+/** Shopify merchants can create pages to hold static HTML content. Each Page object represents a custom page on the online store. */
+export declare type Page = HasMetafields & Node & OnlineStorePublishable & {
+    __typename?: 'Page';
+    /** The description of the page, complete with HTML formatting. */
+    body: Scalars['HTML'];
+    /** Summary of the page body. */
+    bodySummary: Scalars['String'];
+    /** The timestamp of the page creation. */
+    createdAt: Scalars['DateTime'];
+    /** A human-friendly unique string for the page automatically generated from its title. */
+    handle: Scalars['String'];
+    /** A globally-unique identifier. */
+    id: Scalars['ID'];
+    /** Returns a metafield found by namespace and key. */
+    metafield?: Maybe<Metafield>;
+    /**
+     * The metafields associated with the resource matching the supplied list of namespaces and keys.
+     *
+     */
+    metafields: Array<Maybe<Metafield>>;
+    /** The URL used for viewing the resource on the shop's Online Store. Returns `null` if the resource is currently not published to the Online Store sales channel. */
+    onlineStoreUrl?: Maybe<Scalars['URL']>;
+    /** The page's SEO information. */
+    seo?: Maybe<Seo>;
+    /** The title of the page. */
+    title: Scalars['String'];
+    /** The timestamp of the latest page update. */
+    updatedAt: Scalars['DateTime'];
+};
+/** Shopify merchants can create pages to hold static HTML content. Each Page object represents a custom page on the online store. */
+export declare type PageMetafieldArgs = {
+    key: Scalars['String'];
+    namespace: Scalars['String'];
+};
+/** Shopify merchants can create pages to hold static HTML content. Each Page object represents a custom page on the online store. */
+export declare type PageMetafieldsArgs = {
+    identifiers: Array<HasMetafieldsIdentifier>;
+};
+/**
+ * An auto-generated type for paginating through multiple Pages.
+ *
+ */
+export declare type PageConnection = {
+    __typename?: 'PageConnection';
+    /** A list of edges. */
+    edges: Array<PageEdge>;
+    /** A list of the nodes contained in PageEdge. */
+    nodes: Array<Page>;
+    /** Information to aid in pagination. */
+    pageInfo: PageInfo;
+};
+/**
+ * An auto-generated type which holds one Page and a cursor during pagination.
+ *
+ */
+export declare type PageEdge = {
+    __typename?: 'PageEdge';
+    /** A cursor for use in pagination. */
+    cursor: Scalars['String'];
+    /** The item at the end of PageEdge. */
+    node: Page;
+};
+/**
+ * Returns information about pagination in a connection, in accordance with the
+ * [Relay specification](https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo).
+ *
+ */
+export declare type PageInfo = {
+    __typename?: 'PageInfo';
+    /** The cursor corresponding to the last node in edges. */
+    endCursor?: Maybe<Scalars['String']>;
+    /** Whether there are more pages to fetch following the current page. */
+    hasNextPage: Scalars['Boolean'];
+    /** Whether there are any pages prior to the current page. */
+    hasPreviousPage: Scalars['Boolean'];
+    /** The cursor corresponding to the first node in edges. */
+    startCursor?: Maybe<Scalars['String']>;
+};
+/** The set of valid sort keys for the Page query. */
+export declare enum PageSortKeys {
+    /** Sort by the `id` value. */
+    Id = "ID",
+    /**
+     * Sort by relevance to the search terms when the `query` parameter is specified on the connection.
+     * Don't use this sort key when no search query is specified.
+     *
+     */
+    Relevance = "RELEVANCE",
+    /** Sort by the `title` value. */
+    Title = "TITLE",
+    /** Sort by the `updated_at` value. */
+    UpdatedAt = "UPDATED_AT"
+}
+/** A payment applied to a checkout. */
+export declare type Payment = Node & {
+    __typename?: 'Payment';
+    /** The amount of the payment. */
+    amount: MoneyV2;
+    /**
+     * The amount of the payment.
+     * @deprecated Use `amount` instead.
+     */
+    amountV2: MoneyV2;
+    /** The billing address for the payment. */
+    billingAddress?: Maybe<MailingAddress>;
+    /** The checkout to which the payment belongs. */
+    checkout: Checkout;
+    /** The credit card used for the payment in the case of direct payments. */
+    creditCard?: Maybe<CreditCard>;
+    /** A message describing a processing error during asynchronous processing. */
+    errorMessage?: Maybe<Scalars['String']>;
+    /** A globally-unique identifier. */
+    id: Scalars['ID'];
+    /**
+     * A client-side generated token to identify a payment and perform idempotent operations.
+     * For more information, refer to
+     * [Idempotent requests](https://shopify.dev/api/usage/idempotent-requests).
+     *
+     */
+    idempotencyKey?: Maybe<Scalars['String']>;
+    /** The URL where the customer needs to be redirected so they can complete the 3D Secure payment flow. */
+    nextActionUrl?: Maybe<Scalars['URL']>;
+    /** Whether the payment is still processing asynchronously. */
+    ready: Scalars['Boolean'];
+    /** A flag to indicate if the payment is to be done in test mode for gateways that support it. */
+    test: Scalars['Boolean'];
+    /** The actual transaction recorded by Shopify after having processed the payment with the gateway. */
+    transaction?: Maybe<Transaction>;
+};
+/** Settings related to payments. */
+export declare type PaymentSettings = {
+    __typename?: 'PaymentSettings';
+    /** List of the card brands which the shop accepts. */
+    acceptedCardBrands: Array<CardBrand>;
+    /** The url pointing to the endpoint to vault credit cards. */
+    cardVaultUrl: Scalars['URL'];
+    /** The country where the shop is located. */
+    countryCode: CountryCode;
+    /** The three-letter code for the shop's primary currency. */
+    currencyCode: CurrencyCode;
+    /** A list of enabled currencies (ISO 4217 format) that the shop accepts. Merchants can enable currencies from their Shopify Payments settings in the Shopify admin. */
+    enabledPresentmentCurrencies: Array<CurrencyCode>;
+    /** The shops Shopify Payments account id. */
+    shopifyPaymentsAccountId?: Maybe<Scalars['String']>;
+    /** List of the digital wallets which the shop supports. */
+    supportedDigitalWallets: Array<DigitalWallet>;
+};
+/** The valid values for the types of payment token. */
+export declare enum PaymentTokenType {
+    /** Apple Pay token type. */
+    ApplePay = "APPLE_PAY",
+    /** Google Pay token type. */
+    GooglePay = "GOOGLE_PAY",
+    /** Shopify Pay token type. */
+    ShopifyPay = "SHOPIFY_PAY",
+    /** Stripe token type. */
+    StripeVaultToken = "STRIPE_VAULT_TOKEN",
+    /** Vault payment token type. */
+    Vault = "VAULT"
+}
+/** A filter used to view a subset of products in a collection matching a specific price range. */
+export declare type PriceRangeFilter = {
+    /** The maximum price in the range. Empty indicates no max price. */
+    max?: InputMaybe<Scalars['Float']>;
+    /** The minimum price in the range. Defaults to zero. */
+    min?: InputMaybe<Scalars['Float']>;
+};
+/** The value of the percentage pricing object. */
+export declare type PricingPercentageValue = {
+    __typename?: 'PricingPercentageValue';
+    /** The percentage value of the object. */
+    percentage: Scalars['Float'];
+};
+/** The price value (fixed or percentage) for a discount application. */
+export declare type PricingValue = MoneyV2 | PricingPercentageValue;
+/**
+ * A product represents an individual item for sale in a Shopify store. Products are often physical, but they don't have to be.
+ * For example, a digital download (such as a movie, music or ebook file) also qualifies as a product, as do services (such as equipment rental, work for hire, customization of another product or an extended warranty).
+ */
+export declare type Product = HasMetafields & Node & OnlineStorePublishable & {
+    __typename?: 'Product';
+    /** Indicates if at least one product variant is available for sale. */
+    availableForSale: Scalars['Boolean'];
+    /** List of collections a product belongs to. */
+    collections: CollectionConnection;
+    /** The compare at price of the product across all variants. */
+    compareAtPriceRange: ProductPriceRange;
+    /** The date and time when the product was created. */
+    createdAt: Scalars['DateTime'];
+    /** Stripped description of the product, single line with HTML tags removed. */
+    description: Scalars['String'];
+    /** The description of the product, complete with HTML formatting. */
+    descriptionHtml: Scalars['HTML'];
+    /**
+     * The featured image for the product.
+     *
+     * This field is functionally equivalent to `images(first: 1)`.
+     *
+     */
+    featuredImage?: Maybe<Image>;
+    /**
+     * A human-friendly unique string for the Product automatically generated from its title.
+     * They are used by the Liquid templating language to refer to objects.
+     *
+     */
+    handle: Scalars['String'];
+    /** A globally-unique identifier. */
+    id: Scalars['ID'];
+    /** List of images associated with the product. */
+    images: ImageConnection;
+    /** Whether the product is a gift card. */
+    isGiftCard: Scalars['Boolean'];
+    /** The media associated with the product. */
+    media: MediaConnection;
+    /** Returns a metafield found by namespace and key. */
+    metafield?: Maybe<Metafield>;
+    /**
+     * The metafields associated with the resource matching the supplied list of namespaces and keys.
+     *
+     */
+    metafields: Array<Maybe<Metafield>>;
+    /** The URL used for viewing the resource on the shop's Online Store. Returns `null` if the resource is currently not published to the Online Store sales channel. */
+    onlineStoreUrl?: Maybe<Scalars['URL']>;
+    /** List of product options. */
+    options: Array<ProductOption>;
+    /** The price range. */
+    priceRange: ProductPriceRange;
+    /** A categorization that a product can be tagged with, commonly used for filtering and searching. */
+    productType: Scalars['String'];
+    /** The date and time when the product was published to the channel. */
+    publishedAt: Scalars['DateTime'];
+    /** Whether the product can only be purchased with a selling plan. */
+    requiresSellingPlan: Scalars['Boolean'];
+    /** A list of a product's available selling plan groups. A selling plan group represents a selling method. For example, 'Subscribe and save' is a selling method where customers pay for goods or services per delivery. A selling plan group contains individual selling plans. */
+    sellingPlanGroups: SellingPlanGroupConnection;
+    /** The product's SEO information. */
+    seo: Seo;
+    /**
+     * A comma separated list of tags that have been added to the product.
+     * Additional access scope required for private apps: unauthenticated_read_product_tags.
+     *
+     */
+    tags: Array<Scalars['String']>;
+    /** The products title. */
+    title: Scalars['String'];
+    /** The total quantity of inventory in stock for this Product. */
+    totalInventory?: Maybe<Scalars['Int']>;
+    /**
+     * The date and time when the product was last modified.
+     * A product's `updatedAt` value can change for different reasons. For example, if an order
+     * is placed for a product that has inventory tracking set up, then the inventory adjustment
+     * is counted as an update.
+     *
+     */
+    updatedAt: Scalars['DateTime'];
+    /**
+     * Find a products variant based on its selected options.
+     * This is useful for converting a users selection of product options into a single matching variant.
+     * If there is not a variant for the selected options, `null` will be returned.
+     *
+     */
+    variantBySelectedOptions?: Maybe<ProductVariant>;
+    /** List of the products variants. */
+    variants: ProductVariantConnection;
+    /** The products vendor name. */
+    vendor: Scalars['String'];
+};
+/**
+ * A product represents an individual item for sale in a Shopify store. Products are often physical, but they don't have to be.
+ * For example, a digital download (such as a movie, music or ebook file) also qualifies as a product, as do services (such as equipment rental, work for hire, customization of another product or an extended warranty).
+ */
+export declare type ProductCollectionsArgs = {
+    after?: InputMaybe<Scalars['String']>;
+    before?: InputMaybe<Scalars['String']>;
+    first?: InputMaybe<Scalars['Int']>;
+    last?: InputMaybe<Scalars['Int']>;
+    reverse?: InputMaybe<Scalars['Boolean']>;
+};
+/**
+ * A product represents an individual item for sale in a Shopify store. Products are often physical, but they don't have to be.
+ * For example, a digital download (such as a movie, music or ebook file) also qualifies as a product, as do services (such as equipment rental, work for hire, customization of another product or an extended warranty).
+ */
+export declare type ProductDescriptionArgs = {
+    truncateAt?: InputMaybe<Scalars['Int']>;
+};
+/**
+ * A product represents an individual item for sale in a Shopify store. Products are often physical, but they don't have to be.
+ * For example, a digital download (such as a movie, music or ebook file) also qualifies as a product, as do services (such as equipment rental, work for hire, customization of another product or an extended warranty).
+ */
+export declare type ProductImagesArgs = {
+    after?: InputMaybe<Scalars['String']>;
+    before?: InputMaybe<Scalars['String']>;
+    first?: InputMaybe<Scalars['Int']>;
+    last?: InputMaybe<Scalars['Int']>;
+    reverse?: InputMaybe<Scalars['Boolean']>;
+    sortKey?: InputMaybe<ProductImageSortKeys>;
+};
+/**
+ * A product represents an individual item for sale in a Shopify store. Products are often physical, but they don't have to be.
+ * For example, a digital download (such as a movie, music or ebook file) also qualifies as a product, as do services (such as equipment rental, work for hire, customization of another product or an extended warranty).
+ */
+export declare type ProductMediaArgs = {
+    after?: InputMaybe<Scalars['String']>;
+    before?: InputMaybe<Scalars['String']>;
+    first?: InputMaybe<Scalars['Int']>;
+    last?: InputMaybe<Scalars['Int']>;
+    reverse?: InputMaybe<Scalars['Boolean']>;
+    sortKey?: InputMaybe<ProductMediaSortKeys>;
+};
+/**
+ * A product represents an individual item for sale in a Shopify store. Products are often physical, but they don't have to be.
+ * For example, a digital download (such as a movie, music or ebook file) also qualifies as a product, as do services (such as equipment rental, work for hire, customization of another product or an extended warranty).
+ */
+export declare type ProductMetafieldArgs = {
+    key: Scalars['String'];
+    namespace: Scalars['String'];
+};
+/**
+ * A product represents an individual item for sale in a Shopify store. Products are often physical, but they don't have to be.
+ * For example, a digital download (such as a movie, music or ebook file) also qualifies as a product, as do services (such as equipment rental, work for hire, customization of another product or an extended warranty).
+ */
+export declare type ProductMetafieldsArgs = {
+    identifiers: Array<HasMetafieldsIdentifier>;
+};
+/**
+ * A product represents an individual item for sale in a Shopify store. Products are often physical, but they don't have to be.
+ * For example, a digital download (such as a movie, music or ebook file) also qualifies as a product, as do services (such as equipment rental, work for hire, customization of another product or an extended warranty).
+ */
+export declare type ProductOptionsArgs = {
+    first?: InputMaybe<Scalars['Int']>;
+};
+/**
+ * A product represents an individual item for sale in a Shopify store. Products are often physical, but they don't have to be.
+ * For example, a digital download (such as a movie, music or ebook file) also qualifies as a product, as do services (such as equipment rental, work for hire, customization of another product or an extended warranty).
+ */
+export declare type ProductSellingPlanGroupsArgs = {
+    after?: InputMaybe<Scalars['String']>;
+    before?: InputMaybe<Scalars['String']>;
+    first?: InputMaybe<Scalars['Int']>;
+    last?: InputMaybe<Scalars['Int']>;
+    reverse?: InputMaybe<Scalars['Boolean']>;
+};
+/**
+ * A product represents an individual item for sale in a Shopify store. Products are often physical, but they don't have to be.
+ * For example, a digital download (such as a movie, music or ebook file) also qualifies as a product, as do services (such as equipment rental, work for hire, customization of another product or an extended warranty).
+ */
+export declare type ProductVariantBySelectedOptionsArgs = {
+    selectedOptions: Array<SelectedOptionInput>;
+};
+/**
+ * A product represents an individual item for sale in a Shopify store. Products are often physical, but they don't have to be.
+ * For example, a digital download (such as a movie, music or ebook file) also qualifies as a product, as do services (such as equipment rental, work for hire, customization of another product or an extended warranty).
+ */
+export declare type ProductVariantsArgs = {
+    after?: InputMaybe<Scalars['String']>;
+    before?: InputMaybe<Scalars['String']>;
+    first?: InputMaybe<Scalars['Int']>;
+    last?: InputMaybe<Scalars['Int']>;
+    reverse?: InputMaybe<Scalars['Boolean']>;
+    sortKey?: InputMaybe<ProductVariantSortKeys>;
+};
+/** The set of valid sort keys for the ProductCollection query. */
+export declare enum ProductCollectionSortKeys {
+    /** Sort by the `best-selling` value. */
+    BestSelling = "BEST_SELLING",
+    /** Sort by the `collection-default` value. */
+    CollectionDefault = "COLLECTION_DEFAULT",
+    /** Sort by the `created` value. */
+    Created = "CREATED",
+    /** Sort by the `id` value. */
+    Id = "ID",
+    /** Sort by the `manual` value. */
+    Manual = "MANUAL",
+    /** Sort by the `price` value. */
+    Price = "PRICE",
+    /**
+     * Sort by relevance to the search terms when the `query` parameter is specified on the connection.
+     * Don't use this sort key when no search query is specified.
+     *
+     */
+    Relevance = "RELEVANCE",
+    /** Sort by the `title` value. */
+    Title = "TITLE"
+}
+/**
+ * An auto-generated type for paginating through multiple Products.
+ *
+ */
+export declare type ProductConnection = {
+    __typename?: 'ProductConnection';
+    /** A list of edges. */
+    edges: Array<ProductEdge>;
+    /** A list of available filters. */
+    filters: Array<Filter>;
+    /** A list of the nodes contained in ProductEdge. */
+    nodes: Array<Product>;
+    /** Information to aid in pagination. */
+    pageInfo: PageInfo;
+};
+/**
+ * An auto-generated type which holds one Product and a cursor during pagination.
+ *
+ */
+export declare type ProductEdge = {
+    __typename?: 'ProductEdge';
+    /** A cursor for use in pagination. */
+    cursor: Scalars['String'];
+    /** The item at the end of ProductEdge. */
+    node: Product;
+};
+/** A filter used to view a subset of products in a collection. */
+export declare type ProductFilter = {
+    /** Filter on if the product is available for sale. */
+    available?: InputMaybe<Scalars['Boolean']>;
+    /** A range of prices to filter with-in. */
+    price?: InputMaybe<PriceRangeFilter>;
+    /** A product metafield to filter on. */
+    productMetafield?: InputMaybe<MetafieldFilter>;
+    /** The product type to filter on. */
+    productType?: InputMaybe<Scalars['String']>;
+    /** The product vendor to filter on. */
+    productVendor?: InputMaybe<Scalars['String']>;
+    /** A variant metafield to filter on. */
+    variantMetafield?: InputMaybe<MetafieldFilter>;
+    /** A variant option to filter on. */
+    variantOption?: InputMaybe<VariantOptionFilter>;
+};
+/** The set of valid sort keys for the ProductImage query. */
+export declare enum ProductImageSortKeys {
+    /** Sort by the `created_at` value. */
+    CreatedAt = "CREATED_AT",
+    /** Sort by the `id` value. */
+    Id = "ID",
+    /** Sort by the `position` value. */
+    Position = "POSITION",
+    /**
+     * Sort by relevance to the search terms when the `query` parameter is specified on the connection.
+     * Don't use this sort key when no search query is specified.
+     *
+     */
+    Relevance = "RELEVANCE"
+}
+/** The set of valid sort keys for the ProductMedia query. */
+export declare enum ProductMediaSortKeys {
+    /** Sort by the `id` value. */
+    Id = "ID",
+    /** Sort by the `position` value. */
+    Position = "POSITION",
+    /**
+     * Sort by relevance to the search terms when the `query` parameter is specified on the connection.
+     * Don't use this sort key when no search query is specified.
+     *
+     */
+    Relevance = "RELEVANCE"
+}
+/**
+ * Product property names like "Size", "Color", and "Material" that the customers can select.
+ * Variants are selected based on permutations of these options.
+ * 255 characters limit each.
+ *
+ */
+export declare type ProductOption = Node & {
+    __typename?: 'ProductOption';
+    /** A globally-unique identifier. */
+    id: Scalars['ID'];
+    /** The product options name. */
+    name: Scalars['String'];
+    /** The corresponding value to the product option name. */
+    values: Array<Scalars['String']>;
+};
+/** The price range of the product. */
+export declare type ProductPriceRange = {
+    __typename?: 'ProductPriceRange';
+    /** The highest variant's price. */
+    maxVariantPrice: MoneyV2;
+    /** The lowest variant's price. */
+    minVariantPrice: MoneyV2;
+};
+/** The set of valid sort keys for the Product query. */
+export declare enum ProductSortKeys {
+    /** Sort by the `best_selling` value. */
+    BestSelling = "BEST_SELLING",
+    /** Sort by the `created_at` value. */
+    CreatedAt = "CREATED_AT",
+    /** Sort by the `id` value. */
+    Id = "ID",
+    /** Sort by the `price` value. */
+    Price = "PRICE",
+    /** Sort by the `product_type` value. */
+    ProductType = "PRODUCT_TYPE",
+    /**
+     * Sort by relevance to the search terms when the `query` parameter is specified on the connection.
+     * Don't use this sort key when no search query is specified.
+     *
+     */
+    Relevance = "RELEVANCE",
+    /** Sort by the `title` value. */
+    Title = "TITLE",
+    /** Sort by the `updated_at` value. */
+    UpdatedAt = "UPDATED_AT",
+    /** Sort by the `vendor` value. */
+    Vendor = "VENDOR"
+}
+/** A product variant represents a different version of a product, such as differing sizes or differing colors. */
+export declare type ProductVariant = HasMetafields & Node & {
+    __typename?: 'ProductVariant';
+    /** Indicates if the product variant is available for sale. */
+    availableForSale: Scalars['Boolean'];
+    /** The barcode (for example, ISBN, UPC, or GTIN) associated with the variant. */
+    barcode?: Maybe<Scalars['String']>;
+    /** The compare at price of the variant. This can be used to mark a variant as on sale, when `compareAtPrice` is higher than `price`. */
+    compareAtPrice?: Maybe<MoneyV2>;
+    /**
+     * The compare at price of the variant. This can be used to mark a variant as on sale, when `compareAtPriceV2` is higher than `priceV2`.
+     * @deprecated Use `compareAtPrice` instead.
+     */
+    compareAtPriceV2?: Maybe<MoneyV2>;
+    /** Whether a product is out of stock but still available for purchase (used for backorders). */
+    currentlyNotInStock: Scalars['Boolean'];
+    /** A globally-unique identifier. */
+    id: Scalars['ID'];
+    /**
+     * Image associated with the product variant. This field falls back to the product image if no image is available.
+     *
+     */
+    image?: Maybe<Image>;
+    /** Returns a metafield found by namespace and key. */
+    metafield?: Maybe<Metafield>;
+    /**
+     * The metafields associated with the resource matching the supplied list of namespaces and keys.
+     *
+     */
+    metafields: Array<Maybe<Metafield>>;
+    /** The product variants price. */
+    price: MoneyV2;
+    /**
+     * The product variants price.
+     * @deprecated Use `price` instead.
+     */
+    priceV2: MoneyV2;
+    /** The product object that the product variant belongs to. */
+    product: Product;
+    /** The total sellable quantity of the variant for online sales channels. */
+    quantityAvailable?: Maybe<Scalars['Int']>;
+    /** Whether a customer needs to provide a shipping address when placing an order for the product variant. */
+    requiresShipping: Scalars['Boolean'];
+    /** List of product options applied to the variant. */
+    selectedOptions: Array<SelectedOption>;
+    /** Represents an association between a variant and a selling plan. Selling plan allocations describe which selling plans are available for each variant, and what their impact is on pricing. */
+    sellingPlanAllocations: SellingPlanAllocationConnection;
+    /** The SKU (stock keeping unit) associated with the variant. */
+    sku?: Maybe<Scalars['String']>;
+    /** The in-store pickup availability of this variant by location. */
+    storeAvailability: StoreAvailabilityConnection;
+    /** The product variants title. */
+    title: Scalars['String'];
+    /** The unit price value for the variant based on the variant's measurement. */
+    unitPrice?: Maybe<MoneyV2>;
+    /** The unit price measurement for the variant. */
+    unitPriceMeasurement?: Maybe<UnitPriceMeasurement>;
+    /** The weight of the product variant in the unit system specified with `weight_unit`. */
+    weight?: Maybe<Scalars['Float']>;
+    /** Unit of measurement for weight. */
+    weightUnit: WeightUnit;
+};
+/** A product variant represents a different version of a product, such as differing sizes or differing colors. */
+export declare type ProductVariantMetafieldArgs = {
+    key: Scalars['String'];
+    namespace: Scalars['String'];
+};
+/** A product variant represents a different version of a product, such as differing sizes or differing colors. */
+export declare type ProductVariantMetafieldsArgs = {
+    identifiers: Array<HasMetafieldsIdentifier>;
+};
+/** A product variant represents a different version of a product, such as differing sizes or differing colors. */
+export declare type ProductVariantSellingPlanAllocationsArgs = {
+    after?: InputMaybe<Scalars['String']>;
+    before?: InputMaybe<Scalars['String']>;
+    first?: InputMaybe<Scalars['Int']>;
+    last?: InputMaybe<Scalars['Int']>;
+    reverse?: InputMaybe<Scalars['Boolean']>;
+};
+/** A product variant represents a different version of a product, such as differing sizes or differing colors. */
+export declare type ProductVariantStoreAvailabilityArgs = {
+    after?: InputMaybe<Scalars['String']>;
+    before?: InputMaybe<Scalars['String']>;
+    first?: InputMaybe<Scalars['Int']>;
+    last?: InputMaybe<Scalars['Int']>;
+    reverse?: InputMaybe<Scalars['Boolean']>;
+};
+/**
+ * An auto-generated type for paginating through multiple ProductVariants.
+ *
+ */
+export declare type ProductVariantConnection = {
+    __typename?: 'ProductVariantConnection';
+    /** A list of edges. */
+    edges: Array<ProductVariantEdge>;
+    /** A list of the nodes contained in ProductVariantEdge. */
+    nodes: Array<ProductVariant>;
+    /** Information to aid in pagination. */
+    pageInfo: PageInfo;
+};
+/**
+ * An auto-generated type which holds one ProductVariant and a cursor during pagination.
+ *
+ */
+export declare type ProductVariantEdge = {
+    __typename?: 'ProductVariantEdge';
+    /** A cursor for use in pagination. */
+    cursor: Scalars['String'];
+    /** The item at the end of ProductVariantEdge. */
+    node: ProductVariant;
+};
+/** The set of valid sort keys for the ProductVariant query. */
+export declare enum ProductVariantSortKeys {
+    /** Sort by the `id` value. */
+    Id = "ID",
+    /** Sort by the `position` value. */
+    Position = "POSITION",
+    /**
+     * Sort by relevance to the search terms when the `query` parameter is specified on the connection.
+     * Don't use this sort key when no search query is specified.
+     *
+     */
+    Relevance = "RELEVANCE",
+    /** Sort by the `sku` value. */
+    Sku = "SKU",
+    /** Sort by the `title` value. */
+    Title = "TITLE"
+}
+/** The schemas entry-point for queries. This acts as the public, top-level API from which all queries must start. */
+export declare type QueryRoot = {
+    __typename?: 'QueryRoot';
+    /** List of the shop's articles. */
+    articles: ArticleConnection;
+    /** Fetch a specific `Blog` by one of its unique attributes. */
+    blog?: Maybe<Blog>;
+    /**
+     * Find a blog by its handle.
+     * @deprecated Use `blog` instead.
+     */
+    blogByHandle?: Maybe<Blog>;
+    /** List of the shop's blogs. */
+    blogs: BlogConnection;
+    /**
+     * Retrieve a cart by its ID. For more information, refer to
+     * [Manage a cart with the Storefront API](https://shopify.dev/custom-storefronts/cart/manage).
+     *
+     */
+    cart?: Maybe<Cart>;
+    /** Fetch a specific `Collection` by one of its unique attributes. */
+    collection?: Maybe<Collection>;
+    /**
+     * Find a collection by its handle.
+     * @deprecated Use `collection` instead.
+     */
+    collectionByHandle?: Maybe<Collection>;
+    /** List of the shops collections. */
+    collections: CollectionConnection;
+    /** Find a customer by its access token. */
+    customer?: Maybe<Customer>;
+    /** Returns the localized experiences configured for the shop. */
+    localization: Localization;
+    /**
+     * List of the shop's locations that support in-store pickup.
+     *
+     * When sorting by distance, you must specify a location via the `near` argument.
+     *
+     */
+    locations: LocationConnection;
+    /** A storefront menu. */
+    menu?: Maybe<Menu>;
+    /** Returns a specific node by ID. */
+    node?: Maybe<AppliedGiftCard | Article | Blog | Cart | CartLine | Checkout | CheckoutLineItem | Collection | Comment | ExternalVideo | GenericFile | Location | MailingAddress | MediaImage | Menu | MenuItem | Metafield | Model3d | Order | Page | Payment | Product | ProductOption | ProductVariant | Shop | ShopPolicy | UrlRedirect | Video>;
+    /** Returns the list of nodes with the given IDs. */
+    nodes: Array<Maybe<AppliedGiftCard | Article | Blog | Cart | CartLine | Checkout | CheckoutLineItem | Collection | Comment | ExternalVideo | GenericFile | Location | MailingAddress | MediaImage | Menu | MenuItem | Metafield | Model3d | Order | Page | Payment | Product | ProductOption | ProductVariant | Shop | ShopPolicy | UrlRedirect | Video>>;
+    /** Fetch a specific `Page` by one of its unique attributes. */
+    page?: Maybe<Page>;
+    /**
+     * Find a page by its handle.
+     * @deprecated Use `page` instead.
+     */
+    pageByHandle?: Maybe<Page>;
+    /** List of the shop's pages. */
+    pages: PageConnection;
+    /** Fetch a specific `Product` by one of its unique attributes. */
+    product?: Maybe<Product>;
+    /**
+     * Find a product by its handle.
+     * @deprecated Use `product` instead.
+     */
+    productByHandle?: Maybe<Product>;
+    /**
+     * Find recommended products related to a given `product_id`.
+     * To learn more about how recommendations are generated, see
+     * [*Showing product recommendations on product pages*](https://help.shopify.com/themes/development/recommended-products).
+     *
+     */
+    productRecommendations?: Maybe<Array<Product>>;
+    /**
+     * Tags added to products.
+     * Additional access scope required: unauthenticated_read_product_tags.
+     *
+     */
+    productTags: StringConnection;
+    /** List of product types for the shop's products that are published to your app. */
+    productTypes: StringConnection;
+    /** List of the shops products. */
+    products: ProductConnection;
+    /** The list of public Storefront API versions, including supported, release candidate and unstable versions. */
+    publicApiVersions: Array<ApiVersion>;
+    /** The shop associated with the storefront access token. */
+    shop: Shop;
+    /** A list of redirects for a shop. */
+    urlRedirects: UrlRedirectConnection;
+};
+/** The schemas entry-point for queries. This acts as the public, top-level API from which all queries must start. */
+export declare type QueryRootArticlesArgs = {
+    after?: InputMaybe<Scalars['String']>;
+    before?: InputMaybe<Scalars['String']>;
+    first?: InputMaybe<Scalars['Int']>;
+    last?: InputMaybe<Scalars['Int']>;
+    query?: InputMaybe<Scalars['String']>;
+    reverse?: InputMaybe<Scalars['Boolean']>;
+    sortKey?: InputMaybe<ArticleSortKeys>;
+};
+/** The schemas entry-point for queries. This acts as the public, top-level API from which all queries must start. */
+export declare type QueryRootBlogArgs = {
+    handle?: InputMaybe<Scalars['String']>;
+    id?: InputMaybe<Scalars['ID']>;
+};
+/** The schemas entry-point for queries. This acts as the public, top-level API from which all queries must start. */
+export declare type QueryRootBlogByHandleArgs = {
+    handle: Scalars['String'];
+};
+/** The schemas entry-point for queries. This acts as the public, top-level API from which all queries must start. */
+export declare type QueryRootBlogsArgs = {
+    after?: InputMaybe<Scalars['String']>;
+    before?: InputMaybe<Scalars['String']>;
+    first?: InputMaybe<Scalars['Int']>;
+    last?: InputMaybe<Scalars['Int']>;
+    query?: InputMaybe<Scalars['String']>;
+    reverse?: InputMaybe<Scalars['Boolean']>;
+    sortKey?: InputMaybe<BlogSortKeys>;
+};
+/** The schemas entry-point for queries. This acts as the public, top-level API from which all queries must start. */
+export declare type QueryRootCartArgs = {
+    id: Scalars['ID'];
+};
+/** The schemas entry-point for queries. This acts as the public, top-level API from which all queries must start. */
+export declare type QueryRootCollectionArgs = {
+    handle?: InputMaybe<Scalars['String']>;
+    id?: InputMaybe<Scalars['ID']>;
+};
+/** The schemas entry-point for queries. This acts as the public, top-level API from which all queries must start. */
+export declare type QueryRootCollectionByHandleArgs = {
+    handle: Scalars['String'];
+};
+/** The schemas entry-point for queries. This acts as the public, top-level API from which all queries must start. */
+export declare type QueryRootCollectionsArgs = {
+    after?: InputMaybe<Scalars['String']>;
+    before?: InputMaybe<Scalars['String']>;
+    first?: InputMaybe<Scalars['Int']>;
+    last?: InputMaybe<Scalars['Int']>;
+    query?: InputMaybe<Scalars['String']>;
+    reverse?: InputMaybe<Scalars['Boolean']>;
+    sortKey?: InputMaybe<CollectionSortKeys>;
+};
+/** The schemas entry-point for queries. This acts as the public, top-level API from which all queries must start. */
+export declare type QueryRootCustomerArgs = {
+    customerAccessToken: Scalars['String'];
+};
+/** The schemas entry-point for queries. This acts as the public, top-level API from which all queries must start. */
+export declare type QueryRootLocationsArgs = {
+    after?: InputMaybe<Scalars['String']>;
+    before?: InputMaybe<Scalars['String']>;
+    first?: InputMaybe<Scalars['Int']>;
+    last?: InputMaybe<Scalars['Int']>;
+    near?: InputMaybe<GeoCoordinateInput>;
+    reverse?: InputMaybe<Scalars['Boolean']>;
+    sortKey?: InputMaybe<LocationSortKeys>;
+};
+/** The schemas entry-point for queries. This acts as the public, top-level API from which all queries must start. */
+export declare type QueryRootMenuArgs = {
+    handle: Scalars['String'];
+};
+/** The schemas entry-point for queries. This acts as the public, top-level API from which all queries must start. */
+export declare type QueryRootNodeArgs = {
+    id: Scalars['ID'];
+};
+/** The schemas entry-point for queries. This acts as the public, top-level API from which all queries must start. */
+export declare type QueryRootNodesArgs = {
+    ids: Array<Scalars['ID']>;
+};
+/** The schemas entry-point for queries. This acts as the public, top-level API from which all queries must start. */
+export declare type QueryRootPageArgs = {
+    handle?: InputMaybe<Scalars['String']>;
+    id?: InputMaybe<Scalars['ID']>;
+};
+/** The schemas entry-point for queries. This acts as the public, top-level API from which all queries must start. */
+export declare type QueryRootPageByHandleArgs = {
+    handle: Scalars['String'];
+};
+/** The schemas entry-point for queries. This acts as the public, top-level API from which all queries must start. */
+export declare type QueryRootPagesArgs = {
+    after?: InputMaybe<Scalars['String']>;
+    before?: InputMaybe<Scalars['String']>;
+    first?: InputMaybe<Scalars['Int']>;
+    last?: InputMaybe<Scalars['Int']>;
+    query?: InputMaybe<Scalars['String']>;
+    reverse?: InputMaybe<Scalars['Boolean']>;
+    sortKey?: InputMaybe<PageSortKeys>;
+};
+/** The schemas entry-point for queries. This acts as the public, top-level API from which all queries must start. */
+export declare type QueryRootProductArgs = {
+    handle?: InputMaybe<Scalars['String']>;
+    id?: InputMaybe<Scalars['ID']>;
+};
+/** The schemas entry-point for queries. This acts as the public, top-level API from which all queries must start. */
+export declare type QueryRootProductByHandleArgs = {
+    handle: Scalars['String'];
+};
+/** The schemas entry-point for queries. This acts as the public, top-level API from which all queries must start. */
+export declare type QueryRootProductRecommendationsArgs = {
+    productId: Scalars['ID'];
+};
+/** The schemas entry-point for queries. This acts as the public, top-level API from which all queries must start. */
+export declare type QueryRootProductTagsArgs = {
+    first: Scalars['Int'];
+};
+/** The schemas entry-point for queries. This acts as the public, top-level API from which all queries must start. */
+export declare type QueryRootProductTypesArgs = {
+    first: Scalars['Int'];
+};
+/** The schemas entry-point for queries. This acts as the public, top-level API from which all queries must start. */
+export declare type QueryRootProductsArgs = {
+    after?: InputMaybe<Scalars['String']>;
+    before?: InputMaybe<Scalars['String']>;
+    first?: InputMaybe<Scalars['Int']>;
+    last?: InputMaybe<Scalars['Int']>;
+    query?: InputMaybe<Scalars['String']>;
+    reverse?: InputMaybe<Scalars['Boolean']>;
+    sortKey?: InputMaybe<ProductSortKeys>;
+};
+/** The schemas entry-point for queries. This acts as the public, top-level API from which all queries must start. */
+export declare type QueryRootUrlRedirectsArgs = {
+    after?: InputMaybe<Scalars['String']>;
+    before?: InputMaybe<Scalars['String']>;
+    first?: InputMaybe<Scalars['Int']>;
+    last?: InputMaybe<Scalars['Int']>;
+    reverse?: InputMaybe<Scalars['Boolean']>;
+};
+/** SEO information. */
+export declare type Seo = {
+    __typename?: 'SEO';
+    /** The meta description. */
+    description?: Maybe<Scalars['String']>;
+    /** The SEO title. */
+    title?: Maybe<Scalars['String']>;
+};
+/**
+ * Script discount applications capture the intentions of a discount that
+ * was created by a Shopify Script.
+ *
+ */
+export declare type ScriptDiscountApplication = DiscountApplication & {
+    __typename?: 'ScriptDiscountApplication';
+    /** The method by which the discount's value is allocated to its entitled items. */
+    allocationMethod: DiscountApplicationAllocationMethod;
+    /** Which lines of targetType that the discount is allocated over. */
+    targetSelection: DiscountApplicationTargetSelection;
+    /** The type of line that the discount is applicable towards. */
+    targetType: DiscountApplicationTargetType;
+    /** The title of the application as defined by the Script. */
+    title: Scalars['String'];
+    /** The value of the discount application. */
+    value: PricingValue;
+};
+/**
+ * Properties used by customers to select a product variant.
+ * Products can have multiple options, like different sizes or colors.
+ *
+ */
+export declare type SelectedOption = {
+    __typename?: 'SelectedOption';
+    /** The product options name. */
+    name: Scalars['String'];
+    /** The product options value. */
+    value: Scalars['String'];
+};
+/** Specifies the input fields required for a selected option. */
+export declare type SelectedOptionInput = {
+    /** The product options name. */
+    name: Scalars['String'];
+    /** The product options value. */
+    value: Scalars['String'];
+};
+/** Represents how products and variants can be sold and purchased. */
+export declare type SellingPlan = {
+    __typename?: 'SellingPlan';
+    /** The initial payment due for the purchase. */
+    checkoutCharge: SellingPlanCheckoutCharge;
+    /** The description of the selling plan. */
+    description?: Maybe<Scalars['String']>;
+    /** A globally-unique identifier. */
+    id: Scalars['ID'];
+    /** The name of the selling plan. For example, '6 weeks of prepaid granola, delivered weekly'. */
+    name: Scalars['String'];
+    /** The selling plan options available in the drop-down list in the storefront. For example, 'Delivery every week' or 'Delivery every 2 weeks' specifies the delivery frequency options for the product. Individual selling plans contribute their options to the associated selling plan group. For example, a selling plan group might have an option called `option1: Delivery every`. One selling plan in that group could contribute `option1: 2 weeks` with the pricing for that option, and another selling plan could contribute `option1: 4 weeks`, with different pricing. */
+    options: Array<SellingPlanOption>;
+    /** The price adjustments that a selling plan makes when a variant is purchased with a selling plan. */
+    priceAdjustments: Array<SellingPlanPriceAdjustment>;
+    /** Whether purchasing the selling plan will result in multiple deliveries. */
+    recurringDeliveries: Scalars['Boolean'];
+};
+/** Represents an association between a variant and a selling plan. Selling plan allocations describe the options offered for each variant, and the price of the variant when purchased with a selling plan. */
+export declare type SellingPlanAllocation = {
+    __typename?: 'SellingPlanAllocation';
+    /** The checkout charge amount due for the purchase. */
+    checkoutChargeAmount: MoneyV2;
+    /** A list of price adjustments, with a maximum of two. When there are two, the first price adjustment goes into effect at the time of purchase, while the second one starts after a certain number of orders. A price adjustment represents how a selling plan affects pricing when a variant is purchased with a selling plan. Prices display in the customer's currency if the shop is configured for it. */
+    priceAdjustments: Array<SellingPlanAllocationPriceAdjustment>;
+    /** The remaining balance charge amount due for the purchase. */
+    remainingBalanceChargeAmount: MoneyV2;
+    /** A representation of how products and variants can be sold and purchased. For example, an individual selling plan could be '6 weeks of prepaid granola, delivered weekly'. */
+    sellingPlan: SellingPlan;
+};
+/**
+ * An auto-generated type for paginating through multiple SellingPlanAllocations.
+ *
+ */
+export declare type SellingPlanAllocationConnection = {
+    __typename?: 'SellingPlanAllocationConnection';
+    /** A list of edges. */
+    edges: Array<SellingPlanAllocationEdge>;
+    /** A list of the nodes contained in SellingPlanAllocationEdge. */
+    nodes: Array<SellingPlanAllocation>;
+    /** Information to aid in pagination. */
+    pageInfo: PageInfo;
+};
+/**
+ * An auto-generated type which holds one SellingPlanAllocation and a cursor during pagination.
+ *
+ */
+export declare type SellingPlanAllocationEdge = {
+    __typename?: 'SellingPlanAllocationEdge';
+    /** A cursor for use in pagination. */
+    cursor: Scalars['String'];
+    /** The item at the end of SellingPlanAllocationEdge. */
+    node: SellingPlanAllocation;
+};
+/** The resulting prices for variants when they're purchased with a specific selling plan. */
+export declare type SellingPlanAllocationPriceAdjustment = {
+    __typename?: 'SellingPlanAllocationPriceAdjustment';
+    /** The price of the variant when it's purchased without a selling plan for the same number of deliveries. For example, if a customer purchases 6 deliveries of $10.00 granola separately, then the price is 6 x $10.00 = $60.00. */
+    compareAtPrice: MoneyV2;
+    /** The effective price for a single delivery. For example, for a prepaid subscription plan that includes 6 deliveries at the price of $48.00, the per delivery price is $8.00. */
+    perDeliveryPrice: MoneyV2;
+    /** The price of the variant when it's purchased with a selling plan For example, for a prepaid subscription plan that includes 6 deliveries of $10.00 granola, where the customer gets 20% off, the price is 6 x $10.00 x 0.80 = $48.00. */
+    price: MoneyV2;
+    /** The resulting price per unit for the variant associated with the selling plan. If the variant isn't sold by quantity or measurement, then this field returns `null`. */
+    unitPrice?: Maybe<MoneyV2>;
+};
+/** The initial payment due for the purchase. */
+export declare type SellingPlanCheckoutCharge = {
+    __typename?: 'SellingPlanCheckoutCharge';
+    /** The charge type for the checkout charge. */
+    type: SellingPlanCheckoutChargeType;
+    /** The charge value for the checkout charge. */
+    value: SellingPlanCheckoutChargeValue;
+};
+/** The percentage value of the price used for checkout charge. */
+export declare type SellingPlanCheckoutChargePercentageValue = {
+    __typename?: 'SellingPlanCheckoutChargePercentageValue';
+    /** The percentage value of the price used for checkout charge. */
+    percentage: Scalars['Float'];
+};
+/** The checkout charge when the full amount isn't charged at checkout. */
+export declare enum SellingPlanCheckoutChargeType {
+    /** The checkout charge is a percentage of the product or variant price. */
+    Percentage = "PERCENTAGE",
+    /** The checkout charge is a fixed price amount. */
+    Price = "PRICE"
+}
+/** The portion of the price to be charged at checkout. */
+export declare type SellingPlanCheckoutChargeValue = MoneyV2 | SellingPlanCheckoutChargePercentageValue;
+/**
+ * An auto-generated type for paginating through multiple SellingPlans.
+ *
+ */
+export declare type SellingPlanConnection = {
+    __typename?: 'SellingPlanConnection';
+    /** A list of edges. */
+    edges: Array<SellingPlanEdge>;
+    /** A list of the nodes contained in SellingPlanEdge. */
+    nodes: Array<SellingPlan>;
+    /** Information to aid in pagination. */
+    pageInfo: PageInfo;
+};
+/**
+ * An auto-generated type which holds one SellingPlan and a cursor during pagination.
+ *
+ */
+export declare type SellingPlanEdge = {
+    __typename?: 'SellingPlanEdge';
+    /** A cursor for use in pagination. */
+    cursor: Scalars['String'];
+    /** The item at the end of SellingPlanEdge. */
+    node: SellingPlan;
+};
+/** A fixed amount that's deducted from the original variant price. For example, $10.00 off. */
+export declare type SellingPlanFixedAmountPriceAdjustment = {
+    __typename?: 'SellingPlanFixedAmountPriceAdjustment';
+    /** The money value of the price adjustment. */
+    adjustmentAmount: MoneyV2;
+};
+/** A fixed price adjustment for a variant that's purchased with a selling plan. */
+export declare type SellingPlanFixedPriceAdjustment = {
+    __typename?: 'SellingPlanFixedPriceAdjustment';
+    /** A new price of the variant when it's purchased with the selling plan. */
+    price: MoneyV2;
+};
+/** Represents a selling method. For example, 'Subscribe and save' is a selling method where customers pay for goods or services per delivery. A selling plan group contains individual selling plans. */
+export declare type SellingPlanGroup = {
+    __typename?: 'SellingPlanGroup';
+    /** A display friendly name for the app that created the selling plan group. */
+    appName?: Maybe<Scalars['String']>;
+    /** The name of the selling plan group. */
+    name: Scalars['String'];
+    /** Represents the selling plan options available in the drop-down list in the storefront. For example, 'Delivery every week' or 'Delivery every 2 weeks' specifies the delivery frequency options for the product. */
+    options: Array<SellingPlanGroupOption>;
+    /** A list of selling plans in a selling plan group. A selling plan is a representation of how products and variants can be sold and purchased. For example, an individual selling plan could be '6 weeks of prepaid granola, delivered weekly'. */
+    sellingPlans: SellingPlanConnection;
+};
+/** Represents a selling method. For example, 'Subscribe and save' is a selling method where customers pay for goods or services per delivery. A selling plan group contains individual selling plans. */
+export declare type SellingPlanGroupSellingPlansArgs = {
+    after?: InputMaybe<Scalars['String']>;
+    before?: InputMaybe<Scalars['String']>;
+    first?: InputMaybe<Scalars['Int']>;
+    last?: InputMaybe<Scalars['Int']>;
+    reverse?: InputMaybe<Scalars['Boolean']>;
+};
+/**
+ * An auto-generated type for paginating through multiple SellingPlanGroups.
+ *
+ */
+export declare type SellingPlanGroupConnection = {
+    __typename?: 'SellingPlanGroupConnection';
+    /** A list of edges. */
+    edges: Array<SellingPlanGroupEdge>;
+    /** A list of the nodes contained in SellingPlanGroupEdge. */
+    nodes: Array<SellingPlanGroup>;
+    /** Information to aid in pagination. */
+    pageInfo: PageInfo;
+};
+/**
+ * An auto-generated type which holds one SellingPlanGroup and a cursor during pagination.
+ *
+ */
+export declare type SellingPlanGroupEdge = {
+    __typename?: 'SellingPlanGroupEdge';
+    /** A cursor for use in pagination. */
+    cursor: Scalars['String'];
+    /** The item at the end of SellingPlanGroupEdge. */
+    node: SellingPlanGroup;
+};
+/**
+ * Represents an option on a selling plan group that's available in the drop-down list in the storefront.
+ *
+ * Individual selling plans contribute their options to the associated selling plan group. For example, a selling plan group might have an option called `option1: Delivery every`. One selling plan in that group could contribute `option1: 2 weeks` with the pricing for that option, and another selling plan could contribute `option1: 4 weeks`, with different pricing.
+ */
+export declare type SellingPlanGroupOption = {
+    __typename?: 'SellingPlanGroupOption';
+    /** The name of the option. For example, 'Delivery every'. */
+    name: Scalars['String'];
+    /** The values for the options specified by the selling plans in the selling plan group. For example, '1 week', '2 weeks', '3 weeks'. */
+    values: Array<Scalars['String']>;
+};
+/** An option provided by a Selling Plan. */
+export declare type SellingPlanOption = {
+    __typename?: 'SellingPlanOption';
+    /** The name of the option (ie "Delivery every"). */
+    name?: Maybe<Scalars['String']>;
+    /** The value of the option (ie "Month"). */
+    value?: Maybe<Scalars['String']>;
+};
+/** A percentage amount that's deducted from the original variant price. For example, 10% off. */
+export declare type SellingPlanPercentagePriceAdjustment = {
+    __typename?: 'SellingPlanPercentagePriceAdjustment';
+    /** The percentage value of the price adjustment. */
+    adjustmentPercentage: Scalars['Int'];
+};
+/** Represents by how much the price of a variant associated with a selling plan is adjusted. Each variant can have up to two price adjustments. If a variant has multiple price adjustments, then the first price adjustment applies when the variant is initially purchased. The second price adjustment applies after a certain number of orders (specified by the `orderCount` field) are made. If a selling plan doesn't have any price adjustments, then the unadjusted price of the variant is the effective price. */
+export declare type SellingPlanPriceAdjustment = {
+    __typename?: 'SellingPlanPriceAdjustment';
+    /** The type of price adjustment. An adjustment value can have one of three types: percentage, amount off, or a new price. */
+    adjustmentValue: SellingPlanPriceAdjustmentValue;
+    /** The number of orders that the price adjustment applies to. If the price adjustment always applies, then this field is `null`. */
+    orderCount?: Maybe<Scalars['Int']>;
+};
+/** Represents by how much the price of a variant associated with a selling plan is adjusted. Each variant can have up to two price adjustments. */
+export declare type SellingPlanPriceAdjustmentValue = SellingPlanFixedAmountPriceAdjustment | SellingPlanFixedPriceAdjustment | SellingPlanPercentagePriceAdjustment;
+/** A shipping rate to be applied to a checkout. */
+export declare type ShippingRate = {
+    __typename?: 'ShippingRate';
+    /** Human-readable unique identifier for this shipping rate. */
+    handle: Scalars['String'];
+    /** Price of this shipping rate. */
+    price: MoneyV2;
+    /**
+     * Price of this shipping rate.
+     * @deprecated Use `price` instead.
+     */
+    priceV2: MoneyV2;
+    /** Title of this shipping rate. */
+    title: Scalars['String'];
+};
+/** Shop represents a collection of the general settings and information about the shop. */
+export declare type Shop = HasMetafields & Node & {
+    __typename?: 'Shop';
+    /** The shop's branding configuration. */
+    brand?: Maybe<Brand>;
+    /** A description of the shop. */
+    description?: Maybe<Scalars['String']>;
+    /** A globally-unique identifier. */
+    id: Scalars['ID'];
+    /** Returns a metafield found by namespace and key. */
+    metafield?: Maybe<Metafield>;
+    /**
+     * The metafields associated with the resource matching the supplied list of namespaces and keys.
+     *
+     */
+    metafields: Array<Maybe<Metafield>>;
+    /** A string representing the way currency is formatted when the currency isnt specified. */
+    moneyFormat: Scalars['String'];
+    /** The shops name. */
+    name: Scalars['String'];
+    /** Settings related to payments. */
+    paymentSettings: PaymentSettings;
+    /** The primary domain of the shops Online Store. */
+    primaryDomain: Domain;
+    /** The shops privacy policy. */
+    privacyPolicy?: Maybe<ShopPolicy>;
+    /** The shops refund policy. */
+    refundPolicy?: Maybe<ShopPolicy>;
+    /** The shops shipping policy. */
+    shippingPolicy?: Maybe<ShopPolicy>;
+    /** Countries that the shop ships to. */
+    shipsToCountries: Array<CountryCode>;
+    /** The shops subscription policy. */
+    subscriptionPolicy?: Maybe<ShopPolicyWithDefault>;
+    /** The shops terms of service. */
+    termsOfService?: Maybe<ShopPolicy>;
+};
+/** Shop represents a collection of the general settings and information about the shop. */
+export declare type ShopMetafieldArgs = {
+    key: Scalars['String'];
+    namespace: Scalars['String'];
+};
+/** Shop represents a collection of the general settings and information about the shop. */
+export declare type ShopMetafieldsArgs = {
+    identifiers: Array<HasMetafieldsIdentifier>;
+};
+/** Policy that a merchant has configured for their store, such as their refund or privacy policy. */
+export declare type ShopPolicy = Node & {
+    __typename?: 'ShopPolicy';
+    /** Policy text, maximum size of 64kb. */
+    body: Scalars['String'];
+    /** Policys handle. */
+    handle: Scalars['String'];
+    /** A globally-unique identifier. */
+    id: Scalars['ID'];
+    /** Policys title. */
+    title: Scalars['String'];
+    /** Public URL to the policy. */
+    url: Scalars['URL'];
+};
+/**
+ * A policy for the store that comes with a default value, such as a subscription policy.
+ * If the merchant hasn't configured a policy for their store, then the policy will return the default value.
+ * Otherwise, the policy will return the merchant-configured value.
+ *
+ */
+export declare type ShopPolicyWithDefault = {
+    __typename?: 'ShopPolicyWithDefault';
+    /** The text of the policy. Maximum size: 64KB. */
+    body: Scalars['String'];
+    /** The handle of the policy. */
+    handle: Scalars['String'];
+    /** The unique identifier of the policy. A default policy doesn't have an ID. */
+    id?: Maybe<Scalars['ID']>;
+    /** The title of the policy. */
+    title: Scalars['String'];
+    /** Public URL to the policy. */
+    url: Scalars['URL'];
+};
+/**
+ * The availability of a product variant at a particular location.
+ * Local pick-up must be enabled in the  store's shipping settings, otherwise this will return an empty result.
+ *
+ */
+export declare type StoreAvailability = {
+    __typename?: 'StoreAvailability';
+    /** Whether the product variant is in-stock at this location. */
+    available: Scalars['Boolean'];
+    /** The location where this product variant is stocked at. */
+    location: Location;
+    /** Returns the estimated amount of time it takes for pickup to be ready (Example: Usually ready in 24 hours). */
+    pickUpTime: Scalars['String'];
+};
+/**
+ * An auto-generated type for paginating through multiple StoreAvailabilities.
+ *
+ */
+export declare type StoreAvailabilityConnection = {
+    __typename?: 'StoreAvailabilityConnection';
+    /** A list of edges. */
+    edges: Array<StoreAvailabilityEdge>;
+    /** A list of the nodes contained in StoreAvailabilityEdge. */
+    nodes: Array<StoreAvailability>;
+    /** Information to aid in pagination. */
+    pageInfo: PageInfo;
+};
+/**
+ * An auto-generated type which holds one StoreAvailability and a cursor during pagination.
+ *
+ */
+export declare type StoreAvailabilityEdge = {
+    __typename?: 'StoreAvailabilityEdge';
+    /** A cursor for use in pagination. */
+    cursor: Scalars['String'];
+    /** The item at the end of StoreAvailabilityEdge. */
+    node: StoreAvailability;
+};
+/**
+ * An auto-generated type for paginating through a list of Strings.
+ *
+ */
+export declare type StringConnection = {
+    __typename?: 'StringConnection';
+    /** A list of edges. */
+    edges: Array<StringEdge>;
+    /** Information to aid in pagination. */
+    pageInfo: PageInfo;
+};
+/**
+ * An auto-generated type which holds one String and a cursor during pagination.
+ *
+ */
+export declare type StringEdge = {
+    __typename?: 'StringEdge';
+    /** A cursor for use in pagination. */
+    cursor: Scalars['String'];
+    /** The item at the end of StringEdge. */
+    node: Scalars['String'];
+};
+/**
+ * Specifies the fields required to complete a checkout with
+ * a tokenized payment.
+ *
+ */
+export declare type TokenizedPaymentInputV3 = {
+    /** The billing address for the payment. */
+    billingAddress: MailingAddressInput;
+    /** A unique client generated key used to avoid duplicate charges. When a duplicate payment is found, the original is returned instead of creating a new one. For more information, refer to [Idempotent requests](https://shopify.dev/api/usage/idempotent-requests). */
+    idempotencyKey: Scalars['String'];
+    /** Public Hash Key used for AndroidPay payments only. */
+    identifier?: InputMaybe<Scalars['String']>;
+    /** The amount and currency of the payment. */
+    paymentAmount: MoneyInput;
+    /** A simple string or JSON containing the required payment data for the tokenized payment. */
+    paymentData: Scalars['String'];
+    /** Whether to execute the payment in test mode, if possible. Test mode is not supported in production stores. Defaults to `false`. */
+    test?: InputMaybe<Scalars['Boolean']>;
+    /** The type of payment token. */
+    type: PaymentTokenType;
+};
+/** An object representing exchange of money for a product or service. */
+export declare type Transaction = {
+    __typename?: 'Transaction';
+    /** The amount of money that the transaction was for. */
+    amount: MoneyV2;
+    /**
+     * The amount of money that the transaction was for.
+     * @deprecated Use `amount` instead.
+     */
+    amountV2: MoneyV2;
+    /** The kind of the transaction. */
+    kind: TransactionKind;
+    /**
+     * The status of the transaction.
+     * @deprecated Use `statusV2` instead.
+     */
+    status: TransactionStatus;
+    /** The status of the transaction. */
+    statusV2?: Maybe<TransactionStatus>;
+    /** Whether the transaction was done in test mode or not. */
+    test: Scalars['Boolean'];
+};
+/** The different kinds of order transactions. */
+export declare enum TransactionKind {
+    /**
+     * An amount reserved against the cardholder's funding source.
+     * Money does not change hands until the authorization is captured.
+     *
+     */
+    Authorization = "AUTHORIZATION",
+    /** A transfer of the money that was reserved during the authorization stage. */
+    Capture = "CAPTURE",
+    /** Money returned to the customer when they have paid too much. */
+    Change = "CHANGE",
+    /** An authorization for a payment taken with an EMV credit card reader. */
+    EmvAuthorization = "EMV_AUTHORIZATION",
+    /** An authorization and capture performed together in a single step. */
+    Sale = "SALE"
+}
+/** Transaction statuses describe the status of a transaction. */
+export declare enum TransactionStatus {
+    /** There was an error while processing the transaction. */
+    Error = "ERROR",
+    /** The transaction failed. */
+    Failure = "FAILURE",
+    /** The transaction is pending. */
+    Pending = "PENDING",
+    /** The transaction succeeded. */
+    Success = "SUCCESS"
+}
+/**
+ * The measurement used to calculate a unit price for a product variant (e.g. $9.99 / 100ml).
+ *
+ */
+export declare type UnitPriceMeasurement = {
+    __typename?: 'UnitPriceMeasurement';
+    /** The type of unit of measurement for the unit price measurement. */
+    measuredType?: Maybe<UnitPriceMeasurementMeasuredType>;
+    /** The quantity unit for the unit price measurement. */
+    quantityUnit?: Maybe<UnitPriceMeasurementMeasuredUnit>;
+    /** The quantity value for the unit price measurement. */
+    quantityValue: Scalars['Float'];
+    /** The reference unit for the unit price measurement. */
+    referenceUnit?: Maybe<UnitPriceMeasurementMeasuredUnit>;
+    /** The reference value for the unit price measurement. */
+    referenceValue: Scalars['Int'];
+};
+/** The accepted types of unit of measurement. */
+export declare enum UnitPriceMeasurementMeasuredType {
+    /** Unit of measurements representing areas. */
+    Area = "AREA",
+    /** Unit of measurements representing lengths. */
+    Length = "LENGTH",
+    /** Unit of measurements representing volumes. */
+    Volume = "VOLUME",
+    /** Unit of measurements representing weights. */
+    Weight = "WEIGHT"
+}
+/** The valid units of measurement for a unit price measurement. */
+export declare enum UnitPriceMeasurementMeasuredUnit {
+    /** 100 centiliters equals 1 liter. */
+    Cl = "CL",
+    /** 100 centimeters equals 1 meter. */
+    Cm = "CM",
+    /** Metric system unit of weight. */
+    G = "G",
+    /** 1 kilogram equals 1000 grams. */
+    Kg = "KG",
+    /** Metric system unit of volume. */
+    L = "L",
+    /** Metric system unit of length. */
+    M = "M",
+    /** Metric system unit of area. */
+    M2 = "M2",
+    /** 1 cubic meter equals 1000 liters. */
+    M3 = "M3",
+    /** 1000 milligrams equals 1 gram. */
+    Mg = "MG",
+    /** 1000 milliliters equals 1 liter. */
+    Ml = "ML",
+    /** 1000 millimeters equals 1 meter. */
+    Mm = "MM"
+}
+/** Systems of weights and measures. */
+export declare enum UnitSystem {
+    /** Imperial system of weights and measures. */
+    ImperialSystem = "IMPERIAL_SYSTEM",
+    /** Metric system of weights and measures. */
+    MetricSystem = "METRIC_SYSTEM"
+}
+/** A redirect on the online store. */
+export declare type UrlRedirect = Node & {
+    __typename?: 'UrlRedirect';
+    /** The ID of the URL redirect. */
+    id: Scalars['ID'];
+    /** The old path to be redirected from. When the user visits this path, they'll be redirected to the target location. */
+    path: Scalars['String'];
+    /** The target location where the user will be redirected to. */
+    target: Scalars['String'];
+};
+/**
+ * An auto-generated type for paginating through multiple UrlRedirects.
+ *
+ */
+export declare type UrlRedirectConnection = {
+    __typename?: 'UrlRedirectConnection';
+    /** A list of edges. */
+    edges: Array<UrlRedirectEdge>;
+    /** A list of the nodes contained in UrlRedirectEdge. */
+    nodes: Array<UrlRedirect>;
+    /** Information to aid in pagination. */
+    pageInfo: PageInfo;
+};
+/**
+ * An auto-generated type which holds one UrlRedirect and a cursor during pagination.
+ *
+ */
+export declare type UrlRedirectEdge = {
+    __typename?: 'UrlRedirectEdge';
+    /** A cursor for use in pagination. */
+    cursor: Scalars['String'];
+    /** The item at the end of UrlRedirectEdge. */
+    node: UrlRedirect;
+};
+/** Represents an error in the input of a mutation. */
+export declare type UserError = DisplayableError & {
+    __typename?: 'UserError';
+    /** The path to the input field that caused the error. */
+    field?: Maybe<Array<Scalars['String']>>;
+    /** The error message. */
+    message: Scalars['String'];
+};
+/** A filter used to view a subset of products in a collection matching a specific variant option. */
+export declare type VariantOptionFilter = {
+    /** The name of the variant option to filter on. */
+    name: Scalars['String'];
+    /** The value of the variant option to filter on. */
+    value: Scalars['String'];
+};
+/** Represents a Shopify hosted video. */
+export declare type Video = Media & Node & {
+    __typename?: 'Video';
+    /** A word or phrase to share the nature or contents of a media. */
+    alt?: Maybe<Scalars['String']>;
+    /** A globally-unique identifier. */
+    id: Scalars['ID'];
+    /** The media content type. */
+    mediaContentType: MediaContentType;
+    /** The preview image for the media. */
+    previewImage?: Maybe<Image>;
+    /** The sources for a video. */
+    sources: Array<VideoSource>;
+};
+/** Represents a source for a Shopify hosted video. */
+export declare type VideoSource = {
+    __typename?: 'VideoSource';
+    /** The format of the video source. */
+    format: Scalars['String'];
+    /** The height of the video. */
+    height: Scalars['Int'];
+    /** The video MIME type. */
+    mimeType: Scalars['String'];
+    /** The URL of the video. */
+    url: Scalars['String'];
+    /** The width of the video. */
+    width: Scalars['Int'];
+};
+/** Units of measurement for weight. */
+export declare enum WeightUnit {
+    /** Metric system unit of mass. */
+    Grams = "GRAMS",
+    /** 1 kilogram equals 1000 grams. */
+    Kilograms = "KILOGRAMS",
+    /** Imperial system unit of mass. */
+    Ounces = "OUNCES",
+    /** 1 pound equals 16 ounces. */
+    Pounds = "POUNDS"
+}
diff --git a/dist/dist/esnext/storefront-api-types.js b/dist/dist/esnext/storefront-api-types.js
new file mode 100644
index 0000000000000000000000000000000000000000..c44228028f189004cc20b758eca22a39d081ba31
--- /dev/null
+++ b/dist/dist/esnext/storefront-api-types.js
@@ -0,0 +1,1775 @@
+/** The set of valid sort keys for the Article query. */
+export var ArticleSortKeys;
+(function (ArticleSortKeys) {
+    /** Sort by the `author` value. */
+    ArticleSortKeys["Author"] = "AUTHOR";
+    /** Sort by the `blog_title` value. */
+    ArticleSortKeys["BlogTitle"] = "BLOG_TITLE";
+    /** Sort by the `id` value. */
+    ArticleSortKeys["Id"] = "ID";
+    /** Sort by the `published_at` value. */
+    ArticleSortKeys["PublishedAt"] = "PUBLISHED_AT";
+    /**
+     * Sort by relevance to the search terms when the `query` parameter is specified on the connection.
+     * Don't use this sort key when no search query is specified.
+     *
+     */
+    ArticleSortKeys["Relevance"] = "RELEVANCE";
+    /** Sort by the `title` value. */
+    ArticleSortKeys["Title"] = "TITLE";
+    /** Sort by the `updated_at` value. */
+    ArticleSortKeys["UpdatedAt"] = "UPDATED_AT";
+})(ArticleSortKeys || (ArticleSortKeys = {}));
+/** The set of valid sort keys for the Blog query. */
+export var BlogSortKeys;
+(function (BlogSortKeys) {
+    /** Sort by the `handle` value. */
+    BlogSortKeys["Handle"] = "HANDLE";
+    /** Sort by the `id` value. */
+    BlogSortKeys["Id"] = "ID";
+    /**
+     * Sort by relevance to the search terms when the `query` parameter is specified on the connection.
+     * Don't use this sort key when no search query is specified.
+     *
+     */
+    BlogSortKeys["Relevance"] = "RELEVANCE";
+    /** Sort by the `title` value. */
+    BlogSortKeys["Title"] = "TITLE";
+})(BlogSortKeys || (BlogSortKeys = {}));
+/** Card brand, such as Visa or Mastercard, which can be used for payments. */
+export var CardBrand;
+(function (CardBrand) {
+    /** American Express. */
+    CardBrand["AmericanExpress"] = "AMERICAN_EXPRESS";
+    /** Diners Club. */
+    CardBrand["DinersClub"] = "DINERS_CLUB";
+    /** Discover. */
+    CardBrand["Discover"] = "DISCOVER";
+    /** JCB. */
+    CardBrand["Jcb"] = "JCB";
+    /** Mastercard. */
+    CardBrand["Mastercard"] = "MASTERCARD";
+    /** Visa. */
+    CardBrand["Visa"] = "VISA";
+})(CardBrand || (CardBrand = {}));
+/** Possible error codes that can be returned by `CartUserError`. */
+export var CartErrorCode;
+(function (CartErrorCode) {
+    /** The input value is invalid. */
+    CartErrorCode["Invalid"] = "INVALID";
+    /** Merchandise line was not found in cart. */
+    CartErrorCode["InvalidMerchandiseLine"] = "INVALID_MERCHANDISE_LINE";
+    /** The input value should be less than the maximum value allowed. */
+    CartErrorCode["LessThan"] = "LESS_THAN";
+    /** Missing discount code. */
+    CartErrorCode["MissingDiscountCode"] = "MISSING_DISCOUNT_CODE";
+    /** Missing note. */
+    CartErrorCode["MissingNote"] = "MISSING_NOTE";
+})(CartErrorCode || (CartErrorCode = {}));
+/** Possible error codes that can be returned by `CheckoutUserError`. */
+export var CheckoutErrorCode;
+(function (CheckoutErrorCode) {
+    /** Checkout is already completed. */
+    CheckoutErrorCode["AlreadyCompleted"] = "ALREADY_COMPLETED";
+    /** Input email contains an invalid domain name. */
+    CheckoutErrorCode["BadDomain"] = "BAD_DOMAIN";
+    /** The input value is blank. */
+    CheckoutErrorCode["Blank"] = "BLANK";
+    /** Cart does not meet discount requirements notice. */
+    CheckoutErrorCode["CartDoesNotMeetDiscountRequirementsNotice"] = "CART_DOES_NOT_MEET_DISCOUNT_REQUIREMENTS_NOTICE";
+    /** Customer already used once per customer discount notice. */
+    CheckoutErrorCode["CustomerAlreadyUsedOncePerCustomerDiscountNotice"] = "CUSTOMER_ALREADY_USED_ONCE_PER_CUSTOMER_DISCOUNT_NOTICE";
+    /** Discount already applied. */
+    CheckoutErrorCode["DiscountAlreadyApplied"] = "DISCOUNT_ALREADY_APPLIED";
+    /** Discount disabled. */
+    CheckoutErrorCode["DiscountDisabled"] = "DISCOUNT_DISABLED";
+    /** Discount expired. */
+    CheckoutErrorCode["DiscountExpired"] = "DISCOUNT_EXPIRED";
+    /** Discount limit reached. */
+    CheckoutErrorCode["DiscountLimitReached"] = "DISCOUNT_LIMIT_REACHED";
+    /** Discount not found. */
+    CheckoutErrorCode["DiscountNotFound"] = "DISCOUNT_NOT_FOUND";
+    /** Checkout is already completed. */
+    CheckoutErrorCode["Empty"] = "EMPTY";
+    /** Queue token has expired. */
+    CheckoutErrorCode["ExpiredQueueToken"] = "EXPIRED_QUEUE_TOKEN";
+    /** Gift card has already been applied. */
+    CheckoutErrorCode["GiftCardAlreadyApplied"] = "GIFT_CARD_ALREADY_APPLIED";
+    /** Gift card code is invalid. */
+    CheckoutErrorCode["GiftCardCodeInvalid"] = "GIFT_CARD_CODE_INVALID";
+    /** Gift card currency does not match checkout currency. */
+    CheckoutErrorCode["GiftCardCurrencyMismatch"] = "GIFT_CARD_CURRENCY_MISMATCH";
+    /** Gift card has no funds left. */
+    CheckoutErrorCode["GiftCardDepleted"] = "GIFT_CARD_DEPLETED";
+    /** Gift card is disabled. */
+    CheckoutErrorCode["GiftCardDisabled"] = "GIFT_CARD_DISABLED";
+    /** Gift card is expired. */
+    CheckoutErrorCode["GiftCardExpired"] = "GIFT_CARD_EXPIRED";
+    /** Gift card was not found. */
+    CheckoutErrorCode["GiftCardNotFound"] = "GIFT_CARD_NOT_FOUND";
+    /** Gift card cannot be applied to a checkout that contains a gift card. */
+    CheckoutErrorCode["GiftCardUnusable"] = "GIFT_CARD_UNUSABLE";
+    /** The input value should be greater than or equal to the minimum value allowed. */
+    CheckoutErrorCode["GreaterThanOrEqualTo"] = "GREATER_THAN_OR_EQUAL_TO";
+    /** Higher value discount applied. */
+    CheckoutErrorCode["HigherValueDiscountApplied"] = "HIGHER_VALUE_DISCOUNT_APPLIED";
+    /** The input value is invalid. */
+    CheckoutErrorCode["Invalid"] = "INVALID";
+    /** Cannot specify country and presentment currency code. */
+    CheckoutErrorCode["InvalidCountryAndCurrency"] = "INVALID_COUNTRY_AND_CURRENCY";
+    /** Input Zip is invalid for country provided. */
+    CheckoutErrorCode["InvalidForCountry"] = "INVALID_FOR_COUNTRY";
+    /** Input Zip is invalid for country and province provided. */
+    CheckoutErrorCode["InvalidForCountryAndProvince"] = "INVALID_FOR_COUNTRY_AND_PROVINCE";
+    /** Invalid province in country. */
+    CheckoutErrorCode["InvalidProvinceInCountry"] = "INVALID_PROVINCE_IN_COUNTRY";
+    /** Queue token is invalid. */
+    CheckoutErrorCode["InvalidQueueToken"] = "INVALID_QUEUE_TOKEN";
+    /** Invalid region in country. */
+    CheckoutErrorCode["InvalidRegionInCountry"] = "INVALID_REGION_IN_COUNTRY";
+    /** Invalid state in country. */
+    CheckoutErrorCode["InvalidStateInCountry"] = "INVALID_STATE_IN_COUNTRY";
+    /** The input value should be less than the maximum value allowed. */
+    CheckoutErrorCode["LessThan"] = "LESS_THAN";
+    /** The input value should be less than or equal to the maximum value allowed. */
+    CheckoutErrorCode["LessThanOrEqualTo"] = "LESS_THAN_OR_EQUAL_TO";
+    /** Line item was not found in checkout. */
+    CheckoutErrorCode["LineItemNotFound"] = "LINE_ITEM_NOT_FOUND";
+    /** Checkout is locked. */
+    CheckoutErrorCode["Locked"] = "LOCKED";
+    /** Maximum number of discount codes limit reached. */
+    CheckoutErrorCode["MaximumDiscountCodeLimitReached"] = "MAXIMUM_DISCOUNT_CODE_LIMIT_REACHED";
+    /** Missing payment input. */
+    CheckoutErrorCode["MissingPaymentInput"] = "MISSING_PAYMENT_INPUT";
+    /** Not enough in stock. */
+    CheckoutErrorCode["NotEnoughInStock"] = "NOT_ENOUGH_IN_STOCK";
+    /** Input value is not supported. */
+    CheckoutErrorCode["NotSupported"] = "NOT_SUPPORTED";
+    /** The input value needs to be blank. */
+    CheckoutErrorCode["Present"] = "PRESENT";
+    /** Shipping rate expired. */
+    CheckoutErrorCode["ShippingRateExpired"] = "SHIPPING_RATE_EXPIRED";
+    /** Throttled during checkout. */
+    CheckoutErrorCode["ThrottledDuringCheckout"] = "THROTTLED_DURING_CHECKOUT";
+    /** The input value is too long. */
+    CheckoutErrorCode["TooLong"] = "TOO_LONG";
+    /** The amount of the payment does not match the value to be paid. */
+    CheckoutErrorCode["TotalPriceMismatch"] = "TOTAL_PRICE_MISMATCH";
+    /** Unable to apply discount. */
+    CheckoutErrorCode["UnableToApply"] = "UNABLE_TO_APPLY";
+})(CheckoutErrorCode || (CheckoutErrorCode = {}));
+/** The set of valid sort keys for the Collection query. */
+export var CollectionSortKeys;
+(function (CollectionSortKeys) {
+    /** Sort by the `id` value. */
+    CollectionSortKeys["Id"] = "ID";
+    /**
+     * Sort by relevance to the search terms when the `query` parameter is specified on the connection.
+     * Don't use this sort key when no search query is specified.
+     *
+     */
+    CollectionSortKeys["Relevance"] = "RELEVANCE";
+    /** Sort by the `title` value. */
+    CollectionSortKeys["Title"] = "TITLE";
+    /** Sort by the `updated_at` value. */
+    CollectionSortKeys["UpdatedAt"] = "UPDATED_AT";
+})(CollectionSortKeys || (CollectionSortKeys = {}));
+/**
+ * The code designating a country/region, which generally follows ISO 3166-1 alpha-2 guidelines.
+ * If a territory doesn't have a country code value in the `CountryCode` enum, then it might be considered a subdivision
+ * of another country. For example, the territories associated with Spain are represented by the country code `ES`,
+ * and the territories associated with the United States of America are represented by the country code `US`.
+ *
+ */
+export var CountryCode;
+(function (CountryCode) {
+    /** Ascension Island. */
+    CountryCode["Ac"] = "AC";
+    /** Andorra. */
+    CountryCode["Ad"] = "AD";
+    /** United Arab Emirates. */
+    CountryCode["Ae"] = "AE";
+    /** Afghanistan. */
+    CountryCode["Af"] = "AF";
+    /** Antigua & Barbuda. */
+    CountryCode["Ag"] = "AG";
+    /** Anguilla. */
+    CountryCode["Ai"] = "AI";
+    /** Albania. */
+    CountryCode["Al"] = "AL";
+    /** Armenia. */
+    CountryCode["Am"] = "AM";
+    /** Netherlands Antilles. */
+    CountryCode["An"] = "AN";
+    /** Angola. */
+    CountryCode["Ao"] = "AO";
+    /** Argentina. */
+    CountryCode["Ar"] = "AR";
+    /** Austria. */
+    CountryCode["At"] = "AT";
+    /** Australia. */
+    CountryCode["Au"] = "AU";
+    /** Aruba. */
+    CountryCode["Aw"] = "AW";
+    /** land Islands. */
+    CountryCode["Ax"] = "AX";
+    /** Azerbaijan. */
+    CountryCode["Az"] = "AZ";
+    /** Bosnia & Herzegovina. */
+    CountryCode["Ba"] = "BA";
+    /** Barbados. */
+    CountryCode["Bb"] = "BB";
+    /** Bangladesh. */
+    CountryCode["Bd"] = "BD";
+    /** Belgium. */
+    CountryCode["Be"] = "BE";
+    /** Burkina Faso. */
+    CountryCode["Bf"] = "BF";
+    /** Bulgaria. */
+    CountryCode["Bg"] = "BG";
+    /** Bahrain. */
+    CountryCode["Bh"] = "BH";
+    /** Burundi. */
+    CountryCode["Bi"] = "BI";
+    /** Benin. */
+    CountryCode["Bj"] = "BJ";
+    /** St. Barthlemy. */
+    CountryCode["Bl"] = "BL";
+    /** Bermuda. */
+    CountryCode["Bm"] = "BM";
+    /** Brunei. */
+    CountryCode["Bn"] = "BN";
+    /** Bolivia. */
+    CountryCode["Bo"] = "BO";
+    /** Caribbean Netherlands. */
+    CountryCode["Bq"] = "BQ";
+    /** Brazil. */
+    CountryCode["Br"] = "BR";
+    /** Bahamas. */
+    CountryCode["Bs"] = "BS";
+    /** Bhutan. */
+    CountryCode["Bt"] = "BT";
+    /** Bouvet Island. */
+    CountryCode["Bv"] = "BV";
+    /** Botswana. */
+    CountryCode["Bw"] = "BW";
+    /** Belarus. */
+    CountryCode["By"] = "BY";
+    /** Belize. */
+    CountryCode["Bz"] = "BZ";
+    /** Canada. */
+    CountryCode["Ca"] = "CA";
+    /** Cocos (Keeling) Islands. */
+    CountryCode["Cc"] = "CC";
+    /** Congo - Kinshasa. */
+    CountryCode["Cd"] = "CD";
+    /** Central African Republic. */
+    CountryCode["Cf"] = "CF";
+    /** Congo - Brazzaville. */
+    CountryCode["Cg"] = "CG";
+    /** Switzerland. */
+    CountryCode["Ch"] = "CH";
+    /** Cte dIvoire. */
+    CountryCode["Ci"] = "CI";
+    /** Cook Islands. */
+    CountryCode["Ck"] = "CK";
+    /** Chile. */
+    CountryCode["Cl"] = "CL";
+    /** Cameroon. */
+    CountryCode["Cm"] = "CM";
+    /** China. */
+    CountryCode["Cn"] = "CN";
+    /** Colombia. */
+    CountryCode["Co"] = "CO";
+    /** Costa Rica. */
+    CountryCode["Cr"] = "CR";
+    /** Cuba. */
+    CountryCode["Cu"] = "CU";
+    /** Cape Verde. */
+    CountryCode["Cv"] = "CV";
+    /** Curaao. */
+    CountryCode["Cw"] = "CW";
+    /** Christmas Island. */
+    CountryCode["Cx"] = "CX";
+    /** Cyprus. */
+    CountryCode["Cy"] = "CY";
+    /** Czechia. */
+    CountryCode["Cz"] = "CZ";
+    /** Germany. */
+    CountryCode["De"] = "DE";
+    /** Djibouti. */
+    CountryCode["Dj"] = "DJ";
+    /** Denmark. */
+    CountryCode["Dk"] = "DK";
+    /** Dominica. */
+    CountryCode["Dm"] = "DM";
+    /** Dominican Republic. */
+    CountryCode["Do"] = "DO";
+    /** Algeria. */
+    CountryCode["Dz"] = "DZ";
+    /** Ecuador. */
+    CountryCode["Ec"] = "EC";
+    /** Estonia. */
+    CountryCode["Ee"] = "EE";
+    /** Egypt. */
+    CountryCode["Eg"] = "EG";
+    /** Western Sahara. */
+    CountryCode["Eh"] = "EH";
+    /** Eritrea. */
+    CountryCode["Er"] = "ER";
+    /** Spain. */
+    CountryCode["Es"] = "ES";
+    /** Ethiopia. */
+    CountryCode["Et"] = "ET";
+    /** Finland. */
+    CountryCode["Fi"] = "FI";
+    /** Fiji. */
+    CountryCode["Fj"] = "FJ";
+    /** Falkland Islands. */
+    CountryCode["Fk"] = "FK";
+    /** Faroe Islands. */
+    CountryCode["Fo"] = "FO";
+    /** France. */
+    CountryCode["Fr"] = "FR";
+    /** Gabon. */
+    CountryCode["Ga"] = "GA";
+    /** United Kingdom. */
+    CountryCode["Gb"] = "GB";
+    /** Grenada. */
+    CountryCode["Gd"] = "GD";
+    /** Georgia. */
+    CountryCode["Ge"] = "GE";
+    /** French Guiana. */
+    CountryCode["Gf"] = "GF";
+    /** Guernsey. */
+    CountryCode["Gg"] = "GG";
+    /** Ghana. */
+    CountryCode["Gh"] = "GH";
+    /** Gibraltar. */
+    CountryCode["Gi"] = "GI";
+    /** Greenland. */
+    CountryCode["Gl"] = "GL";
+    /** Gambia. */
+    CountryCode["Gm"] = "GM";
+    /** Guinea. */
+    CountryCode["Gn"] = "GN";
+    /** Guadeloupe. */
+    CountryCode["Gp"] = "GP";
+    /** Equatorial Guinea. */
+    CountryCode["Gq"] = "GQ";
+    /** Greece. */
+    CountryCode["Gr"] = "GR";
+    /** South Georgia & South Sandwich Islands. */
+    CountryCode["Gs"] = "GS";
+    /** Guatemala. */
+    CountryCode["Gt"] = "GT";
+    /** Guinea-Bissau. */
+    CountryCode["Gw"] = "GW";
+    /** Guyana. */
+    CountryCode["Gy"] = "GY";
+    /** Hong Kong SAR. */
+    CountryCode["Hk"] = "HK";
+    /** Heard & McDonald Islands. */
+    CountryCode["Hm"] = "HM";
+    /** Honduras. */
+    CountryCode["Hn"] = "HN";
+    /** Croatia. */
+    CountryCode["Hr"] = "HR";
+    /** Haiti. */
+    CountryCode["Ht"] = "HT";
+    /** Hungary. */
+    CountryCode["Hu"] = "HU";
+    /** Indonesia. */
+    CountryCode["Id"] = "ID";
+    /** Ireland. */
+    CountryCode["Ie"] = "IE";
+    /** Israel. */
+    CountryCode["Il"] = "IL";
+    /** Isle of Man. */
+    CountryCode["Im"] = "IM";
+    /** India. */
+    CountryCode["In"] = "IN";
+    /** British Indian Ocean Territory. */
+    CountryCode["Io"] = "IO";
+    /** Iraq. */
+    CountryCode["Iq"] = "IQ";
+    /** Iran. */
+    CountryCode["Ir"] = "IR";
+    /** Iceland. */
+    CountryCode["Is"] = "IS";
+    /** Italy. */
+    CountryCode["It"] = "IT";
+    /** Jersey. */
+    CountryCode["Je"] = "JE";
+    /** Jamaica. */
+    CountryCode["Jm"] = "JM";
+    /** Jordan. */
+    CountryCode["Jo"] = "JO";
+    /** Japan. */
+    CountryCode["Jp"] = "JP";
+    /** Kenya. */
+    CountryCode["Ke"] = "KE";
+    /** Kyrgyzstan. */
+    CountryCode["Kg"] = "KG";
+    /** Cambodia. */
+    CountryCode["Kh"] = "KH";
+    /** Kiribati. */
+    CountryCode["Ki"] = "KI";
+    /** Comoros. */
+    CountryCode["Km"] = "KM";
+    /** St. Kitts & Nevis. */
+    CountryCode["Kn"] = "KN";
+    /** North Korea. */
+    CountryCode["Kp"] = "KP";
+    /** South Korea. */
+    CountryCode["Kr"] = "KR";
+    /** Kuwait. */
+    CountryCode["Kw"] = "KW";
+    /** Cayman Islands. */
+    CountryCode["Ky"] = "KY";
+    /** Kazakhstan. */
+    CountryCode["Kz"] = "KZ";
+    /** Laos. */
+    CountryCode["La"] = "LA";
+    /** Lebanon. */
+    CountryCode["Lb"] = "LB";
+    /** St. Lucia. */
+    CountryCode["Lc"] = "LC";
+    /** Liechtenstein. */
+    CountryCode["Li"] = "LI";
+    /** Sri Lanka. */
+    CountryCode["Lk"] = "LK";
+    /** Liberia. */
+    CountryCode["Lr"] = "LR";
+    /** Lesotho. */
+    CountryCode["Ls"] = "LS";
+    /** Lithuania. */
+    CountryCode["Lt"] = "LT";
+    /** Luxembourg. */
+    CountryCode["Lu"] = "LU";
+    /** Latvia. */
+    CountryCode["Lv"] = "LV";
+    /** Libya. */
+    CountryCode["Ly"] = "LY";
+    /** Morocco. */
+    CountryCode["Ma"] = "MA";
+    /** Monaco. */
+    CountryCode["Mc"] = "MC";
+    /** Moldova. */
+    CountryCode["Md"] = "MD";
+    /** Montenegro. */
+    CountryCode["Me"] = "ME";
+    /** St. Martin. */
+    CountryCode["Mf"] = "MF";
+    /** Madagascar. */
+    CountryCode["Mg"] = "MG";
+    /** North Macedonia. */
+    CountryCode["Mk"] = "MK";
+    /** Mali. */
+    CountryCode["Ml"] = "ML";
+    /** Myanmar (Burma). */
+    CountryCode["Mm"] = "MM";
+    /** Mongolia. */
+    CountryCode["Mn"] = "MN";
+    /** Macao SAR. */
+    CountryCode["Mo"] = "MO";
+    /** Martinique. */
+    CountryCode["Mq"] = "MQ";
+    /** Mauritania. */
+    CountryCode["Mr"] = "MR";
+    /** Montserrat. */
+    CountryCode["Ms"] = "MS";
+    /** Malta. */
+    CountryCode["Mt"] = "MT";
+    /** Mauritius. */
+    CountryCode["Mu"] = "MU";
+    /** Maldives. */
+    CountryCode["Mv"] = "MV";
+    /** Malawi. */
+    CountryCode["Mw"] = "MW";
+    /** Mexico. */
+    CountryCode["Mx"] = "MX";
+    /** Malaysia. */
+    CountryCode["My"] = "MY";
+    /** Mozambique. */
+    CountryCode["Mz"] = "MZ";
+    /** Namibia. */
+    CountryCode["Na"] = "NA";
+    /** New Caledonia. */
+    CountryCode["Nc"] = "NC";
+    /** Niger. */
+    CountryCode["Ne"] = "NE";
+    /** Norfolk Island. */
+    CountryCode["Nf"] = "NF";
+    /** Nigeria. */
+    CountryCode["Ng"] = "NG";
+    /** Nicaragua. */
+    CountryCode["Ni"] = "NI";
+    /** Netherlands. */
+    CountryCode["Nl"] = "NL";
+    /** Norway. */
+    CountryCode["No"] = "NO";
+    /** Nepal. */
+    CountryCode["Np"] = "NP";
+    /** Nauru. */
+    CountryCode["Nr"] = "NR";
+    /** Niue. */
+    CountryCode["Nu"] = "NU";
+    /** New Zealand. */
+    CountryCode["Nz"] = "NZ";
+    /** Oman. */
+    CountryCode["Om"] = "OM";
+    /** Panama. */
+    CountryCode["Pa"] = "PA";
+    /** Peru. */
+    CountryCode["Pe"] = "PE";
+    /** French Polynesia. */
+    CountryCode["Pf"] = "PF";
+    /** Papua New Guinea. */
+    CountryCode["Pg"] = "PG";
+    /** Philippines. */
+    CountryCode["Ph"] = "PH";
+    /** Pakistan. */
+    CountryCode["Pk"] = "PK";
+    /** Poland. */
+    CountryCode["Pl"] = "PL";
+    /** St. Pierre & Miquelon. */
+    CountryCode["Pm"] = "PM";
+    /** Pitcairn Islands. */
+    CountryCode["Pn"] = "PN";
+    /** Palestinian Territories. */
+    CountryCode["Ps"] = "PS";
+    /** Portugal. */
+    CountryCode["Pt"] = "PT";
+    /** Paraguay. */
+    CountryCode["Py"] = "PY";
+    /** Qatar. */
+    CountryCode["Qa"] = "QA";
+    /** Runion. */
+    CountryCode["Re"] = "RE";
+    /** Romania. */
+    CountryCode["Ro"] = "RO";
+    /** Serbia. */
+    CountryCode["Rs"] = "RS";
+    /** Russia. */
+    CountryCode["Ru"] = "RU";
+    /** Rwanda. */
+    CountryCode["Rw"] = "RW";
+    /** Saudi Arabia. */
+    CountryCode["Sa"] = "SA";
+    /** Solomon Islands. */
+    CountryCode["Sb"] = "SB";
+    /** Seychelles. */
+    CountryCode["Sc"] = "SC";
+    /** Sudan. */
+    CountryCode["Sd"] = "SD";
+    /** Sweden. */
+    CountryCode["Se"] = "SE";
+    /** Singapore. */
+    CountryCode["Sg"] = "SG";
+    /** St. Helena. */
+    CountryCode["Sh"] = "SH";
+    /** Slovenia. */
+    CountryCode["Si"] = "SI";
+    /** Svalbard & Jan Mayen. */
+    CountryCode["Sj"] = "SJ";
+    /** Slovakia. */
+    CountryCode["Sk"] = "SK";
+    /** Sierra Leone. */
+    CountryCode["Sl"] = "SL";
+    /** San Marino. */
+    CountryCode["Sm"] = "SM";
+    /** Senegal. */
+    CountryCode["Sn"] = "SN";
+    /** Somalia. */
+    CountryCode["So"] = "SO";
+    /** Suriname. */
+    CountryCode["Sr"] = "SR";
+    /** South Sudan. */
+    CountryCode["Ss"] = "SS";
+    /** So Tom & Prncipe. */
+    CountryCode["St"] = "ST";
+    /** El Salvador. */
+    CountryCode["Sv"] = "SV";
+    /** Sint Maarten. */
+    CountryCode["Sx"] = "SX";
+    /** Syria. */
+    CountryCode["Sy"] = "SY";
+    /** Eswatini. */
+    CountryCode["Sz"] = "SZ";
+    /** Tristan da Cunha. */
+    CountryCode["Ta"] = "TA";
+    /** Turks & Caicos Islands. */
+    CountryCode["Tc"] = "TC";
+    /** Chad. */
+    CountryCode["Td"] = "TD";
+    /** French Southern Territories. */
+    CountryCode["Tf"] = "TF";
+    /** Togo. */
+    CountryCode["Tg"] = "TG";
+    /** Thailand. */
+    CountryCode["Th"] = "TH";
+    /** Tajikistan. */
+    CountryCode["Tj"] = "TJ";
+    /** Tokelau. */
+    CountryCode["Tk"] = "TK";
+    /** Timor-Leste. */
+    CountryCode["Tl"] = "TL";
+    /** Turkmenistan. */
+    CountryCode["Tm"] = "TM";
+    /** Tunisia. */
+    CountryCode["Tn"] = "TN";
+    /** Tonga. */
+    CountryCode["To"] = "TO";
+    /** Turkey. */
+    CountryCode["Tr"] = "TR";
+    /** Trinidad & Tobago. */
+    CountryCode["Tt"] = "TT";
+    /** Tuvalu. */
+    CountryCode["Tv"] = "TV";
+    /** Taiwan. */
+    CountryCode["Tw"] = "TW";
+    /** Tanzania. */
+    CountryCode["Tz"] = "TZ";
+    /** Ukraine. */
+    CountryCode["Ua"] = "UA";
+    /** Uganda. */
+    CountryCode["Ug"] = "UG";
+    /** U.S. Outlying Islands. */
+    CountryCode["Um"] = "UM";
+    /** United States. */
+    CountryCode["Us"] = "US";
+    /** Uruguay. */
+    CountryCode["Uy"] = "UY";
+    /** Uzbekistan. */
+    CountryCode["Uz"] = "UZ";
+    /** Vatican City. */
+    CountryCode["Va"] = "VA";
+    /** St. Vincent & Grenadines. */
+    CountryCode["Vc"] = "VC";
+    /** Venezuela. */
+    CountryCode["Ve"] = "VE";
+    /** British Virgin Islands. */
+    CountryCode["Vg"] = "VG";
+    /** Vietnam. */
+    CountryCode["Vn"] = "VN";
+    /** Vanuatu. */
+    CountryCode["Vu"] = "VU";
+    /** Wallis & Futuna. */
+    CountryCode["Wf"] = "WF";
+    /** Samoa. */
+    CountryCode["Ws"] = "WS";
+    /** Kosovo. */
+    CountryCode["Xk"] = "XK";
+    /** Yemen. */
+    CountryCode["Ye"] = "YE";
+    /** Mayotte. */
+    CountryCode["Yt"] = "YT";
+    /** South Africa. */
+    CountryCode["Za"] = "ZA";
+    /** Zambia. */
+    CountryCode["Zm"] = "ZM";
+    /** Zimbabwe. */
+    CountryCode["Zw"] = "ZW";
+    /** Unknown Region. */
+    CountryCode["Zz"] = "ZZ";
+})(CountryCode || (CountryCode = {}));
+/** The part of the image that should remain after cropping. */
+export var CropRegion;
+(function (CropRegion) {
+    /** Keep the bottom of the image. */
+    CropRegion["Bottom"] = "BOTTOM";
+    /** Keep the center of the image. */
+    CropRegion["Center"] = "CENTER";
+    /** Keep the left of the image. */
+    CropRegion["Left"] = "LEFT";
+    /** Keep the right of the image. */
+    CropRegion["Right"] = "RIGHT";
+    /** Keep the top of the image. */
+    CropRegion["Top"] = "TOP";
+})(CropRegion || (CropRegion = {}));
+/**
+ * The three-letter currency codes that represent the world currencies used in stores. These include standard ISO 4217 codes, legacy codes,
+ * and non-standard codes.
+ *
+ */
+export var CurrencyCode;
+(function (CurrencyCode) {
+    /** United Arab Emirates Dirham (AED). */
+    CurrencyCode["Aed"] = "AED";
+    /** Afghan Afghani (AFN). */
+    CurrencyCode["Afn"] = "AFN";
+    /** Albanian Lek (ALL). */
+    CurrencyCode["All"] = "ALL";
+    /** Armenian Dram (AMD). */
+    CurrencyCode["Amd"] = "AMD";
+    /** Netherlands Antillean Guilder. */
+    CurrencyCode["Ang"] = "ANG";
+    /** Angolan Kwanza (AOA). */
+    CurrencyCode["Aoa"] = "AOA";
+    /** Argentine Pesos (ARS). */
+    CurrencyCode["Ars"] = "ARS";
+    /** Australian Dollars (AUD). */
+    CurrencyCode["Aud"] = "AUD";
+    /** Aruban Florin (AWG). */
+    CurrencyCode["Awg"] = "AWG";
+    /** Azerbaijani Manat (AZN). */
+    CurrencyCode["Azn"] = "AZN";
+    /** Bosnia and Herzegovina Convertible Mark (BAM). */
+    CurrencyCode["Bam"] = "BAM";
+    /** Barbadian Dollar (BBD). */
+    CurrencyCode["Bbd"] = "BBD";
+    /** Bangladesh Taka (BDT). */
+    CurrencyCode["Bdt"] = "BDT";
+    /** Bulgarian Lev (BGN). */
+    CurrencyCode["Bgn"] = "BGN";
+    /** Bahraini Dinar (BHD). */
+    CurrencyCode["Bhd"] = "BHD";
+    /** Burundian Franc (BIF). */
+    CurrencyCode["Bif"] = "BIF";
+    /** Bermudian Dollar (BMD). */
+    CurrencyCode["Bmd"] = "BMD";
+    /** Brunei Dollar (BND). */
+    CurrencyCode["Bnd"] = "BND";
+    /** Bolivian Boliviano (BOB). */
+    CurrencyCode["Bob"] = "BOB";
+    /** Brazilian Real (BRL). */
+    CurrencyCode["Brl"] = "BRL";
+    /** Bahamian Dollar (BSD). */
+    CurrencyCode["Bsd"] = "BSD";
+    /** Bhutanese Ngultrum (BTN). */
+    CurrencyCode["Btn"] = "BTN";
+    /** Botswana Pula (BWP). */
+    CurrencyCode["Bwp"] = "BWP";
+    /** Belarusian Ruble (BYN). */
+    CurrencyCode["Byn"] = "BYN";
+    /** Belarusian Ruble (BYR). */
+    CurrencyCode["Byr"] = "BYR";
+    /** Belize Dollar (BZD). */
+    CurrencyCode["Bzd"] = "BZD";
+    /** Canadian Dollars (CAD). */
+    CurrencyCode["Cad"] = "CAD";
+    /** Congolese franc (CDF). */
+    CurrencyCode["Cdf"] = "CDF";
+    /** Swiss Francs (CHF). */
+    CurrencyCode["Chf"] = "CHF";
+    /** Chilean Peso (CLP). */
+    CurrencyCode["Clp"] = "CLP";
+    /** Chinese Yuan Renminbi (CNY). */
+    CurrencyCode["Cny"] = "CNY";
+    /** Colombian Peso (COP). */
+    CurrencyCode["Cop"] = "COP";
+    /** Costa Rican Colones (CRC). */
+    CurrencyCode["Crc"] = "CRC";
+    /** Cape Verdean escudo (CVE). */
+    CurrencyCode["Cve"] = "CVE";
+    /** Czech Koruny (CZK). */
+    CurrencyCode["Czk"] = "CZK";
+    /** Djiboutian Franc (DJF). */
+    CurrencyCode["Djf"] = "DJF";
+    /** Danish Kroner (DKK). */
+    CurrencyCode["Dkk"] = "DKK";
+    /** Dominican Peso (DOP). */
+    CurrencyCode["Dop"] = "DOP";
+    /** Algerian Dinar (DZD). */
+    CurrencyCode["Dzd"] = "DZD";
+    /** Egyptian Pound (EGP). */
+    CurrencyCode["Egp"] = "EGP";
+    /** Eritrean Nakfa (ERN). */
+    CurrencyCode["Ern"] = "ERN";
+    /** Ethiopian Birr (ETB). */
+    CurrencyCode["Etb"] = "ETB";
+    /** Euro (EUR). */
+    CurrencyCode["Eur"] = "EUR";
+    /** Fijian Dollars (FJD). */
+    CurrencyCode["Fjd"] = "FJD";
+    /** Falkland Islands Pounds (FKP). */
+    CurrencyCode["Fkp"] = "FKP";
+    /** United Kingdom Pounds (GBP). */
+    CurrencyCode["Gbp"] = "GBP";
+    /** Georgian Lari (GEL). */
+    CurrencyCode["Gel"] = "GEL";
+    /** Ghanaian Cedi (GHS). */
+    CurrencyCode["Ghs"] = "GHS";
+    /** Gibraltar Pounds (GIP). */
+    CurrencyCode["Gip"] = "GIP";
+    /** Gambian Dalasi (GMD). */
+    CurrencyCode["Gmd"] = "GMD";
+    /** Guinean Franc (GNF). */
+    CurrencyCode["Gnf"] = "GNF";
+    /** Guatemalan Quetzal (GTQ). */
+    CurrencyCode["Gtq"] = "GTQ";
+    /** Guyanese Dollar (GYD). */
+    CurrencyCode["Gyd"] = "GYD";
+    /** Hong Kong Dollars (HKD). */
+    CurrencyCode["Hkd"] = "HKD";
+    /** Honduran Lempira (HNL). */
+    CurrencyCode["Hnl"] = "HNL";
+    /** Croatian Kuna (HRK). */
+    CurrencyCode["Hrk"] = "HRK";
+    /** Haitian Gourde (HTG). */
+    CurrencyCode["Htg"] = "HTG";
+    /** Hungarian Forint (HUF). */
+    CurrencyCode["Huf"] = "HUF";
+    /** Indonesian Rupiah (IDR). */
+    CurrencyCode["Idr"] = "IDR";
+    /** Israeli New Shekel (NIS). */
+    CurrencyCode["Ils"] = "ILS";
+    /** Indian Rupees (INR). */
+    CurrencyCode["Inr"] = "INR";
+    /** Iraqi Dinar (IQD). */
+    CurrencyCode["Iqd"] = "IQD";
+    /** Iranian Rial (IRR). */
+    CurrencyCode["Irr"] = "IRR";
+    /** Icelandic Kronur (ISK). */
+    CurrencyCode["Isk"] = "ISK";
+    /** Jersey Pound. */
+    CurrencyCode["Jep"] = "JEP";
+    /** Jamaican Dollars (JMD). */
+    CurrencyCode["Jmd"] = "JMD";
+    /** Jordanian Dinar (JOD). */
+    CurrencyCode["Jod"] = "JOD";
+    /** Japanese Yen (JPY). */
+    CurrencyCode["Jpy"] = "JPY";
+    /** Kenyan Shilling (KES). */
+    CurrencyCode["Kes"] = "KES";
+    /** Kyrgyzstani Som (KGS). */
+    CurrencyCode["Kgs"] = "KGS";
+    /** Cambodian Riel. */
+    CurrencyCode["Khr"] = "KHR";
+    /** Kiribati Dollar (KID). */
+    CurrencyCode["Kid"] = "KID";
+    /** Comorian Franc (KMF). */
+    CurrencyCode["Kmf"] = "KMF";
+    /** South Korean Won (KRW). */
+    CurrencyCode["Krw"] = "KRW";
+    /** Kuwaiti Dinar (KWD). */
+    CurrencyCode["Kwd"] = "KWD";
+    /** Cayman Dollars (KYD). */
+    CurrencyCode["Kyd"] = "KYD";
+    /** Kazakhstani Tenge (KZT). */
+    CurrencyCode["Kzt"] = "KZT";
+    /** Laotian Kip (LAK). */
+    CurrencyCode["Lak"] = "LAK";
+    /** Lebanese Pounds (LBP). */
+    CurrencyCode["Lbp"] = "LBP";
+    /** Sri Lankan Rupees (LKR). */
+    CurrencyCode["Lkr"] = "LKR";
+    /** Liberian Dollar (LRD). */
+    CurrencyCode["Lrd"] = "LRD";
+    /** Lesotho Loti (LSL). */
+    CurrencyCode["Lsl"] = "LSL";
+    /** Lithuanian Litai (LTL). */
+    CurrencyCode["Ltl"] = "LTL";
+    /** Latvian Lati (LVL). */
+    CurrencyCode["Lvl"] = "LVL";
+    /** Libyan Dinar (LYD). */
+    CurrencyCode["Lyd"] = "LYD";
+    /** Moroccan Dirham. */
+    CurrencyCode["Mad"] = "MAD";
+    /** Moldovan Leu (MDL). */
+    CurrencyCode["Mdl"] = "MDL";
+    /** Malagasy Ariary (MGA). */
+    CurrencyCode["Mga"] = "MGA";
+    /** Macedonia Denar (MKD). */
+    CurrencyCode["Mkd"] = "MKD";
+    /** Burmese Kyat (MMK). */
+    CurrencyCode["Mmk"] = "MMK";
+    /** Mongolian Tugrik. */
+    CurrencyCode["Mnt"] = "MNT";
+    /** Macanese Pataca (MOP). */
+    CurrencyCode["Mop"] = "MOP";
+    /** Mauritanian Ouguiya (MRU). */
+    CurrencyCode["Mru"] = "MRU";
+    /** Mauritian Rupee (MUR). */
+    CurrencyCode["Mur"] = "MUR";
+    /** Maldivian Rufiyaa (MVR). */
+    CurrencyCode["Mvr"] = "MVR";
+    /** Malawian Kwacha (MWK). */
+    CurrencyCode["Mwk"] = "MWK";
+    /** Mexican Pesos (MXN). */
+    CurrencyCode["Mxn"] = "MXN";
+    /** Malaysian Ringgits (MYR). */
+    CurrencyCode["Myr"] = "MYR";
+    /** Mozambican Metical. */
+    CurrencyCode["Mzn"] = "MZN";
+    /** Namibian Dollar. */
+    CurrencyCode["Nad"] = "NAD";
+    /** Nigerian Naira (NGN). */
+    CurrencyCode["Ngn"] = "NGN";
+    /** Nicaraguan Crdoba (NIO). */
+    CurrencyCode["Nio"] = "NIO";
+    /** Norwegian Kroner (NOK). */
+    CurrencyCode["Nok"] = "NOK";
+    /** Nepalese Rupee (NPR). */
+    CurrencyCode["Npr"] = "NPR";
+    /** New Zealand Dollars (NZD). */
+    CurrencyCode["Nzd"] = "NZD";
+    /** Omani Rial (OMR). */
+    CurrencyCode["Omr"] = "OMR";
+    /** Panamian Balboa (PAB). */
+    CurrencyCode["Pab"] = "PAB";
+    /** Peruvian Nuevo Sol (PEN). */
+    CurrencyCode["Pen"] = "PEN";
+    /** Papua New Guinean Kina (PGK). */
+    CurrencyCode["Pgk"] = "PGK";
+    /** Philippine Peso (PHP). */
+    CurrencyCode["Php"] = "PHP";
+    /** Pakistani Rupee (PKR). */
+    CurrencyCode["Pkr"] = "PKR";
+    /** Polish Zlotych (PLN). */
+    CurrencyCode["Pln"] = "PLN";
+    /** Paraguayan Guarani (PYG). */
+    CurrencyCode["Pyg"] = "PYG";
+    /** Qatari Rial (QAR). */
+    CurrencyCode["Qar"] = "QAR";
+    /** Romanian Lei (RON). */
+    CurrencyCode["Ron"] = "RON";
+    /** Serbian dinar (RSD). */
+    CurrencyCode["Rsd"] = "RSD";
+    /** Russian Rubles (RUB). */
+    CurrencyCode["Rub"] = "RUB";
+    /** Rwandan Franc (RWF). */
+    CurrencyCode["Rwf"] = "RWF";
+    /** Saudi Riyal (SAR). */
+    CurrencyCode["Sar"] = "SAR";
+    /** Solomon Islands Dollar (SBD). */
+    CurrencyCode["Sbd"] = "SBD";
+    /** Seychellois Rupee (SCR). */
+    CurrencyCode["Scr"] = "SCR";
+    /** Sudanese Pound (SDG). */
+    CurrencyCode["Sdg"] = "SDG";
+    /** Swedish Kronor (SEK). */
+    CurrencyCode["Sek"] = "SEK";
+    /** Singapore Dollars (SGD). */
+    CurrencyCode["Sgd"] = "SGD";
+    /** Saint Helena Pounds (SHP). */
+    CurrencyCode["Shp"] = "SHP";
+    /** Sierra Leonean Leone (SLL). */
+    CurrencyCode["Sll"] = "SLL";
+    /** Somali Shilling (SOS). */
+    CurrencyCode["Sos"] = "SOS";
+    /** Surinamese Dollar (SRD). */
+    CurrencyCode["Srd"] = "SRD";
+    /** South Sudanese Pound (SSP). */
+    CurrencyCode["Ssp"] = "SSP";
+    /** Sao Tome And Principe Dobra (STD). */
+    CurrencyCode["Std"] = "STD";
+    /** Sao Tome And Principe Dobra (STN). */
+    CurrencyCode["Stn"] = "STN";
+    /** Syrian Pound (SYP). */
+    CurrencyCode["Syp"] = "SYP";
+    /** Swazi Lilangeni (SZL). */
+    CurrencyCode["Szl"] = "SZL";
+    /** Thai baht (THB). */
+    CurrencyCode["Thb"] = "THB";
+    /** Tajikistani Somoni (TJS). */
+    CurrencyCode["Tjs"] = "TJS";
+    /** Turkmenistani Manat (TMT). */
+    CurrencyCode["Tmt"] = "TMT";
+    /** Tunisian Dinar (TND). */
+    CurrencyCode["Tnd"] = "TND";
+    /** Tongan Pa'anga (TOP). */
+    CurrencyCode["Top"] = "TOP";
+    /** Turkish Lira (TRY). */
+    CurrencyCode["Try"] = "TRY";
+    /** Trinidad and Tobago Dollars (TTD). */
+    CurrencyCode["Ttd"] = "TTD";
+    /** Taiwan Dollars (TWD). */
+    CurrencyCode["Twd"] = "TWD";
+    /** Tanzanian Shilling (TZS). */
+    CurrencyCode["Tzs"] = "TZS";
+    /** Ukrainian Hryvnia (UAH). */
+    CurrencyCode["Uah"] = "UAH";
+    /** Ugandan Shilling (UGX). */
+    CurrencyCode["Ugx"] = "UGX";
+    /** United States Dollars (USD). */
+    CurrencyCode["Usd"] = "USD";
+    /** Uruguayan Pesos (UYU). */
+    CurrencyCode["Uyu"] = "UYU";
+    /** Uzbekistan som (UZS). */
+    CurrencyCode["Uzs"] = "UZS";
+    /** Venezuelan Bolivares (VED). */
+    CurrencyCode["Ved"] = "VED";
+    /** Venezuelan Bolivares (VEF). */
+    CurrencyCode["Vef"] = "VEF";
+    /** Venezuelan Bolivares (VES). */
+    CurrencyCode["Ves"] = "VES";
+    /** Vietnamese ng (VND). */
+    CurrencyCode["Vnd"] = "VND";
+    /** Vanuatu Vatu (VUV). */
+    CurrencyCode["Vuv"] = "VUV";
+    /** Samoan Tala (WST). */
+    CurrencyCode["Wst"] = "WST";
+    /** Central African CFA Franc (XAF). */
+    CurrencyCode["Xaf"] = "XAF";
+    /** East Caribbean Dollar (XCD). */
+    CurrencyCode["Xcd"] = "XCD";
+    /** West African CFA franc (XOF). */
+    CurrencyCode["Xof"] = "XOF";
+    /** CFP Franc (XPF). */
+    CurrencyCode["Xpf"] = "XPF";
+    /** Unrecognized currency. */
+    CurrencyCode["Xxx"] = "XXX";
+    /** Yemeni Rial (YER). */
+    CurrencyCode["Yer"] = "YER";
+    /** South African Rand (ZAR). */
+    CurrencyCode["Zar"] = "ZAR";
+    /** Zambian Kwacha (ZMW). */
+    CurrencyCode["Zmw"] = "ZMW";
+})(CurrencyCode || (CurrencyCode = {}));
+/** Possible error codes that can be returned by `CustomerUserError`. */
+export var CustomerErrorCode;
+(function (CustomerErrorCode) {
+    /** Customer already enabled. */
+    CustomerErrorCode["AlreadyEnabled"] = "ALREADY_ENABLED";
+    /** Input email contains an invalid domain name. */
+    CustomerErrorCode["BadDomain"] = "BAD_DOMAIN";
+    /** The input value is blank. */
+    CustomerErrorCode["Blank"] = "BLANK";
+    /** Input contains HTML tags. */
+    CustomerErrorCode["ContainsHtmlTags"] = "CONTAINS_HTML_TAGS";
+    /** Input contains URL. */
+    CustomerErrorCode["ContainsUrl"] = "CONTAINS_URL";
+    /** Customer is disabled. */
+    CustomerErrorCode["CustomerDisabled"] = "CUSTOMER_DISABLED";
+    /** The input value is invalid. */
+    CustomerErrorCode["Invalid"] = "INVALID";
+    /** Multipass token is not valid. */
+    CustomerErrorCode["InvalidMultipassRequest"] = "INVALID_MULTIPASS_REQUEST";
+    /** Address does not exist. */
+    CustomerErrorCode["NotFound"] = "NOT_FOUND";
+    /** Input password starts or ends with whitespace. */
+    CustomerErrorCode["PasswordStartsOrEndsWithWhitespace"] = "PASSWORD_STARTS_OR_ENDS_WITH_WHITESPACE";
+    /** The input value is already taken. */
+    CustomerErrorCode["Taken"] = "TAKEN";
+    /** Invalid activation token. */
+    CustomerErrorCode["TokenInvalid"] = "TOKEN_INVALID";
+    /** The input value is too long. */
+    CustomerErrorCode["TooLong"] = "TOO_LONG";
+    /** The input value is too short. */
+    CustomerErrorCode["TooShort"] = "TOO_SHORT";
+    /** Unidentified customer. */
+    CustomerErrorCode["UnidentifiedCustomer"] = "UNIDENTIFIED_CUSTOMER";
+})(CustomerErrorCode || (CustomerErrorCode = {}));
+/** List of different delivery method types. */
+export var DeliveryMethodType;
+(function (DeliveryMethodType) {
+    /** Local Delivery. */
+    DeliveryMethodType["Local"] = "LOCAL";
+    /** None. */
+    DeliveryMethodType["None"] = "NONE";
+    /** Shipping to a Pickup Point. */
+    DeliveryMethodType["PickupPoint"] = "PICKUP_POINT";
+    /** Local Pickup. */
+    DeliveryMethodType["PickUp"] = "PICK_UP";
+    /** Retail. */
+    DeliveryMethodType["Retail"] = "RETAIL";
+    /** Shipping. */
+    DeliveryMethodType["Shipping"] = "SHIPPING";
+})(DeliveryMethodType || (DeliveryMethodType = {}));
+/** Digital wallet, such as Apple Pay, which can be used for accelerated checkouts. */
+export var DigitalWallet;
+(function (DigitalWallet) {
+    /** Android Pay. */
+    DigitalWallet["AndroidPay"] = "ANDROID_PAY";
+    /** Apple Pay. */
+    DigitalWallet["ApplePay"] = "APPLE_PAY";
+    /** Google Pay. */
+    DigitalWallet["GooglePay"] = "GOOGLE_PAY";
+    /** Shopify Pay. */
+    DigitalWallet["ShopifyPay"] = "SHOPIFY_PAY";
+})(DigitalWallet || (DigitalWallet = {}));
+/** The method by which the discount's value is allocated onto its entitled lines. */
+export var DiscountApplicationAllocationMethod;
+(function (DiscountApplicationAllocationMethod) {
+    /** The value is spread across all entitled lines. */
+    DiscountApplicationAllocationMethod["Across"] = "ACROSS";
+    /** The value is applied onto every entitled line. */
+    DiscountApplicationAllocationMethod["Each"] = "EACH";
+    /** The value is specifically applied onto a particular line. */
+    DiscountApplicationAllocationMethod["One"] = "ONE";
+})(DiscountApplicationAllocationMethod || (DiscountApplicationAllocationMethod = {}));
+/**
+ * The lines on the order to which the discount is applied, of the type defined by
+ * the discount application's `targetType`. For example, the value `ENTITLED`, combined with a `targetType` of
+ * `LINE_ITEM`, applies the discount on all line items that are entitled to the discount.
+ * The value `ALL`, combined with a `targetType` of `SHIPPING_LINE`, applies the discount on all shipping lines.
+ *
+ */
+export var DiscountApplicationTargetSelection;
+(function (DiscountApplicationTargetSelection) {
+    /** The discount is allocated onto all the lines. */
+    DiscountApplicationTargetSelection["All"] = "ALL";
+    /** The discount is allocated onto only the lines that it's entitled for. */
+    DiscountApplicationTargetSelection["Entitled"] = "ENTITLED";
+    /** The discount is allocated onto explicitly chosen lines. */
+    DiscountApplicationTargetSelection["Explicit"] = "EXPLICIT";
+})(DiscountApplicationTargetSelection || (DiscountApplicationTargetSelection = {}));
+/**
+ * The type of line (i.e. line item or shipping line) on an order that the discount is applicable towards.
+ *
+ */
+export var DiscountApplicationTargetType;
+(function (DiscountApplicationTargetType) {
+    /** The discount applies onto line items. */
+    DiscountApplicationTargetType["LineItem"] = "LINE_ITEM";
+    /** The discount applies onto shipping lines. */
+    DiscountApplicationTargetType["ShippingLine"] = "SHIPPING_LINE";
+})(DiscountApplicationTargetType || (DiscountApplicationTargetType = {}));
+/**
+ * The type of data that the filter group represents.
+ *
+ * For more information, refer to [Filter products in a collection with the Storefront API]
+ * (https://shopify.dev/custom-storefronts/products-collections/filter-products).
+ *
+ */
+export var FilterType;
+(function (FilterType) {
+    /** A boolean value. */
+    FilterType["Boolean"] = "BOOLEAN";
+    /** A list of selectable values. */
+    FilterType["List"] = "LIST";
+    /** A range of prices. */
+    FilterType["PriceRange"] = "PRICE_RANGE";
+})(FilterType || (FilterType = {}));
+/** List of supported image content types. */
+export var ImageContentType;
+(function (ImageContentType) {
+    /** A JPG image. */
+    ImageContentType["Jpg"] = "JPG";
+    /** A PNG image. */
+    ImageContentType["Png"] = "PNG";
+    /** A WEBP image. */
+    ImageContentType["Webp"] = "WEBP";
+})(ImageContentType || (ImageContentType = {}));
+/** ISO 639-1 language codes supported by Shopify. */
+export var LanguageCode;
+(function (LanguageCode) {
+    /** Afrikaans. */
+    LanguageCode["Af"] = "AF";
+    /** Akan. */
+    LanguageCode["Ak"] = "AK";
+    /** Amharic. */
+    LanguageCode["Am"] = "AM";
+    /** Arabic. */
+    LanguageCode["Ar"] = "AR";
+    /** Assamese. */
+    LanguageCode["As"] = "AS";
+    /** Azerbaijani. */
+    LanguageCode["Az"] = "AZ";
+    /** Belarusian. */
+    LanguageCode["Be"] = "BE";
+    /** Bulgarian. */
+    LanguageCode["Bg"] = "BG";
+    /** Bambara. */
+    LanguageCode["Bm"] = "BM";
+    /** Bangla. */
+    LanguageCode["Bn"] = "BN";
+    /** Tibetan. */
+    LanguageCode["Bo"] = "BO";
+    /** Breton. */
+    LanguageCode["Br"] = "BR";
+    /** Bosnian. */
+    LanguageCode["Bs"] = "BS";
+    /** Catalan. */
+    LanguageCode["Ca"] = "CA";
+    /** Chechen. */
+    LanguageCode["Ce"] = "CE";
+    /** Czech. */
+    LanguageCode["Cs"] = "CS";
+    /** Church Slavic. */
+    LanguageCode["Cu"] = "CU";
+    /** Welsh. */
+    LanguageCode["Cy"] = "CY";
+    /** Danish. */
+    LanguageCode["Da"] = "DA";
+    /** German. */
+    LanguageCode["De"] = "DE";
+    /** Dzongkha. */
+    LanguageCode["Dz"] = "DZ";
+    /** Ewe. */
+    LanguageCode["Ee"] = "EE";
+    /** Greek. */
+    LanguageCode["El"] = "EL";
+    /** English. */
+    LanguageCode["En"] = "EN";
+    /** Esperanto. */
+    LanguageCode["Eo"] = "EO";
+    /** Spanish. */
+    LanguageCode["Es"] = "ES";
+    /** Estonian. */
+    LanguageCode["Et"] = "ET";
+    /** Basque. */
+    LanguageCode["Eu"] = "EU";
+    /** Persian. */
+    LanguageCode["Fa"] = "FA";
+    /** Fulah. */
+    LanguageCode["Ff"] = "FF";
+    /** Finnish. */
+    LanguageCode["Fi"] = "FI";
+    /** Faroese. */
+    LanguageCode["Fo"] = "FO";
+    /** French. */
+    LanguageCode["Fr"] = "FR";
+    /** Western Frisian. */
+    LanguageCode["Fy"] = "FY";
+    /** Irish. */
+    LanguageCode["Ga"] = "GA";
+    /** Scottish Gaelic. */
+    LanguageCode["Gd"] = "GD";
+    /** Galician. */
+    LanguageCode["Gl"] = "GL";
+    /** Gujarati. */
+    LanguageCode["Gu"] = "GU";
+    /** Manx. */
+    LanguageCode["Gv"] = "GV";
+    /** Hausa. */
+    LanguageCode["Ha"] = "HA";
+    /** Hebrew. */
+    LanguageCode["He"] = "HE";
+    /** Hindi. */
+    LanguageCode["Hi"] = "HI";
+    /** Croatian. */
+    LanguageCode["Hr"] = "HR";
+    /** Hungarian. */
+    LanguageCode["Hu"] = "HU";
+    /** Armenian. */
+    LanguageCode["Hy"] = "HY";
+    /** Interlingua. */
+    LanguageCode["Ia"] = "IA";
+    /** Indonesian. */
+    LanguageCode["Id"] = "ID";
+    /** Igbo. */
+    LanguageCode["Ig"] = "IG";
+    /** Sichuan Yi. */
+    LanguageCode["Ii"] = "II";
+    /** Icelandic. */
+    LanguageCode["Is"] = "IS";
+    /** Italian. */
+    LanguageCode["It"] = "IT";
+    /** Japanese. */
+    LanguageCode["Ja"] = "JA";
+    /** Javanese. */
+    LanguageCode["Jv"] = "JV";
+    /** Georgian. */
+    LanguageCode["Ka"] = "KA";
+    /** Kikuyu. */
+    LanguageCode["Ki"] = "KI";
+    /** Kazakh. */
+    LanguageCode["Kk"] = "KK";
+    /** Kalaallisut. */
+    LanguageCode["Kl"] = "KL";
+    /** Khmer. */
+    LanguageCode["Km"] = "KM";
+    /** Kannada. */
+    LanguageCode["Kn"] = "KN";
+    /** Korean. */
+    LanguageCode["Ko"] = "KO";
+    /** Kashmiri. */
+    LanguageCode["Ks"] = "KS";
+    /** Kurdish. */
+    LanguageCode["Ku"] = "KU";
+    /** Cornish. */
+    LanguageCode["Kw"] = "KW";
+    /** Kyrgyz. */
+    LanguageCode["Ky"] = "KY";
+    /** Luxembourgish. */
+    LanguageCode["Lb"] = "LB";
+    /** Ganda. */
+    LanguageCode["Lg"] = "LG";
+    /** Lingala. */
+    LanguageCode["Ln"] = "LN";
+    /** Lao. */
+    LanguageCode["Lo"] = "LO";
+    /** Lithuanian. */
+    LanguageCode["Lt"] = "LT";
+    /** Luba-Katanga. */
+    LanguageCode["Lu"] = "LU";
+    /** Latvian. */
+    LanguageCode["Lv"] = "LV";
+    /** Malagasy. */
+    LanguageCode["Mg"] = "MG";
+    /** Mori. */
+    LanguageCode["Mi"] = "MI";
+    /** Macedonian. */
+    LanguageCode["Mk"] = "MK";
+    /** Malayalam. */
+    LanguageCode["Ml"] = "ML";
+    /** Mongolian. */
+    LanguageCode["Mn"] = "MN";
+    /** Marathi. */
+    LanguageCode["Mr"] = "MR";
+    /** Malay. */
+    LanguageCode["Ms"] = "MS";
+    /** Maltese. */
+    LanguageCode["Mt"] = "MT";
+    /** Burmese. */
+    LanguageCode["My"] = "MY";
+    /** Norwegian (Bokml). */
+    LanguageCode["Nb"] = "NB";
+    /** North Ndebele. */
+    LanguageCode["Nd"] = "ND";
+    /** Nepali. */
+    LanguageCode["Ne"] = "NE";
+    /** Dutch. */
+    LanguageCode["Nl"] = "NL";
+    /** Norwegian Nynorsk. */
+    LanguageCode["Nn"] = "NN";
+    /** Norwegian. */
+    LanguageCode["No"] = "NO";
+    /** Oromo. */
+    LanguageCode["Om"] = "OM";
+    /** Odia. */
+    LanguageCode["Or"] = "OR";
+    /** Ossetic. */
+    LanguageCode["Os"] = "OS";
+    /** Punjabi. */
+    LanguageCode["Pa"] = "PA";
+    /** Polish. */
+    LanguageCode["Pl"] = "PL";
+    /** Pashto. */
+    LanguageCode["Ps"] = "PS";
+    /** Portuguese. */
+    LanguageCode["Pt"] = "PT";
+    /** Portuguese (Brazil). */
+    LanguageCode["PtBr"] = "PT_BR";
+    /** Portuguese (Portugal). */
+    LanguageCode["PtPt"] = "PT_PT";
+    /** Quechua. */
+    LanguageCode["Qu"] = "QU";
+    /** Romansh. */
+    LanguageCode["Rm"] = "RM";
+    /** Rundi. */
+    LanguageCode["Rn"] = "RN";
+    /** Romanian. */
+    LanguageCode["Ro"] = "RO";
+    /** Russian. */
+    LanguageCode["Ru"] = "RU";
+    /** Kinyarwanda. */
+    LanguageCode["Rw"] = "RW";
+    /** Sindhi. */
+    LanguageCode["Sd"] = "SD";
+    /** Northern Sami. */
+    LanguageCode["Se"] = "SE";
+    /** Sango. */
+    LanguageCode["Sg"] = "SG";
+    /** Sinhala. */
+    LanguageCode["Si"] = "SI";
+    /** Slovak. */
+    LanguageCode["Sk"] = "SK";
+    /** Slovenian. */
+    LanguageCode["Sl"] = "SL";
+    /** Shona. */
+    LanguageCode["Sn"] = "SN";
+    /** Somali. */
+    LanguageCode["So"] = "SO";
+    /** Albanian. */
+    LanguageCode["Sq"] = "SQ";
+    /** Serbian. */
+    LanguageCode["Sr"] = "SR";
+    /** Sundanese. */
+    LanguageCode["Su"] = "SU";
+    /** Swedish. */
+    LanguageCode["Sv"] = "SV";
+    /** Swahili. */
+    LanguageCode["Sw"] = "SW";
+    /** Tamil. */
+    LanguageCode["Ta"] = "TA";
+    /** Telugu. */
+    LanguageCode["Te"] = "TE";
+    /** Tajik. */
+    LanguageCode["Tg"] = "TG";
+    /** Thai. */
+    LanguageCode["Th"] = "TH";
+    /** Tigrinya. */
+    LanguageCode["Ti"] = "TI";
+    /** Turkmen. */
+    LanguageCode["Tk"] = "TK";
+    /** Tongan. */
+    LanguageCode["To"] = "TO";
+    /** Turkish. */
+    LanguageCode["Tr"] = "TR";
+    /** Tatar. */
+    LanguageCode["Tt"] = "TT";
+    /** Uyghur. */
+    LanguageCode["Ug"] = "UG";
+    /** Ukrainian. */
+    LanguageCode["Uk"] = "UK";
+    /** Urdu. */
+    LanguageCode["Ur"] = "UR";
+    /** Uzbek. */
+    LanguageCode["Uz"] = "UZ";
+    /** Vietnamese. */
+    LanguageCode["Vi"] = "VI";
+    /** Volapk. */
+    LanguageCode["Vo"] = "VO";
+    /** Wolof. */
+    LanguageCode["Wo"] = "WO";
+    /** Xhosa. */
+    LanguageCode["Xh"] = "XH";
+    /** Yiddish. */
+    LanguageCode["Yi"] = "YI";
+    /** Yoruba. */
+    LanguageCode["Yo"] = "YO";
+    /** Chinese. */
+    LanguageCode["Zh"] = "ZH";
+    /** Chinese (Simplified). */
+    LanguageCode["ZhCn"] = "ZH_CN";
+    /** Chinese (Traditional). */
+    LanguageCode["ZhTw"] = "ZH_TW";
+    /** Zulu. */
+    LanguageCode["Zu"] = "ZU";
+})(LanguageCode || (LanguageCode = {}));
+/** The set of valid sort keys for the Location query. */
+export var LocationSortKeys;
+(function (LocationSortKeys) {
+    /** Sort by the `city` value. */
+    LocationSortKeys["City"] = "CITY";
+    /** Sort by the `distance` value. */
+    LocationSortKeys["Distance"] = "DISTANCE";
+    /** Sort by the `id` value. */
+    LocationSortKeys["Id"] = "ID";
+    /** Sort by the `name` value. */
+    LocationSortKeys["Name"] = "NAME";
+})(LocationSortKeys || (LocationSortKeys = {}));
+/** The possible content types for a media object. */
+export var MediaContentType;
+(function (MediaContentType) {
+    /** An externally hosted video. */
+    MediaContentType["ExternalVideo"] = "EXTERNAL_VIDEO";
+    /** A Shopify hosted image. */
+    MediaContentType["Image"] = "IMAGE";
+    /** A 3d model. */
+    MediaContentType["Model_3D"] = "MODEL_3D";
+    /** A Shopify hosted video. */
+    MediaContentType["Video"] = "VIDEO";
+})(MediaContentType || (MediaContentType = {}));
+/** Host for a Media Resource. */
+export var MediaHost;
+(function (MediaHost) {
+    /** Host for Vimeo embedded videos. */
+    MediaHost["Vimeo"] = "VIMEO";
+    /** Host for YouTube embedded videos. */
+    MediaHost["Youtube"] = "YOUTUBE";
+})(MediaHost || (MediaHost = {}));
+/** A menu item type. */
+export var MenuItemType;
+(function (MenuItemType) {
+    /** An article link. */
+    MenuItemType["Article"] = "ARTICLE";
+    /** A blog link. */
+    MenuItemType["Blog"] = "BLOG";
+    /** A catalog link. */
+    MenuItemType["Catalog"] = "CATALOG";
+    /** A collection link. */
+    MenuItemType["Collection"] = "COLLECTION";
+    /** A collection link. */
+    MenuItemType["Collections"] = "COLLECTIONS";
+    /** A frontpage link. */
+    MenuItemType["Frontpage"] = "FRONTPAGE";
+    /** An http link. */
+    MenuItemType["Http"] = "HTTP";
+    /** A page link. */
+    MenuItemType["Page"] = "PAGE";
+    /** A product link. */
+    MenuItemType["Product"] = "PRODUCT";
+    /** A search link. */
+    MenuItemType["Search"] = "SEARCH";
+    /** A shop policy link. */
+    MenuItemType["ShopPolicy"] = "SHOP_POLICY";
+})(MenuItemType || (MenuItemType = {}));
+/** Represents the reason for the order's cancellation. */
+export var OrderCancelReason;
+(function (OrderCancelReason) {
+    /** The customer wanted to cancel the order. */
+    OrderCancelReason["Customer"] = "CUSTOMER";
+    /** Payment was declined. */
+    OrderCancelReason["Declined"] = "DECLINED";
+    /** The order was fraudulent. */
+    OrderCancelReason["Fraud"] = "FRAUD";
+    /** There was insufficient inventory. */
+    OrderCancelReason["Inventory"] = "INVENTORY";
+    /** The order was canceled for an unlisted reason. */
+    OrderCancelReason["Other"] = "OTHER";
+})(OrderCancelReason || (OrderCancelReason = {}));
+/** Represents the order's current financial status. */
+export var OrderFinancialStatus;
+(function (OrderFinancialStatus) {
+    /** Displayed as **Authorized**. */
+    OrderFinancialStatus["Authorized"] = "AUTHORIZED";
+    /** Displayed as **Paid**. */
+    OrderFinancialStatus["Paid"] = "PAID";
+    /** Displayed as **Partially paid**. */
+    OrderFinancialStatus["PartiallyPaid"] = "PARTIALLY_PAID";
+    /** Displayed as **Partially refunded**. */
+    OrderFinancialStatus["PartiallyRefunded"] = "PARTIALLY_REFUNDED";
+    /** Displayed as **Pending**. */
+    OrderFinancialStatus["Pending"] = "PENDING";
+    /** Displayed as **Refunded**. */
+    OrderFinancialStatus["Refunded"] = "REFUNDED";
+    /** Displayed as **Voided**. */
+    OrderFinancialStatus["Voided"] = "VOIDED";
+})(OrderFinancialStatus || (OrderFinancialStatus = {}));
+/** Represents the order's aggregated fulfillment status for display purposes. */
+export var OrderFulfillmentStatus;
+(function (OrderFulfillmentStatus) {
+    /** Displayed as **Fulfilled**. All of the items in the order have been fulfilled. */
+    OrderFulfillmentStatus["Fulfilled"] = "FULFILLED";
+    /** Displayed as **In progress**. Some of the items in the order have been fulfilled, or a request for fulfillment has been sent to the fulfillment service. */
+    OrderFulfillmentStatus["InProgress"] = "IN_PROGRESS";
+    /** Displayed as **On hold**. All of the unfulfilled items in this order are on hold. */
+    OrderFulfillmentStatus["OnHold"] = "ON_HOLD";
+    /** Displayed as **Open**. None of the items in the order have been fulfilled. Replaced by "UNFULFILLED" status. */
+    OrderFulfillmentStatus["Open"] = "OPEN";
+    /** Displayed as **Partially fulfilled**. Some of the items in the order have been fulfilled. */
+    OrderFulfillmentStatus["PartiallyFulfilled"] = "PARTIALLY_FULFILLED";
+    /** Displayed as **Pending fulfillment**. A request for fulfillment of some items awaits a response from the fulfillment service. Replaced by "IN_PROGRESS" status. */
+    OrderFulfillmentStatus["PendingFulfillment"] = "PENDING_FULFILLMENT";
+    /** Displayed as **Restocked**. All of the items in the order have been restocked. Replaced by "UNFULFILLED" status. */
+    OrderFulfillmentStatus["Restocked"] = "RESTOCKED";
+    /** Displayed as **Scheduled**. All of the unfulfilled items in this order are scheduled for fulfillment at later time. */
+    OrderFulfillmentStatus["Scheduled"] = "SCHEDULED";
+    /** Displayed as **Unfulfilled**. None of the items in the order have been fulfilled. */
+    OrderFulfillmentStatus["Unfulfilled"] = "UNFULFILLED";
+})(OrderFulfillmentStatus || (OrderFulfillmentStatus = {}));
+/** The set of valid sort keys for the Order query. */
+export var OrderSortKeys;
+(function (OrderSortKeys) {
+    /** Sort by the `id` value. */
+    OrderSortKeys["Id"] = "ID";
+    /** Sort by the `processed_at` value. */
+    OrderSortKeys["ProcessedAt"] = "PROCESSED_AT";
+    /**
+     * Sort by relevance to the search terms when the `query` parameter is specified on the connection.
+     * Don't use this sort key when no search query is specified.
+     *
+     */
+    OrderSortKeys["Relevance"] = "RELEVANCE";
+    /** Sort by the `total_price` value. */
+    OrderSortKeys["TotalPrice"] = "TOTAL_PRICE";
+})(OrderSortKeys || (OrderSortKeys = {}));
+/** The set of valid sort keys for the Page query. */
+export var PageSortKeys;
+(function (PageSortKeys) {
+    /** Sort by the `id` value. */
+    PageSortKeys["Id"] = "ID";
+    /**
+     * Sort by relevance to the search terms when the `query` parameter is specified on the connection.
+     * Don't use this sort key when no search query is specified.
+     *
+     */
+    PageSortKeys["Relevance"] = "RELEVANCE";
+    /** Sort by the `title` value. */
+    PageSortKeys["Title"] = "TITLE";
+    /** Sort by the `updated_at` value. */
+    PageSortKeys["UpdatedAt"] = "UPDATED_AT";
+})(PageSortKeys || (PageSortKeys = {}));
+/** The valid values for the types of payment token. */
+export var PaymentTokenType;
+(function (PaymentTokenType) {
+    /** Apple Pay token type. */
+    PaymentTokenType["ApplePay"] = "APPLE_PAY";
+    /** Google Pay token type. */
+    PaymentTokenType["GooglePay"] = "GOOGLE_PAY";
+    /** Shopify Pay token type. */
+    PaymentTokenType["ShopifyPay"] = "SHOPIFY_PAY";
+    /** Stripe token type. */
+    PaymentTokenType["StripeVaultToken"] = "STRIPE_VAULT_TOKEN";
+    /** Vault payment token type. */
+    PaymentTokenType["Vault"] = "VAULT";
+})(PaymentTokenType || (PaymentTokenType = {}));
+/** The set of valid sort keys for the ProductCollection query. */
+export var ProductCollectionSortKeys;
+(function (ProductCollectionSortKeys) {
+    /** Sort by the `best-selling` value. */
+    ProductCollectionSortKeys["BestSelling"] = "BEST_SELLING";
+    /** Sort by the `collection-default` value. */
+    ProductCollectionSortKeys["CollectionDefault"] = "COLLECTION_DEFAULT";
+    /** Sort by the `created` value. */
+    ProductCollectionSortKeys["Created"] = "CREATED";
+    /** Sort by the `id` value. */
+    ProductCollectionSortKeys["Id"] = "ID";
+    /** Sort by the `manual` value. */
+    ProductCollectionSortKeys["Manual"] = "MANUAL";
+    /** Sort by the `price` value. */
+    ProductCollectionSortKeys["Price"] = "PRICE";
+    /**
+     * Sort by relevance to the search terms when the `query` parameter is specified on the connection.
+     * Don't use this sort key when no search query is specified.
+     *
+     */
+    ProductCollectionSortKeys["Relevance"] = "RELEVANCE";
+    /** Sort by the `title` value. */
+    ProductCollectionSortKeys["Title"] = "TITLE";
+})(ProductCollectionSortKeys || (ProductCollectionSortKeys = {}));
+/** The set of valid sort keys for the ProductImage query. */
+export var ProductImageSortKeys;
+(function (ProductImageSortKeys) {
+    /** Sort by the `created_at` value. */
+    ProductImageSortKeys["CreatedAt"] = "CREATED_AT";
+    /** Sort by the `id` value. */
+    ProductImageSortKeys["Id"] = "ID";
+    /** Sort by the `position` value. */
+    ProductImageSortKeys["Position"] = "POSITION";
+    /**
+     * Sort by relevance to the search terms when the `query` parameter is specified on the connection.
+     * Don't use this sort key when no search query is specified.
+     *
+     */
+    ProductImageSortKeys["Relevance"] = "RELEVANCE";
+})(ProductImageSortKeys || (ProductImageSortKeys = {}));
+/** The set of valid sort keys for the ProductMedia query. */
+export var ProductMediaSortKeys;
+(function (ProductMediaSortKeys) {
+    /** Sort by the `id` value. */
+    ProductMediaSortKeys["Id"] = "ID";
+    /** Sort by the `position` value. */
+    ProductMediaSortKeys["Position"] = "POSITION";
+    /**
+     * Sort by relevance to the search terms when the `query` parameter is specified on the connection.
+     * Don't use this sort key when no search query is specified.
+     *
+     */
+    ProductMediaSortKeys["Relevance"] = "RELEVANCE";
+})(ProductMediaSortKeys || (ProductMediaSortKeys = {}));
+/** The set of valid sort keys for the Product query. */
+export var ProductSortKeys;
+(function (ProductSortKeys) {
+    /** Sort by the `best_selling` value. */
+    ProductSortKeys["BestSelling"] = "BEST_SELLING";
+    /** Sort by the `created_at` value. */
+    ProductSortKeys["CreatedAt"] = "CREATED_AT";
+    /** Sort by the `id` value. */
+    ProductSortKeys["Id"] = "ID";
+    /** Sort by the `price` value. */
+    ProductSortKeys["Price"] = "PRICE";
+    /** Sort by the `product_type` value. */
+    ProductSortKeys["ProductType"] = "PRODUCT_TYPE";
+    /**
+     * Sort by relevance to the search terms when the `query` parameter is specified on the connection.
+     * Don't use this sort key when no search query is specified.
+     *
+     */
+    ProductSortKeys["Relevance"] = "RELEVANCE";
+    /** Sort by the `title` value. */
+    ProductSortKeys["Title"] = "TITLE";
+    /** Sort by the `updated_at` value. */
+    ProductSortKeys["UpdatedAt"] = "UPDATED_AT";
+    /** Sort by the `vendor` value. */
+    ProductSortKeys["Vendor"] = "VENDOR";
+})(ProductSortKeys || (ProductSortKeys = {}));
+/** The set of valid sort keys for the ProductVariant query. */
+export var ProductVariantSortKeys;
+(function (ProductVariantSortKeys) {
+    /** Sort by the `id` value. */
+    ProductVariantSortKeys["Id"] = "ID";
+    /** Sort by the `position` value. */
+    ProductVariantSortKeys["Position"] = "POSITION";
+    /**
+     * Sort by relevance to the search terms when the `query` parameter is specified on the connection.
+     * Don't use this sort key when no search query is specified.
+     *
+     */
+    ProductVariantSortKeys["Relevance"] = "RELEVANCE";
+    /** Sort by the `sku` value. */
+    ProductVariantSortKeys["Sku"] = "SKU";
+    /** Sort by the `title` value. */
+    ProductVariantSortKeys["Title"] = "TITLE";
+})(ProductVariantSortKeys || (ProductVariantSortKeys = {}));
+/** The checkout charge when the full amount isn't charged at checkout. */
+export var SellingPlanCheckoutChargeType;
+(function (SellingPlanCheckoutChargeType) {
+    /** The checkout charge is a percentage of the product or variant price. */
+    SellingPlanCheckoutChargeType["Percentage"] = "PERCENTAGE";
+    /** The checkout charge is a fixed price amount. */
+    SellingPlanCheckoutChargeType["Price"] = "PRICE";
+})(SellingPlanCheckoutChargeType || (SellingPlanCheckoutChargeType = {}));
+/** The different kinds of order transactions. */
+export var TransactionKind;
+(function (TransactionKind) {
+    /**
+     * An amount reserved against the cardholder's funding source.
+     * Money does not change hands until the authorization is captured.
+     *
+     */
+    TransactionKind["Authorization"] = "AUTHORIZATION";
+    /** A transfer of the money that was reserved during the authorization stage. */
+    TransactionKind["Capture"] = "CAPTURE";
+    /** Money returned to the customer when they have paid too much. */
+    TransactionKind["Change"] = "CHANGE";
+    /** An authorization for a payment taken with an EMV credit card reader. */
+    TransactionKind["EmvAuthorization"] = "EMV_AUTHORIZATION";
+    /** An authorization and capture performed together in a single step. */
+    TransactionKind["Sale"] = "SALE";
+})(TransactionKind || (TransactionKind = {}));
+/** Transaction statuses describe the status of a transaction. */
+export var TransactionStatus;
+(function (TransactionStatus) {
+    /** There was an error while processing the transaction. */
+    TransactionStatus["Error"] = "ERROR";
+    /** The transaction failed. */
+    TransactionStatus["Failure"] = "FAILURE";
+    /** The transaction is pending. */
+    TransactionStatus["Pending"] = "PENDING";
+    /** The transaction succeeded. */
+    TransactionStatus["Success"] = "SUCCESS";
+})(TransactionStatus || (TransactionStatus = {}));
+/** The accepted types of unit of measurement. */
+export var UnitPriceMeasurementMeasuredType;
+(function (UnitPriceMeasurementMeasuredType) {
+    /** Unit of measurements representing areas. */
+    UnitPriceMeasurementMeasuredType["Area"] = "AREA";
+    /** Unit of measurements representing lengths. */
+    UnitPriceMeasurementMeasuredType["Length"] = "LENGTH";
+    /** Unit of measurements representing volumes. */
+    UnitPriceMeasurementMeasuredType["Volume"] = "VOLUME";
+    /** Unit of measurements representing weights. */
+    UnitPriceMeasurementMeasuredType["Weight"] = "WEIGHT";
+})(UnitPriceMeasurementMeasuredType || (UnitPriceMeasurementMeasuredType = {}));
+/** The valid units of measurement for a unit price measurement. */
+export var UnitPriceMeasurementMeasuredUnit;
+(function (UnitPriceMeasurementMeasuredUnit) {
+    /** 100 centiliters equals 1 liter. */
+    UnitPriceMeasurementMeasuredUnit["Cl"] = "CL";
+    /** 100 centimeters equals 1 meter. */
+    UnitPriceMeasurementMeasuredUnit["Cm"] = "CM";
+    /** Metric system unit of weight. */
+    UnitPriceMeasurementMeasuredUnit["G"] = "G";
+    /** 1 kilogram equals 1000 grams. */
+    UnitPriceMeasurementMeasuredUnit["Kg"] = "KG";
+    /** Metric system unit of volume. */
+    UnitPriceMeasurementMeasuredUnit["L"] = "L";
+    /** Metric system unit of length. */
+    UnitPriceMeasurementMeasuredUnit["M"] = "M";
+    /** Metric system unit of area. */
+    UnitPriceMeasurementMeasuredUnit["M2"] = "M2";
+    /** 1 cubic meter equals 1000 liters. */
+    UnitPriceMeasurementMeasuredUnit["M3"] = "M3";
+    /** 1000 milligrams equals 1 gram. */
+    UnitPriceMeasurementMeasuredUnit["Mg"] = "MG";
+    /** 1000 milliliters equals 1 liter. */
+    UnitPriceMeasurementMeasuredUnit["Ml"] = "ML";
+    /** 1000 millimeters equals 1 meter. */
+    UnitPriceMeasurementMeasuredUnit["Mm"] = "MM";
+})(UnitPriceMeasurementMeasuredUnit || (UnitPriceMeasurementMeasuredUnit = {}));
+/** Systems of weights and measures. */
+export var UnitSystem;
+(function (UnitSystem) {
+    /** Imperial system of weights and measures. */
+    UnitSystem["ImperialSystem"] = "IMPERIAL_SYSTEM";
+    /** Metric system of weights and measures. */
+    UnitSystem["MetricSystem"] = "METRIC_SYSTEM";
+})(UnitSystem || (UnitSystem = {}));
+/** Units of measurement for weight. */
+export var WeightUnit;
+(function (WeightUnit) {
+    /** Metric system unit of mass. */
+    WeightUnit["Grams"] = "GRAMS";
+    /** 1 kilogram equals 1000 grams. */
+    WeightUnit["Kilograms"] = "KILOGRAMS";
+    /** Imperial system unit of mass. */
+    WeightUnit["Ounces"] = "OUNCES";
+    /** 1 pound equals 16 ounces. */
+    WeightUnit["Pounds"] = "POUNDS";
+})(WeightUnit || (WeightUnit = {}));
diff --git a/dist/dist/esnext/streaming.server.d.ts b/dist/dist/esnext/streaming.server.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11dbb9a5c7e41f75513cbed0c248e43eb59f0dc7
--- /dev/null
+++ b/dist/dist/esnext/streaming.server.d.ts
@@ -0,0 +1,16 @@
+export { renderToPipeableStream as ssrRenderToPipeableStream, // Only available in Node context
+renderToReadableStream as ssrRenderToReadableStream, } from 'react-dom/server';
+declare type ServerContextJSONValue = string | boolean | number | null | Readonly<ServerContextJSONValueCircular> | {
+    [key: string]: ServerContextJSONValueCircular;
+};
+interface ServerContextJSONValueCircular extends Array<ServerContextJSONValue> {
+}
+export declare const rscRenderToReadableStream: (App: JSX.Element, options?: {
+    onError?: ((error: Error) => void) | undefined;
+    context?: [string, ServerContextJSONValue][] | undefined;
+    identifierPrefix?: string | undefined;
+} | undefined) => ReadableStream<Uint8Array>;
+export declare const createFromReadableStream: (rs: ReadableStream<Uint8Array>) => {
+    readRoot: () => JSX.Element;
+};
+export declare function bufferReadableStream(reader: ReadableStreamDefaultReader, cb?: (chunk: string) => void): Promise<string>;
diff --git a/dist/dist/esnext/streaming.server.js b/dist/dist/esnext/streaming.server.js
new file mode 100644
index 0000000000000000000000000000000000000000..18d58a6998f185876a893295bffc3abf0e22f381
--- /dev/null
+++ b/dist/dist/esnext/streaming.server.js
@@ -0,0 +1,24 @@
+export { renderToPipeableStream as ssrRenderToPipeableStream, // Only available in Node context
+renderToReadableStream as ssrRenderToReadableStream, // Only available in Browser/Worker context
+ } from 'react-dom/server';
+// @ts-ignore
+import { renderToReadableStream as _rscRenderToReadableStream } from '@shopify/hydrogen/vendor/react-server-dom-vite/writer.browser.server';
+// @ts-ignore
+import { createFromReadableStream as _createFromReadableStream } from '@shopify/hydrogen/vendor/react-server-dom-vite';
+export const rscRenderToReadableStream = _rscRenderToReadableStream;
+export const createFromReadableStream = _createFromReadableStream;
+export async function bufferReadableStream(reader, cb) {
+    const decoder = new TextDecoder();
+    let result = '';
+    while (true) {
+        const { done, value } = await reader.read();
+        if (done)
+            break;
+        const stringValue = typeof value === 'string' ? value : decoder.decode(value);
+        result += stringValue;
+        if (cb) {
+            cb(stringValue);
+        }
+    }
+    return result;
+}
diff --git a/dist/dist/esnext/testing.d.ts b/dist/dist/esnext/testing.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4a1da1995f8f48e245646a22f55bf2b5ae00e4e2
--- /dev/null
+++ b/dist/dist/esnext/testing.d.ts
@@ -0,0 +1,2 @@
+export { MockedServerRequestProvider } from './utilities/tests/MockedServerRequestProvider.server.js';
+export { ShopifyTestProviders } from './utilities/tests/provider-helpers.js';
diff --git a/dist/dist/esnext/testing.js b/dist/dist/esnext/testing.js
new file mode 100644
index 0000000000000000000000000000000000000000..4a1da1995f8f48e245646a22f55bf2b5ae00e4e2
--- /dev/null
+++ b/dist/dist/esnext/testing.js
@@ -0,0 +1,2 @@
+export { MockedServerRequestProvider } from './utilities/tests/MockedServerRequestProvider.server.js';
+export { ShopifyTestProviders } from './utilities/tests/provider-helpers.js';
diff --git a/dist/dist/esnext/types.d.ts b/dist/dist/esnext/types.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8655ada86f452cf73d044f845123df9d2597269d
--- /dev/null
+++ b/dist/dist/esnext/types.d.ts
@@ -0,0 +1,117 @@
+/// <reference types="node" />
+export * from './shared-types.js';
+import { ShopifyConfig } from './shared-types.js';
+import type { ServerResponse } from 'http';
+import type { Logger, LoggerConfig } from './utilities/log/index.js';
+import type { HydrogenRequest } from './foundation/HydrogenRequest/HydrogenRequest.server.js';
+import type { HydrogenResponse } from './foundation/HydrogenResponse/HydrogenResponse.server.js';
+import type { Metafield } from './storefront-api-types.js';
+import type { SessionStorageAdapter } from './foundation/session/session-types.js';
+import type { PartialDeep, JsonValue } from 'type-fest';
+import type { TemplateParts } from './utilities/template.js';
+export declare type AssembleHtmlParams = {
+    ssrHtml: string;
+    rscPayload?: string;
+    routes?: ImportGlobEagerOutput;
+    request: HydrogenRequest;
+    template: string;
+};
+export declare type RunSsrParams = {
+    state: Record<string, any>;
+    rsc: {
+        readable: ReadableStream;
+        didError: () => Error | undefined;
+    };
+    routes?: ImportGlobEagerOutput;
+    request: HydrogenRequest;
+    response: HydrogenResponse;
+    log: Logger;
+    dev?: boolean;
+    template: TemplateParts;
+    nonce?: string;
+    nodeResponse?: ServerResponse;
+    revalidate?: Boolean;
+};
+export declare type RunRscParams = {
+    App: any;
+    state: Record<string, any>;
+    log: Logger;
+    request: HydrogenRequest;
+    response: HydrogenResponse;
+};
+export declare type Hook = (params: {
+    url: URL;
+} & Record<string, any>) => any | Promise<any>;
+export declare type ImportGlobEagerOutput = Record<string, Record<'default' | 'api', any>>;
+export declare type InlineHydrogenRoutes = string | {
+    files: string;
+    basePath?: string;
+};
+export declare type ResolvedHydrogenRoutes = {
+    files: ImportGlobEagerOutput;
+    dirPrefix: string;
+    basePath: string;
+};
+declare type ConfigFetcher<T> = (request: HydrogenRequest) => T | Promise<T>;
+export declare type ShopifyConfigFetcher = ConfigFetcher<ShopifyConfig>;
+export declare type ServerAnalyticsConnector = {
+    request: (requestUrl: string, requestHeader: Headers, data?: any, contentType?: 'json' | 'text') => Promise<any>;
+};
+export declare type InlineHydrogenConfig = ClientConfig & {
+    routes?: InlineHydrogenRoutes;
+    shopify?: ShopifyConfig | ShopifyConfigFetcher;
+    serverAnalyticsConnectors?: Array<ServerAnalyticsConnector>;
+    logger?: LoggerConfig;
+    session?: (log: Logger) => SessionStorageAdapter;
+    poweredByHeader?: boolean;
+    serverErrorPage?: string;
+    __EXPERIMENTAL__devTools?: boolean;
+};
+export declare type ResolvedHydrogenConfig = Omit<InlineHydrogenConfig, 'routes'> & {
+    routes: ResolvedHydrogenRoutes;
+};
+export declare type ClientConfig = {
+    /** React's StrictMode is on by default for your client side app; if you want to turn it off (not recommended), you can pass `false` */
+    strictMode?: boolean;
+};
+export declare type ClientHandler = (App: React.ElementType, config: ClientConfig) => Promise<void>;
+export interface GraphQLConnection<T> {
+    edges?: {
+        node: T;
+    }[];
+    nodes?: T[];
+}
+export declare type ParsedMetafield = Omit<PartialDeep<Metafield>, 'value'> & {
+    value?: string | number | boolean | JsonValue | Date | Rating | Measurement;
+};
+export interface Rating {
+    value: number;
+    scale_min: number;
+    scale_max: number;
+}
+export interface Measurement {
+    unit: string;
+    value: number;
+}
+export declare type QueryKey = string | readonly unknown[];
+export declare type NoStoreStrategy = {
+    mode: string;
+};
+export interface AllCacheOptions {
+    mode?: string;
+    maxAge?: number;
+    staleWhileRevalidate?: number;
+    sMaxAge?: number;
+    staleIfError?: number;
+}
+export declare type CachingStrategy = AllCacheOptions;
+export declare type PreloadOptions = boolean | string;
+export declare type HydrogenRouteProps = {
+    request: HydrogenRequest;
+    response: HydrogenResponse;
+    log: Logger;
+    params: Record<string, any>;
+    pathname: string;
+    search: string;
+    [key: string]: any;
+};
diff --git a/dist/dist/esnext/types.js b/dist/dist/esnext/types.js
new file mode 100644
index 0000000000000000000000000000000000000000..b55357bd5fb9d2d9b59050ae8c3845203a9c72e0
--- /dev/null
+++ b/dist/dist/esnext/types.js
@@ -0,0 +1 @@
+export * from './shared-types.js';
diff --git a/dist/dist/esnext/utilities/apiRoutes.d.ts b/dist/dist/esnext/utilities/apiRoutes.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d8ca2f88b5ca65ec429a77ed175f81f48d5eefaf
--- /dev/null
+++ b/dist/dist/esnext/utilities/apiRoutes.d.ts
@@ -0,0 +1,44 @@
+import { ResolvedHydrogenConfig, ResolvedHydrogenRoutes } from '../types.js';
+import { Logger } from '../utilities/log/index.js';
+import type { HydrogenRequest } from '../foundation/HydrogenRequest/HydrogenRequest.server.js';
+import type { SessionApi, SessionStorageAdapter } from '../foundation/session/session-types.js';
+import { UseShopQueryResponse } from '../hooks/useShopQuery/hooks.js';
+declare type RouteParams = Record<string, string>;
+export declare type RequestOptions = {
+    log: Logger;
+    params: RouteParams;
+    queryShop: <T>(args: QueryShopArgs) => Promise<UseShopQueryResponse<T>>;
+    session: SessionApi | null;
+    hydrogenConfig: ResolvedHydrogenConfig;
+};
+export declare type ResourceGetter = (request: HydrogenRequest, requestOptions: RequestOptions) => Promise<Response | Object | String>;
+interface HydrogenApiRoute {
+    path: string;
+    resource: ResourceGetter;
+    hasServerComponent: boolean;
+}
+export declare type ApiRouteMatch = {
+    resource: ResourceGetter;
+    hasServerComponent: boolean;
+    params: RouteParams;
+};
+export declare function extractPathFromRoutesKey(routesKey: string, dirPrefix: string | RegExp): string;
+export declare function getApiRoutes({ files: routes, basePath: topLevelPath, dirPrefix, }: Partial<ResolvedHydrogenRoutes>): Array<HydrogenApiRoute>;
+export declare function getApiRouteFromURL(url: URL, routes: Array<HydrogenApiRoute>): ApiRouteMatch | null;
+/** The `queryShop` utility is a function that helps you query the Storefront API.
+ * It's similar to the `useShopQuery` hook, which is available in server components.
+ * To use `queryShop`, pass `shopifyConfig` to `renderHydrogen` inside `App.server.jsx`.
+ */
+interface QueryShopArgs {
+    /** A string of the GraphQL query.
+     * If no query is provided, then the `useShopQuery` makes no calls to the Storefront API.
+     */
+    query: string;
+    /** An object of the variables for the GraphQL query. */
+    variables?: Record<string, any>;
+}
+export declare function renderApiRoute(request: HydrogenRequest, route: ApiRouteMatch, hydrogenConfig: ResolvedHydrogenConfig, { session, suppressLog, }: {
+    session?: SessionStorageAdapter;
+    suppressLog?: boolean;
+}): Promise<Response | Request>;
+export {};
diff --git a/dist/dist/esnext/utilities/apiRoutes.js b/dist/dist/esnext/utilities/apiRoutes.js
new file mode 100644
index 0000000000000000000000000000000000000000..85164fc20a09b882b3b452ede6bbee31c4503000
--- /dev/null
+++ b/dist/dist/esnext/utilities/apiRoutes.js
@@ -0,0 +1,200 @@
+import { matchPath } from './matchPath.js';
+import { getLoggerWithContext, logServerResponse, } from '../utilities/log/index.js';
+import { fetchBuilder, graphqlRequestBody } from './fetch.js';
+import { getStorefrontApiRequestHeaders } from './storefrontApi.js';
+import { emptySessionImplementation } from '../foundation/session/session.js';
+import { FORM_REDIRECT_COOKIE, RSC_PATHNAME } from '../constants.js';
+let memoizedApiRoutes = [];
+let memoizedRawRoutes = {};
+export function extractPathFromRoutesKey(routesKey, dirPrefix) {
+    let path = routesKey
+        .replace(dirPrefix, '')
+        .replace(/\.server\.(t|j)sx?$/, '')
+        /**
+         * Replace /index with /
+         */
+        .replace(/\/index$/i, '/')
+        /**
+         * Only lowercase the first letter. This allows the developer to use camelCase
+         * dynamic paths while ensuring their standard routes are normalized to lowercase.
+         */
+        .replace(/\b[A-Z]/, (firstLetter) => firstLetter.toLowerCase())
+        /**
+         * Convert /[handle].jsx and /[...handle].jsx to /:handle.jsx for react-router-dom
+         */
+        .replace(/\[(?:[.]{3})?(\w+?)\]/g, (_match, param) => `:${param}`);
+    if (path.endsWith('/') && path !== '/') {
+        path = path.substring(0, path.length - 1);
+    }
+    return path;
+}
+export function getApiRoutes({ files: routes, basePath: topLevelPath = '', dirPrefix = '', }) {
+    if (!routes || memoizedRawRoutes === routes)
+        return memoizedApiRoutes;
+    const topLevelPrefix = topLevelPath.replace('*', '').replace(/\/$/, '');
+    const keys = Object.keys(routes);
+    const apiRoutes = keys
+        .filter((key) => routes[key].api)
+        .map((key) => {
+        const path = extractPathFromRoutesKey(key, dirPrefix);
+        /**
+         * Catch-all routes [...handle].jsx don't need an exact match
+         * https://reactrouter.com/core/api/Route/exact-bool
+         */
+        const exact = !/\[(?:[.]{3})(\w+?)\]/.test(key);
+        return {
+            path: topLevelPrefix + path,
+            resource: routes[key].api,
+            hasServerComponent: !!routes[key].default,
+            exact,
+        };
+    });
+    memoizedApiRoutes = [
+        ...apiRoutes.filter((route) => !route.path.includes(':')),
+        ...apiRoutes.filter((route) => route.path.includes(':')),
+    ];
+    memoizedRawRoutes = routes;
+    return memoizedApiRoutes;
+}
+export function getApiRouteFromURL(url, routes) {
+    let foundRoute, foundRouteDetails;
+    for (let i = 0; i < routes.length; i++) {
+        foundRouteDetails = matchPath(url.pathname, routes[i]);
+        if (foundRouteDetails) {
+            foundRoute = routes[i];
+            break;
+        }
+    }
+    if (!foundRoute)
+        return null;
+    return {
+        resource: foundRoute.resource,
+        params: foundRouteDetails.params,
+        hasServerComponent: foundRoute.hasServerComponent,
+    };
+}
+function queryShopBuilder(shopifyConfigGetter, request) {
+    return async function queryShop({ query, variables, }) {
+        const shopifyConfig = typeof shopifyConfigGetter === 'function'
+            ? await shopifyConfigGetter(request)
+            : shopifyConfigGetter;
+        if (!shopifyConfig) {
+            throw new Error('Shopify connection info was not found in Hydrogen config');
+        }
+        const { storeDomain, storefrontApiVersion, storefrontToken, privateStorefrontToken, storefrontId, } = shopifyConfig;
+        const buyerIp = request.getBuyerIp();
+        const extraHeaders = getStorefrontApiRequestHeaders({
+            buyerIp,
+            publicStorefrontToken: storefrontToken,
+            privateStorefrontToken,
+            storefrontId,
+        });
+        const fetcher = fetchBuilder(`https://${storeDomain}/api/${storefrontApiVersion}/graphql.json`, {
+            method: 'POST',
+            body: graphqlRequestBody(query, variables),
+            headers: {
+                'Content-Type': 'application/json',
+                ...extraHeaders,
+            },
+        });
+        return await fetcher();
+    };
+}
+export async function renderApiRoute(request, route, hydrogenConfig, { session, suppressLog, }) {
+    let response;
+    const log = getLoggerWithContext(request);
+    let cookieToSet = '';
+    try {
+        response = await route.resource(request, {
+            log,
+            params: route.params,
+            queryShop: queryShopBuilder(hydrogenConfig.shopify, request),
+            hydrogenConfig,
+            session: session
+                ? {
+                    async getFlash(key) {
+                        const data = await session.get(request);
+                        const value = data[key];
+                        if (value) {
+                            delete data[key];
+                            await session.set(request, data);
+                        }
+                        return value;
+                    },
+                    async get() {
+                        return session.get(request);
+                    },
+                    async set(key, value) {
+                        const data = await session.get(request);
+                        data[key] = value;
+                        cookieToSet = await session.set(request, data);
+                    },
+                    async destroy() {
+                        cookieToSet = await session.destroy(request);
+                    },
+                }
+                : emptySessionImplementation(log),
+        });
+        if (!(response instanceof Response || response instanceof Request)) {
+            if (typeof response === 'string' || response instanceof String) {
+                response = new Response(response);
+            }
+            else if (typeof response === 'object') {
+                response = new Response(JSON.stringify(response), {
+                    headers: {
+                        'Content-Type': 'application/json',
+                    },
+                });
+            }
+        }
+        if (!response) {
+            response = new Response(null);
+        }
+        if (cookieToSet) {
+            response.headers.set('Set-Cookie', cookieToSet);
+        }
+    }
+    catch (e) {
+        log.error(e);
+        response = new Response('Error processing: ' + request.url, {
+            status: 500,
+        });
+    }
+    if (!suppressLog) {
+        logServerResponse('api', request, response.status ?? 200, false);
+    }
+    if (response instanceof Request) {
+        const url = new URL(request.url);
+        const newUrl = new URL(response.url, url);
+        if (request.headers.get('Hydrogen-Client') === 'Form-Action') {
+            response.headers.set('Hydrogen-RSC-Pathname', newUrl.pathname + newUrl.search);
+            return new Request(getRscUrl(url, newUrl), {
+                headers: response.headers,
+            });
+        }
+        else {
+            // This request was made by a native form presumably because the client components had yet to hydrate,
+            // Because of this, we need to redirect instead of just rendering the response.
+            // Doing so prevents odd refresh / back behavior. The redirect response also should *never* be cached.
+            response.headers.set('Location', newUrl.href);
+            response.headers.set('Cache-Control', 'no-store');
+            response.headers.append('Set-Cookie', `${FORM_REDIRECT_COOKIE}=1`);
+            return new Response(null, {
+                status: 303,
+                headers: response.headers,
+            });
+        }
+    }
+    return response;
+}
+function getRscUrl(currentUrl, newUrl) {
+    const rscUrl = new URL(RSC_PATHNAME, currentUrl);
+    const searchParams = new URLSearchParams({
+        state: JSON.stringify({
+            pathname: newUrl.pathname,
+            search: newUrl.search,
+        }),
+    });
+    rscUrl.search = searchParams.toString();
+    return rscUrl.toString();
+}
diff --git a/dist/dist/esnext/utilities/bot-ua.d.ts b/dist/dist/esnext/utilities/bot-ua.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f016f45fbe11152b0a6a00a4d3dba0f35200530c
--- /dev/null
+++ b/dist/dist/esnext/utilities/bot-ua.d.ts
@@ -0,0 +1,4 @@
+/**
+ * Determines if the request is from a bot, using the URL and User Agent
+ */
+export declare function isBotUA(url: URL, userAgent: string | null): boolean;
diff --git a/dist/dist/esnext/utilities/bot-ua.js b/dist/dist/esnext/utilities/bot-ua.js
new file mode 100644
index 0000000000000000000000000000000000000000..374c5105236b04517501b4a08d5439e90a431c87
--- /dev/null
+++ b/dist/dist/esnext/utilities/bot-ua.js
@@ -0,0 +1,61 @@
+/**
+ * An alphabetized list of User Agents of known bots, combined from lists found at:
+ * https://github.com/vercel/next.js/blob/d87dc2b5a0b3fdbc0f6806a47be72bad59564bd0/packages/next/server/utils.ts#L18-L22
+ * https://github.com/GoogleChrome/rendertron/blob/6f681688737846b28754fbfdf5db173846a826df/middleware/src/middleware.ts#L24-L41
+ */
+const botUserAgents = [
+    'AdsBot-Google',
+    'applebot',
+    'Baiduspider',
+    'baiduspider',
+    'Bytespider',
+    '360Spider',
+    'PetalBot',
+    'Yisouspider',
+    'bingbot',
+    'Bingbot',
+    'BingPreview',
+    'bitlybot',
+    'Discordbot',
+    'DuckDuckBot',
+    'Embedly',
+    'facebookcatalog',
+    'facebookexternalhit',
+    'Google-PageRenderer',
+    'Googlebot',
+    'googleweblight',
+    'ia_archive',
+    'LinkedInBot',
+    'Mediapartners-Google',
+    'outbrain',
+    'pinterest',
+    'quora link preview',
+    'redditbot',
+    'rogerbot',
+    'showyoubot',
+    'SkypeUriPreview',
+    'Slackbot',
+    'Slurp',
+    'sogou',
+    'Storebot-Google',
+    'TelegramBot',
+    'tumblr',
+    'Twitterbot',
+    'vkShare',
+    'W3C_Validator',
+    'WhatsApp',
+    'yandex',
+    // SEO Tools
+    'Seoradar',
+    'W3C html2txt',
+];
+/**
+ * Creates a regex based on the botUserAgents array
+ */
+const botUARegex = new RegExp(botUserAgents.join('|'), 'i');
+/**
+ * Determines if the request is from a bot, using the URL and User Agent
+ */
+export function isBotUA(url, userAgent) {
+    return (url.searchParams.has('_bot') || (!!userAgent && botUARegex.test(userAgent)));
+}
diff --git a/dist/dist/esnext/utilities/defer.d.ts b/dist/dist/esnext/utilities/defer.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..880ef3ed6c9392df018186e1b5c9ba507ee21a97
--- /dev/null
+++ b/dist/dist/esnext/utilities/defer.d.ts
@@ -0,0 +1,6 @@
+export declare function defer<T = unknown | undefined>(): {
+    promise: Promise<T>;
+    status: 'pending' | 'resolved' | 'rejected';
+    resolve: (value: T) => void;
+    reject: (reason?: any) => void;
+};
diff --git a/dist/dist/esnext/utilities/defer.js b/dist/dist/esnext/utilities/defer.js
new file mode 100644
index 0000000000000000000000000000000000000000..09cc043627243e37e4b736a0d1f1c31aab2abf31
--- /dev/null
+++ b/dist/dist/esnext/utilities/defer.js
@@ -0,0 +1,14 @@
+export function defer() {
+    const deferred = { status: 'pending' };
+    deferred.promise = new Promise((resolve, reject) => {
+        deferred.resolve = (value) => {
+            deferred.status = 'resolved';
+            return resolve(value);
+        };
+        deferred.reject = (error) => {
+            deferred.status = 'rejected';
+            return reject(error);
+        };
+    });
+    return deferred;
+}
diff --git a/dist/dist/esnext/utilities/devtools.d.ts b/dist/dist/esnext/utilities/devtools.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f9d6db1b29ded74c35458c4e09057187701dadee
--- /dev/null
+++ b/dist/dist/esnext/utilities/devtools.d.ts
@@ -0,0 +1,11 @@
+export declare type DevServerMessage = {
+    type: 'warn';
+    data: string;
+} | {
+    type: 'error';
+    data: {
+        message: string;
+        stack: string;
+    };
+};
+export declare function sendMessageToClient(client: "browser-console" | "dev-tools" | undefined, payload: DevServerMessage): void;
diff --git a/dist/dist/esnext/utilities/devtools.js b/dist/dist/esnext/utilities/devtools.js
new file mode 100644
index 0000000000000000000000000000000000000000..30367ffaec009d5afe35300717bf981a3745af90
--- /dev/null
+++ b/dist/dist/esnext/utilities/devtools.js
@@ -0,0 +1,11 @@
+export function sendMessageToClient(client = 'browser-console', payload) {
+    // @ts-ignore
+    const devServer = globalThis.__viteDevServer;
+    if (devServer) {
+        devServer.ws.send({
+            type: 'custom',
+            event: `hydrogen-${client}`,
+            data: payload,
+        });
+    }
+}
diff --git a/dist/dist/esnext/utilities/empty-hydrogen-config.d.ts b/dist/dist/esnext/utilities/empty-hydrogen-config.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d87c48512f1ad843bb1309c01a45b38fbf09402c
--- /dev/null
+++ b/dist/dist/esnext/utilities/empty-hydrogen-config.d.ts
@@ -0,0 +1,2 @@
+declare const _default: {};
+export default _default;
diff --git a/dist/dist/esnext/utilities/empty-hydrogen-config.js b/dist/dist/esnext/utilities/empty-hydrogen-config.js
new file mode 100644
index 0000000000000000000000000000000000000000..72e883bcc394f88c38e6ce0bb2b6cfc6aa1aefc0
--- /dev/null
+++ b/dist/dist/esnext/utilities/empty-hydrogen-config.js
@@ -0,0 +1,2 @@
+// Hydrogen config fallback when not found in filesystem.
+export default {};
diff --git a/dist/dist/esnext/utilities/error.d.ts b/dist/dist/esnext/utilities/error.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..67a3f6d5d8e5fbb4f8575c2a99a783bbc1126406
--- /dev/null
+++ b/dist/dist/esnext/utilities/error.d.ts
@@ -0,0 +1 @@
+export declare function getErrorMarkup(error: Error): string;
diff --git a/dist/dist/esnext/utilities/error.js b/dist/dist/esnext/utilities/error.js
new file mode 100644
index 0000000000000000000000000000000000000000..4c4731df0d4d5a57a335c30891e909e2563d6308
--- /dev/null
+++ b/dist/dist/esnext/utilities/error.js
@@ -0,0 +1,6 @@
+export function getErrorMarkup(error) {
+    return `<script type="module">
+    import {ErrorOverlay} from '/@vite/client.js';
+    document.body.appendChild(new ErrorOverlay(${JSON.stringify(error, Object.getOwnPropertyNames(error)).replace(/</g, '\\u003c')}));
+</script>`;
+}
diff --git a/dist/dist/esnext/utilities/fetch.d.ts b/dist/dist/esnext/utilities/fetch.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..239f07a1f27f2e8e570867bb2a4c00e8693e39ab
--- /dev/null
+++ b/dist/dist/esnext/utilities/fetch.d.ts
@@ -0,0 +1,9 @@
+declare type FetchInit = {
+    body?: string;
+    method?: string;
+    headers?: Record<string, string>;
+};
+export declare function fetchBuilder<T>(url: string, options?: FetchInit): () => Promise<T>;
+export declare function graphqlRequestBody(query: string, variables?: Record<string, any>): string;
+export declare function decodeShopifyId(id: string): string;
+export {};
diff --git a/dist/dist/esnext/utilities/fetch.js b/dist/dist/esnext/utilities/fetch.js
new file mode 100644
index 0000000000000000000000000000000000000000..7518cd5ac920efea7a66d2940b6a6e1a48ed150c
--- /dev/null
+++ b/dist/dist/esnext/utilities/fetch.js
@@ -0,0 +1,34 @@
+import { LIB_VERSION } from '../version.js';
+const defaultHeaders = {
+    'content-type': 'application/json',
+    'user-agent': `Hydrogen ${LIB_VERSION}`,
+};
+export function fetchBuilder(url, options = {}) {
+    const requestInit = {
+        ...options,
+        headers: { ...defaultHeaders, ...options.headers },
+    };
+    return async () => {
+        const response = await fetch(url, requestInit);
+        if (!response.ok) {
+            if (response.status === 403 || response.status === 401) {
+                throw new Error(`Request to the Storefront API failed! You may have a bad value in 'hydrogen.config.js'. Response status: ${response.status}, Request ID: ${response.headers.get('x-request-id')}`);
+            }
+            throw new Error(`Request to the Storefront API failed! Response status: ${response.status}, Request ID: ${response.headers.get('x-request-id')}`);
+        }
+        const data = await response.json();
+        return data;
+    };
+}
+export function graphqlRequestBody(query, variables) {
+    return JSON.stringify({
+        query,
+        variables,
+    });
+}
+export function decodeShopifyId(id) {
+    if (!id.startsWith('gid://')) {
+        throw new Error('invalid Shopify ID');
+    }
+    return id;
+}
diff --git a/dist/dist/esnext/utilities/flattenConnection/flattenConnection.d.ts b/dist/dist/esnext/utilities/flattenConnection/flattenConnection.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..87c0b886400fbdf60b2c9f1e4bee7a639c9453a7
--- /dev/null
+++ b/dist/dist/esnext/utilities/flattenConnection/flattenConnection.d.ts
@@ -0,0 +1,7 @@
+import type { GraphQLConnection } from '../../types.js';
+import type { PartialDeep } from 'type-fest';
+/**
+ * The `flattenConnection` utility transforms a connection object from the Storefront API (for example, [Product-related connections](https://shopify.dev/api/storefront/reference/products/product)) into a flat array of nodes.
+ * The utility works with either `nodes` or `edges.node`.
+ */
+export declare function flattenConnection<T>(connection: PartialDeep<GraphQLConnection<T>>): PartialDeep<T>[];
diff --git a/dist/dist/esnext/utilities/flattenConnection/flattenConnection.js b/dist/dist/esnext/utilities/flattenConnection/flattenConnection.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3e36c42e35dadd9f9b65d3bacf82a8a904dcee1
--- /dev/null
+++ b/dist/dist/esnext/utilities/flattenConnection/flattenConnection.js
@@ -0,0 +1,18 @@
+/**
+ * The `flattenConnection` utility transforms a connection object from the Storefront API (for example, [Product-related connections](https://shopify.dev/api/storefront/reference/products/product)) into a flat array of nodes.
+ * The utility works with either `nodes` or `edges.node`.
+ */
+export function flattenConnection(connection) {
+    if (connection.nodes) {
+        return connection.nodes;
+    }
+    if (connection.edges) {
+        return connection.edges.map((edge) => {
+            if (!edge?.node) {
+                throw new Error('Connection edges must contain nodes');
+            }
+            return edge.node;
+        });
+    }
+    return [];
+}
diff --git a/dist/dist/esnext/utilities/flattenConnection/index.d.ts b/dist/dist/esnext/utilities/flattenConnection/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..63f650ea01db28ac04b03fee84ac9c752fbac927
--- /dev/null
+++ b/dist/dist/esnext/utilities/flattenConnection/index.d.ts
@@ -0,0 +1 @@
+export { flattenConnection } from './flattenConnection.js';
diff --git a/dist/dist/esnext/utilities/flattenConnection/index.js b/dist/dist/esnext/utilities/flattenConnection/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..63f650ea01db28ac04b03fee84ac9c752fbac927
--- /dev/null
+++ b/dist/dist/esnext/utilities/flattenConnection/index.js
@@ -0,0 +1 @@
+export { flattenConnection } from './flattenConnection.js';
diff --git a/dist/dist/esnext/utilities/graphql-tag.d.ts b/dist/dist/esnext/utilities/graphql-tag.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4f8fe601c18a50546948f06419b34cfa840e7aa4
--- /dev/null
+++ b/dist/dist/esnext/utilities/graphql-tag.d.ts
@@ -0,0 +1 @@
+export declare const gql: (s: TemplateStringsArray, ...args: any[]) => string;
diff --git a/dist/dist/esnext/utilities/graphql-tag.js b/dist/dist/esnext/utilities/graphql-tag.js
new file mode 100644
index 0000000000000000000000000000000000000000..e7ac8b8827e6db8e71848dbc694f43b221a44451
--- /dev/null
+++ b/dist/dist/esnext/utilities/graphql-tag.js
@@ -0,0 +1,6 @@
+export const gql = (s, ...args) => s
+    .map((ss, i) => `${ss}${args[i] || ''}`)
+    .join('')
+    .replace(/\s+#.*$/gm, '') // Remove GQL comments
+    .replace(/\s+/gm, ' ') // Minify spaces
+    .trim();
diff --git a/dist/dist/esnext/utilities/graphql-tracker.d.ts b/dist/dist/esnext/utilities/graphql-tracker.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..310cbb04641247c37829b6f5a25f44eabf85f9fd
--- /dev/null
+++ b/dist/dist/esnext/utilities/graphql-tracker.d.ts
@@ -0,0 +1,17 @@
+import type { ASTNode } from 'graphql';
+export declare const TIMEOUT_MS = 2000;
+declare type TrackerParams = {
+    query: ASTNode | string;
+    data: {
+        data: unknown;
+    };
+    onUnusedData?: (params: {
+        queryName: string;
+        properties: string[];
+    }) => void;
+};
+export declare function injectGraphQLTracker({ query, data, onUnusedData, }: TrackerParams): (check?: (params: {
+    queryName: string;
+    properties: string[];
+}) => void) => void;
+export {};
diff --git a/dist/dist/esnext/utilities/graphql-tracker.js b/dist/dist/esnext/utilities/graphql-tracker.js
new file mode 100644
index 0000000000000000000000000000000000000000..d803f7ca8d7c5b7a76a9148103fc734543f8f268
--- /dev/null
+++ b/dist/dist/esnext/utilities/graphql-tracker.js
@@ -0,0 +1,121 @@
+import gqlDev from 'graphql-tag';
+export const TIMEOUT_MS = 2000;
+export function injectGraphQLTracker({ query, data, onUnusedData, }) {
+    if (__HYDROGEN_DEV__ && typeof query === 'string') {
+        query = gqlDev `${query}`;
+    }
+    const info = convertQueryToResolveInfo(query);
+    // E.g. ['shop.stuff.myString']
+    const requestedFields = getFieldList(info.nodes, info.fragments);
+    // Remove the last key of each path to avoid proxying primitive
+    // values. Reverse order to avoid accessing already defined
+    // proxies (i.e. handle child properties before parent properties)
+    // E.g. `shop.stuff.myString` => `shop.stuff`
+    const uniqueFieldPaths = [
+        ...new Set(requestedFields.map((path) => path.split('.').slice(0, -1).join('.'))),
+    ].reverse();
+    const queryName = findOperationDefinition(query).name?.value || '';
+    // Record fields that are read in the proxy to compare later.
+    const readFieldsMap = {};
+    let isCheckedOnce = false;
+    const checkFields = (check = onUnusedData) => {
+        isCheckedOnce = true;
+        const properties = requestedFields
+            .filter((prop) => !readFieldsMap[prop] && !prop.endsWith('.__typename'))
+            .map((prop) => prop.replace(/\.edges\./g, '.').replace(/\.node\./g, '.'));
+        if (properties.length > 0) {
+            return check({ queryName, properties });
+        }
+    };
+    let readTimeout;
+    uniqueFieldPaths.forEach((fieldPath) => deepTransform(data, 'data.' + fieldPath, (value) => {
+        if (typeof value !== 'object' || value === null)
+            return value;
+        return new Proxy(value, {
+            get(target, prop) {
+                if (typeof prop === 'string') {
+                    const fullPath = fieldPath + '.' + prop;
+                    if (!readFieldsMap[fullPath]) {
+                        readFieldsMap[fullPath] = true;
+                        if (onUnusedData && !isCheckedOnce) {
+                            clearTimeout(readTimeout);
+                            readTimeout = setTimeout(checkFields, TIMEOUT_MS);
+                        }
+                    }
+                }
+                return target[prop];
+            },
+        });
+    }));
+    return checkFields;
+}
+function findOperationDefinition(query) {
+    return query.definitions.find((def) => def.kind === 'OperationDefinition');
+}
+function convertQueryToResolveInfo(query) {
+    return {
+        // Root of the selection nodes
+        nodes: findOperationDefinition(query)?.selectionSet
+            .selections,
+        // Collection of all the fragments in this query
+        fragments: query.definitions.reduce((acc, current) => {
+            if (current.kind === 'FragmentDefinition') {
+                acc[current.name.value] = current;
+            }
+            return acc;
+        }, {}),
+    };
+}
+/**
+ * Extracts the selection fields from a query AST as a list of dot-separated paths.
+ * @param selectionNodes - Selection nodes from the AST
+ * @param fragments - Fragments from the AST
+ * @param path - Accummulated path for recursion
+ * @returns A plain JS array representing the selection fields
+ */
+function getFieldList(nodes, fragments = {}, path = '') {
+    return nodes.reduce((acc, node) => {
+        let nextPath = path;
+        let nextNodes;
+        if (node.kind === 'FragmentSpread') {
+            nextNodes = fragments[node.name.value].selectionSet.selections;
+        }
+        else if (node.kind === 'InlineFragment') {
+            nextNodes = node.selectionSet?.selections;
+        }
+        else if (node.kind === 'Field') {
+            nextNodes = node.selectionSet?.selections;
+            const name = node.alias?.value ?? node.name?.value;
+            nextPath = path ? `${path}.${name}` : name;
+            if (!nextNodes)
+                acc.push(nextPath); // This is a leaf
+        }
+        if (nextNodes)
+            acc.push(...getFieldList(nextNodes, fragments, nextPath));
+        return acc;
+    }, []);
+}
+/**
+ * Transform a nested property in a given object (in place).
+ * @param input - Object to transform
+ * @param path - Dot-separated path to the nested property
+ * @param valueTransform - Transformer function
+ */
+function deepTransform(input, path, valueTransform) {
+    const keys = Array.isArray(path) ? path : path.split('.');
+    let obj = input;
+    let key;
+    for (let index = 0; !!obj && index < keys.length; index++) {
+        key = keys[index];
+        if (index === keys.length - 1) {
+            // Last property, transform value
+            obj[key] = valueTransform(obj[key]);
+        }
+        else if (Array.isArray(obj[key])) {
+            // We've found an array in the middle, run this recursively
+            const subKeys = keys.slice(index + 1);
+            obj[key].forEach((v) => deepTransform(v, subKeys, valueTransform));
+        }
+        obj = obj[key];
+    }
+}
diff --git a/dist/dist/esnext/utilities/hash.d.ts b/dist/dist/esnext/utilities/hash.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..06eba4295bed63849e52120cacdf822496b7c6a9
--- /dev/null
+++ b/dist/dist/esnext/utilities/hash.d.ts
@@ -0,0 +1,2 @@
+import type { QueryKey } from '../types.js';
+export declare function hashKey(queryKey: QueryKey): string;
diff --git a/dist/dist/esnext/utilities/hash.js b/dist/dist/esnext/utilities/hash.js
new file mode 100644
index 0000000000000000000000000000000000000000..1391d103878f19dd68fab39bc3b05302af0879f9
--- /dev/null
+++ b/dist/dist/esnext/utilities/hash.js
@@ -0,0 +1,30 @@
+import { STOREFRONT_API_BUYER_IP_HEADER } from '../constants.js';
+export function hashKey(queryKey) {
+    const rawKeys = Array.isArray(queryKey) ? queryKey : [queryKey];
+    let hash = '';
+    // Keys from useShopQuery are in the following shape:
+    // ['prefix', 'api-endpoint', {body:'query',headers:{}}]
+    // Since the API endpoint already contains the shop domain and api version,
+    // we can ignore the headers and only use the `body` from the payload.
+    for (const key of rawKeys) {
+        if (key != null) {
+            if (typeof key === 'object') {
+                // Queries from useQuery might not have a `body`. In that case,
+                // fallback to a safer (but slower) stringify.
+                if (!!key.body && typeof key.body === 'string') {
+                    hash += key.body;
+                    if (!!key.headers && key.headers[STOREFRONT_API_BUYER_IP_HEADER]) {
+                        hash += key.headers[STOREFRONT_API_BUYER_IP_HEADER];
+                    }
+                }
+                else {
+                    hash += JSON.stringify(key);
+                }
+            }
+            else {
+                hash += key;
+            }
+        }
+    }
+    return hash;
+}
diff --git a/dist/dist/esnext/utilities/html-encoding.d.ts b/dist/dist/esnext/utilities/html-encoding.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b43653e2d52e59111373e497e92489e6463c0bea
--- /dev/null
+++ b/dist/dist/esnext/utilities/html-encoding.d.ts
@@ -0,0 +1 @@
+export declare function htmlEncode(html: string): string;
diff --git a/dist/dist/esnext/utilities/html-encoding.js b/dist/dist/esnext/utilities/html-encoding.js
new file mode 100644
index 0000000000000000000000000000000000000000..f050865302a807426bebe4dbb2a2b3eee78f9d4e
--- /dev/null
+++ b/dist/dist/esnext/utilities/html-encoding.js
@@ -0,0 +1,8 @@
+export function htmlEncode(html) {
+    return html
+        .replace(/&/g, '&amp;')
+        .replace(/</g, '&lt;')
+        .replace(/>/g, '&gt;')
+        .replace(/"/g, '&quot;')
+        .replace(/'/g, '&#39;');
+}
diff --git a/dist/dist/esnext/utilities/image_size.d.ts b/dist/dist/esnext/utilities/image_size.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b13e617e9f5f74f66b72aa7d8cfef4332706db52
--- /dev/null
+++ b/dist/dist/esnext/utilities/image_size.d.ts
@@ -0,0 +1,34 @@
+import type { Image as ImageType } from '../storefront-api-types.js';
+import type { PartialDeep } from 'type-fest';
+import type { ShopifyLoaderOptions, ShopifyLoaderParams } from '../components/Image';
+export declare const IMG_SRC_SET_SIZES: number[];
+/**
+ * Adds image size parameters to an image URL hosted by Shopify's CDN
+ */
+export declare function addImageSizeParametersToUrl({ src, width, height, crop, scale, }: ShopifyLoaderParams): string;
+export declare function shopifyImageLoader(params: ShopifyLoaderParams): string;
+declare type HtmlImageProps = React.ImgHTMLAttributes<HTMLImageElement>;
+export declare type GetShopifyImageDimensionsProps = {
+    data: Pick<PartialDeep<ImageType>, 'altText' | 'url' | 'id' | 'width' | 'height'>;
+    loaderOptions?: ShopifyLoaderOptions;
+    elementProps?: {
+        width?: HtmlImageProps['width'];
+        height?: HtmlImageProps['height'];
+    };
+};
+declare type GetShopifyImageDimensionsPropsReturn = {
+    width: number | string | null;
+    height: number | string | null;
+};
+/**
+ * Width and height are determined using the followiing priority list:
+ * 1. `loaderOptions`'s width/height
+ * 2. `elementProps`'s width/height
+ * 3. `data`'s width/height
+ *
+ * If only one of `width` or `height` are defined, then the other will attempt to be calculated based on the Image's aspect ratio,
+ * provided that both `data.width` and `data.height` are available. If not, then the aspect ratio cannot be determined and the missing
+ * value will reamin as `null`
+ */
+export declare function getShopifyImageDimensions({ data: sfapiImage, loaderOptions, elementProps, }: GetShopifyImageDimensionsProps): GetShopifyImageDimensionsPropsReturn;
+export {};
diff --git a/dist/dist/esnext/utilities/image_size.js b/dist/dist/esnext/utilities/image_size.js
new file mode 100644
index 0000000000000000000000000000000000000000..dabcba6470b673d9dfef34a7865296d0830e01a6
--- /dev/null
+++ b/dist/dist/esnext/utilities/image_size.js
@@ -0,0 +1,96 @@
+// TODO: Are there other CDNs missing from here?
+const PRODUCTION_CDN_HOSTNAMES = [
+    'cdn.shopify.com',
+    'cdn.shopifycdn.net',
+    'shopify-assets.shopifycdn.com',
+    'shopify-assets.shopifycdn.net',
+];
+const LOCAL_CDN_HOSTNAMES = ['spin.dev'];
+const ALL_CDN_HOSTNAMES = [...PRODUCTION_CDN_HOSTNAMES, ...LOCAL_CDN_HOSTNAMES];
+// based on the default width sizes used by the Shopify liquid HTML tag img_tag plus a 2560 width to account for 2k resolutions
+// reference: https://shopify.dev/api/liquid/filters/html-filters#image_tag
+export const IMG_SRC_SET_SIZES = [352, 832, 1200, 1920, 2560];
+/**
+ * Adds image size parameters to an image URL hosted by Shopify's CDN
+ */
+export function addImageSizeParametersToUrl({ src, width, height, crop, scale, }) {
+    const newUrl = new URL(src);
+    const multipliedScale = scale ?? 1;
+    if (width) {
+        let finalWidth;
+        if (typeof width === 'string') {
+            finalWidth = (IMG_SRC_SET_SIZES[0] * multipliedScale).toString();
+        }
+        else {
+            finalWidth = (Number(width) * multipliedScale).toString();
+        }
+        newUrl.searchParams.append('width', finalWidth);
+    }
+    if (height && typeof height === 'number') {
+        newUrl.searchParams.append('height', (height * multipliedScale).toString());
+    }
+    crop && newUrl.searchParams.append('crop', crop);
+    // for now we intentionally leave off the scale param, and instead multiple width & height by scale instead
+    // scale && newUrl.searchParams.append('scale', scale.toString());
+    return newUrl.toString();
+}
+export function shopifyImageLoader(params) {
+    const newSrc = new URL(params.src);
+    const isShopifyServedImage = ALL_CDN_HOSTNAMES.some((allowedHostname) => newSrc.hostname.endsWith(allowedHostname));
+    if (!isShopifyServedImage ||
+        (!params.width && !params.height && !params.crop && !params.scale)) {
+        return params.src;
+    }
+    return addImageSizeParametersToUrl(params);
+}
+/**
+ * Width and height are determined using the followiing priority list:
+ * 1. `loaderOptions`'s width/height
+ * 2. `elementProps`'s width/height
+ * 3. `data`'s width/height
+ *
+ * If only one of `width` or `height` are defined, then the other will attempt to be calculated based on the Image's aspect ratio,
+ * provided that both `data.width` and `data.height` are available. If not, then the aspect ratio cannot be determined and the missing
+ * value will reamin as `null`
+ */
+export function getShopifyImageDimensions({ data: sfapiImage, loaderOptions, elementProps, }) {
+    let aspectRatio = null;
+    if (sfapiImage?.width && sfapiImage?.height) {
+        aspectRatio = sfapiImage?.width / sfapiImage?.height;
+    }
+    //  * 1. `loaderOptions`'s width/height
+    if (loaderOptions?.width || loaderOptions?.height) {
+        return {
+            width: loaderOptions?.width ??
+                (aspectRatio && typeof loaderOptions.height === 'number'
+                    ? Math.round(aspectRatio * loaderOptions.height)
+                    : null),
+            height: loaderOptions?.height ??
+                (aspectRatio && typeof loaderOptions.width === 'number'
+                    ? Math.round(aspectRatio * loaderOptions.width)
+                    : null),
+        };
+    }
+    //  * 2. `elementProps`'s width/height
+    if (elementProps?.width || elementProps?.height) {
+        return {
+            width: elementProps?.width ??
+                (aspectRatio && typeof elementProps.height === 'number'
+                    ? Math.round(aspectRatio * elementProps.height)
+                    : null),
+            height: elementProps?.height ??
+                (aspectRatio && typeof elementProps.width === 'number'
+                    ? Math.round(aspectRatio * elementProps.width)
+                    : null),
+        };
+    }
+    //  * 3. `data`'s width/height
+    if (sfapiImage?.width || sfapiImage?.height) {
+        return {
+            // can't calculate the aspect ratio here
+            width: sfapiImage?.width ?? null,
+            height: sfapiImage?.height ?? null,
+        };
+    }
+    return { width: null, height: null };
+}
diff --git a/dist/dist/esnext/utilities/index.d.ts b/dist/dist/esnext/utilities/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..15f04e45139978711eb425280cd387214d348ec7
--- /dev/null
+++ b/dist/dist/esnext/utilities/index.d.ts
@@ -0,0 +1,12 @@
+export { addImageSizeParametersToUrl, getShopifyImageDimensions, shopifyImageLoader, IMG_SRC_SET_SIZES, } from './image_size.js';
+export { YouTube, Vimeo, addParametersToEmbeddedVideoUrl, useEmbeddedVideoUrl, } from './video_parameters.js';
+export { loadScript } from './load_script.js';
+export { wrapPromise } from './suspense.js';
+export { flattenConnection } from './flattenConnection/index.js';
+export { isBrowser } from './isBrowser/index.js';
+export { isServer } from './isServer/index.js';
+export { getMeasurementAsParts, getMeasurementAsString } from './measurement.js';
+export { parseMetafieldValue, parseMetafield } from './parseMetafield/index.js';
+export { fetchBuilder, graphqlRequestBody, decodeShopifyId } from './fetch.js';
+export { getTime } from './timing.js';
+export { htmlEncode } from './html-encoding.js';
diff --git a/dist/dist/esnext/utilities/index.js b/dist/dist/esnext/utilities/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..eece444f87236a57898c1c2f3641b2ab546d2895
--- /dev/null
+++ b/dist/dist/esnext/utilities/index.js
@@ -0,0 +1,12 @@
+export { addImageSizeParametersToUrl, getShopifyImageDimensions, shopifyImageLoader, IMG_SRC_SET_SIZES, } from './image_size.js';
+export { addParametersToEmbeddedVideoUrl, useEmbeddedVideoUrl, } from './video_parameters.js';
+export { loadScript } from './load_script.js';
+export { wrapPromise } from './suspense.js';
+export { flattenConnection } from './flattenConnection/index.js';
+export { isBrowser } from './isBrowser/index.js';
+export { isServer } from './isServer/index.js';
+export { getMeasurementAsParts, getMeasurementAsString } from './measurement.js';
+export { parseMetafieldValue, parseMetafield } from './parseMetafield/index.js';
+export { fetchBuilder, graphqlRequestBody, decodeShopifyId } from './fetch.js';
+export { getTime } from './timing.js';
+export { htmlEncode } from './html-encoding.js';
diff --git a/dist/dist/esnext/utilities/isBrowser/index.d.ts b/dist/dist/esnext/utilities/isBrowser/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8512c5736189ce0b97ea3042b5aa4e10f0d8acc0
--- /dev/null
+++ b/dist/dist/esnext/utilities/isBrowser/index.d.ts
@@ -0,0 +1 @@
+export { isBrowser } from './isBrowser.js';
diff --git a/dist/dist/esnext/utilities/isBrowser/index.js b/dist/dist/esnext/utilities/isBrowser/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..8512c5736189ce0b97ea3042b5aa4e10f0d8acc0
--- /dev/null
+++ b/dist/dist/esnext/utilities/isBrowser/index.js
@@ -0,0 +1 @@
+export { isBrowser } from './isBrowser.js';
diff --git a/dist/dist/esnext/utilities/isBrowser/isBrowser.d.ts b/dist/dist/esnext/utilities/isBrowser/isBrowser.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..703c1669a8ff0d8cfdbfd7d64f8dbbd1c4cb74b3
--- /dev/null
+++ b/dist/dist/esnext/utilities/isBrowser/isBrowser.d.ts
@@ -0,0 +1,4 @@
+/** The `isClient` utility is a function that returns a boolean indicating
+ * if the code was run in the browser.
+ */
+export declare function isBrowser(): boolean;
diff --git a/dist/dist/esnext/utilities/isBrowser/isBrowser.js b/dist/dist/esnext/utilities/isBrowser/isBrowser.js
new file mode 100644
index 0000000000000000000000000000000000000000..5c885099b6155edd25a5676b82d2e1f857f11d25
--- /dev/null
+++ b/dist/dist/esnext/utilities/isBrowser/isBrowser.js
@@ -0,0 +1,6 @@
+/** The `isClient` utility is a function that returns a boolean indicating
+ * if the code was run in the browser.
+ */
+export function isBrowser() {
+    return typeof document !== 'undefined';
+}
diff --git a/dist/dist/esnext/utilities/isServer/index.d.ts b/dist/dist/esnext/utilities/isServer/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..023baf1be4f6efac44a4d2cf234791bf03e24ec0
--- /dev/null
+++ b/dist/dist/esnext/utilities/isServer/index.d.ts
@@ -0,0 +1 @@
+export { isServer } from './isServer.js';
diff --git a/dist/dist/esnext/utilities/isServer/index.js b/dist/dist/esnext/utilities/isServer/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..023baf1be4f6efac44a4d2cf234791bf03e24ec0
--- /dev/null
+++ b/dist/dist/esnext/utilities/isServer/index.js
@@ -0,0 +1 @@
+export { isServer } from './isServer.js';
diff --git a/dist/dist/esnext/utilities/isServer/isServer.d.ts b/dist/dist/esnext/utilities/isServer/isServer.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a7cf0b61f69a5f8247d6628c535650638bde798a
--- /dev/null
+++ b/dist/dist/esnext/utilities/isServer/isServer.d.ts
@@ -0,0 +1,4 @@
+/** The `isServer` utility is a function that returns a `boolean` indicating
+ * if the code was run on the server.
+ */
+export declare function isServer(): boolean;
diff --git a/dist/dist/esnext/utilities/isServer/isServer.js b/dist/dist/esnext/utilities/isServer/isServer.js
new file mode 100644
index 0000000000000000000000000000000000000000..f9b46235e76b75ce086616b9ab53292ea7ffe16b
--- /dev/null
+++ b/dist/dist/esnext/utilities/isServer/isServer.js
@@ -0,0 +1,7 @@
+import { isBrowser } from '../isBrowser/index.js';
+/** The `isServer` utility is a function that returns a `boolean` indicating
+ * if the code was run on the server.
+ */
+export function isServer() {
+    return !isBrowser();
+}
diff --git a/dist/dist/esnext/utilities/load_script.d.ts b/dist/dist/esnext/utilities/load_script.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6a8260ce728dad1c2fdf0376008a57146c18c9ee
--- /dev/null
+++ b/dist/dist/esnext/utilities/load_script.d.ts
@@ -0,0 +1,4 @@
+export declare function loadScript(src: string, options?: {
+    module?: boolean;
+    in?: 'head' | 'body';
+}): Promise<boolean>;
diff --git a/dist/dist/esnext/utilities/load_script.js b/dist/dist/esnext/utilities/load_script.js
new file mode 100644
index 0000000000000000000000000000000000000000..247e5c20ab513096489a927a58fc58d99f264bb1
--- /dev/null
+++ b/dist/dist/esnext/utilities/load_script.js
@@ -0,0 +1,28 @@
+const SCRIPTS_LOADED = {};
+export function loadScript(src, options) {
+    const isScriptLoaded = SCRIPTS_LOADED[src];
+    if (isScriptLoaded) {
+        return isScriptLoaded;
+    }
+    const promise = new Promise((resolve, reject) => {
+        const script = document.createElement('script');
+        if (options?.module) {
+            script.type = 'module';
+        }
+        script.src = src;
+        script.onload = () => {
+            resolve(true);
+        };
+        script.onerror = () => {
+            reject(false);
+        };
+        if (options?.in === 'head') {
+            document.head.appendChild(script);
+        }
+        else {
+            document.body.appendChild(script);
+        }
+    });
+    SCRIPTS_LOADED[src] = promise;
+    return promise;
+}
diff --git a/dist/dist/esnext/utilities/locale/index.d.ts b/dist/dist/esnext/utilities/locale/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a44485cb4f2fc7f999a9a50189d1a18566d511ad
--- /dev/null
+++ b/dist/dist/esnext/utilities/locale/index.d.ts
@@ -0,0 +1 @@
+export { getLocale } from './locale.js';
diff --git a/dist/dist/esnext/utilities/locale/index.js b/dist/dist/esnext/utilities/locale/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..a44485cb4f2fc7f999a9a50189d1a18566d511ad
--- /dev/null
+++ b/dist/dist/esnext/utilities/locale/index.js
@@ -0,0 +1 @@
+export { getLocale } from './locale.js';
diff --git a/dist/dist/esnext/utilities/locale/locale.d.ts b/dist/dist/esnext/utilities/locale/locale.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8b194e6503b06dcdbd674bdee32d13be498686bc
--- /dev/null
+++ b/dist/dist/esnext/utilities/locale/locale.d.ts
@@ -0,0 +1,7 @@
+import { CountryCode, LanguageCode } from '../../storefront-api-types.js';
+/**
+ * Calculates locale based on provided language and countryCode
+ * 1. If language is extended with region, then hyphenate and use as locale
+ * 2. Else merge language and countryCode
+ */
+export declare function getLocale(language?: `${LanguageCode}`, countryCode?: `${CountryCode}`): string;
diff --git a/dist/dist/esnext/utilities/locale/locale.js b/dist/dist/esnext/utilities/locale/locale.js
new file mode 100644
index 0000000000000000000000000000000000000000..6139ee6d1d1a1f701470c1e21ba25d7187e06521
--- /dev/null
+++ b/dist/dist/esnext/utilities/locale/locale.js
@@ -0,0 +1,22 @@
+/**
+ * Calculates locale based on provided language and countryCode
+ * 1. If language is extended with region, then hyphenate and use as locale
+ * 2. Else merge language and countryCode
+ */
+export function getLocale(language, countryCode) {
+    if (!language || !countryCode) {
+        return '';
+    }
+    if (isLanguageExtended(language)) {
+        return hyphenateLanguage(language);
+    }
+    return `${language}-${countryCode}`;
+}
+function hyphenateLanguage(str) {
+    return str.replace('_', '-');
+}
+function isLanguageExtended(str) {
+    if (!str)
+        return false;
+    return str.includes('_') || str.includes('-');
+}
diff --git a/dist/dist/esnext/utilities/log/index.d.ts b/dist/dist/esnext/utilities/log/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..079769550472ebf199978311423eaad3fcf58e34
--- /dev/null
+++ b/dist/dist/esnext/utilities/log/index.d.ts
@@ -0,0 +1,4 @@
+export { log, setLogger, getLoggerWithContext, Logger, logServerResponse, type RenderType, type LoggerConfig, } from './log.js';
+export { collectQueryCacheControlHeaders, logCacheControlHeaders, } from './log-cache-header.js';
+export { logCacheApiStatus } from './log-cache-api-status.js';
+export { collectQueryTimings, logQueryTimings } from './log-query-timeline.js';
diff --git a/dist/dist/esnext/utilities/log/index.js b/dist/dist/esnext/utilities/log/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..3e5285a194a348c0ed08db9c6f260b7e09acba77
--- /dev/null
+++ b/dist/dist/esnext/utilities/log/index.js
@@ -0,0 +1,4 @@
+export { log, setLogger, getLoggerWithContext, logServerResponse, } from './log.js';
+export { collectQueryCacheControlHeaders, logCacheControlHeaders, } from './log-cache-header.js';
+export { logCacheApiStatus } from './log-cache-api-status.js';
+export { collectQueryTimings, logQueryTimings } from './log-query-timeline.js';
diff --git a/dist/dist/esnext/utilities/log/log-cache-api-status.d.ts b/dist/dist/esnext/utilities/log/log-cache-api-status.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9ecf8505f9542d8cc64d6d80a85ee824b42cdc8c
--- /dev/null
+++ b/dist/dist/esnext/utilities/log/log-cache-api-status.d.ts
@@ -0,0 +1 @@
+export declare function logCacheApiStatus(status: string | null, url: string): void;
diff --git a/dist/dist/esnext/utilities/log/log-cache-api-status.js b/dist/dist/esnext/utilities/log/log-cache-api-status.js
new file mode 100644
index 0000000000000000000000000000000000000000..52c3ed93a7371cb98a7d8aa3d72c3293a6f515d0
--- /dev/null
+++ b/dist/dist/esnext/utilities/log/log-cache-api-status.js
@@ -0,0 +1,17 @@
+import { findQueryName } from './utils.js';
+import { gray } from 'kolorist';
+import { log } from '.';
+export function logCacheApiStatus(status, url) {
+    if (!log.options().showCacheApiStatus) {
+        return;
+    }
+    let queryName;
+    if (url.includes('shopify.dev')) {
+        url = decodeURIComponent(url);
+        queryName = findQueryName(url);
+        if (url.includes('?lock')) {
+            queryName += '-lock';
+        }
+    }
+    log.debug(gray(`[Cache] ${status?.padEnd(8)} ${queryName ? `query ${queryName}` : url}`));
+}
diff --git a/dist/dist/esnext/utilities/log/log-cache-header.d.ts b/dist/dist/esnext/utilities/log/log-cache-header.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7f84439d4a72f6153ecc723644ce3d5ff5101649
--- /dev/null
+++ b/dist/dist/esnext/utilities/log/log-cache-header.d.ts
@@ -0,0 +1,10 @@
+import { HydrogenRequest } from '../../foundation/HydrogenRequest/HydrogenRequest.server.js';
+import { HydrogenResponse } from '../../foundation/HydrogenResponse/HydrogenResponse.server.js';
+import { QueryKey } from '../../types.js';
+import { type RenderType } from './log.js';
+export declare type QueryCacheControlHeaders = {
+    name: string;
+    header: string | null;
+};
+export declare function collectQueryCacheControlHeaders(request: HydrogenRequest, queryKey: QueryKey, cacheControlHeader: string | null): void;
+export declare function logCacheControlHeaders(type: RenderType, request: HydrogenRequest, response?: HydrogenResponse): void;
diff --git a/dist/dist/esnext/utilities/log/log-cache-header.js b/dist/dist/esnext/utilities/log/log-cache-header.js
new file mode 100644
index 0000000000000000000000000000000000000000..f5887f622ed90b90cf55c6af75c1dfedbb646249
--- /dev/null
+++ b/dist/dist/esnext/utilities/log/log-cache-header.js
@@ -0,0 +1,30 @@
+import { hashKey } from '../hash.js';
+import { findQueryName, parseUrl } from './utils.js';
+import { gray } from 'kolorist';
+import { getLoggerWithContext } from './log.js';
+const color = gray;
+export function collectQueryCacheControlHeaders(request, queryKey, cacheControlHeader) {
+    request.ctx.queryCacheControl.push({
+        name: findQueryName(hashKey(queryKey)),
+        header: cacheControlHeader,
+    });
+}
+export function logCacheControlHeaders(type, request, response) {
+    const log = getLoggerWithContext(request);
+    if (!log.options().showCacheControlHeader) {
+        return;
+    }
+    log.debug(color(` Cache control header for ${parseUrl(type, request.url)}`));
+    if (response) {
+        log.debug(color(` ${response.cacheControlHeader}`));
+    }
+    const queryList = request.ctx.queryCacheControl;
+    const longestQueryNameLength = queryList.reduce((max, query) => Math.max(max, query.name.length), 0);
+    if (queryList.length > 0) {
+        log.debug(color(''));
+        queryList.forEach((query) => {
+            log.debug(color(` query ${query.name.padEnd(longestQueryNameLength + 1)}${query.header}`));
+        });
+    }
+    log.debug(color(''));
+}
diff --git a/dist/dist/esnext/utilities/log/log-query-timeline.d.ts b/dist/dist/esnext/utilities/log/log-query-timeline.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0c385313460cd03c8f8149fccd119de3b4b630cd
--- /dev/null
+++ b/dist/dist/esnext/utilities/log/log-query-timeline.d.ts
@@ -0,0 +1,12 @@
+import { HydrogenRequest } from '../../foundation/HydrogenRequest/HydrogenRequest.server.js';
+import { QueryKey } from '../../types.js';
+import { type RenderType } from './log.js';
+export declare type TimingType = 'requested' | 'resolved' | 'rendered' | 'preload';
+export declare type QueryTiming = {
+    name: string;
+    timingType: TimingType;
+    timestamp: number;
+    duration?: number;
+};
+export declare function collectQueryTimings(request: HydrogenRequest, queryKey: QueryKey, timingType: TimingType, duration?: number): void;
+export declare function logQueryTimings(type: RenderType, request: HydrogenRequest): void;
diff --git a/dist/dist/esnext/utilities/log/log-query-timeline.js b/dist/dist/esnext/utilities/log/log-query-timeline.js
new file mode 100644
index 0000000000000000000000000000000000000000..4f42aae28c4465dded40ecf598365a956797af11
--- /dev/null
+++ b/dist/dist/esnext/utilities/log/log-query-timeline.js
@@ -0,0 +1,105 @@
+import { hashKey } from '../hash.js';
+import { findQueryName, parseUrl } from './utils.js';
+import { gray, red, yellow, green } from 'kolorist';
+import { getLoggerWithContext } from './log.js';
+import { getTime } from '../timing.js';
+const color = gray;
+const TIMING_MAPPING = {
+    requested: 'Requested',
+    rendered: 'Rendered',
+    resolved: 'Resolved',
+    preload: 'Preload',
+};
+export function collectQueryTimings(request, queryKey, timingType, duration) {
+    const hashedKey = hashKey(queryKey);
+    if (hashedKey !== 'hydrogen-shopify-config') {
+        request.ctx.queryTimings.push({
+            name: findQueryName(hashedKey),
+            timingType,
+            timestamp: getTime(),
+            duration,
+        });
+    }
+}
+export function logQueryTimings(type, request) {
+    const log = getLoggerWithContext(request);
+    if (!__HYDROGEN_DEV__ && !log.options().showQueryTiming) {
+        return;
+    }
+    const previouslyLoadedRequest = request.previouslyLoadedRequest();
+    let logMessage = color(` Query timings for ${parseUrl(type, request.url)}`);
+    let firstSuspenseWaterfallQueryName = '';
+    const queryList = request.ctx.queryTimings;
+    if (queryList.length > 0) {
+        const requestStartTime = request.time;
+        const detectSuspenseWaterfall = {};
+        const detectMultipleDataLoad = {};
+        const preloadedQueries = new Set();
+        let suspenseWaterfallDetectedCount = 0;
+        queryList.forEach((query, index) => {
+            if (query.timingType === 'preload')
+                preloadedQueries.add(query.name);
+            if (query.timingType === 'requested' || query.timingType === 'preload') {
+                detectSuspenseWaterfall[query.name] = true;
+            }
+            else if (query.timingType === 'rendered') {
+                delete detectSuspenseWaterfall[query.name];
+            }
+            else if (query.timingType === 'resolved') {
+                detectMultipleDataLoad[query.name] = detectMultipleDataLoad[query.name]
+                    ? detectMultipleDataLoad[query.name] + 1
+                    : 1;
+            }
+            const loadColor = query.timingType === 'preload' ? green : color;
+            const duration = query.duration;
+            logMessage += color(`\n ${`${(query.timestamp - requestStartTime).toFixed(2)}ms`.padEnd(10)} ${loadColor(TIMING_MAPPING[query.timingType].padEnd(10))} ${query.name}${query.timingType === 'resolved'
+                ? ` (Took ${duration?.toFixed(2)}ms)`
+                : ''}`);
+            // SSR + RSC render path generates 2 `load` and `render` for each query
+            // We want to avoid falsely identifying a suspense waterfall near the end
+            // of the query list
+            //
+            // The (index + 4) is detecting that near the end of list.
+            // A complete set of events for a given query is 4 entries
+            //  (639.62ms)  Requested  Localization
+            //  (993.33ms)  Resolved   Localization (Took 353.66ms)
+            //  (993.96ms)  Requested  Localization      <-- second time React tries to load
+            //  (994.03ms)  Rendered   Localization
+            //
+            // so the end of list index range is 3 (one less from a set entry) + 1 (zero index)
+            if (queryList.length >= index + 4 &&
+                Object.keys(detectSuspenseWaterfall).length === 0 &&
+                !preloadedQueries.has(query.name) &&
+                previouslyLoadedRequest) {
+                // Store the first suspense waterfall query name to display in the summary console output
+                if (!firstSuspenseWaterfallQueryName)
+                    firstSuspenseWaterfallQueryName = query.name;
+                suspenseWaterfallDetectedCount++;
+                const warningColor = suspenseWaterfallDetectedCount === 1 ? yellow : red;
+                logMessage += `\n${color(` `)}${warningColor(`Suspense waterfall detected`)}`;
+            }
+        });
+        const unusedQueries = Object.keys(detectSuspenseWaterfall);
+        if (unusedQueries.length > 0) {
+            unusedQueries.forEach((queryName) => {
+                logMessage += `\n${color(` `)}${yellow(`Unused query detected: ${queryName}`)}`;
+            });
+        }
+        Object.keys(detectMultipleDataLoad).forEach((queryName) => {
+            const count = detectMultipleDataLoad[queryName];
+            if (count > 1) {
+                logMessage += `\n${color(` `)}${yellow(`Multiple data loads detected: ${queryName}`)}`;
+            }
+        });
+    }
+    logMessage += '\n' + color('');
+    if (log.options().showQueryTiming) {
+        log.debug(logMessage);
+    }
+    else if (firstSuspenseWaterfallQueryName) {
+        log.debug(yellow('Suspense waterfall detected on query: ' +
+            firstSuspenseWaterfallQueryName));
+        log.debug('  Add the `showQueryTiming` property to your Hydrogen configuration to see more information:');
+        log.debug('  https://shopify.dev/custom-storefronts/hydrogen/framework/hydrogen-config#logger');
+    }
+}
diff --git a/dist/dist/esnext/utilities/log/log.d.ts b/dist/dist/esnext/utilities/log/log.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4b885c45d4d0836224bc0d04a7ce60787c1022b0
--- /dev/null
+++ b/dist/dist/esnext/utilities/log/log.d.ts
@@ -0,0 +1,28 @@
+import { HydrogenRequest } from '../../foundation/HydrogenRequest/HydrogenRequest.server.js';
+/** The `log` utility is a function that's used for logging debugging, warning, and error information about the application.
+ * Use this utility by importing `log` from `@shopify/hydrogen`, or by using a `log` prop passed to each page
+ * component. We recommend using the `log` prop passed to each page because it will associated your log to the
+ * current request in progress.
+ */
+declare type LoggerMethod = (...args: Array<any>) => void | Promise<any>;
+export interface Logger {
+    trace: LoggerMethod;
+    debug: LoggerMethod;
+    warn: LoggerMethod;
+    error: LoggerMethod;
+    fatal: LoggerMethod;
+    options: () => LoggerOptions;
+}
+export declare type LoggerOptions = {
+    showCacheControlHeader?: boolean;
+    showCacheApiStatus?: boolean;
+    showQueryTiming?: boolean;
+    showUnusedQueryProperties?: boolean;
+};
+export declare type LoggerConfig = Partial<Exclude<Logger, 'options'>> & LoggerOptions;
+export declare type RenderType = 'str' | 'rsc' | 'ssr' | 'api';
+export declare function getLoggerWithContext(context: Partial<HydrogenRequest>): Logger;
+export declare const log: Logger;
+export declare function setLogger(config?: LoggerConfig): void;
+export declare function logServerResponse(type: RenderType, request: HydrogenRequest, responseStatus: number, didError: boolean): void;
+export {};
diff --git a/dist/dist/esnext/utilities/log/log.js b/dist/dist/esnext/utilities/log/log.js
new file mode 100644
index 0000000000000000000000000000000000000000..41d87856b0ca32dea76b4c33c49153a68c012a7f
--- /dev/null
+++ b/dist/dist/esnext/utilities/log/log.js
@@ -0,0 +1,89 @@
+import { yellow, red, green, italic, lightBlue } from 'kolorist';
+import { getTime } from '../timing.js';
+import { parseUrl } from './utils.js';
+const defaultLogger = {
+    trace(context, ...args) {
+        // Re-enable following line to show trace debugging information
+        // console.log(context.id, ...args);
+    },
+    debug(context, ...args) {
+        console.log(...args);
+    },
+    warn(context, ...args) {
+        console.warn(yellow('WARN: '), ...args);
+    },
+    error(context, error, ...extra) {
+        const url = context ? ` ${context.url}` : '';
+        if (error instanceof Error) {
+            console.error(red(`Error processing route:${url}\n${error.stack}`));
+        }
+        else {
+            console.error(red(`Error:${url} ${error}`));
+        }
+    },
+    fatal(context, ...args) {
+        console.error(red('FATAL: '), ...args);
+    },
+    options: () => ({}),
+};
+let currentLogger = defaultLogger;
+function doLog(method, request, ...args) {
+    try {
+        const maybePromise = currentLogger[method](request, ...args);
+        if (maybePromise instanceof Promise) {
+            request?.ctx?.runtime?.waitUntil?.(maybePromise.catch((e) => {
+                const message = e instanceof Error ? e.stack : e;
+                defaultLogger.error(`Promise error from the custom logging implementation for logger.${method} failed:\n${message}`);
+            }));
+        }
+    }
+    catch (e) {
+        const message = e instanceof Error ? e.stack : e;
+        defaultLogger.error(`The custom logging implementation for logger.${method} failed:\n${message}`);
+    }
+}
+export function getLoggerWithContext(context) {
+    return {
+        trace: (...args) => doLog('trace', context, ...args),
+        debug: (...args) => doLog('debug', context, ...args),
+        warn: (...args) => doLog('warn', context, ...args),
+        error: (...args) => doLog('error', context, ...args),
+        fatal: (...args) => doLog('fatal', context, ...args),
+        options: () => currentLogger.options(),
+    };
+}
+export const log = getLoggerWithContext({});
+export function setLogger(config) {
+    if (!config) {
+        currentLogger = defaultLogger;
+        return;
+    }
+    const options = {};
+    currentLogger = { ...defaultLogger, ...config, options: () => options };
+    for (const key of Object.keys(config)) {
+        if (!(key in defaultLogger)) {
+            delete currentLogger[key];
+            options[key] = config[key];
+        }
+    }
+}
+const SERVER_RESPONSE_MAP = {
+    str: 'streaming SSR',
+    rsc: 'Server Components',
+    ssr: 'buffered SSR',
+};
+export function logServerResponse(type, request, responseStatus, didError) {
+    const log = getLoggerWithContext(request);
+    const coloredResponseStatus = responseStatus >= 500
+        ? red(responseStatus)
+        : responseStatus >= 400
+            ? yellow(responseStatus)
+            : responseStatus >= 300
+                ? lightBlue(responseStatus)
+                : green(responseStatus);
+    const fullType = SERVER_RESPONSE_MAP[type] || type;
+    const styledType = italic(fullType.padEnd(17));
+    const paddedTiming = ((getTime() - request.time).toFixed(2) + ' ms').padEnd(10);
+    const url = parseUrl(type, request.url);
+    log.debug(`${request.method} ${styledType} ${coloredResponseStatus} ${didError || responseStatus >= 400 ? red('error') : green('ok   ')} ${paddedTiming} ${url}`);
+}
diff --git a/dist/dist/esnext/utilities/log/utils.d.ts b/dist/dist/esnext/utilities/log/utils.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..da6d28121c0267c47b493e7201eb2ac10f6f0ffd
--- /dev/null
+++ b/dist/dist/esnext/utilities/log/utils.d.ts
@@ -0,0 +1,3 @@
+import type { RenderType } from './log.js';
+export declare function findQueryName(key: string): string;
+export declare function parseUrl(type: RenderType, url: string): string;
diff --git a/dist/dist/esnext/utilities/log/utils.js b/dist/dist/esnext/utilities/log/utils.js
new file mode 100644
index 0000000000000000000000000000000000000000..159630ba08d3a7402c0971678e2eec9f51133b4b
--- /dev/null
+++ b/dist/dist/esnext/utilities/log/utils.js
@@ -0,0 +1,11 @@
+export function findQueryName(key) {
+    if (key.length < 100) {
+        return key.replace(__HYDROGEN_CACHE_ID__, '').replace(/"/g, '');
+    }
+    return key.match(/query\s+([^\s({]+)/)?.[1] || '<unknown>';
+}
+export function parseUrl(type, url) {
+    return type === 'rsc'
+        ? decodeURIComponent(url.substring(url.indexOf('=') + 1))
+        : url;
+}
diff --git a/dist/dist/esnext/utilities/matchPath.d.ts b/dist/dist/esnext/utilities/matchPath.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6573d4061c5e2b589ef869b366fecfca9ccd143a
--- /dev/null
+++ b/dist/dist/esnext/utilities/matchPath.d.ts
@@ -0,0 +1,10 @@
+import { TokensToRegexpOptions } from 'path-to-regexp';
+interface MatchPathOptions extends TokensToRegexpOptions {
+    path?: string;
+    exact?: boolean;
+}
+/**
+ * Public API for matching a URL pathname to a path.
+ */
+export declare function matchPath(pathname: string, options?: MatchPathOptions): any;
+export {};
diff --git a/dist/dist/esnext/utilities/matchPath.js b/dist/dist/esnext/utilities/matchPath.js
new file mode 100644
index 0000000000000000000000000000000000000000..6e44ec1d1ba78247fbed391a406763c179018041
--- /dev/null
+++ b/dist/dist/esnext/utilities/matchPath.js
@@ -0,0 +1,54 @@
+import { pathToRegexp } from 'path-to-regexp';
+// Modified from React Router v5
+// https://github.com/remix-run/react-router/blob/v5/packages/react-router/modules/matchPath.js
+const cache = {};
+const cacheLimit = 10000;
+let cacheCount = 0;
+function compilePath(path, options) {
+    const cacheKey = `${options.end}${options.strict}${options.sensitive}`;
+    const pathCache = cache[cacheKey] || (cache[cacheKey] = {});
+    if (pathCache[path])
+        return pathCache[path];
+    const keys = [];
+    const regexp = pathToRegexp(path, keys, options);
+    const result = { regexp, keys };
+    if (cacheCount < cacheLimit) {
+        pathCache[path] = result;
+        cacheCount++;
+    }
+    return result;
+}
+/**
+ * Public API for matching a URL pathname to a path.
+ */
+export function matchPath(pathname, options = {}) {
+    const { path, exact = false, strict = false, sensitive = false } = options;
+    const paths = [].concat(path);
+    return paths.reduce((matched, path) => {
+        if (!path && path !== '')
+            return null;
+        if (matched)
+            return matched;
+        const { regexp, keys } = compilePath(path, {
+            end: exact,
+            strict,
+            sensitive,
+        });
+        const match = regexp.exec(pathname);
+        if (!match)
+            return null;
+        const [url, ...values] = match;
+        const isExact = pathname === url;
+        if (exact && !isExact)
+            return null;
+        return {
+            path,
+            url: path === '/' && url === '' ? '/' : url,
+            isExact,
+            params: keys.reduce((memo, key, index) => {
+                memo[key.name] = values[index];
+                return memo;
+            }, {}),
+        };
+    }, null);
+}
diff --git a/dist/dist/esnext/utilities/measurement.d.ts b/dist/dist/esnext/utilities/measurement.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..98da5bab04e1e79dcf86812b849d992cac691dcf
--- /dev/null
+++ b/dist/dist/esnext/utilities/measurement.d.ts
@@ -0,0 +1,3 @@
+import { Measurement } from '../types.js';
+export declare function getMeasurementAsString(measurement: Measurement, locale?: string, options?: Intl.NumberFormatOptions): string;
+export declare function getMeasurementAsParts(measurement: Measurement, locale?: string, options?: Intl.NumberFormatOptions): Intl.NumberFormatPart[];
diff --git a/dist/dist/esnext/utilities/measurement.js b/dist/dist/esnext/utilities/measurement.js
new file mode 100644
index 0000000000000000000000000000000000000000..4605d679e1d655f061eacb1e51cb2c9243e7f01c
--- /dev/null
+++ b/dist/dist/esnext/utilities/measurement.js
@@ -0,0 +1,98 @@
+const UNIT_MAPPING = {
+    // Dimension
+    mm: 'millimeter',
+    cm: 'centimeter',
+    m: 'meter',
+    in: 'inch',
+    ft: 'foot',
+    yd: 'yard',
+    // Volume
+    ml: 'milliliter',
+    l: 'liter',
+    us_fl_oz: 'fluid-ounce',
+    us_gal: 'gallon',
+    // Weight
+    kg: 'kilogram',
+    g: 'gram',
+    lb: 'pound',
+    oz: 'ounce',
+};
+export function getMeasurementAsString(measurement, locale = 'en-us', options = {}) {
+    let measure = {
+        value: measurement.value,
+        unit: UNIT_MAPPING[measurement.unit],
+    };
+    if (measure.unit == null) {
+        measure = convertToSupportedUnit(measurement.value, measurement.unit);
+    }
+    return new Intl.NumberFormat(locale, {
+        ...options,
+        unit: measure.unit,
+        style: 'unit',
+    }).format(measure.value);
+}
+export function getMeasurementAsParts(measurement, locale = 'en-us', options = {}) {
+    let measure = {
+        value: measurement.value,
+        unit: UNIT_MAPPING[measurement.unit],
+    };
+    if (measure.unit == null) {
+        measure = convertToSupportedUnit(measurement.value, measurement.unit);
+    }
+    return new Intl.NumberFormat(locale, {
+        ...options,
+        unit: measure.unit,
+        style: 'unit',
+    }).formatToParts(measure.value);
+}
+function convertToSupportedUnit(value, unit) {
+    switch (unit) {
+        case 'cl':
+            return {
+                value: value / 1000,
+                unit: 'liter',
+            };
+        case 'm3':
+            return {
+                value: value * 1000,
+                unit: 'liter',
+            };
+        case 'us_pt':
+            return {
+                value: value * 0.125,
+                unit: 'gallon',
+            };
+        case 'us_qt':
+            return {
+                value: value * 0.5,
+                unit: 'gallon',
+            };
+        case 'us_oz':
+            return {
+                value: value / 128,
+                unit: 'gallon',
+            };
+        case 'imp_pt':
+            return {
+                value: value / 6.661,
+                unit: 'gallon',
+            };
+        case 'imp_qt':
+            return {
+                value: value / 3.331,
+                unit: 'gallon',
+            };
+        case 'imp_gal':
+            return {
+                value: value / 1.201,
+                unit: 'gallon',
+            };
+        case 'imp_fl_oz':
+            return {
+                value: value * 0.96076,
+                unit: 'fluid-ounce',
+            };
+        default:
+            throw new Error(`Unit not supported: ${unit}`);
+    }
+}
diff --git a/dist/dist/esnext/utilities/object.d.ts b/dist/dist/esnext/utilities/object.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b28cc2a1cae401af307a91a6355ac58ff835ccb8
--- /dev/null
+++ b/dist/dist/esnext/utilities/object.d.ts
@@ -0,0 +1,5 @@
+declare type Descriptor = Parameters<typeof Object.defineProperty>[2];
+export declare function createObject<T extends {} = object>(properties: T, { prototype, ...descriptor }?: {
+    prototype?: any;
+} & Exclude<Descriptor, 'value'>): T;
+export {};
diff --git a/dist/dist/esnext/utilities/object.js b/dist/dist/esnext/utilities/object.js
new file mode 100644
index 0000000000000000000000000000000000000000..1cbb636982fc6e85b2dbe38b24189e3a4c853c3a
--- /dev/null
+++ b/dist/dist/esnext/utilities/object.js
@@ -0,0 +1,7 @@
+// Create objects with null prototypes for faster access
+export function createObject(properties, { prototype = null, ...descriptor } = {}) {
+    return Object.create(prototype, Object.entries(properties).reduce((acc, [key, value]) => {
+        acc[key] = { enumerable: true, ...descriptor, value };
+        return acc;
+    }, {}));
+}
diff --git a/dist/dist/esnext/utilities/parse.d.ts b/dist/dist/esnext/utilities/parse.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..728e8fdfe215e29e202d26b523dbb3294c589dfa
--- /dev/null
+++ b/dist/dist/esnext/utilities/parse.d.ts
@@ -0,0 +1 @@
+export declare function parseJSON(json: any): any;
diff --git a/dist/dist/esnext/utilities/parse.js b/dist/dist/esnext/utilities/parse.js
new file mode 100644
index 0000000000000000000000000000000000000000..dc81a55ea0a7fcedc38d22c2b3539c1ada9f57fa
--- /dev/null
+++ b/dist/dist/esnext/utilities/parse.js
@@ -0,0 +1,9 @@
+export function parseJSON(json) {
+    if (String(json).includes('__proto__'))
+        return JSON.parse(json, noproto);
+    return JSON.parse(json);
+}
+function noproto(k, v) {
+    if (k !== '__proto__')
+        return v;
+}
diff --git a/dist/dist/esnext/utilities/parseMetafield/index.d.ts b/dist/dist/esnext/utilities/parseMetafield/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c8e944197bfb6e76cc2a40a52cbad7c775173ca4
--- /dev/null
+++ b/dist/dist/esnext/utilities/parseMetafield/index.d.ts
@@ -0,0 +1 @@
+export { parseMetafield, parseMetafieldValue } from './parseMetafield.js';
diff --git a/dist/dist/esnext/utilities/parseMetafield/index.js b/dist/dist/esnext/utilities/parseMetafield/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..c8e944197bfb6e76cc2a40a52cbad7c775173ca4
--- /dev/null
+++ b/dist/dist/esnext/utilities/parseMetafield/index.js
@@ -0,0 +1 @@
+export { parseMetafield, parseMetafieldValue } from './parseMetafield.js';
diff --git a/dist/dist/esnext/utilities/parseMetafield/parseMetafield.d.ts b/dist/dist/esnext/utilities/parseMetafield/parseMetafield.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bfb13198abf0352f7b2edf7f271ac1e21598d875
--- /dev/null
+++ b/dist/dist/esnext/utilities/parseMetafield/parseMetafield.d.ts
@@ -0,0 +1,15 @@
+import type { Metafield } from '../../storefront-api-types.js';
+import type { ParsedMetafield } from '../../types.js';
+import type { PartialDeep } from 'type-fest';
+/**
+ * The `parseMetafield` utility transforms a [Metafield](https://shopify.dev/api/storefront/reference/common-objects/Metafield)
+ * into a new object whose `values` have been parsed according to the metafield `type`.
+ * If the metafield is `null`, then it returns `null` back.
+ */
+export declare function parseMetafield(
+/** A [Metafield](https://shopify.dev/api/storefront/reference/common-objects/Metafield) or null */
+metafield: PartialDeep<Metafield> | null): PartialDeep<ParsedMetafield> | null;
+/**
+ * The `parseMetafieldValue` function parses a [Metafield](https://shopify.dev/api/storefront/reference/common-objects/metafield)'s `value` from a string into a sensible type corresponding to the [Metafield](https://shopify.dev/api/storefront/reference/common-objects/metafield)'s `type`.
+ */
+export declare function parseMetafieldValue(metafield: PartialDeep<Metafield> | null): ParsedMetafield['value'];
diff --git a/dist/dist/esnext/utilities/parseMetafield/parseMetafield.js b/dist/dist/esnext/utilities/parseMetafield/parseMetafield.js
new file mode 100644
index 0000000000000000000000000000000000000000..a52af442b78df034dcdaa8db66f0390cb39cb91a
--- /dev/null
+++ b/dist/dist/esnext/utilities/parseMetafield/parseMetafield.js
@@ -0,0 +1,62 @@
+import { parseJSON } from '../parse.js';
+/**
+ * The `parseMetafield` utility transforms a [Metafield](https://shopify.dev/api/storefront/reference/common-objects/Metafield)
+ * into a new object whose `values` have been parsed according to the metafield `type`.
+ * If the metafield is `null`, then it returns `null` back.
+ */
+export function parseMetafield(
+/** A [Metafield](https://shopify.dev/api/storefront/reference/common-objects/Metafield) or null */
+metafield) {
+    if (!metafield) {
+        return null;
+    }
+    if (__HYDROGEN_DEV__ &&
+        (metafield.value === null || metafield.value === undefined)) {
+        console.warn(`'parseMetafield()' was passed ${metafield.value} for 'metafield.value'`);
+    }
+    return {
+        ...metafield,
+        value: parseMetafieldValue(metafield),
+    };
+}
+/**
+ * The `parseMetafieldValue` function parses a [Metafield](https://shopify.dev/api/storefront/reference/common-objects/metafield)'s `value` from a string into a sensible type corresponding to the [Metafield](https://shopify.dev/api/storefront/reference/common-objects/metafield)'s `type`.
+ */
+export function parseMetafieldValue(metafield) {
+    if (!metafield) {
+        return null;
+    }
+    if (metafield.value === null || metafield.value === undefined) {
+        if (__HYDROGEN_DEV__) {
+            console.warn(`'parseMetafieldValue()' was passed ${metafield.value} for 'metafield.value'`);
+        }
+        return metafield.value;
+    }
+    switch (metafield.type) {
+        case 'boolean':
+            return metafield.value === 'true';
+        case 'number_integer':
+            return parseInt(metafield.value);
+        case 'number_decimal':
+            return parseFloat(metafield.value);
+        case 'date':
+        case 'date_time':
+            return new Date(metafield.value);
+        case 'json':
+        case 'weight':
+        case 'dimension':
+        case 'volume':
+        case 'rating':
+            return parseJSON(metafield.value);
+        case 'color':
+        case 'single_line_text_field':
+        case 'multi_line_text_field':
+        case 'product_reference':
+        case 'page_reference':
+        case 'variant_reference':
+        case 'file_reference':
+        case 'url':
+        default:
+            return metafield.value;
+    }
+}
diff --git a/dist/dist/esnext/utilities/storefrontApi.d.ts b/dist/dist/esnext/utilities/storefrontApi.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d77096a3540e095dba0217d7dc719cf30da0ac38
--- /dev/null
+++ b/dist/dist/esnext/utilities/storefrontApi.d.ts
@@ -0,0 +1,7 @@
+export declare function getStorefrontApiRequestHeaders({ buyerIp, publicStorefrontToken, privateStorefrontToken, storefrontId, }: {
+    buyerIp?: string | null;
+    publicStorefrontToken: string;
+    privateStorefrontToken: string | undefined;
+    storefrontId: string | undefined;
+}): Record<string, any>;
+export declare function getOxygenVariable(key: string): any;
diff --git a/dist/dist/esnext/utilities/storefrontApi.js b/dist/dist/esnext/utilities/storefrontApi.js
new file mode 100644
index 0000000000000000000000000000000000000000..b6abaa8fe2c71c61913667f55cdc8bfc8a2c7508
--- /dev/null
+++ b/dist/dist/esnext/utilities/storefrontApi.js
@@ -0,0 +1,48 @@
+/* global Oxygen */
+import { OXYGEN_SECRET_TOKEN_ENVIRONMENT_VARIABLE, STOREFRONT_API_SECRET_TOKEN_HEADER, STOREFRONT_API_PUBLIC_TOKEN_HEADER, STOREFRONT_API_BUYER_IP_HEADER, SHOPIFY_STOREFRONT_ID_VARIABLE, SHOPIFY_STOREFRONT_ID_HEADER, } from '../constants.js';
+import { log } from './log/log.js';
+let secretTokenWarned = false;
+let storefrontIdWarned = false;
+export function getStorefrontApiRequestHeaders({ buyerIp, publicStorefrontToken, privateStorefrontToken, storefrontId, }) {
+    const headers = {};
+    if (!privateStorefrontToken) {
+        privateStorefrontToken = getOxygenVariable(OXYGEN_SECRET_TOKEN_ENVIRONMENT_VARIABLE);
+        if (!secretTokenWarned) {
+            secretTokenWarned = true;
+            if (!privateStorefrontToken && !__HYDROGEN_DEV__) {
+                log.error('No secret Shopify storefront API token was defined. This means your app will be rate limited!\nSee how to add the token: ');
+            }
+            else if (privateStorefrontToken) {
+                log.warn('The private shopify storefront API token was loaded implicitly by an environment variable. This is deprecated, and instead the variable should be defined directly in the Hydrogen Config.\nFor more information: https://shopify.dev/custom-storefronts/hydrogen/framework/hydrogen-config');
+            }
+        }
+    }
+    if (!storefrontId) {
+        storefrontId = getOxygenVariable(SHOPIFY_STOREFRONT_ID_VARIABLE);
+        if (!storefrontIdWarned) {
+            storefrontIdWarned = true;
+            if (storefrontId) {
+                log.warn('The storefrontId was loaded implicitly by an environment variable. This is deprecated, and instead the variable should be defined directly in the Hydrogen Config.\nFor more information: https://shopify.dev/custom-storefronts/hydrogen/framework/hydrogen-config');
+            }
+        }
+    }
+    /**
+     * Only pass one type of storefront token at a time.
+     */
+    if (privateStorefrontToken) {
+        headers[STOREFRONT_API_SECRET_TOKEN_HEADER] = privateStorefrontToken;
+    }
+    else {
+        headers[STOREFRONT_API_PUBLIC_TOKEN_HEADER] = publicStorefrontToken;
+    }
+    if (buyerIp) {
+        headers[STOREFRONT_API_BUYER_IP_HEADER] = buyerIp;
+    }
+    if (storefrontId) {
+        headers[SHOPIFY_STOREFRONT_ID_HEADER] = storefrontId;
+    }
+    return headers;
+}
+export function getOxygenVariable(key) {
+    return typeof Oxygen !== 'undefined' ? Oxygen?.env?.[key] : null;
+}
diff --git a/dist/dist/esnext/utilities/suspense.d.ts b/dist/dist/esnext/utilities/suspense.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d401ccd1a56902c5f6d39f50ddee17ca68cd4afa
--- /dev/null
+++ b/dist/dist/esnext/utilities/suspense.d.ts
@@ -0,0 +1,12 @@
+import { QueryKey } from '../types.js';
+/**
+ * Wrap the fetch promise in a way that React Suspense understands.
+ * Essentially, keep throwing something until you have legit data.
+ */
+export declare function wrapPromise<T>(promise: Promise<T>): {
+    read: () => T;
+};
+declare type Await<T> = T extends Promise<infer V> ? V : never;
+export declare const suspendFunction: <Fn extends () => Promise<unknown>>(key: QueryKey, fn: Fn) => Await<ReturnType<Fn>>;
+export declare const preloadFunction: (key: QueryKey, fn: () => Promise<unknown>) => unknown;
+export {};
diff --git a/dist/dist/esnext/utilities/suspense.js b/dist/dist/esnext/utilities/suspense.js
new file mode 100644
index 0000000000000000000000000000000000000000..113e49c703791e19f2e0e818e94021625331e261
--- /dev/null
+++ b/dist/dist/esnext/utilities/suspense.js
@@ -0,0 +1,58 @@
+import { hashKey } from './hash.js';
+/**
+ * Wrap the fetch promise in a way that React Suspense understands.
+ * Essentially, keep throwing something until you have legit data.
+ */
+export function wrapPromise(promise) {
+    let status = 'pending';
+    let response;
+    const suspender = promise.then((res) => {
+        status = 'success';
+        response = res;
+    }, (err) => {
+        status = 'error';
+        response = err;
+    });
+    const read = () => {
+        switch (status) {
+            case 'pending':
+                throw suspender;
+            case 'error':
+                throw response;
+            default:
+                return response;
+        }
+    };
+    return { read };
+}
+const browserCache = {};
+/**
+ * Perform an async function in a synchronous way for Suspense support.
+ * To be used only in the client.
+ * Inspired by https://github.com/pmndrs/suspend-react
+ */
+function query(key, fn, preload = false) {
+    const stringKey = hashKey(key);
+    if (browserCache[stringKey]) {
+        const entry = browserCache[stringKey];
+        if (preload)
+            return undefined;
+        if (entry.error)
+            throw entry.error;
+        if (entry.response)
+            return entry.response;
+        if (!preload)
+            throw entry.promise;
+    }
+    const entry = {
+        promise: fn()
+            .then((response) => (entry.response = response))
+            .catch((error) => (entry.error = error)),
+    };
+    browserCache[stringKey] = entry;
+    if (!preload)
+        throw entry.promise;
+    return undefined;
+}
+export const suspendFunction = (key, fn) => query(key, fn);
+export const preloadFunction = (key, fn) => query(key, fn, true);
diff --git a/dist/dist/esnext/utilities/template.d.ts b/dist/dist/esnext/utilities/template.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d733e74e5a292287fe5f0cfbd81f3f40728a201b
--- /dev/null
+++ b/dist/dist/esnext/utilities/template.d.ts
@@ -0,0 +1,10 @@
+export declare function getTemplate(indexTemplate: string | ((url: string) => Promise<string | {
+    default: string;
+}>), url?: URL): Promise<{
+    noScriptTemplate: string;
+    bootstrapScripts: string[];
+    bootstrapModules: string[];
+    raw: string;
+    linkHeader: string;
+}>;
+export declare type TemplateParts = Awaited<ReturnType<typeof getTemplate>>;
diff --git a/dist/dist/esnext/utilities/template.js b/dist/dist/esnext/utilities/template.js
new file mode 100644
index 0000000000000000000000000000000000000000..9f5df97587366d894678e4c2529a83e72bedbe8b
--- /dev/null
+++ b/dist/dist/esnext/utilities/template.js
@@ -0,0 +1,60 @@
+/**
+ * Strip out script `src` values from <script> tags in a given HTML template.
+ * Returns two lists of scripts, split based on whether they are `type="module"`.
+ */
+function stripScriptsFromTemplate(template) {
+    const bootstrapScripts = [];
+    const bootstrapModules = [];
+    const scripts = template.matchAll(/<script\n*?.+?src="(?<script>([^"]+?))"\n*.*?><\/script>/g);
+    for (const match of scripts) {
+        const scriptName = match.groups?.script;
+        if (!scriptName)
+            continue;
+        if (match[0].includes(`type="module"`)) {
+            bootstrapModules.push(scriptName);
+        }
+        else {
+            bootstrapScripts.push(scriptName);
+        }
+        template = template.replace(match[0], '');
+    }
+    return { noScriptTemplate: template, bootstrapScripts, bootstrapModules };
+}
+function extractAttributes(string) {
+    const attributes = {};
+    for (const [, attr, value] of string.matchAll(/\s([\w-]+)="([^"]*?)"/gm)) {
+        attributes[attr] = value;
+    }
+    return attributes;
+}
+export async function getTemplate(indexTemplate, url) {
+    let raw = typeof indexTemplate === 'function'
+        ? await indexTemplate(url?.toString() || '')
+        : indexTemplate;
+    if (raw && typeof raw !== 'string') {
+        raw = raw.default;
+    }
+    return {
+        raw,
+        linkHeader: createLinkHeader(raw),
+        ...stripScriptsFromTemplate(raw),
+    };
+}
+const ALLOWED_REL_ATTRS = ['stylesheet', 'preconnect', 'preload'];
+function createLinkHeader(template) {
+    const assets = (template.match(/\s*<link[^<>]+?>/gim) || []).map(extractAttributes);
+    const links = [];
+    for (const { href, rel = '', ...attrs } of assets) {
+        if (href && ALLOWED_REL_ATTRS.includes(rel)) {
+            const isStyle = rel === 'stylesheet';
+            if (isStyle && !attrs.as)
+                attrs.as = 'style';
+            links.push([
+                `<${encodeURI(href.replace(/^https?:/i, ''))}>`,
+                `rel=${isStyle ? 'preload' : rel}`,
+                ...Object.entries(attrs).map((entry) => entry.join('=')),
+            ].join('; '));
+        }
+    }
+    return links.join(', ');
+}
diff --git a/dist/dist/esnext/utilities/tests/MockedServerRequestProvider.server.d.ts b/dist/dist/esnext/utilities/tests/MockedServerRequestProvider.server.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6ba81114ad45d6572da102db2ef461f87e0462f3
--- /dev/null
+++ b/dist/dist/esnext/utilities/tests/MockedServerRequestProvider.server.d.ts
@@ -0,0 +1,6 @@
+import React from 'react';
+import { ShopifyProviderOptions } from '../../utilities/tests/provider-helpers.js';
+export declare function MockedServerRequestProvider({ children, setServerProps, serverProps, requestUrl, }: Omit<ShopifyProviderOptions, 'history'> & {
+    children: React.ReactElement;
+    requestUrl?: string;
+}): JSX.Element;
diff --git a/dist/dist/esnext/utilities/tests/MockedServerRequestProvider.server.js b/dist/dist/esnext/utilities/tests/MockedServerRequestProvider.server.js
new file mode 100644
index 0000000000000000000000000000000000000000..e63102e42c60d821bcb5d905313fc969298c98de
--- /dev/null
+++ b/dist/dist/esnext/utilities/tests/MockedServerRequestProvider.server.js
@@ -0,0 +1,9 @@
+import React from 'react';
+import { ServerRequestProvider } from '../../foundation/ServerRequestProvider/ServerRequestProvider.js';
+import { ServerPropsProvider } from '../../foundation/ServerPropsProvider/ServerPropsProvider.js';
+import { HydrogenRequest } from '../../foundation/HydrogenRequest/HydrogenRequest.server.js';
+export function MockedServerRequestProvider({ children, setServerProps = () => { }, serverProps = { pathname: '', search: '' }, requestUrl = 'https://examples.com', }) {
+    const request = new HydrogenRequest(new Request(requestUrl));
+    return (React.createElement(ServerRequestProvider, { request: request },
+        React.createElement(ServerPropsProvider, { setServerPropsForRsc: setServerProps, initialServerProps: serverProps, setRscResponseFromApiRoute: () => { } }, children)));
+}
diff --git a/dist/dist/esnext/utilities/tests/price.d.ts b/dist/dist/esnext/utilities/tests/price.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3d9ff9ddb2d626d6718aa53b8f23d585cae78ffa
--- /dev/null
+++ b/dist/dist/esnext/utilities/tests/price.d.ts
@@ -0,0 +1,5 @@
+import { CurrencyCode, MoneyV2 } from '../../storefront-api-types.js';
+export declare function getPrice(price?: Partial<MoneyV2>): {
+    currencyCode: CurrencyCode;
+    amount: string;
+};
diff --git a/dist/dist/esnext/utilities/tests/price.js b/dist/dist/esnext/utilities/tests/price.js
new file mode 100644
index 0000000000000000000000000000000000000000..c7d7d64df5fa052aeedd07df7a92240205405d48
--- /dev/null
+++ b/dist/dist/esnext/utilities/tests/price.js
@@ -0,0 +1,8 @@
+import faker from 'faker';
+import { CurrencyCode } from '../../storefront-api-types.js';
+export function getPrice(price = {}) {
+    return {
+        currencyCode: price.currencyCode ?? CurrencyCode.Cad,
+        amount: price.amount ?? faker.finance.amount(),
+    };
+}
diff --git a/dist/dist/esnext/utilities/tests/provider-helpers.d.ts b/dist/dist/esnext/utilities/tests/provider-helpers.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..eb41c040d0559fd31ef227857ec4d5226125465a
--- /dev/null
+++ b/dist/dist/esnext/utilities/tests/provider-helpers.d.ts
@@ -0,0 +1,31 @@
+import React from 'react';
+import { BrowserHistory } from 'history';
+import { ShopifyConfig } from '../../types.js';
+import { LocationServerProps, ServerProps } from '../../foundation/ServerPropsProvider/ServerPropsProvider.js';
+import { type CartWithActions, type Cart } from '../../components/CartProvider/types.js';
+export declare function ShopifyTestProviders({ children, setServerProps, serverProps, shopifyConfig, history, }: ShopifyProviderOptions & {
+    children: React.ReactNode;
+}): JSX.Element;
+export declare function CartTestProviders({ children, cartProviderValues, }: {
+    children: React.ReactNode;
+    cartProviderValues?: Parameters<typeof getCartProviderValues>[0];
+}): JSX.Element;
+export declare function getShopifyConfig(config?: Partial<ShopifyConfig>): {
+    countryCode: string;
+    languageCode: string;
+    storeDomain: string;
+    storefrontToken: string;
+    storefrontApiVersion: string;
+};
+declare function getCartProviderValues({ cart, ...config }?: CartProviderOptions): CartWithActions;
+declare type SetServerProps = React.Dispatch<React.SetStateAction<ServerProps>>;
+export interface ShopifyProviderOptions {
+    shopifyConfig?: Partial<ShopifyConfig>;
+    setServerProps?: SetServerProps;
+    serverProps?: LocationServerProps;
+    history?: BrowserHistory;
+}
+declare type CartProviderOptions = {
+    cart?: Partial<Cart>;
+} & Partial<CartWithActions>;
+export {};
diff --git a/dist/dist/esnext/utilities/tests/provider-helpers.js b/dist/dist/esnext/utilities/tests/provider-helpers.js
new file mode 100644
index 0000000000000000000000000000000000000000..d3cb737a53587406b231dc3285e592eba53d96a2
--- /dev/null
+++ b/dist/dist/esnext/utilities/tests/provider-helpers.js
@@ -0,0 +1,36 @@
+import React from 'react';
+import { DEFAULT_COUNTRY, DEFAULT_LANGUAGE } from '../../foundation/constants.js';
+import { ShopifyProvider } from '../../foundation/ShopifyProvider/ShopifyProvider.server.js';
+import { BrowserRouter } from '../../foundation/Router/BrowserRouter.client.js';
+import { ServerPropsProvider, } from '../../foundation/ServerPropsProvider/ServerPropsProvider.js';
+import { CartContext } from '../../components/CartProvider/context.js';
+import { CART_ACTIONS } from '../../components/CartProvider/tests/fixtures.js';
+export function ShopifyTestProviders({ children, setServerProps = (() => { }), serverProps = { pathname: '', search: '' }, shopifyConfig, history, }) {
+    const finalShopifyConfig = getShopifyConfig(shopifyConfig);
+    return (React.createElement(ServerPropsProvider, { setServerPropsForRsc: setServerProps, initialServerProps: serverProps, setRscResponseFromApiRoute: () => { } },
+        React.createElement(ShopifyProvider, { shopifyConfig: finalShopifyConfig, languageCode: "EN", countryCode: "US" },
+            React.createElement(BrowserRouter, { history: history }, children))));
+}
+export function CartTestProviders({ children, cartProviderValues, }) {
+    const finalValue = getCartProviderValues(cartProviderValues);
+    return (React.createElement(CartContext.Provider, { value: finalValue }, children));
+}
+export function getShopifyConfig(config = {}) {
+    const languageCode = config.defaultLanguageCode ?? DEFAULT_LANGUAGE;
+    const countryCode = config.defaultCountryCode ?? DEFAULT_COUNTRY;
+    return {
+        countryCode: countryCode.toUpperCase(),
+        languageCode: languageCode.toUpperCase(),
+        storeDomain: config.storeDomain ?? 'notashop.myshopify.io',
+        storefrontToken: config.storefrontToken ?? 'abc123',
+        storefrontApiVersion: config.storefrontApiVersion ?? '2022-07',
+    };
+}
+function getCartProviderValues({ cart = {}, ...config } = {}) {
+    const finalConfig = {
+        ...CART_ACTIONS,
+        ...cart,
+        ...config,
+    };
+    return finalConfig;
+}
diff --git a/dist/dist/esnext/utilities/timing.d.ts b/dist/dist/esnext/utilities/timing.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..99fb442880a3931ee8c64ae8b95b4571c30149c3
--- /dev/null
+++ b/dist/dist/esnext/utilities/timing.d.ts
@@ -0,0 +1,7 @@
+/**
+ * Not all environments have access to Performance.now(). This is to prevent
+ * timing side channel attacks.
+ *
+ * See: https://community.cloudflare.com/t/cloudflare-workers-how-do-i-measure-execution-time-of-my-method/69672
+ */
+export declare function getTime(): number;
diff --git a/dist/dist/esnext/utilities/timing.js b/dist/dist/esnext/utilities/timing.js
new file mode 100644
index 0000000000000000000000000000000000000000..b8c5a4d2e282455a9ad4a0411986c19f62d42e33
--- /dev/null
+++ b/dist/dist/esnext/utilities/timing.js
@@ -0,0 +1,14 @@
+/**
+ * Not all environments have access to Performance.now(). This is to prevent
+ * timing side channel attacks.
+ *
+ * See: https://community.cloudflare.com/t/cloudflare-workers-how-do-i-measure-execution-time-of-my-method/69672
+ */
+export function getTime() {
+    if (typeof performance !== 'undefined' && performance.now) {
+        return performance.now();
+    }
+    else {
+        return Date.now();
+    }
+}
diff --git a/dist/dist/esnext/utilities/video_parameters.d.ts b/dist/dist/esnext/utilities/video_parameters.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2bf1db1edb5f70537de37e2cc187db5d8fbf15e5
--- /dev/null
+++ b/dist/dist/esnext/utilities/video_parameters.d.ts
@@ -0,0 +1,47 @@
+export interface YouTube {
+    autoplay?: 0 | 1;
+    cc_lang_pref?: string;
+    cc_load_policy?: 1;
+    color?: 'red' | 'white';
+    controls?: 0 | 1;
+    disablekb?: 0 | 1;
+    enablejsapi?: 0 | 1;
+    end?: number;
+    fs?: 0 | 1;
+    hl?: string;
+    iv_load_policy?: 1 | 3;
+    list?: string;
+    list_type?: 'playlist' | 'user_uploads';
+    loop?: 0 | 1;
+    modest_branding?: 1;
+    origin?: string;
+    playlist?: string;
+    plays_inline?: 0 | 1;
+    rel?: 0 | 1;
+    start?: number;
+    widget_referrer?: string;
+}
+declare type VimeoBoolean = 0 | 1 | boolean;
+export interface Vimeo {
+    autopause?: VimeoBoolean;
+    autoplay?: VimeoBoolean;
+    background?: VimeoBoolean;
+    byline?: VimeoBoolean;
+    color?: string;
+    controls?: VimeoBoolean;
+    dnt?: VimeoBoolean;
+    loop?: VimeoBoolean;
+    muted?: VimeoBoolean;
+    pip?: VimeoBoolean;
+    playsinline?: VimeoBoolean;
+    portrait?: VimeoBoolean;
+    quality?: '240p' | '360p' | '540p' | '720p' | '1080p' | '2k' | '4k';
+    speed?: VimeoBoolean;
+    '#t'?: string;
+    texttrack?: string;
+    title?: VimeoBoolean;
+    transparent?: VimeoBoolean;
+}
+export declare function addParametersToEmbeddedVideoUrl(url: string, parameters?: YouTube | Vimeo): string;
+export declare function useEmbeddedVideoUrl(url: string, parameters?: YouTube | Vimeo): string;
+export {};
diff --git a/dist/dist/esnext/utilities/video_parameters.js b/dist/dist/esnext/utilities/video_parameters.js
new file mode 100644
index 0000000000000000000000000000000000000000..3f63828887f3ceda4f17b57ce00f1c24a1fffbf8
--- /dev/null
+++ b/dist/dist/esnext/utilities/video_parameters.js
@@ -0,0 +1,22 @@
+import { useMemo } from 'react';
+export function addParametersToEmbeddedVideoUrl(url, parameters) {
+    if (parameters == null) {
+        return url;
+    }
+    const params = Object.keys(parameters).reduce((accumulator, param) => {
+        const value = parameters[param];
+        if (value == null) {
+            return accumulator;
+        }
+        return accumulator + `&${param}=${value}`;
+    }, '');
+    return `${url}?${params}`;
+}
+export function useEmbeddedVideoUrl(url, parameters) {
+    return useMemo(() => {
+        if (!parameters) {
+            return url;
+        }
+        return addParametersToEmbeddedVideoUrl(url, parameters);
+    }, [url, parameters]);
+}
diff --git a/dist/dist/esnext/utilities/vite.d.ts b/dist/dist/esnext/utilities/vite.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bb2e7cf61a03c7fe127557ef1da780414cc18c35
--- /dev/null
+++ b/dist/dist/esnext/utilities/vite.d.ts
@@ -0,0 +1 @@
+export declare const isVite3: any;
diff --git a/dist/dist/esnext/utilities/vite.js b/dist/dist/esnext/utilities/vite.js
new file mode 100644
index 0000000000000000000000000000000000000000..a4ef8851a4343d9d5630fc55f779bf263589dbf3
--- /dev/null
+++ b/dist/dist/esnext/utilities/vite.js
@@ -0,0 +1,4 @@
+// `version` is only exported in Vite 3
+import * as vite from 'vite';
+// @ts-ignore
+export const isVite3 = vite.version?.startsWith('3.');
diff --git a/dist/dist/esnext/utilities/web-api-polyfill.d.ts b/dist/dist/esnext/utilities/web-api-polyfill.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cb0ff5c3b541f646105198ee23ac0fc3d805023e
--- /dev/null
+++ b/dist/dist/esnext/utilities/web-api-polyfill.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/dist/dist/esnext/utilities/web-api-polyfill.js b/dist/dist/esnext/utilities/web-api-polyfill.js
new file mode 100644
index 0000000000000000000000000000000000000000..ca4965f7e0ec260aa436d5cdb729ead44cff3c01
--- /dev/null
+++ b/dist/dist/esnext/utilities/web-api-polyfill.js
@@ -0,0 +1,25 @@
+import fetch, { Request, Response, Headers } from 'node-fetch';
+import AbortController from 'abort-controller';
+import { ReadableStream, WritableStream, TransformStream, } from 'web-streams-polyfill/ponyfill';
+import { FormData } from 'undici';
+if (!globalThis.fetch) {
+    Object.assign(globalThis, {
+        fetch,
+        Request,
+        Response,
+        Headers,
+        AbortController,
+    });
+}
+if (!globalThis.FormData) {
+    Object.assign(globalThis, {
+        FormData,
+    });
+}
+if (!globalThis.ReadableStream) {
+    Object.assign(globalThis, {
+        ReadableStream,
+        WritableStream,
+        TransformStream,
+    });
+}
diff --git a/dist/dist/esnext/version.d.ts b/dist/dist/esnext/version.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e984aaa2b822bd29d5cd37b676555c2a801a852b
--- /dev/null
+++ b/dist/dist/esnext/version.d.ts
@@ -0,0 +1 @@
+export declare const LIB_VERSION = "1.5.0";
diff --git a/dist/dist/esnext/version.js b/dist/dist/esnext/version.js
new file mode 100644
index 0000000000000000000000000000000000000000..ec271423e04a596d4c8bd974c195b6c8f72f90c0
--- /dev/null
+++ b/dist/dist/esnext/version.js
@@ -0,0 +1 @@
+export const LIB_VERSION = '1.5.0';
diff --git a/dist/dist/node/foundation/session/session-types.d.ts b/dist/dist/node/foundation/session/session-types.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5aa3044d0245f35fdb25fec98fab67c5b1030114
--- /dev/null
+++ b/dist/dist/node/foundation/session/session-types.d.ts
@@ -0,0 +1,15 @@
+export declare type SessionSyncApi = {
+    get: () => Record<string, string>;
+    set: (data: Record<string, any>) => any;
+};
+export declare type SessionApi = {
+    get: () => Promise<Record<string, string>>;
+    set: (key: string, value: string) => Promise<void>;
+    destroy: () => Promise<void>;
+    getFlash: (key: string) => any;
+};
+export declare type SessionStorageAdapter = {
+    get: (request: Request) => Promise<Record<string, string>>;
+    set: (request: Request, value: Record<string, string>) => Promise<string>;
+    destroy: (request: Request) => Promise<string>;
+};
diff --git a/dist/dist/node/foundation/session/session-types.js b/dist/dist/node/foundation/session/session-types.js
new file mode 100644
index 0000000000000000000000000000000000000000..c8ad2e549bdc6801e0d1c80b0308d4b9bd4985ce
--- /dev/null
+++ b/dist/dist/node/foundation/session/session-types.js
@@ -0,0 +1,2 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
diff --git a/dist/dist/node/framework/cache/in-memory.d.ts b/dist/dist/node/framework/cache/in-memory.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6ccedcdb2f8a7fda49f6380542054f3bd6d7630b
--- /dev/null
+++ b/dist/dist/node/framework/cache/in-memory.d.ts
@@ -0,0 +1,17 @@
+/**
+ * This is a limited implementation of an in-memory cache.
+ * It only supports the `cache-control` header.
+ * It does NOT support `age` or `expires` headers.
+ * @see https://developer.mozilla.org/en-US/docs/Web/API/Cache
+ */
+export declare class InMemoryCache implements Cache {
+    #private;
+    constructor();
+    add(request: RequestInfo): Promise<void>;
+    addAll(requests: RequestInfo[]): Promise<void>;
+    matchAll(request?: RequestInfo, options?: CacheQueryOptions): Promise<readonly Response[]>;
+    put(request: Request, response: Response): Promise<void>;
+    match(request: Request): Promise<Response | undefined>;
+    delete(request: Request): Promise<boolean>;
+    keys(request?: Request): Promise<Request[]>;
+}
diff --git a/dist/dist/node/framework/cache/in-memory.js b/dist/dist/node/framework/cache/in-memory.js
new file mode 100644
index 0000000000000000000000000000000000000000..b845499bc8e5d0b08fcdca0ba1cf0fed207e0dad
--- /dev/null
+++ b/dist/dist/node/framework/cache/in-memory.js
@@ -0,0 +1,84 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.InMemoryCache = void 0;
+/**
+ * This is a limited implementation of an in-memory cache.
+ * It only supports the `cache-control` header.
+ * It does NOT support `age` or `expires` headers.
+ * @see https://developer.mozilla.org/en-US/docs/Web/API/Cache
+ */
+class InMemoryCache {
+    #store;
+    constructor() {
+        this.#store = new Map();
+    }
+    add(request) {
+        throw new Error('Method not implemented. Use `put` instead.');
+    }
+    addAll(requests) {
+        throw new Error('Method not implemented. Use `put` instead.');
+    }
+    matchAll(request, options) {
+        throw new Error('Method not implemented. Use `match` instead.');
+    }
+    async put(request, response) {
+        if (request.method !== 'GET') {
+            throw new TypeError('Cannot cache response to non-GET request.');
+        }
+        if (response.status === 206) {
+            throw new TypeError('Cannot cache response to a range request (206 Partial Content).');
+        }
+        if (response.headers.get('vary')?.includes('*')) {
+            throw new TypeError("Cannot cache response with 'Vary: *' header.");
+        }
+        this.#store.set(request.url, {
+            body: new Uint8Array(await response.arrayBuffer()),
+            status: response.status,
+            headers: [...response.headers],
+            timestamp: Date.now(),
+        });
+    }
+    async match(request) {
+        if (request.method !== 'GET')
+            return;
+        const match = this.#store.get(request.url);
+        if (!match) {
+            return;
+        }
+        const { body, timestamp, ...metadata } = match;
+        const headers = new Headers(metadata.headers);
+        const cacheControl = headers.get('cache-control') || '';
+        const maxAge = parseInt(cacheControl.match(/max-age=(\d+)/)?.[1] || '0', 10);
+        const swr = parseInt(cacheControl.match(/stale-while-revalidate=(\d+)/)?.[1] || '0', 10);
+        const age = (Date.now() - timestamp) / 1000;
+        const isMiss = age > maxAge + swr;
+        if (isMiss) {
+            this.#store.delete(request.url);
+            return;
+        }
+        const isStale = age > maxAge;
+        headers.set('cache', isStale ? 'STALE' : 'HIT');
+        headers.set('date', new Date(timestamp).toUTCString());
+        return new Response(body, {
+            status: metadata.status ?? 200,
+            headers,
+        });
+    }
+    async delete(request) {
+        if (this.#store.has(request.url)) {
+            this.#store.delete(request.url);
+            return true;
+        }
+        return false;
+    }
+    keys(request) {
+        const cacheKeys = [];
+        for (const url of this.#store.keys()) {
+            if (!request || request.url === url) {
+                cacheKeys.push(new Request(url));
+            }
+        }
+        return Promise.resolve(cacheKeys);
+    }
+}
+exports.InMemoryCache = InMemoryCache;
diff --git a/dist/dist/node/framework/graphiql.d.ts b/dist/dist/node/framework/graphiql.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d834c3428ffae6d3e4886c53d81f5c2fe6ea9789
--- /dev/null
+++ b/dist/dist/node/framework/graphiql.d.ts
@@ -0,0 +1 @@
+export declare function graphiqlHtml(shop: string, token: string, apiVersion: string): string;
diff --git a/dist/dist/node/framework/graphiql.js b/dist/dist/node/framework/graphiql.js
new file mode 100644
index 0000000000000000000000000000000000000000..4d2f180c58a7eb3e9611bd7261abf519e96b7bb9
--- /dev/null
+++ b/dist/dist/node/framework/graphiql.js
@@ -0,0 +1,38 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.graphiqlHtml = void 0;
+function graphiqlHtml(shop, token, apiVersion) {
+    return `
+<!DOCTYPE html>
+<html>
+<head>
+  <meta charset=utf-8/>
+  <meta name="viewport" content="user-scalable=no, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, minimal-ui">
+  <title>Shopify Storefront API</title>
+  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/graphql-playground-react/build/static/css/index.css" />
+  <link rel="shortcut icon" href="//cdn.jsdelivr.net/npm/graphql-playground-react/build/favicon.png" />
+  <script src="//cdn.jsdelivr.net/npm/graphql-playground-react/build/static/js/middleware.js"></script>
+</head>
+<body>
+  <div id="root"></div>
+  <script>window.addEventListener('load', function (event) {
+    GraphQLPlayground.init(document.getElementById('root'), {
+      endpoint:'https://${shop}/api/${apiVersion}/graphql.json',
+      settings:{
+        'request.globalHeaders': {
+          Accept: 'application/json',
+          'Content-Type': 'application/graphql',
+          'X-Shopify-Storefront-Access-Token': '${token}'
+        }
+      },
+      tabs: [{
+        endpoint: 'https://${shop}/api/${apiVersion}/graphql.json',
+        query: '{ shop { name } }'
+      }]
+    })
+  })</script>
+</body>
+</html>
+`;
+}
+exports.graphiqlHtml = graphiqlHtml;
diff --git a/dist/dist/node/framework/load-config.d.ts b/dist/dist/node/framework/load-config.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1c3bc772f84177954216bee2c8776446ebb61780
--- /dev/null
+++ b/dist/dist/node/framework/load-config.d.ts
@@ -0,0 +1,5 @@
+export declare function loadConfig(options?: {
+    root: string;
+}): Promise<{
+    configuration: any;
+}>;
diff --git a/dist/dist/node/framework/load-config.js b/dist/dist/node/framework/load-config.js
new file mode 100644
index 0000000000000000000000000000000000000000..9f19236272919b449ba728a02d8f52d7d82c48a8
--- /dev/null
+++ b/dist/dist/node/framework/load-config.js
@@ -0,0 +1,11 @@
+"use strict";
+// Provide Hydrogen config loader to external tools like the CLI
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.loadConfig = void 0;
+const vite_plugin_hydrogen_virtual_files_js_1 = require("./plugins/vite-plugin-hydrogen-virtual-files.js");
+const viteception_js_1 = require("./viteception.js");
+async function loadConfig(options = { root: process.cwd() }) {
+    const { loaded } = await (0, viteception_js_1.viteception)([vite_plugin_hydrogen_virtual_files_js_1.VIRTUAL_PROXY_HYDROGEN_CONFIG_ID], options);
+    return { configuration: loaded[0].default };
+}
+exports.loadConfig = loadConfig;
diff --git a/dist/dist/node/framework/middleware.d.ts b/dist/dist/node/framework/middleware.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7d726bd838e2215685d5fec519b7bf40a5e1fc3e
--- /dev/null
+++ b/dist/dist/node/framework/middleware.d.ts
@@ -0,0 +1,21 @@
+import type { ShopifyConfig } from '../shared-types.js';
+import type { IncomingMessage, NextFunction } from 'connect';
+import type { ServerResponse } from 'http';
+import type { ViteDevServer } from 'vite';
+declare type HydrogenMiddlewareArgs = {
+    dev?: boolean;
+    indexTemplate: string | ((url: string) => Promise<string>);
+    getServerEntrypoint: () => any;
+    devServer?: ViteDevServer;
+    cache?: Cache;
+};
+export declare function graphiqlMiddleware({ getShopifyConfig, dev, }: {
+    getShopifyConfig: (request: IncomingMessage) => ShopifyConfig | Promise<ShopifyConfig>;
+    dev?: boolean;
+}): (request: IncomingMessage, response: ServerResponse, next: NextFunction) => Promise<void>;
+/**
+ * Provides middleware to Node.js Express-like servers. Used by the Hydrogen
+ * Vite dev server plugin as well as production Node.js implementation.
+ */
+export declare function hydrogenMiddleware({ dev, cache, indexTemplate, getServerEntrypoint, devServer, }: HydrogenMiddlewareArgs): (request: IncomingMessage, response: ServerResponse, next: NextFunction) => Promise<void>;
+export {};
diff --git a/dist/dist/node/framework/middleware.js b/dist/dist/node/framework/middleware.js
new file mode 100644
index 0000000000000000000000000000000000000000..6b09db2d979a9ab3e167bf5390bacc7ff73a4c71
--- /dev/null
+++ b/dist/dist/node/framework/middleware.js
@@ -0,0 +1,124 @@
+"use strict";
+var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    var desc = Object.getOwnPropertyDescriptor(m, k);
+    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
+      desc = { enumerable: true, get: function() { return m[k]; } };
+    }
+    Object.defineProperty(o, k2, desc);
+}) : (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    o[k2] = m[k];
+}));
+var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
+    Object.defineProperty(o, "default", { enumerable: true, value: v });
+}) : function(o, v) {
+    o["default"] = v;
+});
+var __importStar = (this && this.__importStar) || function (mod) {
+    if (mod && mod.__esModule) return mod;
+    var result = {};
+    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
+    __setModuleDefault(result, mod);
+    return result;
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.hydrogenMiddleware = exports.graphiqlMiddleware = void 0;
+const graphiql_js_1 = require("./graphiql.js");
+function graphiqlMiddleware({ getShopifyConfig, dev, }) {
+    return async function (request, response, next) {
+        if (dev && isGraphiqlRequest(request)) {
+            const shopifyConfig = await getShopifyConfig(request);
+            return respondWithGraphiql(response, shopifyConfig);
+        }
+        next();
+    };
+}
+exports.graphiqlMiddleware = graphiqlMiddleware;
+let entrypointError = null;
+/**
+ * Provides middleware to Node.js Express-like servers. Used by the Hydrogen
+ * Vite dev server plugin as well as production Node.js implementation.
+ */
+function hydrogenMiddleware({ dev, cache, indexTemplate, getServerEntrypoint, devServer, }) {
+    if (dev && devServer) {
+        // Store this globally for devtools
+        // @ts-ignore
+        globalThis.__viteDevServer = devServer;
+    }
+    /**
+     * We're running in the Node.js runtime without access to `fetch`,
+     * which is needed for proxy requests and server-side API requests.
+     */
+    const webPolyfills = !globalThis.fetch || !globalThis.ReadableStream
+        ? Promise.resolve().then(() => __importStar(require('../utilities/web-api-polyfill.js'))) : undefined;
+    return async function (request, response, next) {
+        try {
+            await webPolyfills;
+            const entrypoint = await Promise.resolve(getServerEntrypoint()).catch((error) => {
+                // Errors are only thrown the first time we try to load the entry point.
+                // After refreshing the browser, this just loads an empty module
+                // and doesn't throw anymore. Store this error in the outer scope
+                // to keep throwing it on refresh until things are fixed.
+                entrypointError = error;
+            });
+            const handleRequest = entrypoint?.default ?? entrypoint;
+            if (typeof handleRequest !== 'function') {
+                if (entrypointError) {
+                    throw entrypointError;
+                }
+                else {
+                    // This means there is no error when loading the entry point but
+                    // we are still not getting a function as the default export.
+                    throw new Error('Something is wrong in your project. Make sure to add "export default renderHydrogen(...)" in your server entry file.');
+                }
+            }
+            entrypointError = null;
+            await handleRequest(request, {
+                dev,
+                cache,
+                indexTemplate,
+                streamableResponse: response,
+            });
+        }
+        catch (e) {
+            if (dev && devServer)
+                devServer.ssrFixStacktrace(e);
+            response.statusCode = 500;
+            /**
+             * Attempt to print the error stack within the template.
+             * This allows the react-refresh plugin and other Vite runtime helpers
+             * to display the error and auto-refresh when the error is fixed, instead
+             * of a white screen that needs a manual refresh.
+             */
+            try {
+                const template = typeof indexTemplate === 'function'
+                    ? await indexTemplate(request.originalUrl ?? request.url ?? '')
+                    : indexTemplate;
+                const html = template.replace(`<div id="root"></div>`, `<div id="root"><pre><code>${e.stack}</code></pre></div>`);
+                response.write(html);
+                next(e);
+            }
+            catch (_e) {
+                // If template loading is the culprit, give up and just return the error stack.
+                response.write(e.stack);
+                next(e);
+            }
+        }
+    };
+}
+exports.hydrogenMiddleware = hydrogenMiddleware;
+/**
+ * /graphiql and /___graphql are supported
+ */
+function isGraphiqlRequest(request) {
+    return /^\/(?:_{3})?graphi?ql/.test(request.url || '');
+}
+async function respondWithGraphiql(response, shopifyConfig) {
+    if (!shopifyConfig) {
+        throw new Error("You must provide a 'shopify' property in your Hydrogen config file");
+    }
+    const { storeDomain, storefrontToken, storefrontApiVersion } = shopifyConfig;
+    response.setHeader('Content-Type', 'text/html');
+    response.end((0, graphiql_js_1.graphiqlHtml)(storeDomain?.replace(/^https?:\/\//, ''), storefrontToken, storefrontApiVersion));
+}
diff --git a/dist/dist/node/framework/plugin.d.ts b/dist/dist/node/framework/plugin.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..08017a0378a471cb736245fd2719ad863137686b
--- /dev/null
+++ b/dist/dist/node/framework/plugin.d.ts
@@ -0,0 +1,5 @@
+import type { HydrogenVitePluginOptions } from './types.js';
+import type { Plugin } from 'vite';
+declare const hydrogenPlugin: (pluginOptions?: HydrogenVitePluginOptions) => Plugin[];
+export = hydrogenPlugin;
+export default hydrogenPlugin;
diff --git a/dist/dist/node/framework/plugin.js b/dist/dist/node/framework/plugin.js
new file mode 100644
index 0000000000000000000000000000000000000000..7a77fe1e7603270a1b589a9c9e735c8e5792602b
--- /dev/null
+++ b/dist/dist/node/framework/plugin.js
@@ -0,0 +1,40 @@
+"use strict";
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+const vite_plugin_hydrogen_config_js_1 = __importDefault(require("./plugins/vite-plugin-hydrogen-config.js"));
+const vite_plugin_hydrogen_middleware_js_1 = __importDefault(require("./plugins/vite-plugin-hydrogen-middleware.js"));
+const vite_plugin_hydrogen_client_components_cache_js_1 = __importDefault(require("./plugins/vite-plugin-hydrogen-client-components-cache.js"));
+const vite_plugin_hydrogen_virtual_files_js_1 = __importDefault(require("./plugins/vite-plugin-hydrogen-virtual-files.js"));
+const vite_plugin_platform_entry_js_1 = __importDefault(require("./plugins/vite-plugin-platform-entry.js"));
+const vite_plugin_hydrogen_rsc_js_1 = __importDefault(require("./plugins/vite-plugin-hydrogen-rsc.js"));
+const vite_plugin_ssr_interop_js_1 = __importDefault(require("./plugins/vite-plugin-ssr-interop.js"));
+const vite_plugin_hydration_auto_import_js_1 = __importDefault(require("./plugins/vite-plugin-hydration-auto-import.js"));
+const vite_plugin_inspect_1 = __importDefault(require("vite-plugin-inspect"));
+const plugin_react_1 = __importDefault(require("@vitejs/plugin-react"));
+const vite_plugin_css_rsc_js_1 = __importDefault(require("./plugins/vite-plugin-css-rsc.js"));
+const vite_plugin_css_modules_rsc_js_1 = __importDefault(require("./plugins/vite-plugin-css-modules-rsc.js"));
+const vite_plugin_client_imports_js_1 = __importDefault(require("./plugins/vite-plugin-client-imports.js"));
+const vite_plugin_hydrogen_suppress_warnings_js_1 = __importDefault(require("./plugins/vite-plugin-hydrogen-suppress-warnings.js"));
+const vite_plugin_assets_version_js_1 = __importDefault(require("./plugins/vite-plugin-assets-version.js"));
+const hydrogenPlugin = (pluginOptions = {}) => {
+    return [
+        process.env.VITE_INSPECT && (0, vite_plugin_inspect_1.default)(),
+        (0, vite_plugin_hydrogen_config_js_1.default)(pluginOptions),
+        (0, vite_plugin_hydrogen_client_components_cache_js_1.default)(),
+        (0, vite_plugin_client_imports_js_1.default)(),
+        (0, vite_plugin_hydrogen_middleware_js_1.default)(pluginOptions),
+        (0, vite_plugin_hydrogen_virtual_files_js_1.default)(pluginOptions),
+        (0, plugin_react_1.default)(),
+        (0, vite_plugin_hydration_auto_import_js_1.default)(),
+        (0, vite_plugin_ssr_interop_js_1.default)(),
+        pluginOptions.experimental?.css === 'global' ? (0, vite_plugin_css_rsc_js_1.default)() : (0, vite_plugin_css_modules_rsc_js_1.default)(),
+        (0, vite_plugin_hydrogen_rsc_js_1.default)(pluginOptions),
+        (0, vite_plugin_platform_entry_js_1.default)(),
+        (0, vite_plugin_hydrogen_suppress_warnings_js_1.default)(),
+        pluginOptions.assetHashVersion &&
+            (0, vite_plugin_assets_version_js_1.default)(pluginOptions.assetHashVersion),
+    ];
+};
+exports.default = hydrogenPlugin; // For ESM
+module.exports = hydrogenPlugin;
diff --git a/dist/dist/node/framework/plugins/vite-plugin-assets-version.d.ts b/dist/dist/node/framework/plugins/vite-plugin-assets-version.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..848f1cc417c0a339af61e4fea55c7de93ac4ed01
--- /dev/null
+++ b/dist/dist/node/framework/plugins/vite-plugin-assets-version.d.ts
@@ -0,0 +1,2 @@
+import { Plugin } from 'vite';
+export default function assetsVersion(version?: string): Plugin;
diff --git a/dist/dist/node/framework/plugins/vite-plugin-assets-version.js b/dist/dist/node/framework/plugins/vite-plugin-assets-version.js
new file mode 100644
index 0000000000000000000000000000000000000000..8690be9b3fa1085e147a222b417d498058e2ebbf
--- /dev/null
+++ b/dist/dist/node/framework/plugins/vite-plugin-assets-version.js
@@ -0,0 +1,15 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+/* -- Plugin notes:
+ * Used to manually change the hash of output chunks (`index.k12dw5q.js`)
+ * when their content have not been updated.
+ */
+function assetsVersion(version) {
+    return {
+        name: 'hydrogen:augment-with-version',
+        augmentChunkHash() {
+            return version ?? '';
+        },
+    };
+}
+exports.default = assetsVersion;
diff --git a/dist/dist/node/framework/plugins/vite-plugin-client-imports.d.ts b/dist/dist/node/framework/plugins/vite-plugin-client-imports.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ad546c642d55dfff0bf84fd6c2f9382af7bc83fc
--- /dev/null
+++ b/dist/dist/node/framework/plugins/vite-plugin-client-imports.d.ts
@@ -0,0 +1,2 @@
+import type { Plugin } from 'vite';
+export default function clientImports(): Plugin;
diff --git a/dist/dist/node/framework/plugins/vite-plugin-client-imports.js b/dist/dist/node/framework/plugins/vite-plugin-client-imports.js
new file mode 100644
index 0000000000000000000000000000000000000000..037f1d5634fad12bc5baf70a0bcaf3aad4dd1de0
--- /dev/null
+++ b/dist/dist/node/framework/plugins/vite-plugin-client-imports.js
@@ -0,0 +1,31 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+/* -- Plugin notes:
+ * This plugin allows to import always from '@shopify/hydrogen' path, instead of
+ * using '@shopify/hydrogen/client' in browser files. It does this by redirecting
+ * the server path to the browser path if the importer file is a client component.
+ */
+function clientImports() {
+    return {
+        name: 'hydrogen:client-imports',
+        enforce: 'pre',
+        /**
+         * When importer does not end in `server.jsx`, and source is `@shopify/hydrogen`,
+         * replace with `@shopify/hydrogen/client`. This prevents other server-only imports
+         * from "leaking" into the client bundle.
+         */
+        async resolveId(source, importer, { ssr }) {
+            if (ssr)
+                return;
+            if (/\.server\.(j|t)sx?/.test(importer ?? ''))
+                return;
+            if ('@shopify/hydrogen' !== source)
+                return;
+            const resolution = await this.resolve('@shopify/hydrogen/client', importer, { skipSelf: true });
+            if (resolution) {
+                return resolution.id;
+            }
+        },
+    };
+}
+exports.default = clientImports;
diff --git a/dist/dist/node/framework/plugins/vite-plugin-css-modules-rsc.d.ts b/dist/dist/node/framework/plugins/vite-plugin-css-modules-rsc.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..971c92ede3e5f5ba9a0ca7506529b7f8718c9e67
--- /dev/null
+++ b/dist/dist/node/framework/plugins/vite-plugin-css-modules-rsc.d.ts
@@ -0,0 +1,2 @@
+import type { Plugin } from 'vite';
+export default function cssModulesRsc(): Plugin[];
diff --git a/dist/dist/node/framework/plugins/vite-plugin-css-modules-rsc.js b/dist/dist/node/framework/plugins/vite-plugin-css-modules-rsc.js
new file mode 100644
index 0000000000000000000000000000000000000000..d475304b9f1f8a4accf3e4cc36fbaf44055d9104
--- /dev/null
+++ b/dist/dist/node/framework/plugins/vite-plugin-css-modules-rsc.js
@@ -0,0 +1,107 @@
+"use strict";
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+const vite_plugin_hydrogen_middleware_js_1 = require("./vite-plugin-hydrogen-middleware.js");
+const magic_string_1 = __importDefault(require("magic-string"));
+const path_1 = __importDefault(require("path"));
+/* -- Plugin notes:
+ * Old approach to inlining CSS inside server components. This is deprecated.
+ */
+const cssModuleRE = /\.module\.(s?css|sass|less|stylus)/;
+function cssModulesRsc() {
+    // 1. Original CSS module: `.myStyle { color: red; }`
+    // 2. CSS module after 'pre' Vite transforms: `.myStyle_hashedXYZ { color: red; }`
+    // 3. CSS module after 'post' Vite transforms: `export const myStyle = 'myStyle_hashedXYZ';`
+    let cssMap = new Map();
+    let config;
+    return [
+        {
+            name: 'css-modules-rsc',
+            configResolved(_config) {
+                config = _config;
+                cssMap = new Map();
+                // Place this plugin before react-refresh to
+                // modify files before JSX is compiled.
+                // @ts-ignore
+                config.plugins.unshift(autoStyleTagPlugin());
+            },
+            transform(code, id) {
+                if (cssModuleRE.test(id)) {
+                    cssMap.set(id, code);
+                }
+            },
+        },
+        {
+            name: 'css-modules-rsc-post',
+            enforce: 'post',
+            transform(code, id) {
+                if (id.includes('.module.') && cssMap.has(id)) {
+                    const isDev = config.command === 'serve';
+                    const key = path_1.default.relative(config.root, id.split('?')[0]);
+                    const s = new magic_string_1.default(code);
+                    s.prepend((isDev
+                        ? `import {jsxDEV as _jsx} from 'react/jsx-dev-runtime';`
+                        : `import {jsx as _jsx} from 'react/jsx-runtime';`) +
+                        `export const StyleTag = () => _jsx('style', {dangerouslySetInnerHTML: {__html: ${JSON.stringify(cssMap.get(id))}}});` +
+                        `\nStyleTag.key = '${key}';\n`);
+                    s.replace(/export default \{/gs, `export default {\n  StyleTag,`);
+                    return {
+                        code: s.toString(),
+                        map: s.generateMap({ file: id, source: id }),
+                    };
+                }
+            },
+        },
+    ];
+}
+exports.default = cssModulesRsc;
+function autoStyleTagPlugin() {
+    return {
+        name: 'css-modules-auto-style-tag',
+        transform(code, id) {
+            id = id.split('?')[0];
+            if (/\.[jt]sx$/.test(id) &&
+                !id.endsWith(vite_plugin_hydrogen_middleware_js_1.HYDROGEN_DEFAULT_SERVER_ENTRY) &&
+                !id.endsWith(path_1.default.format({
+                    name: vite_plugin_hydrogen_middleware_js_1.HYDROGEN_DEFAULT_SERVER_ENTRY,
+                    ext: path_1.default.extname(id),
+                })) &&
+                cssModuleRE.test(code) &&
+                code.includes('export default')) {
+                const s = new magic_string_1.default(code);
+                // 1. Gather style tags in an array
+                let styleCount = 0;
+                s.prepend(`const __styleTags = [];\n`);
+                s.replace(/^import\s+(.+?)\s+from\s+['"]([^'"]+?\.module\.[^'"]+?)['"]/gm, (all, statements, from) => {
+                    if (!cssModuleRE.test(from)) {
+                        return all;
+                    }
+                    if (statements.startsWith('{')) {
+                        // Add default import
+                        const replacement = `__style${styleCount++}, {`;
+                        statements = statements.replace('{', replacement);
+                        all = all.replace('{', replacement);
+                    }
+                    const defaultImport = statements
+                        .split(',')[0]
+                        .replace(/\*\s+as\s+/, '')
+                        .trim();
+                    return all + `; __styleTags.push(${defaultImport}.StyleTag)`;
+                });
+                // 2. Wrap default export in a new component that includes the style tags
+                s.replace(/export default/gm, 'const __defaultExport = ');
+                s.append(`\nconst __ApplyStyleTags = function (props) {\n` +
+                    `  return <>{__styleTags.map(ST => <ST key={ST.key} />)}<__defaultExport {...props} /></>;` +
+                    `\n}\n\n` +
+                    `Object.defineProperty(__ApplyStyleTags, 'name', {value: 'ApplyStyleTags_' + (__defaultExport.name || '')});\n` +
+                    `export default __ApplyStyleTags;`);
+                return {
+                    code: s.toString(),
+                    map: s.generateMap({ file: id, source: id }),
+                };
+            }
+        },
+    };
+}
diff --git a/dist/dist/node/framework/plugins/vite-plugin-css-rsc.d.ts b/dist/dist/node/framework/plugins/vite-plugin-css-rsc.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e45473f53cd23231607f01340a2dfc8d87eabec6
--- /dev/null
+++ b/dist/dist/node/framework/plugins/vite-plugin-css-rsc.d.ts
@@ -0,0 +1,2 @@
+import { type Plugin } from 'vite';
+export default function cssRsc(): Plugin;
diff --git a/dist/dist/node/framework/plugins/vite-plugin-css-rsc.js b/dist/dist/node/framework/plugins/vite-plugin-css-rsc.js
new file mode 100644
index 0000000000000000000000000000000000000000..199bb98f8a3d28873b2d7edf47bf74e952ad4e63
--- /dev/null
+++ b/dist/dist/node/framework/plugins/vite-plugin-css-rsc.js
@@ -0,0 +1,219 @@
+"use strict";
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+const path_1 = __importDefault(require("path"));
+const magic_string_1 = __importDefault(require("magic-string"));
+const vite_1 = require("vite");
+const VITE_CSS_CHUNK_NAME = 'style.css';
+const INJECT_STYLES_COMMENT = '<!--__INJECT_STYLES__-->';
+const CSS_EXTENSIONS_RE = /\.(css|sass|scss|stylus|less)(\.|\?|$)/;
+const CSS_MODULES_EXTENSIONS_RE = /\.module\.(css|sass|scss|stylus|less)(\?|$)/;
+const EVENT_CSS_IMPORT = 'hydrogen-css-modules-update-imports';
+const EVENT_CSS_CLASSES = 'hydrogen-css-modules-update-classes';
+const CSS_MODULES_HMR_INJECT = `
+import {createHotContext, injectQuery} from "/@vite/client";
+
+if (!import.meta.hot) {
+  import.meta.hot = createHotContext("/index.html");
+}
+
+import.meta.hot.on('${EVENT_CSS_IMPORT}', ({ids, timestamp}) => {
+  ids.forEach((id) => {
+    import(injectQuery(id, 't=' + timestamp));
+  });
+});
+
+import.meta.hot.on('${EVENT_CSS_CLASSES}', ({replacements}) => {
+  replacements.forEach(([oldClass, newClass]) => {
+    document.querySelectorAll('.' + oldClass).forEach(node => {
+      node.classList.replace(oldClass, newClass);
+    })
+  });
+});
+`;
+// Keep this in the outer scope to share it
+// across client <> server builds.
+let clientBuildPath;
+/* -- Plugin notes:
+ * This plugin collects all the CSS imported in both client and server components and
+ * extracts it in a single stylesheet that is added to the <head>. It does this by:
+ * 1. Removing all the CSS generated during the client build. The client build CSS is a sub-set of the
+ * server build CSS because it can only find CSS imported in client components. This avoids duplicates.
+ * 2. Force Vite to collect CSS in every file during the server build, and emit it as a chunk.
+ * 3. Move the generated CSS chunk in the server build to the client build output as an asset, and link to it in `index.html`.
+ */
+function cssRsc() {
+    let config;
+    let server;
+    let isUsingCssModules = false;
+    const hmrCssCopy = new Map();
+    const hmrCssQueue = new Set();
+    return {
+        name: 'hydrogen:css-rsc',
+        enforce: 'post',
+        config() {
+            // Disable CSS code split to avoid preloading styles
+            // that are already included in index.html
+            return { build: { cssCodeSplit: false } };
+        },
+        configResolved(_config) {
+            config = _config;
+        },
+        configureServer(_server) {
+            server = _server;
+        },
+        transform(code, id, options) {
+            if (options?.ssr && id.includes('index.html?raw')) {
+                // Mark the client build index.html to inject styles later
+                const s = new magic_string_1.default(code);
+                s.replace('</head>', INJECT_STYLES_COMMENT + '</head>');
+                return {
+                    code: s.toString(),
+                    map: s.generateMap({ file: id, source: id }),
+                };
+            }
+            // Manual HMR for CSS Modules
+            if (server && CSS_MODULES_EXTENSIONS_RE.test(id)) {
+                isUsingCssModules = true;
+                const file = id.split('?')[0];
+                // Note: this "CSS" file is actually JavaScript code.
+                // Get a copy of how this CSS was before the current update
+                const oldCode = hmrCssCopy.get(file);
+                // Save a copy of the current CSS for future updates
+                hmrCssCopy.set(file, code);
+                if (!oldCode || !hmrCssQueue.has(file))
+                    return;
+                hmrCssQueue.delete(file);
+                // Diff old code with new code and use the exported class names as a reference
+                // to find out how the resulting CSS classes are renamed.  With this, we can
+                // update classes in the DOM without requesting a full rendering from the server.
+                // Example:
+                // Previous code => export const red = ".red_k3tz4_module";
+                // New code      => export const red = ".red_t93kw_module";
+                const classRE = /export const (.+?) = "(.+?)"/g;
+                const oldClasses = [...oldCode.matchAll(classRE)];
+                const replacements = [];
+                for (const [, newKey, newClass] of code.matchAll(classRE)) {
+                    const oldClass = oldClasses.find(([, oldKey]) => oldKey === newKey)?.[2];
+                    if (oldClass && oldClass !== newClass) {
+                        replacements.push([oldClass, newClass]);
+                    }
+                }
+                if (replacements.length > 0) {
+                    // This event asks the browser to replace old
+                    // hash-based CSS classes with new ones.
+                    // Example: from `.red_k3tz4_module` to `.red_t93kw_module`
+                    server.ws.send({
+                        type: 'custom',
+                        event: EVENT_CSS_CLASSES,
+                        data: { replacements },
+                    });
+                }
+            }
+        },
+        transformIndexHtml(html, { server }) {
+            // Add discovered styles during dev
+            if (server) {
+                const tags = (isUsingCssModules
+                    ? [
+                        {
+                            tag: 'script',
+                            attrs: { type: 'module' },
+                            children: CSS_MODULES_HMR_INJECT,
+                        },
+                    ]
+                    : []);
+                const foundCssFiles = new Set();
+                for (const [key, value] of server.moduleGraph.idToModuleMap.entries()) {
+                    if (
+                    // Note: Some CSS-in-JS libraries use `.css.js`
+                    // extension and we should match it here:
+                    CSS_EXTENSIONS_RE.test((0, vite_1.normalizePath)(key).split('/').pop())) {
+                        let { url, file, lastHMRTimestamp, importers } = value;
+                        if (!foundCssFiles.has(file) &&
+                            !Array.from(importers).some((importer) => foundCssFiles.has(importer.file))) {
+                            foundCssFiles.add(file);
+                            // Vite is adding hash and timestamp to the CSS files downloaded
+                            // from client components. Adding the same query string params
+                            // here prevents this file from being downloaded twice.
+                            if (lastHMRTimestamp) {
+                                const timestampQuery = `?t=${lastHMRTimestamp}`;
+                                // The timestamp needs to be the first query string param.
+                                url = url.includes('?')
+                                    ? url.replace('?', timestampQuery + '&')
+                                    : url + timestampQuery;
+                            }
+                            tags.push(value.type === 'css'
+                                ? { tag: 'link', attrs: { rel: 'stylesheet', href: url } }
+                                : { tag: 'script', attrs: { type: 'module', src: url } });
+                        }
+                    }
+                }
+                return tags;
+            }
+        },
+        generateBundle(options, bundle, isWrite) {
+            if (config.build?.ssr) {
+                // -- Server build
+                if (!clientBuildPath) {
+                    // Default value
+                    clientBuildPath = (0, vite_1.normalizePath)(path_1.default.resolve(config.root, config.build.outDir, '..', 'client'));
+                }
+                const relativeClientPath = (0, vite_1.normalizePath)(path_1.default.relative((0, vite_1.normalizePath)(path_1.default.resolve(config.root, config.build.outDir)), clientBuildPath));
+                let cssAssetFileName = '';
+                const cssAsset = Object.values(bundle).find((file) => file.type === 'asset' && file.name === VITE_CSS_CHUNK_NAME);
+                const outputChunk = Object.values(bundle).find((file) => file.type === 'chunk' && file.isEntry);
+                if (cssAsset) {
+                    cssAssetFileName = cssAsset.fileName;
+                    // Move the CSS file to the client build assets
+                    cssAsset.fileName = (0, vite_1.normalizePath)(path_1.default.join(relativeClientPath, cssAsset.fileName));
+                }
+                let assetPrefix = process.env.HYDROGEN_ASSET_BASE_URL || '/';
+                if (!assetPrefix.endsWith('/'))
+                    assetPrefix += '/';
+                // Add a reference to the CSS file in indexTemplate
+                outputChunk.code = outputChunk.code.replace(INJECT_STYLES_COMMENT, cssAssetFileName &&
+                    `<link rel="stylesheet" href="${assetPrefix + cssAssetFileName}">`);
+            }
+            else {
+                // -- Client build
+                // Save outDir from client build in the outer scope
+                // to read it during the server build. The CLI runs Vite in
+                // the same process so the scope is shared across builds.
+                clientBuildPath = (0, vite_1.normalizePath)(path_1.default.resolve(config.root, config.build.outDir));
+                const indexHtml = bundle['index.html'];
+                const cssAsset = Object.values(bundle).find((file) => file.type === 'asset' && file.name === VITE_CSS_CHUNK_NAME);
+                if (cssAsset) {
+                    // The client build CSS is incomplete because it only includes
+                    // CSS imported in client components (server components are not
+                    // discovered in this build). Remove it from this build and
+                    // let it be added by the server build after this.
+                    delete bundle[cssAsset.fileName];
+                    indexHtml.source = indexHtml.source.replace(new RegExp(`\\s*<link[^<>]+${cssAsset.fileName.replace('.', '\\.')}.*?>`, ''), '');
+                }
+            }
+        },
+        async handleHotUpdate({ modules, server }) {
+            if (modules.every((m) => CSS_MODULES_EXTENSIONS_RE.test(m.file || ''))) {
+                // Opt-out of Vite's default HMR for CSS Modules, we'll handle this manually
+                const file = modules[0].file;
+                hmrCssQueue.add(file);
+                // This event asks the browser to download fresh CSS files.
+                // Fetching these fresh CSS files will trigger another event
+                // from the `transform` hook to replace classes in the DOM.
+                server.ws.send({
+                    type: 'custom',
+                    event: EVENT_CSS_IMPORT,
+                    data: {
+                        ids: modules.map((m) => m.id),
+                        timestamp: modules[0].lastHMRTimestamp || Date.now(),
+                    },
+                });
+                return [];
+            }
+        },
+    };
+}
+exports.default = cssRsc;
diff --git a/dist/dist/node/framework/plugins/vite-plugin-hydration-auto-import.d.ts b/dist/dist/node/framework/plugins/vite-plugin-hydration-auto-import.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7f9c594a7efd9463aed4f4cfad8321d19b859b6a
--- /dev/null
+++ b/dist/dist/node/framework/plugins/vite-plugin-hydration-auto-import.d.ts
@@ -0,0 +1,3 @@
+import { Plugin } from 'vite';
+declare const _default: () => Plugin;
+export default _default;
diff --git a/dist/dist/node/framework/plugins/vite-plugin-hydration-auto-import.js b/dist/dist/node/framework/plugins/vite-plugin-hydration-auto-import.js
new file mode 100644
index 0000000000000000000000000000000000000000..0df0885b2a6ee3d6f7c8f74e2cf0420b7790a972
--- /dev/null
+++ b/dist/dist/node/framework/plugins/vite-plugin-hydration-auto-import.js
@@ -0,0 +1,46 @@
+"use strict";
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+const vite_1 = require("vite");
+const path_1 = __importDefault(require("path"));
+const magic_string_1 = __importDefault(require("magic-string"));
+const HYDROGEN_ENTRY_FILE = 'hydrogen-entry-client.jsx';
+/* -- Plugin notes:
+ * Originally, every Hydrogen app required a `src/entry-client.jsx` file. However, this file
+ * was rarely modified by the user. This plugin provides a virtual file with the same content of
+ * that file, which allows to remove it by default from the file system.
+ * The virtual file created here is imported in `index.html` in a script tag.
+ */
+exports.default = () => {
+    let config;
+    return {
+        name: 'hydrogen:client-hydration-auto-import',
+        enforce: 'pre',
+        configResolved(_config) {
+            config = _config;
+        },
+        resolveId(id, importer) {
+            if ((/^\/?@shopify\/hydrogen\/entry-client$/.test(id) ||
+                id.endsWith(path_1.default.sep + HYDROGEN_ENTRY_FILE)) &&
+                (0, vite_1.normalizePath)(importer || '').endsWith('/index.html')) {
+                // Make this virtual import look like a local project file
+                // to enable React Refresh normally.
+                return path_1.default.join(config.root, HYDROGEN_ENTRY_FILE + '?virtual');
+            }
+            return null;
+        },
+        load(id) {
+            if (id.includes(HYDROGEN_ENTRY_FILE + '?virtual')) {
+                const code = new magic_string_1.default(`import renderHydrogen from '@shopify/hydrogen/entry-client';\n` +
+                    `export default renderHydrogen((props) => props.children);`);
+                return {
+                    code: code.toString(),
+                    map: { mappings: '' },
+                };
+            }
+            return null;
+        },
+    };
+};
diff --git a/dist/dist/node/framework/plugins/vite-plugin-hydrogen-client-components-cache.d.ts b/dist/dist/node/framework/plugins/vite-plugin-hydrogen-client-components-cache.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..eb868251e80792f8e046f8b42cc6c06746423f70
--- /dev/null
+++ b/dist/dist/node/framework/plugins/vite-plugin-hydrogen-client-components-cache.d.ts
@@ -0,0 +1,3 @@
+import { type Plugin } from 'vite';
+declare const _default: () => Plugin;
+export default _default;
diff --git a/dist/dist/node/framework/plugins/vite-plugin-hydrogen-client-components-cache.js b/dist/dist/node/framework/plugins/vite-plugin-hydrogen-client-components-cache.js
new file mode 100644
index 0000000000000000000000000000000000000000..0e1861c336eb586fe182a89a0e02d2e23aa5d533
--- /dev/null
+++ b/dist/dist/node/framework/plugins/vite-plugin-hydrogen-client-components-cache.js
@@ -0,0 +1,38 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const vite_1 = require("vite");
+/* -- Plugin notes:
+ * This dev server middleware prevents Vite from applying immutable cache control headers to client
+ * components. These client components are part of the user's local source, but since they are
+ * referenced via import globs in the `react-dom-server-vite` NPM package, Vite assumes they
+ * are 3P deps that can be cached. This middleware responds to the requests early with `no-cache`.
+ */
+exports.default = () => {
+    return {
+        name: 'hydrogen:client-components-cache',
+        enforce: 'pre',
+        configureServer(server) {
+            server.middlewares.use(async (req, res, next) => {
+                const url = req.url;
+                try {
+                    if (/\.client\.[jt]sx?\?v=/.test(url) &&
+                        !/\/node_modules\//.test(url)) {
+                        const result = await server.transformRequest(url, { html: false });
+                        if (result) {
+                            return (0, vite_1.send)(req, res, result.code, 'js', {
+                                etag: result.etag,
+                                cacheControl: 'no-cache',
+                                headers: server.config.server.headers,
+                                map: result.map,
+                            });
+                        }
+                    }
+                }
+                catch (e) {
+                    next(e);
+                }
+                next();
+            });
+        },
+    };
+};
diff --git a/dist/dist/node/framework/plugins/vite-plugin-hydrogen-config.d.ts b/dist/dist/node/framework/plugins/vite-plugin-hydrogen-config.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c5c0c51934b7d3fa465c12503d4e7789ac6f9c90
--- /dev/null
+++ b/dist/dist/node/framework/plugins/vite-plugin-hydrogen-config.d.ts
@@ -0,0 +1,4 @@
+import { Plugin } from 'vite';
+import type { HydrogenVitePluginOptions } from '../types.js';
+declare const _default: (pluginOptions: HydrogenVitePluginOptions) => Plugin;
+export default _default;
diff --git a/dist/dist/node/framework/plugins/vite-plugin-hydrogen-config.js b/dist/dist/node/framework/plugins/vite-plugin-hydrogen-config.js
new file mode 100644
index 0000000000000000000000000000000000000000..0da82b4cc0249831a7f2bb88b80fd4d7032f8bd2
--- /dev/null
+++ b/dist/dist/node/framework/plugins/vite-plugin-hydrogen-config.js
@@ -0,0 +1,122 @@
+"use strict";
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+const crypto_1 = __importDefault(require("crypto"));
+/* -- Plugin notes:
+ * Provide configuration options to Vite to ensure Hydrogen is built correctly
+ * for worker environments, using latest ES syntax, and some other requirements.
+ */
+exports.default = (pluginOptions) => {
+    const rollupOptions = {
+        output: {},
+    };
+    const isWorker = Boolean(process.env.WORKER) && process.env.WORKER !== 'undefined';
+    return {
+        name: 'hydrogen:config',
+        config: async (config, env) => {
+            // @ts-ignore
+            const isSsrBuild = env.ssrBuild ?? !!config.build?.ssr;
+            /**
+             * By default, SSR dedupe logic gets bundled which runs `require('module')`.
+             * We don't want this in our workers runtime, because `require` is not supported.
+             */
+            rollupOptions.output = {
+                format: isWorker || !isSsrBuild ? 'es' : 'cjs',
+                inlineDynamicImports: isSsrBuild ? true : undefined,
+            };
+            if (process.env.NODE_ENV !== 'development' && !process.env.LOCAL_DEV) {
+                /**
+                 * Ofuscate production asset name - To prevent ad blocker logics that blocks
+                 * certain files due to how it is named.
+                 */
+                rollupOptions.output = {
+                    ...rollupOptions.output,
+                    chunkFileNames: 'assets/[hash].js',
+                };
+            }
+            return {
+                resolve: {
+                    alias: {
+                        // This library is currently included as a compiled vendor lib, not published yet to NPM
+                        'react-server-dom-vite/client-proxy': require.resolve('@shopify/hydrogen/vendor/react-server-dom-vite/esm/react-server-dom-vite-client-proxy.js'),
+                    },
+                },
+                build: {
+                    minify: config.build?.minify ?? (process.env.LOCAL_DEV ? false : 'esbuild'),
+                    sourcemap: true,
+                    rollupOptions: config.build?.rollupOptions
+                        ? Object.assign(rollupOptions, config.build.rollupOptions)
+                        : rollupOptions,
+                    target: config.build?.ssr
+                        ? isWorker
+                            ? 'es2022' // CFW (Updates weekly to latest V8)
+                            : 'es2020' // Node (Support for v14.19 used in SB)
+                        : 'modules', // Browsers (Vite default value)
+                },
+                ssr: {
+                    /**
+                     * Tell Vite to bundle everything when we're building for Workers.
+                     * Otherwise, bundle RSC plugin as a workaround to apply the vendor alias above.
+                     */
+                    noExternal: isWorker || [
+                        /react-server-dom-vite/,
+                        /@shopify\/hydrogen/,
+                    ],
+                    target: isWorker ? 'webworker' : 'node',
+                },
+                // Reload when updating local Hydrogen lib
+                server: process.env.LOCAL_DEV && {
+                    watch: {
+                        ignored: [
+                            '!**/node_modules/@shopify/hydrogen/**',
+                            '!**/node_modules/@shopify/hydrogen-ui/**',
+                        ],
+                    },
+                },
+                optimizeDeps: {
+                    exclude: [
+                        '@shopify/hydrogen',
+                        '@shopify/hydrogen/client',
+                        '@shopify/hydrogen/entry-client',
+                        '@shopify/hydrogen-ui',
+                    ],
+                    include: [
+                        /**
+                         * Additionally, the following dependencies have trouble loading the
+                         * correct version of the dependency (server vs client). This tells Vite to take the
+                         * server versions and optimize them for ESM.
+                         */
+                        'react-helmet-async',
+                        'react-error-boundary',
+                        /**
+                         * Vite cannot find the following dependencies since they might be
+                         * required in RSC asynchronously. This tells Vite to optimize them
+                         * at server start to avoid posterior page reloads and issues (#429 #430).
+                         */
+                        'react',
+                        'react-dom/client',
+                        'react-server-dom-vite/client-proxy',
+                        // https://github.com/vitejs/vite/issues/6215
+                        'react/jsx-runtime',
+                        // https://github.com/nfriedly/set-cookie-parser/issues/50
+                        'set-cookie-parser',
+                        'undici',
+                        '@xstate/react/fsm',
+                    ],
+                },
+                define: {
+                    __HYDROGEN_DEV__: env.mode !== 'production',
+                    __HYDROGEN_WORKER__: isWorker,
+                    __HYDROGEN_TEST__: false,
+                    __HYDROGEN_CACHE_ID__: pluginOptions.purgeQueryCacheOnBuild
+                        ? `"${crypto_1.default.randomBytes(8).toString('hex').slice(0, 8)}"`
+                        : '"__QUERY_CACHE_ID__"',
+                },
+                envPrefix: ['VITE_', 'PUBLIC_'],
+                base: process.env.HYDROGEN_ASSET_BASE_URL,
+            };
+        },
+    };
+};
diff --git a/dist/dist/node/framework/plugins/vite-plugin-hydrogen-middleware.d.ts b/dist/dist/node/framework/plugins/vite-plugin-hydrogen-middleware.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1cebff3a4be92f5755255f24790b90deff4593f2
--- /dev/null
+++ b/dist/dist/node/framework/plugins/vite-plugin-hydrogen-middleware.d.ts
@@ -0,0 +1,11 @@
+import { Plugin } from 'vite';
+import type { HydrogenVitePluginOptions } from '../types.js';
+export declare const HYDROGEN_DEFAULT_SERVER_ENTRY: string;
+declare const _default: (pluginOptions: HydrogenVitePluginOptions) => Plugin;
+export default _default;
+declare global {
+    var Oxygen: {
+        env: any;
+        [key: string]: any;
+    };
+}
diff --git a/dist/dist/node/framework/plugins/vite-plugin-hydrogen-middleware.js b/dist/dist/node/framework/plugins/vite-plugin-hydrogen-middleware.js
new file mode 100644
index 0000000000000000000000000000000000000000..659e808aa649fb5ac66320bc3327e2c6380deb49
--- /dev/null
+++ b/dist/dist/node/framework/plugins/vite-plugin-hydrogen-middleware.js
@@ -0,0 +1,66 @@
+"use strict";
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.HYDROGEN_DEFAULT_SERVER_ENTRY = void 0;
+const vite_1 = require("vite");
+const body_parser_1 = __importDefault(require("body-parser"));
+const path_1 = __importDefault(require("path"));
+const fs_1 = require("fs");
+const middleware_js_1 = require("../middleware.js");
+const in_memory_js_1 = require("../cache/in-memory.js");
+const vite_plugin_hydrogen_virtual_files_js_1 = require("./vite-plugin-hydrogen-virtual-files.js");
+exports.HYDROGEN_DEFAULT_SERVER_ENTRY = process.env.HYDROGEN_SERVER_ENTRY || '/src/App.server';
+/* -- Plugin notes:
+ * By adding a middleware to the Vite dev server, we can handle SSR without needing
+ * a custom node script. It works by handling any requests for `text/html` documents,
+ * loading them in an SSR context, rendering them using the `entry-server` endpoint in the
+ * user's project, and injecting the static HTML into the template.
+ */
+exports.default = (pluginOptions) => {
+    return {
+        name: 'hydrogen:middleware',
+        async configureServer(server) {
+            const resolve = (p) => path_1.default.resolve(server.config.root, p);
+            async function getIndexTemplate(url) {
+                const indexHtml = await fs_1.promises.readFile(resolve('index.html'), 'utf-8');
+                return await server.transformIndexHtml(url, indexHtml);
+            }
+            await polyfillOxygenEnv(server.config);
+            // The default vite middleware rewrites the URL `/graphqil` to `/index.html`
+            // By running this middleware first, we avoid that.
+            server.middlewares.use((0, middleware_js_1.graphiqlMiddleware)({
+                dev: true,
+                getShopifyConfig: async (incomingMessage) => {
+                    const { default: hydrogenConfig } = await server.ssrLoadModule(vite_plugin_hydrogen_virtual_files_js_1.VIRTUAL_PROXY_HYDROGEN_CONFIG_ID);
+                    // @ts-ignore
+                    const { address = 'localhost', port = '3000' } = server.httpServer?.address() || {};
+                    const url = new URL(`http://${address}:${port}${incomingMessage.url}`);
+                    const request = new Request(url.toString(), {
+                        headers: incomingMessage.headers,
+                    });
+                    // @ts-expect-error Manually set `normalizedUrl` which a developer expects to be available
+                    // via `HydrogenRequest` during production runtime.
+                    request.normalizedUrl = request.url;
+                    const { shopify } = hydrogenConfig;
+                    return typeof shopify === 'function' ? shopify(request) : shopify;
+                },
+            }));
+            server.middlewares.use(body_parser_1.default.raw({ type: '*/*' }));
+            return () => server.middlewares.use((0, middleware_js_1.hydrogenMiddleware)({
+                dev: true,
+                indexTemplate: getIndexTemplate,
+                getServerEntrypoint: () => server.ssrLoadModule(exports.HYDROGEN_DEFAULT_SERVER_ENTRY),
+                devServer: server,
+                cache: pluginOptions?.devCache
+                    ? new in_memory_js_1.InMemoryCache()
+                    : undefined,
+            }));
+        },
+    };
+};
+async function polyfillOxygenEnv(config) {
+    const env = await (0, vite_1.loadEnv)(config.mode, config.root, '');
+    globalThis.Oxygen = { env };
+}
diff --git a/dist/dist/node/framework/plugins/vite-plugin-hydrogen-rsc.d.ts b/dist/dist/node/framework/plugins/vite-plugin-hydrogen-rsc.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5d10138c53854afdafd5cb957d418d523bb639c9
--- /dev/null
+++ b/dist/dist/node/framework/plugins/vite-plugin-hydrogen-rsc.d.ts
@@ -0,0 +1,2 @@
+import { HydrogenVitePluginOptions } from '../types.js';
+export default function (options?: HydrogenVitePluginOptions): any;
diff --git a/dist/dist/node/framework/plugins/vite-plugin-hydrogen-rsc.js b/dist/dist/node/framework/plugins/vite-plugin-hydrogen-rsc.js
new file mode 100644
index 0000000000000000000000000000000000000000..7a01e760c7150b21d4de3ddb5644e25b43b04484
--- /dev/null
+++ b/dist/dist/node/framework/plugins/vite-plugin-hydrogen-rsc.js
@@ -0,0 +1,29 @@
+"use strict";
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+// @ts-ignore
+const plugin_js_1 = __importDefault(require("@shopify/hydrogen/vendor/react-server-dom-vite/plugin.js"));
+const vite_plugin_hydrogen_middleware_js_1 = require("./vite-plugin-hydrogen-middleware.js");
+const vite_plugin_hydrogen_virtual_files_js_1 = require("./vite-plugin-hydrogen-virtual-files.js");
+function default_1(options) {
+    return (0, plugin_js_1.default)({
+        serverBuildEntries: [
+            vite_plugin_hydrogen_middleware_js_1.HYDROGEN_DEFAULT_SERVER_ENTRY,
+            vite_plugin_hydrogen_virtual_files_js_1.VIRTUAL_PROXY_HYDROGEN_ROUTES_ID,
+        ],
+        isServerComponentImporterAllowed(importer, source) {
+            return (
+            // Always allow the entry server (e.g. App.server.jsx) to be imported
+            // in other files such as worker.js or server.js.
+            source.includes(vite_plugin_hydrogen_middleware_js_1.HYDROGEN_DEFAULT_SERVER_ENTRY) ||
+                /(index|provider-helpers|entry-server|testing|hydrogen\.config)\.[jt]s/.test(importer) ||
+                // Support importing server components for testing
+                // TODO: revisit this when RSC splits into two bundles
+                /\.(test|vitest|spec)\.[tj]sx?$/.test(importer));
+        },
+        ...options,
+    });
+}
+exports.default = default_1;
diff --git a/dist/dist/node/framework/plugins/vite-plugin-hydrogen-suppress-warnings.d.ts b/dist/dist/node/framework/plugins/vite-plugin-hydrogen-suppress-warnings.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7f9c594a7efd9463aed4f4cfad8321d19b859b6a
--- /dev/null
+++ b/dist/dist/node/framework/plugins/vite-plugin-hydrogen-suppress-warnings.d.ts
@@ -0,0 +1,3 @@
+import { Plugin } from 'vite';
+declare const _default: () => Plugin;
+export default _default;
diff --git a/dist/dist/node/framework/plugins/vite-plugin-hydrogen-suppress-warnings.js b/dist/dist/node/framework/plugins/vite-plugin-hydrogen-suppress-warnings.js
new file mode 100644
index 0000000000000000000000000000000000000000..fcc0687526f39dee54934d3c8eefee12659579ad
--- /dev/null
+++ b/dist/dist/node/framework/plugins/vite-plugin-hydrogen-suppress-warnings.js
@@ -0,0 +1,26 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+/* -- Plugin notes:
+ * Vite prints some warnings automatically are not important and
+ * not actionable. We hide them here to prevent confusing devs when
+ * real warnings or errors appear.
+ */
+exports.default = () => {
+    return {
+        name: 'hydrogen:suppress-warnings',
+        configResolved(config) {
+            // TODO: Fix the actual issues that cause these warnings
+            const filterOut = (msg) => msg.startsWith("@shopify/hydrogen doesn't appear to be written in CJS") ||
+                (msg.includes('missing source files') &&
+                    ['kolorist'].some((lib) => msg.includes(lib)));
+            for (const method of ['warn', 'warnOnce']) {
+                const original = config.logger[method];
+                config.logger[method] = (msg, ...args) => {
+                    if (filterOut(msg))
+                        return;
+                    return original(msg, ...args);
+                };
+            }
+        },
+    };
+};
diff --git a/dist/dist/node/framework/plugins/vite-plugin-hydrogen-virtual-files.d.ts b/dist/dist/node/framework/plugins/vite-plugin-hydrogen-virtual-files.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6198e47e5d9686a3bd6624b4631fa377fd92a7f
--- /dev/null
+++ b/dist/dist/node/framework/plugins/vite-plugin-hydrogen-virtual-files.d.ts
@@ -0,0 +1,7 @@
+import { Plugin } from 'vite';
+import type { HydrogenVitePluginOptions } from '../types.js';
+export declare const HYDROGEN_DEFAULT_SERVER_ENTRY: string;
+export declare const VIRTUAL_PROXY_HYDROGEN_CONFIG_ID: string;
+export declare const VIRTUAL_PROXY_HYDROGEN_ROUTES_ID: string;
+declare const _default: (pluginOptions: HydrogenVitePluginOptions) => Plugin;
+export default _default;
diff --git a/dist/dist/node/framework/plugins/vite-plugin-hydrogen-virtual-files.js b/dist/dist/node/framework/plugins/vite-plugin-hydrogen-virtual-files.js
new file mode 100644
index 0000000000000000000000000000000000000000..1f6e88b5e07605e69ce8508d01201d1506403f88
--- /dev/null
+++ b/dist/dist/node/framework/plugins/vite-plugin-hydrogen-virtual-files.js
@@ -0,0 +1,155 @@
+"use strict";
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.VIRTUAL_PROXY_HYDROGEN_ROUTES_ID = exports.VIRTUAL_PROXY_HYDROGEN_CONFIG_ID = exports.HYDROGEN_DEFAULT_SERVER_ENTRY = void 0;
+const vite_1 = require("vite");
+const path_1 = __importDefault(require("path"));
+const fs_1 = require("fs");
+const viteception_js_1 = require("../viteception.js");
+const magic_string_1 = __importDefault(require("magic-string"));
+const vite_js_1 = require("../../utilities/vite.js");
+/* -- Plugin notes:
+ * The Hydrogen framework needs to import certain files from the user app, such as
+ * routes and config. A priori, we can't import these files from the framework
+ * because we don't know the user path to write it in an `import * from '...'` statement.
+ * Instead, we import "virtual files" that are resolved by Vite in this plugin.
+ * These virtual files can include the user path and re-export the in-app files.
+ */
+exports.HYDROGEN_DEFAULT_SERVER_ENTRY = process.env.HYDROGEN_SERVER_ENTRY || '/src/App.server';
+// The character ":" breaks Vite with Node >= 16.15. Use "_" instead
+const VIRTUAL_PREFIX = 'virtual__';
+const PROXY_PREFIX = 'proxy__';
+const ERROR_FILE = 'error.jsx';
+const VIRTUAL_ERROR_FILE = VIRTUAL_PREFIX + ERROR_FILE;
+const HYDROGEN_CONFIG_ID = 'hydrogen.config.ts';
+const VIRTUAL_HYDROGEN_CONFIG_ID = VIRTUAL_PREFIX + HYDROGEN_CONFIG_ID;
+exports.VIRTUAL_PROXY_HYDROGEN_CONFIG_ID = VIRTUAL_PREFIX + PROXY_PREFIX + HYDROGEN_CONFIG_ID;
+const HYDROGEN_ROUTES_ID = 'hydrogen-routes.server.jsx';
+const VIRTUAL_HYDROGEN_ROUTES_ID = VIRTUAL_PREFIX + HYDROGEN_ROUTES_ID;
+exports.VIRTUAL_PROXY_HYDROGEN_ROUTES_ID = VIRTUAL_PREFIX + PROXY_PREFIX + HYDROGEN_ROUTES_ID;
+const VIRTUAL_STREAM_ID = 'virtual__stream';
+exports.default = (pluginOptions) => {
+    let config;
+    let server;
+    let resolvedConfigPath;
+    return {
+        name: 'hydrogen:virtual-files',
+        configResolved(_config) {
+            config = _config;
+        },
+        configureServer(_server) {
+            server = _server;
+        },
+        resolveId(source, importer) {
+            if (source === VIRTUAL_HYDROGEN_CONFIG_ID) {
+                return findHydrogenConfigPath(config.root, pluginOptions.configPath).then((hcPath) => {
+                    resolvedConfigPath = (0, vite_1.normalizePath)(hcPath);
+                    // This direct dependency on a real file
+                    // makes HMR work for the virtual module.
+                    return this.resolve(hcPath, importer, { skipSelf: true });
+                });
+            }
+            if ([
+                exports.VIRTUAL_PROXY_HYDROGEN_CONFIG_ID,
+                exports.VIRTUAL_PROXY_HYDROGEN_ROUTES_ID,
+                VIRTUAL_HYDROGEN_ROUTES_ID,
+                VIRTUAL_ERROR_FILE,
+                VIRTUAL_STREAM_ID,
+            ].includes(source)) {
+                // Virtual modules convention
+                // https://vitejs.dev/guide/api-plugin.html#virtual-modules-convention
+                return '\0' + source;
+            }
+        },
+        load(id) {
+            if (id === '\0' + VIRTUAL_STREAM_ID) {
+                return {
+                    code: process.env.WORKER
+                        ? `export default {};`
+                        : `export {default} from 'stream';`,
+                };
+            }
+            // Likely due to a bug in Vite, but virtual modules cannot be loaded
+            // directly using ssrLoadModule from a Vite plugin. It needs to be proxied as follows:
+            if (id === '\0' + exports.VIRTUAL_PROXY_HYDROGEN_CONFIG_ID) {
+                return `import hc from '${VIRTUAL_HYDROGEN_CONFIG_ID}'; export default typeof hc === 'function' ? hc() : hc;`;
+            }
+            if (id === '\0' + exports.VIRTUAL_PROXY_HYDROGEN_ROUTES_ID) {
+                return `import hr from '${VIRTUAL_HYDROGEN_ROUTES_ID}'; export default hr;`;
+            }
+            if (id === '\0' + VIRTUAL_HYDROGEN_ROUTES_ID) {
+                return importHydrogenConfig().then((hc) => {
+                    let routesPath = (typeof hc.routes === 'string' ? hc.routes : hc.routes?.files) ??
+                        '/src/routes';
+                    if (routesPath.startsWith('./')) {
+                        routesPath = routesPath.slice(1);
+                    }
+                    if (!routesPath.includes('*')) {
+                        if (!routesPath.endsWith('/')) {
+                            routesPath += '/';
+                        }
+                        routesPath += '**/*.server.[jt](s|sx)';
+                    }
+                    const [dirPrefix] = routesPath.split('/*');
+                    const importGlob = vite_js_1.isVite3
+                        ? `import.meta.glob('${routesPath}', {eager: true})`
+                        : `import.meta.globEager('${routesPath}')`;
+                    let code = `export default {\n  dirPrefix: '${dirPrefix}',\n  basePath: '${hc.routes?.basePath ?? ''}',\n  files: ${importGlob}\n};`;
+                    if (config.command === 'serve') {
+                        // Add dependency on Hydrogen config for HMR
+                        code += `\nimport '${VIRTUAL_HYDROGEN_CONFIG_ID}';`;
+                    }
+                    return { code };
+                });
+            }
+            if (id === '\0' + VIRTUAL_ERROR_FILE) {
+                return importHydrogenConfig().then((hc) => {
+                    const errorPath = hc.serverErrorPage ?? '/src/Error.{jsx,tsx}';
+                    const code = `const errorPage = import.meta.glob("${errorPath}");\n export default Object.values(errorPage)[0];`;
+                    return { code };
+                });
+            }
+        },
+        transform(code, id) {
+            if (id === resolvedConfigPath) {
+                const s = new magic_string_1.default(code);
+                // Wrap in function to avoid evaluating `Oxygen.env`
+                // in the config until we have polyfilled it properly.
+                s.replace(/export\s+default\s+(\w+)\s*\(/g, (all, m1) => all.replace(m1, `() => ${m1}`));
+                return {
+                    code: s.toString(),
+                    map: s.generateMap({ file: id, source: id }),
+                };
+            }
+        },
+    };
+    async function importHydrogenConfig() {
+        if (server) {
+            const loaded = await server.ssrLoadModule(exports.VIRTUAL_PROXY_HYDROGEN_CONFIG_ID);
+            return loaded.default;
+        }
+        const { loaded } = await (0, viteception_js_1.viteception)([exports.VIRTUAL_PROXY_HYDROGEN_CONFIG_ID], {
+            root: config.root,
+        });
+        return loaded[0].default;
+    }
+};
+async function findHydrogenConfigPath(root, userProvidedPath) {
+    let configPath = userProvidedPath;
+    if (!configPath) {
+        // Find the config file in the project root
+        const files = await fs_1.promises.readdir(root);
+        configPath = files.find((file) => /^hydrogen\.config\.[jt]s$/.test(file));
+    }
+    if (configPath) {
+        configPath = (0, vite_1.normalizePath)(configPath);
+        if (!configPath.startsWith('/'))
+            configPath = path_1.default.resolve(root, configPath);
+    }
+    return (configPath ||
+        require.resolve(
+        // eslint-disable-next-line node/no-missing-require
+        '@shopify/hydrogen/utilities/empty-hydrogen-config'));
+}
diff --git a/dist/dist/node/framework/plugins/vite-plugin-platform-entry.d.ts b/dist/dist/node/framework/plugins/vite-plugin-platform-entry.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7f9c594a7efd9463aed4f4cfad8321d19b859b6a
--- /dev/null
+++ b/dist/dist/node/framework/plugins/vite-plugin-platform-entry.d.ts
@@ -0,0 +1,3 @@
+import { Plugin } from 'vite';
+declare const _default: () => Plugin;
+export default _default;
diff --git a/dist/dist/node/framework/plugins/vite-plugin-platform-entry.js b/dist/dist/node/framework/plugins/vite-plugin-platform-entry.js
new file mode 100644
index 0000000000000000000000000000000000000000..3a62321ae2d9df854b02406054ba2410e8d1b8a8
--- /dev/null
+++ b/dist/dist/node/framework/plugins/vite-plugin-platform-entry.js
@@ -0,0 +1,117 @@
+"use strict";
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+const vite_1 = require("vite");
+const vite_plugin_hydrogen_middleware_js_1 = require("./vite-plugin-hydrogen-middleware.js");
+const magic_string_1 = __importDefault(require("magic-string"));
+const path_1 = __importDefault(require("path"));
+const fs_1 = __importDefault(require("fs"));
+const fast_glob_1 = __importDefault(require("fast-glob"));
+const vite_js_1 = require("../../utilities/vite.js");
+const SSR_BUNDLE_NAME = 'index.js';
+// Keep this in the outer scope to share it
+// across client <> server builds.
+let clientBuildPath;
+/* -- Plugin notes:
+ * This plugin simplifies the way a platform entry file imports user files. This is
+ * needed to write generic integrations with different platform providers.
+ *
+ * Instead of using relative paths:
+ * `import handleRequest from '../../<arbitrary_path>/src/App.server';`
+ * `import indexTemplate from '../../<arbitrary_path>/dist/client/index.html?raw';`
+ *
+ *  It allows importing from a known static path which dynamically resolves the user files:
+ * `import {handleRequest, indexTemplate} from '@shopify/hydrogen/platforms';`
+ *
+ */
+exports.default = () => {
+    let config;
+    let isESM;
+    return {
+        name: 'hydrogen:platform-entry',
+        enforce: 'pre',
+        configResolved(_config) {
+            config = _config;
+            if (config.build.ssr) {
+                const { output = {} } = config.build.rollupOptions || {};
+                const { format = vite_js_1.isVite3 ? 'es' : '' } = (Array.isArray(output) ? output[0] : output) || {};
+                isESM = Boolean(process.env.WORKER) || ['es', 'esm'].includes(format);
+            }
+        },
+        resolveId(source, importer) {
+            if ((0, vite_1.normalizePath)(source).includes('/hydrogen/platforms/')) {
+                const hydrogenPath = path_1.default.dirname(require.resolve('@shopify/hydrogen/package.json'));
+                const platformEntryName = source.split(path_1.default.sep).pop() || '';
+                const platformEntryPath = path_1.default.resolve(hydrogenPath, 'dist', 'esnext', 'platforms', platformEntryName);
+                return this.resolve(platformEntryPath, importer, {
+                    skipSelf: true,
+                });
+            }
+            return null;
+        },
+        async transform(code, id, options) {
+            if (config.command === 'build' &&
+                options?.ssr &&
+                /\/hydrogen\/.+platforms\/virtual\./.test((0, vite_1.normalizePath)(id))) {
+                const ms = new magic_string_1.default(code);
+                ms.replace('__HYDROGEN_ENTRY__', vite_plugin_hydrogen_middleware_js_1.HYDROGEN_DEFAULT_SERVER_ENTRY);
+                if (!clientBuildPath) {
+                    // Default value
+                    clientBuildPath = (0, vite_1.normalizePath)(path_1.default.resolve(config.root, config.build.outDir, '..', 'client'));
+                }
+                ms.replace('__HYDROGEN_HTML_TEMPLATE__', (0, vite_1.normalizePath)(path_1.default.resolve(clientBuildPath, 'index.html')));
+                ms.replace('__HYDROGEN_RELATIVE_CLIENT_BUILD__', (0, vite_1.normalizePath)(path_1.default.relative((0, vite_1.normalizePath)(path_1.default.resolve(config.root, config.build.outDir)), clientBuildPath)));
+                const files = clientBuildPath
+                    ? (await (0, fast_glob_1.default)('**/*', {
+                        cwd: clientBuildPath,
+                        ignore: ['**/index.html', `**/${config.build.assetsDir}/**`],
+                    })).map((file) => '/' + file)
+                    : [];
+                ms.replace("\\['__HYDROGEN_ASSETS__'\\]", JSON.stringify(files));
+                ms.replace('__HYDROGEN_ASSETS_DIR__', config.build.assetsDir);
+                ms.replace('__HYDROGEN_ASSETS_BASE_URL__', (process.env.HYDROGEN_ASSET_BASE_URL || '').replace(/\/$/, ''));
+                // Remove the poison pill
+                ms.replace('throw', '//');
+                return {
+                    code: ms.toString(),
+                    map: ms.generateMap({ file: id, source: id }),
+                };
+            }
+        },
+        buildEnd(err) {
+            if (!err && !config.build.ssr && config.command === 'build') {
+                // Save outDir from client build in the outer scope in order
+                // to read it during the server build. The CLI runs Vite in
+                // the same process so the scope is shared across builds.
+                clientBuildPath = (0, vite_1.normalizePath)(path_1.default.resolve(config.root, config.build.outDir));
+            }
+        },
+        generateBundle(options, bundle) {
+            if (config.build.ssr) {
+                const [key, value] = Object.entries(bundle).find(([, value]) => value.type === 'chunk' && value.isEntry);
+                delete bundle[key];
+                value.fileName = SSR_BUNDLE_NAME;
+                bundle[SSR_BUNDLE_NAME] = value;
+                // This ensures the file has a proper
+                // default export instead of exporting an
+                // object containing a 'default' property.
+                if (value.type === 'chunk' && !isESM) {
+                    value.code += `\nmodule.exports = exports.default || exports;`;
+                }
+            }
+        },
+        writeBundle(options) {
+            if (config.build.ssr && options.dir) {
+                const mainFile = `./${SSR_BUNDLE_NAME}`;
+                const packageJson = {
+                    type: isESM ? 'module' : 'commonjs',
+                    main: mainFile,
+                    exports: { '.': mainFile, [mainFile]: mainFile },
+                };
+                fs_1.default.writeFileSync(path_1.default.join(options.dir, 'package.json'), JSON.stringify(packageJson, null, 2), 'utf-8');
+            }
+        },
+    };
+};
diff --git a/dist/dist/node/framework/plugins/vite-plugin-ssr-interop.d.ts b/dist/dist/node/framework/plugins/vite-plugin-ssr-interop.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..708d7b02ccf399b3059c199e4662d7ec69934559
--- /dev/null
+++ b/dist/dist/node/framework/plugins/vite-plugin-ssr-interop.d.ts
@@ -0,0 +1,3 @@
+import type { Plugin } from 'vite';
+declare const _default: () => Plugin;
+export default _default;
diff --git a/dist/dist/node/framework/plugins/vite-plugin-ssr-interop.js b/dist/dist/node/framework/plugins/vite-plugin-ssr-interop.js
new file mode 100644
index 0000000000000000000000000000000000000000..08a77911a8e0af533f4267c5e54fa113434e177f
--- /dev/null
+++ b/dist/dist/node/framework/plugins/vite-plugin-ssr-interop.js
@@ -0,0 +1,22 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+/* -- Plugin notes:
+ * This plugin makes sure we don't leak server logic to the browser when importing
+ * the `useEnvContext` utility.
+ */
+exports.default = () => {
+    return {
+        name: 'hydrogen:ssr-interop',
+        enforce: 'pre',
+        transform(code, id, options = {}) {
+            if (options.ssr && id.includes('foundation/ssr-interop')) {
+                return {
+                    code: code
+                        .replace(/(\s*META_ENV_SSR\s*=\s*)false/, '$1import.meta.env.SSR')
+                        .replace(/\/\/@SSR\s*/g, ''),
+                    map: { mappings: '' },
+                };
+            }
+        },
+    };
+};
diff --git a/dist/dist/node/framework/types.d.ts b/dist/dist/node/framework/types.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e243fcae576ee86e0d09a4b840644f82d3dcb402
--- /dev/null
+++ b/dist/dist/node/framework/types.d.ts
@@ -0,0 +1,20 @@
+export interface HydrogenVitePluginOptions {
+    devCache?: boolean;
+    purgeQueryCacheOnBuild?: boolean;
+    configPath?: string;
+    optimizeBoundaries?: boolean | 'build';
+    assetHashVersion?: string;
+    /**
+     * Experimental features
+     */
+    experimental?: {
+        /**
+         * CSS compatibility with React Server Components.
+         * - `global` inlines all the styles in the DOM and works for all types of CSS.
+         * - `modules-only` inlines the styles in RSC responses and only works for CSS Modules.
+         * @defaultValue `modules-only`
+         * @experimental
+         */
+        css: 'global' | 'modules-only';
+    };
+}
diff --git a/dist/dist/node/framework/types.js b/dist/dist/node/framework/types.js
new file mode 100644
index 0000000000000000000000000000000000000000..c8ad2e549bdc6801e0d1c80b0308d4b9bd4985ce
--- /dev/null
+++ b/dist/dist/node/framework/types.js
@@ -0,0 +1,2 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
diff --git a/dist/dist/node/framework/viteception.d.ts b/dist/dist/node/framework/viteception.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8f00f7f7045b5c5fa532fd37fa67fb07971b0fb1
--- /dev/null
+++ b/dist/dist/node/framework/viteception.d.ts
@@ -0,0 +1,5 @@
+import { InlineConfig } from 'vite';
+export declare function viteception(paths: string[], options?: InlineConfig): Promise<{
+    server: import("vite").ViteDevServer;
+    loaded: Record<string, any>[];
+}>;
diff --git a/dist/dist/node/framework/viteception.js b/dist/dist/node/framework/viteception.js
new file mode 100644
index 0000000000000000000000000000000000000000..9f36a1a666b932132ef47df531b32eba6bb26536
--- /dev/null
+++ b/dist/dist/node/framework/viteception.js
@@ -0,0 +1,26 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.viteception = void 0;
+const vite_1 = require("vite");
+const vite_js_1 = require("../utilities/vite.js");
+async function viteception(paths, options) {
+    const isWorker = process.env.WORKER;
+    delete process.env.WORKER;
+    const server = await (0, vite_1.createServer)({
+        clearScreen: false,
+        server: {
+            middlewareMode: vite_js_1.isVite3 ? true : 'ssr',
+            hmr: false,
+        },
+        // @ts-ignore
+        appType: 'custom',
+        ...options,
+    });
+    if (isWorker) {
+        process.env.WORKER = isWorker;
+    }
+    const loaded = await Promise.all(paths.map((path) => server.ssrLoadModule(path)));
+    await server.close();
+    return { server, loaded };
+}
+exports.viteception = viteception;
diff --git a/dist/dist/node/shared-types.d.ts b/dist/dist/node/shared-types.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d25b7aed00ca4126e25a75d453ecfdbb23ead712
--- /dev/null
+++ b/dist/dist/node/shared-types.d.ts
@@ -0,0 +1,31 @@
+/// <reference types="node" />
+import type { IncomingMessage, ServerResponse } from 'http';
+import type { SessionStorageAdapter } from './foundation/session/session-types';
+export interface RuntimeContext {
+    waitUntil: (fn: Promise<any>) => void;
+}
+export interface RequestHandlerOptions {
+    indexTemplate: string | ((url: string) => Promise<string | {
+        default: string;
+    }>);
+    cache?: Cache;
+    streamableResponse?: ServerResponse;
+    dev?: boolean;
+    context?: RuntimeContext;
+    nonce?: string;
+    buyerIpHeader?: string;
+    sessionApi?: SessionStorageAdapter;
+    headers?: Headers;
+}
+export interface RequestHandler {
+    (request: Request | IncomingMessage, options: RequestHandlerOptions): Promise<Response | undefined>;
+}
+export declare type ShopifyConfig = {
+    defaultLanguageCode?: string;
+    defaultCountryCode?: string;
+    storeDomain: string;
+    storefrontToken: string;
+    storefrontApiVersion: string;
+    privateStorefrontToken?: string;
+    storefrontId?: string;
+};
diff --git a/dist/dist/node/shared-types.js b/dist/dist/node/shared-types.js
new file mode 100644
index 0000000000000000000000000000000000000000..635684cfe20cc1816262ac0c09802b0f26400876
--- /dev/null
+++ b/dist/dist/node/shared-types.js
@@ -0,0 +1,5 @@
+"use strict";
+// These types are shared in ESM and CJS builds.
+// Do not import anything from subfolders here to avoid
+// affecting the files generated in the CJS build.
+Object.defineProperty(exports, "__esModule", { value: true });
diff --git a/dist/dist/node/utilities/vite.d.ts b/dist/dist/node/utilities/vite.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bb2e7cf61a03c7fe127557ef1da780414cc18c35
--- /dev/null
+++ b/dist/dist/node/utilities/vite.d.ts
@@ -0,0 +1 @@
+export declare const isVite3: any;
diff --git a/dist/dist/node/utilities/vite.js b/dist/dist/node/utilities/vite.js
new file mode 100644
index 0000000000000000000000000000000000000000..0b2c496312af355ce60ad0c71445304c9d46e402
--- /dev/null
+++ b/dist/dist/node/utilities/vite.js
@@ -0,0 +1,30 @@
+"use strict";
+var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    var desc = Object.getOwnPropertyDescriptor(m, k);
+    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
+      desc = { enumerable: true, get: function() { return m[k]; } };
+    }
+    Object.defineProperty(o, k2, desc);
+}) : (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    o[k2] = m[k];
+}));
+var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
+    Object.defineProperty(o, "default", { enumerable: true, value: v });
+}) : function(o, v) {
+    o["default"] = v;
+});
+var __importStar = (this && this.__importStar) || function (mod) {
+    if (mod && mod.__esModule) return mod;
+    var result = {};
+    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
+    __setModuleDefault(result, mod);
+    return result;
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.isVite3 = void 0;
+// `version` is only exported in Vite 3
+const vite = __importStar(require("vite"));
+// @ts-ignore
+exports.isVite3 = vite.version?.startsWith('3.');
diff --git a/dist/dist/node/utilities/web-api-polyfill.d.ts b/dist/dist/node/utilities/web-api-polyfill.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cb0ff5c3b541f646105198ee23ac0fc3d805023e
--- /dev/null
+++ b/dist/dist/node/utilities/web-api-polyfill.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/dist/dist/node/utilities/web-api-polyfill.js b/dist/dist/node/utilities/web-api-polyfill.js
new file mode 100644
index 0000000000000000000000000000000000000000..7330087d84f0c5f4c2e7f1ec58fc90b19581e768
--- /dev/null
+++ b/dist/dist/node/utilities/web-api-polyfill.js
@@ -0,0 +1,53 @@
+"use strict";
+var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    var desc = Object.getOwnPropertyDescriptor(m, k);
+    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
+      desc = { enumerable: true, get: function() { return m[k]; } };
+    }
+    Object.defineProperty(o, k2, desc);
+}) : (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    o[k2] = m[k];
+}));
+var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
+    Object.defineProperty(o, "default", { enumerable: true, value: v });
+}) : function(o, v) {
+    o["default"] = v;
+});
+var __importStar = (this && this.__importStar) || function (mod) {
+    if (mod && mod.__esModule) return mod;
+    var result = {};
+    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
+    __setModuleDefault(result, mod);
+    return result;
+};
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+const node_fetch_1 = __importStar(require("node-fetch"));
+const abort_controller_1 = __importDefault(require("abort-controller"));
+const ponyfill_1 = require("web-streams-polyfill/ponyfill");
+const undici_1 = require("undici");
+if (!globalThis.fetch) {
+    Object.assign(globalThis, {
+        fetch: node_fetch_1.default,
+        Request: node_fetch_1.Request,
+        Response: node_fetch_1.Response,
+        Headers: node_fetch_1.Headers,
+        AbortController: abort_controller_1.default,
+    });
+}
+if (!globalThis.FormData) {
+    Object.assign(globalThis, {
+        FormData: undici_1.FormData,
+    });
+}
+if (!globalThis.ReadableStream) {
+    Object.assign(globalThis, {
+        ReadableStream: ponyfill_1.ReadableStream,
+        WritableStream: ponyfill_1.WritableStream,
+        TransformStream: ponyfill_1.TransformStream,
+    });
+}
diff --git a/package.json b/package.json
index 74dab67f61efbd8147e129fb7541a924ad72a3ec..a5613db50448dc285bd1068d4b9f2546e3281d8c 100644
--- a/package.json
+++ b/package.json
@@ -103,6 +103,7 @@
     "babel-loader": "^8.2.2",
     "cpy-cli": "^3.1.0",
     "eslint-plugin-import": "^2.26.0",
+    "faker": "^5.5.3",
     "happy-dom": "^6.0.4",
     "mkdirp": "^1.0.4",
     "npm-run-all": "^4.1.5",
diff --git a/vendor/vendor/react-server-dom-vite/LICENSE b/vendor/vendor/react-server-dom-vite/LICENSE
new file mode 100644
index 0000000000000000000000000000000000000000..b96dcb0480a0b0be0727976e5202a1e7b23edc3f
--- /dev/null
+++ b/vendor/vendor/react-server-dom-vite/LICENSE
@@ -0,0 +1,21 @@
+MIT License
+
+Copyright (c) Facebook, Inc. and its affiliates.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
diff --git a/vendor/vendor/react-server-dom-vite/README.md b/vendor/vendor/react-server-dom-vite/README.md
new file mode 100644
index 0000000000000000000000000000000000000000..fd0771f4d7b41e10069a64cae241a3d856587392
--- /dev/null
+++ b/vendor/vendor/react-server-dom-vite/README.md
@@ -0,0 +1,5 @@
+# react-server-dom-vite
+
+Experimental React Flight bindings for DOM using Vite.
+
+**Use it at your own risk.**
diff --git a/vendor/vendor/react-server-dom-vite/cjs/react-server-dom-vite-plugin.js b/vendor/vendor/react-server-dom-vite/cjs/react-server-dom-vite-plugin.js
new file mode 100644
index 0000000000000000000000000000000000000000..497db42df6b3a2e9e2b5be2ffb94e22605ac66b2
--- /dev/null
+++ b/vendor/vendor/react-server-dom-vite/cjs/react-server-dom-vite-plugin.js
@@ -0,0 +1,632 @@
+/**
+ * @license React
+ * react-server-dom-vite-plugin.js
+ *
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+'use strict';
+
+'use strict';
+
+var esModuleLexer = require('es-module-lexer');
+var MagicString = require('magic-string');
+var fs = require('fs');
+var path = require('path');
+var vite = require('vite');
+
+function _unsupportedIterableToArray(o, minLen) {
+  if (!o) return;
+  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
+  var n = Object.prototype.toString.call(o).slice(8, -1);
+  if (n === "Object" && o.constructor) n = o.constructor.name;
+  if (n === "Map" || n === "Set") return Array.from(o);
+  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
+}
+
+function _arrayLikeToArray(arr, len) {
+  if (len == null || len > arr.length) len = arr.length;
+
+  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
+
+  return arr2;
+}
+
+function _createForOfIteratorHelper(o, allowArrayLike) {
+  var it;
+
+  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
+    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
+      if (it) o = it;
+      var i = 0;
+
+      var F = function () {};
+
+      return {
+        s: F,
+        n: function () {
+          if (i >= o.length) return {
+            done: true
+          };
+          return {
+            done: false,
+            value: o[i++]
+          };
+        },
+        e: function (e) {
+          throw e;
+        },
+        f: F
+      };
+    }
+
+    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
+  }
+
+  var normalCompletion = true,
+      didErr = false,
+      err;
+  return {
+    s: function () {
+      it = o[Symbol.iterator]();
+    },
+    n: function () {
+      var step = it.next();
+      normalCompletion = step.done;
+      return step;
+    },
+    e: function (e) {
+      didErr = true;
+      err = e;
+    },
+    f: function () {
+      try {
+        if (!normalCompletion && it.return != null) it.return();
+      } finally {
+        if (didErr) throw err;
+      }
+    }
+  };
+}
+
+var assign = Object.assign;
+
+var normalizePath = vite.normalizePath,
+    transformWithEsbuild = vite.transformWithEsbuild,
+    createServer = vite.createServer;
+var isVite3 = vite.version && vite.version.startsWith('3.');
+var rscViteFileRE = /\/react-server-dom-vite.js/;
+var noProxyRE = /[&?]no-proxy($|&)/;
+
+var isClientComponent = function (id) {
+  return /\.client\.[jt]sx?($|\?)/.test(id);
+};
+
+function ReactFlightVitePlugin() {
+  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
+      serverBuildEntries = _ref.serverBuildEntries,
+      _ref$optimizeBoundari = _ref.optimizeBoundaries,
+      optimizeBoundaries = _ref$optimizeBoundari === void 0 ? 'build' : _ref$optimizeBoundari,
+      _ref$isServerComponen = _ref.isServerComponentImporterAllowed,
+      isServerComponentImporterAllowed = _ref$isServerComponen === void 0 ? function (importer) {
+    return false;
+  } : _ref$isServerComponen;
+
+  var config;
+  var server;
+  var resolveAlias;
+  var globImporterPath;
+  var allClientBoundaries = new Set();
+
+  function invalidateGlobImporter() {
+    if (globImporterPath && server) {
+      server.watcher.emit('change', globImporterPath);
+    }
+  }
+
+  return {
+    name: 'vite-plugin-react-server-components',
+    enforce: 'pre',
+    buildStart: function () {
+      // Let other plugins differentiate between pure SSR and RSC builds
+      if (config?.build?.ssr) process.env.VITE_RSC_BUILD = 'true';
+    },
+    buildEnd: function () {
+      if (config?.build?.ssr) delete process.env.VITE_RSC_BUILD;
+    },
+    configureServer: function (_server) {
+      server = _server;
+      var seenModules = {};
+      server.ws.on('rsc:cc404', function (data) {
+        if (!seenModules[data.id]) {
+          seenModules[data.id] = true;
+          invalidateGlobImporter();
+        }
+      });
+    },
+    configResolved: async function (_config) {
+      await esModuleLexer.init;
+      config = _config;
+      var aliasPlugin = config.plugins.find(function (plugin) {
+        return plugin.name === 'alias';
+      });
+
+      if (aliasPlugin) {
+        resolveAlias = aliasPlugin.resolveId.bind({
+          // Mock Rollup instance
+          resolve: function (id) {
+            return {
+              then: function () {
+                return id ? {
+                  id: id
+                } : null;
+              }
+            };
+          }
+        });
+      } // By pushing this plugin at the end of the existing array,
+      // we enforce running it *after* Vite resolves import.meta.glob.
+
+
+      config.plugins.push(hashImportsPlugin);
+    },
+    resolveId: function (source, importer) {
+      if (!importer) return null;
+
+      if (noProxyRE.test(source)) {
+        var _source$split = source.split('?'),
+            id = _source$split[0],
+            query = _source$split[1];
+
+        return this.resolve(id, importer, {
+          skipSelf: true
+        }).then(function (result) {
+          if (!result) return null;
+          return assign({}, result, {
+            id: result.id + (query ? "?" + query : ''),
+            moduleSideEffects: false
+          });
+        });
+      }
+      /**
+       * Throw errors when non-Server Components try to load Server Components.
+       */
+
+
+      if (/\.server(\.[jt]sx?)?$/.test(source) && !(/(\.server\.[jt]sx?|index\.html)$/.test(importer) || isServerComponentImporterAllowed(importer, source))) {
+        throw new Error("Cannot import " + source + " from \"" + importer + "\". " + 'By react-server convention, .server.js files can only be imported from other .server.js files. ' + 'That way nobody accidentally sends these to the client by indirectly importing it.');
+      }
+    },
+    load: function (id) {
+      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
+      if (!options.ssr || !isClientComponent(id) || noProxyRE.test(id)) return;
+
+      if (server) {
+        var mod = server.moduleGraph.idToModuleMap.get(id.replace('/@fs', ''));
+
+        if (mod && mod.importers) {
+          if (Array.from(mod.importers).every(function (impMod) {
+            return noProxyRE.test(impMod.id);
+          })) {
+            // This module is only imported from client components
+            // so we don't need to create a module reference
+            return;
+          }
+        } // Mark module as a client component.
+
+
+        var moduleNode = server.moduleGraph.getModuleById(id);
+        if (!moduleNode.meta) moduleNode.meta = {};
+
+        if (!moduleNode.meta.isClientComponent) {
+          moduleNode.meta.isClientComponent = true; // Invalidate glob importer file to account for the
+          // newly discovered client component.
+
+          invalidateGlobImporter();
+        }
+      }
+
+      return proxyClientComponent(id.split('?')[0]);
+    },
+    transform: function (code, id) {
+      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
+
+      // Add more information for this module in the graph.
+      // It will be used later to discover client boundaries.
+      if (server && options.ssr && /\.[jt]sx?($|\?)/.test(id)) {
+        augmentModuleGraph(server.moduleGraph, id, code, config.root, resolveAlias);
+      }
+      /**
+       * In order to allow dynamic component imports from RSC, we use Vite's import.meta.glob.
+       * This hook replaces the glob placeholders with resolved paths to all client components.
+       *
+       * NOTE: Glob import paths MUST be relative to the importer file in
+       * order to get the `?v=xxx` querystring from Vite added to the import URL.
+       * If the paths are relative to the root instead, Vite won't add the querystring
+       * and we will have duplicated files in the browser (with duplicated contexts, etc).
+       */
+
+
+      if (rscViteFileRE.test(id)) {
+        var INJECTING_RE = /\{\s*__INJECTED_CLIENT_IMPORTERS__[:\s]*null[,\s]*\}\s*;/;
+        var s = new MagicString(code);
+        id = id.split('?')[0];
+
+        if (options && options.ssr) {
+          // In SSR, directly use components already discovered by RSC
+          // instead of globs to avoid bundling unused components.
+          s.replace(INJECTING_RE, 'globalThis.__COMPONENT_INDEX');
+          return {
+            code: s.toString(),
+            map: s.generateMap({
+              file: id,
+              source: id
+            })
+          };
+        }
+
+        var injectGlobs = function (clientComponents) {
+          var importerPath = path.dirname(id);
+          var importers = clientComponents.map(function (absolutePath) {
+            return normalizePath(path.relative(importerPath, absolutePath));
+          });
+          var injectedGlobs = "Object.assign(Object.create(null), " + importers.map(function (glob) {
+            return (// Mark the globs to modify the result after Vite resolves them.
+              "\n/* HASH_BEGIN */ " + ("import.meta.glob('" + normalizePath(glob) + "') /* HASH_END */")
+            );
+          }).join(', ') + ");";
+          s.replace(INJECTING_RE, injectedGlobs);
+          return {
+            code: s.toString(),
+            map: s.generateMap({
+              file: id,
+              source: id
+            })
+          };
+        };
+
+        if (config.command === 'serve') {
+          globImporterPath = id; // When mixing client and server components from the same
+          // facade file, the module graph can break and miss certain
+          // import connections (bug in Vite?) due to HMR. Instead of
+          // creating a new list of discovered components from scratch,
+          // reuse the already discovered ones and simply add new ones
+          // to the list without removing anything.
+
+          findClientBoundaries(server.moduleGraph, optimizeBoundaries === true).forEach(function (boundary) {
+            return allClientBoundaries.add(boundary);
+          });
+          return injectGlobs(Array.from(allClientBoundaries));
+        }
+
+        if (!serverBuildEntries) {
+          throw new Error('[react-server-dom-vite] Parameter serverBuildEntries is required for client build');
+        }
+
+        return findClientBoundariesForClientBuild(serverBuildEntries, optimizeBoundaries !== false, config.root).then(injectGlobs);
+      }
+    },
+    handleHotUpdate: function (_ref2) {
+      var modules = _ref2.modules;
+
+      if (modules.some(function (mod) {
+        return mod.meta && mod.meta.isClientComponent;
+      })) {
+        return modules.filter(function (mod) {
+          return !mod.meta || !mod.meta.ssr;
+        });
+      }
+
+      return modules;
+    }
+  };
+}
+
+var btoa = function (hash) {
+  return (// eslint-disable-next-line react-internal/safe-string-coercion
+    Buffer.from(String(hash), 'binary').toString('base64')
+  );
+}; // Quick, lossy hash function: https://stackoverflow.com/a/8831937/4468962
+// Prevents leaking path information in the browser, and minifies RSC responses.
+
+
+function hashCode(value) {
+  var hash = 0;
+
+  for (var i = 0; i < value.length; i++) {
+    var char = value.charCodeAt(i);
+    hash = (hash << 5) - hash + char;
+    hash &= hash;
+  }
+
+  return btoa(hash).replace(/=+/, '');
+}
+
+var getComponentFilename = function (filepath) {
+  return filepath.split('/').pop().split('.').shift();
+};
+
+var getComponentId = function (filepath) {
+  return getComponentFilename(filepath) + "-" + hashCode(filepath);
+};
+async function proxyClientComponent(filepath, src) {
+  var DEFAULT_EXPORT = 'default'; // Modify the import ID to avoid infinite wraps
+
+  var importFrom = filepath + "?no-proxy";
+  await esModuleLexer.init;
+
+  if (!src) {
+    src = await fs.promises.readFile(filepath, 'utf-8');
+  }
+
+  var _await$transformWithE = await transformWithEsbuild(src, filepath),
+      code = _await$transformWithE.code;
+
+  var _parse = esModuleLexer.parse(code),
+      exportStatements = _parse[1];
+
+  var proxyCode = "import {wrapInClientProxy} from 'react-server-dom-vite/client-proxy';\n" + ("import * as allImports from '" + importFrom + "';\n\n"); // Wrap components in Client Proxy
+
+  exportStatements.forEach(function (key) {
+    var isDefault = key === DEFAULT_EXPORT;
+    var componentName = isDefault ? getComponentFilename(filepath) : key;
+    proxyCode += "export " + (isDefault ? DEFAULT_EXPORT : "const " + componentName + " =") + " /* @__PURE__ */wrapInClientProxy({ name: '" + componentName + "', id: '" + getComponentId(filepath) + "', value: allImports['" + key + "'], isDefault: " + // eslint-disable-next-line react-internal/safe-string-coercion
+    String(isDefault) + " });\n";
+  });
+  return {
+    code: proxyCode,
+    moduleSideEffects: false
+  };
+}
+
+function findClientBoundaries(moduleGraph) {
+  var optimizeBoundaries = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
+  var clientBoundaries = []; // eslint-disable-next-line no-for-of-loops/no-for-of-loops
+
+  var _iterator = _createForOfIteratorHelper(moduleGraph.fileToModulesMap.values()),
+      _step;
+
+  try {
+    for (_iterator.s(); !(_step = _iterator.n()).done;) {
+      var set = _step.value;
+      var clientModule = Array.from(set).find(function (moduleNode) {
+        return moduleNode.meta && moduleNode.meta.isClientComponent;
+      });
+
+      if (clientModule && (!optimizeBoundaries || isDirectImportInServer(clientModule))) {
+        clientBoundaries.push(clientModule.file);
+      }
+    }
+  } catch (err) {
+    _iterator.e(err);
+  } finally {
+    _iterator.f();
+  }
+
+  return clientBoundaries;
+}
+
+async function findClientBoundariesForClientBuild(serverEntries, optimizeBoundaries, root) {
+  // Viteception
+  var server = await createServer({
+    root: root,
+    clearScreen: false,
+    server: {
+      middlewareMode: isVite3 ? true : 'ssr',
+      hmr: false
+    },
+    appType: 'custom'
+  });
+
+  try {
+    // Load server entries to discover client components
+    await Promise.all(serverEntries.map(server.ssrLoadModule));
+  } catch (error) {
+    error.message = 'Could not load server build entries: ' + error.message;
+    throw error;
+  }
+
+  await server.close();
+  return findClientBoundaries(server.moduleGraph, optimizeBoundaries);
+}
+
+var hashImportsPlugin = {
+  name: 'vite-plugin-react-server-components-hash-imports',
+  enforce: 'post',
+  transform: function (code, id) {
+    // Turn relative import paths to lossy hashes
+    if (rscViteFileRE.test(id)) {
+      var s = new MagicString(code);
+      s.replace(/\/\*\s*HASH_BEGIN\s*\*\/\s*([^]+?)\/\*\s*HASH_END\s*\*\//gm, function (_, imports) {
+        return imports.trim().replace(/"([^"]+?)":/gm, function (all, relativePath) {
+          if (relativePath === '__VITE_PRELOAD__') return all;
+          var absolutePath = path.resolve(path.dirname(id.split('?')[0]), relativePath);
+          return "\"" + getComponentId(normalizePath(absolutePath)) + "\":";
+        });
+      });
+      return {
+        code: s.toString(),
+        map: s.generateMap({
+          file: id,
+          source: id
+        })
+      };
+    }
+  }
+};
+
+/**
+ * A client module should behave as a client boundary
+ * if it is imported by the server before encountering
+ * another boundary in the process.
+ * This traverses the module graph upwards to find non client
+ * components that import the `originalMod`.
+ *
+ * The `accModInfo` represents the exported members from the
+ * `originalMod` but renamed accordingly to all the intermediate/facade
+ * files in the import chain from the `originalMod` to every parent importer.
+ */
+function isDirectImportInServer(originalMod, currentMod, accModInfo) {
+  // TODO: this should use recursion in any module that exports
+  // the original one, not only in full facade files.
+  if (!currentMod || (currentMod.meta || {}).isFacade) {
+    if (!accModInfo && originalMod.meta && originalMod.meta.namedExports) {
+      // First iteration in the recursion, initialize the
+      // acumulator with data from the original module.
+      accModInfo = {
+        file: originalMod.file,
+        exports: originalMod.meta.namedExports
+      };
+    }
+
+    if (currentMod && accModInfo) {
+      // Update accumulator in subsequent iterations with
+      // whatever the current module is re-exporting.
+      var lastModExports = accModInfo.exports;
+      var lastModImports = currentMod.meta.imports.filter(function (importMeta) {
+        return importMeta.action === 'export' && importMeta.from === accModInfo.file;
+      });
+      accModInfo = {
+        file: currentMod.file,
+        exports: []
+      };
+      lastModImports.forEach(function (mod) {
+        mod.variables.forEach(function (_ref3) {
+          var name = _ref3[0],
+              alias = _ref3[1];
+
+          if (name === '*' && !alias) {
+            var _accModInfo$exports;
+
+            (_accModInfo$exports = accModInfo.exports).push.apply(_accModInfo$exports, lastModExports);
+          } else {
+            accModInfo.exports.push(alias || name);
+          }
+        });
+      });
+    }
+
+    return Array.from((currentMod || originalMod).importers || []).some(function (importer) {
+      return (// eslint-disable-next-line no-unused-vars
+        isDirectImportInServer(originalMod, importer, accModInfo)
+      );
+    });
+  } // Not enough information: safer to assume it is
+  // imported in server to create a new boundary.
+
+
+  if (!currentMod.meta || !originalMod.meta) return true; // If current module is a client component, stop checking
+  // parents since this can be the actual boundary.
+
+  if (isClientComponent(currentMod.file)) return false; // If current module is not a client component, assume
+  // it is a server component on a shared component
+  // that will be imported in the server to be safe.
+  // However, due to the lack of tree-shaking in the dev module graph,
+  // we need to manually make sure this module is importing something from
+  // the original module before marking it as client boundary.
+
+  return currentMod.meta.imports.some(function (imp) {
+    return imp.from === accModInfo.file && (imp.variables || []).some(function (_ref4) {
+      var name = _ref4[0];
+      return accModInfo.exports.includes(name);
+    });
+  });
+}
+
+var RESOLVE_EXTENSIONS = ['', '.js', '.ts', '.jsx', '.tsx', '/index', '/index.js', '/index.ts', '/index.jsx', '/index.tsx']; // Resolve relative paths  and aliases. Examples:
+// - import {XYZ} from '~/components' => import {XYZ} from '<absolute>/src/components/index.ts'
+// - import {XYZ} from '/src/component.client' => import {XYZ} from '<absolute>/src/component.client.jsx'`
+
+function resolveModPath(modPath, dirname) {
+  var extensions = /\.[jt]sx?$/.test(modPath) ? [''] : RESOLVE_EXTENSIONS;
+
+  for (var i = 0; i < extensions.length; i++) {
+    var extension = extensions[i];
+
+    try {
+      var absolutePath = modPath.startsWith('.') ? normalizePath(path.resolve(dirname, modPath)) : modPath;
+      return normalizePath(require.resolve(absolutePath + extension));
+    } catch (error) {// Do not throw, this is likely a virtual module or another exception
+    }
+  }
+}
+
+function augmentModuleGraph(moduleGraph, id, code, root, resolveAlias) {
+  var currentModule = moduleGraph.getModuleById(id);
+  if (!currentModule) return;
+
+  var _id$split = id.split('?'),
+      source = _id$split[0];
+
+  var dirname = normalizePath(path.dirname(source));
+
+  var _parse2 = esModuleLexer.parse(code),
+      rawImports = _parse2[0],
+      namedExports = _parse2[1],
+      isFacade = _parse2[2]; // This is currently not used but it should be considered
+  // to improve the crawling in `isDirectImportInServer`.
+
+
+  var imports = [];
+  rawImports.forEach(function (_ref5) {
+    var startMod = _ref5.s,
+        endMod = _ref5.e,
+        dynamicImportIndex = _ref5.d,
+        startStatement = _ref5.ss,
+        endStatement = _ref5.se;
+    if (dynamicImportIndex !== -1) return; // Skip dynamic imports for now
+
+    var rawModPath = code.slice(startMod, endMod);
+    var modPath = rawModPath.split('?')[0];
+
+    if (resolveAlias) {
+      var resolvedAliasPath = resolveAlias(modPath, 'rsc_importer', {});
+
+      if (resolvedAliasPath && resolvedAliasPath.id) {
+        modPath = resolvedAliasPath.id;
+      }
+    }
+
+    if (modPath && modPath.startsWith('/src/')) {
+      // Vite default alias
+      modPath = normalizePath(path.join(root, modPath));
+    }
+
+    var resolvedPath = resolveModPath(modPath, dirname);
+    if (!resolvedPath) return; // Virtual modules or other exceptions
+
+    var _code$slice$split$0$s = code.slice(startStatement, endStatement).split(/\s+(from\s+)?['"]/m)[0].split(/\s+(.+)/m),
+        action = _code$slice$split$0$s[0],
+        _code$slice$split$0$s2 = _code$slice$split$0$s[1],
+        variables = _code$slice$split$0$s2 === void 0 ? '' : _code$slice$split$0$s2;
+
+    imports.push({
+      action: action,
+      // 'import' or 'export'
+      variables: variables // [['originalName', 'alias']]
+      .trim().replace(/^[^{*]/, 'default as $&').replace(/[{}]/gm, '').trim().split(/\s*,\s*/m).filter(Boolean).map(function (s) {
+        return s.split(/\s+as\s+/m);
+      }),
+      from: resolvedPath,
+      // '/absolute/path'
+      originalFrom: rawModPath // './path' or '3plib/subpath'
+
+    });
+  });
+
+  if (!currentModule.meta) {
+    currentModule.meta = {};
+  }
+
+  assign(currentModule.meta, {
+    isFacade: isFacade,
+    namedExports: namedExports,
+    imports: imports,
+    ssr: true
+  });
+}
+
+module.exports = ReactFlightVitePlugin;
diff --git a/vendor/vendor/react-server-dom-vite/cjs/react-server-dom-vite-writer.browser.development.server.js b/vendor/vendor/react-server-dom-vite/cjs/react-server-dom-vite-writer.browser.development.server.js
new file mode 100644
index 0000000000000000000000000000000000000000..33f2fd38e7c096d8817283ba604b7d439d6d5806
--- /dev/null
+++ b/vendor/vendor/react-server-dom-vite/cjs/react-server-dom-vite-writer.browser.development.server.js
@@ -0,0 +1,1884 @@
+/**
+ * @license React
+ * react-server-dom-vite-writer.browser.development.server.js
+ *
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+'use strict';
+
+if (process.env.NODE_ENV !== "production") {
+  (function() {
+'use strict';
+
+var React = require('react');
+
+var assign = Object.assign;
+
+var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
+
+function error(format) {
+  {
+    {
+      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
+        args[_key2 - 1] = arguments[_key2];
+      }
+
+      printWarning('error', format, args);
+    }
+  }
+}
+
+function printWarning(level, format, args) {
+  // When changing this logic, you might want to also
+  // update consoleWithStackDev.www.js as well.
+  {
+    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
+    var stack = ReactDebugCurrentFrame.getStackAddendum();
+
+    if (stack !== '') {
+      format += '%s';
+      args = args.concat([stack]);
+    } // eslint-disable-next-line react-internal/safe-string-coercion
+
+
+    var argsWithFormat = args.map(function (item) {
+      return String(item);
+    }); // Careful: RN currently depends on this prefix
+
+    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
+    // breaks IE9: https://github.com/facebook/react/issues/13610
+    // eslint-disable-next-line react-internal/no-production-logging
+
+    Function.prototype.apply.call(console[level], console, argsWithFormat);
+  }
+}
+
+function scheduleWork(callback) {
+  callback();
+}
+var VIEW_SIZE = 512;
+var currentView = null;
+var writtenBytes = 0;
+function beginWriting(destination) {
+  currentView = new Uint8Array(VIEW_SIZE);
+  writtenBytes = 0;
+}
+function writeChunk(destination, chunk) {
+  if (chunk.length === 0) {
+    return;
+  }
+
+  if (chunk.length > VIEW_SIZE) {
+    // this chunk may overflow a single view which implies it was not
+    // one that is cached by the streaming renderer. We will enqueu
+    // it directly and expect it is not re-used
+    if (writtenBytes > 0) {
+      destination.enqueue(new Uint8Array(currentView.buffer, 0, writtenBytes));
+      currentView = new Uint8Array(VIEW_SIZE);
+      writtenBytes = 0;
+    }
+
+    destination.enqueue(chunk);
+    return;
+  }
+
+  var bytesToWrite = chunk;
+  var allowableBytes = currentView.length - writtenBytes;
+
+  if (allowableBytes < bytesToWrite.length) {
+    // this chunk would overflow the current view. We enqueue a full view
+    // and start a new view with the remaining chunk
+    if (allowableBytes === 0) {
+      // the current view is already full, send it
+      destination.enqueue(currentView);
+    } else {
+      // fill up the current view and apply the remaining chunk bytes
+      // to a new view.
+      currentView.set(bytesToWrite.subarray(0, allowableBytes), writtenBytes); // writtenBytes += allowableBytes; // this can be skipped because we are going to immediately reset the view
+
+      destination.enqueue(currentView);
+      bytesToWrite = bytesToWrite.subarray(allowableBytes);
+    }
+
+    currentView = new Uint8Array(VIEW_SIZE);
+    writtenBytes = 0;
+  }
+
+  currentView.set(bytesToWrite, writtenBytes);
+  writtenBytes += bytesToWrite.length;
+}
+function writeChunkAndReturn(destination, chunk) {
+  writeChunk(destination, chunk); // in web streams there is no backpressure so we can alwas write more
+
+  return true;
+}
+function completeWriting(destination) {
+  if (currentView && writtenBytes > 0) {
+    destination.enqueue(new Uint8Array(currentView.buffer, 0, writtenBytes));
+    currentView = null;
+    writtenBytes = 0;
+  }
+}
+function close(destination) {
+  destination.close();
+}
+var textEncoder = new TextEncoder();
+function stringToChunk(content) {
+  return textEncoder.encode(content);
+}
+function stringToPrecomputedChunk(content) {
+  return textEncoder.encode(content);
+}
+function closeWithError(destination, error) {
+  if (typeof destination.error === 'function') {
+    // $FlowFixMe: This is an Error object or the destination accepts other types.
+    destination.error(error);
+  } else {
+    // Earlier implementations doesn't support this method. In that environment you're
+    // supposed to throw from a promise returned but we don't return a promise in our
+    // approach. We could fork this implementation but this is environment is an edge
+    // case to begin with. It's even less common to run this in an older environment.
+    // Even then, this is not where errors are supposed to happen and they get reported
+    // to a global callback in addition to this anyway. So it's fine just to close this.
+    destination.close();
+  }
+}
+
+// This file is an intermediate layer to translate between Flight
+var stringify = JSON.stringify;
+
+function serializeRowHeader(tag, id) {
+  return tag + id.toString(16) + ':';
+}
+
+function processErrorChunk(request, id, message, stack) {
+  var errorInfo = {
+    message: message,
+    stack: stack
+  };
+  var row = serializeRowHeader('E', id) + stringify(errorInfo) + '\n';
+  return stringToChunk(row);
+}
+function processModelChunk(request, id, model) {
+  var json = stringify(model, request.toJSON);
+  var row = serializeRowHeader('J', id) + json + '\n';
+  return stringToChunk(row);
+}
+function processReferenceChunk(request, id, reference) {
+  var json = stringify(reference);
+  var row = serializeRowHeader('J', id) + json + '\n';
+  return stringToChunk(row);
+}
+function processModuleChunk(request, id, moduleMetaData) {
+  var json = stringify(moduleMetaData);
+  var row = serializeRowHeader('M', id) + json + '\n';
+  return stringToChunk(row);
+}
+function processProviderChunk(request, id, contextName) {
+  var row = serializeRowHeader('P', id) + contextName + '\n';
+  return stringToChunk(row);
+}
+function processSymbolChunk(request, id, name) {
+  var json = stringify(name);
+  var row = serializeRowHeader('S', id) + json + '\n';
+  return stringToChunk(row);
+}
+
+// eslint-disable-next-line no-unused-vars
+var MODULE_TAG = Symbol.for('react.module.reference');
+function getModuleKey(reference) {
+  if (typeof reference === 'string') reference = globalThis.__STRING_REFERENCE_INDEX[reference];
+  return reference.filepath + '#' + reference.name;
+}
+function isModuleReference(reference) {
+  if (typeof reference === 'string') return !!globalThis.__STRING_REFERENCE_INDEX[reference];
+  return reference.$$typeof === MODULE_TAG;
+}
+function resolveModuleMetaData(config, moduleReference) {
+  if (typeof moduleReference === 'string') moduleReference = globalThis.__STRING_REFERENCE_INDEX[moduleReference];
+  return {
+    id: moduleReference.filepath,
+    name: moduleReference.name
+  };
+}
+
+// ATTENTION
+// When adding new symbols to this file,
+// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
+// The Symbol used to tag the ReactElement-like types.
+var REACT_ELEMENT_TYPE = Symbol.for('react.element');
+var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
+var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
+var REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');
+var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
+var REACT_MEMO_TYPE = Symbol.for('react.memo');
+var REACT_LAZY_TYPE = Symbol.for('react.lazy');
+var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for('react.default_value');
+
+// A reserved attribute.
+// It is handled by React separately and shouldn't be written to the DOM.
+var RESERVED = 0; // A simple string attribute.
+// Attributes that aren't in the filter are presumed to have this type.
+
+var STRING = 1; // A string attribute that accepts booleans in React. In HTML, these are called
+// "enumerated" attributes with "true" and "false" as possible values.
+// When true, it should be set to a "true" string.
+// When false, it should be set to a "false" string.
+
+var BOOLEANISH_STRING = 2; // A real boolean attribute.
+// When true, it should be present (set either to an empty string or its name).
+// When false, it should be omitted.
+
+var BOOLEAN = 3; // An attribute that can be used as a flag as well as with a value.
+// When true, it should be present (set either to an empty string or its name).
+// When false, it should be omitted.
+// For any other value, should be present with that value.
+
+var OVERLOADED_BOOLEAN = 4; // An attribute that must be numeric or parse as a numeric.
+// When falsy, it should be removed.
+
+var NUMERIC = 5; // An attribute that must be positive numeric or parse as a positive numeric.
+// When falsy, it should be removed.
+
+var POSITIVE_NUMERIC = 6;
+
+function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL, removeEmptyString) {
+  this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
+  this.attributeName = attributeName;
+  this.attributeNamespace = attributeNamespace;
+  this.mustUseProperty = mustUseProperty;
+  this.propertyName = name;
+  this.type = type;
+  this.sanitizeURL = sanitizeURL;
+  this.removeEmptyString = removeEmptyString;
+} // When adding attributes to this list, be sure to also add them to
+// the `possibleStandardNames` module to ensure casing and incorrect
+// name warnings.
+
+
+var properties = {}; // These props are reserved by React. They shouldn't be written to the DOM.
+
+var reservedProps = ['children', 'dangerouslySetInnerHTML', // TODO: This prevents the assignment of defaultValue to regular
+// elements (not just inputs). Now that ReactDOMInput assigns to the
+// defaultValue property -- do we need this?
+'defaultValue', 'defaultChecked', 'innerHTML', 'suppressContentEditableWarning', 'suppressHydrationWarning', 'style'];
+
+{
+  reservedProps.push('innerText', 'textContent');
+}
+
+reservedProps.forEach(function (name) {
+  properties[name] = new PropertyInfoRecord(name, RESERVED, false, // mustUseProperty
+  name, // attributeName
+  null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+}); // A few React string attributes have a different name.
+// This is a mapping from React prop names to the attribute names.
+
+[['acceptCharset', 'accept-charset'], ['className', 'class'], ['htmlFor', 'for'], ['httpEquiv', 'http-equiv']].forEach(function (_ref) {
+  var name = _ref[0],
+      attributeName = _ref[1];
+  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
+  attributeName, // attributeName
+  null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+}); // These are "enumerated" HTML attributes that accept "true" and "false".
+// In React, we let users pass `true` and `false` even though technically
+// these aren't boolean attributes (they are coerced to strings).
+
+['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(function (name) {
+  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty
+  name.toLowerCase(), // attributeName
+  null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+}); // These are "enumerated" SVG attributes that accept "true" and "false".
+// In React, we let users pass `true` and `false` even though technically
+// these aren't boolean attributes (they are coerced to strings).
+// Since these are SVG attributes, their attribute names are case-sensitive.
+
+['autoReverse', 'externalResourcesRequired', 'focusable', 'preserveAlpha'].forEach(function (name) {
+  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty
+  name, // attributeName
+  null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+}); // These are HTML boolean attributes.
+
+['allowFullScreen', 'async', // Note: there is a special case that prevents it from being written to the DOM
+// on the client side because the browsers are inconsistent. Instead we call focus().
+'autoFocus', 'autoPlay', 'controls', 'default', 'defer', 'disabled', 'disablePictureInPicture', 'disableRemotePlayback', 'formNoValidate', 'hidden', 'loop', 'noModule', 'noValidate', 'open', 'playsInline', 'readOnly', 'required', 'reversed', 'scoped', 'seamless', // Microdata
+'itemScope'].forEach(function (name) {
+  properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, // mustUseProperty
+  name.toLowerCase(), // attributeName
+  null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+}); // These are the few React props that we set as DOM properties
+// rather than attributes. These are all booleans.
+
+['checked', // Note: `option.selected` is not updated if `select.multiple` is
+// disabled with `removeAttribute`. We have special logic for handling this.
+'multiple', 'muted', 'selected' // NOTE: if you add a camelCased prop to this list,
+// you'll need to set attributeName to name.toLowerCase()
+// instead in the assignment below.
+].forEach(function (name) {
+  properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, // mustUseProperty
+  name, // attributeName
+  null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+}); // These are HTML attributes that are "overloaded booleans": they behave like
+// booleans, but can also accept a string value.
+
+['capture', 'download' // NOTE: if you add a camelCased prop to this list,
+// you'll need to set attributeName to name.toLowerCase()
+// instead in the assignment below.
+].forEach(function (name) {
+  properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, // mustUseProperty
+  name, // attributeName
+  null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+}); // These are HTML attributes that must be positive numbers.
+
+['cols', 'rows', 'size', 'span' // NOTE: if you add a camelCased prop to this list,
+// you'll need to set attributeName to name.toLowerCase()
+// instead in the assignment below.
+].forEach(function (name) {
+  properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, // mustUseProperty
+  name, // attributeName
+  null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+}); // These are HTML attributes that must be numbers.
+
+['rowSpan', 'start'].forEach(function (name) {
+  properties[name] = new PropertyInfoRecord(name, NUMERIC, false, // mustUseProperty
+  name.toLowerCase(), // attributeName
+  null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+});
+var CAMELIZE = /[\-\:]([a-z])/g;
+
+var capitalize = function (token) {
+  return token[1].toUpperCase();
+}; // This is a list of all SVG attributes that need special casing, namespacing,
+// or boolean value assignment. Regular attributes that just accept strings
+// and have the same names are omitted, just like in the HTML attribute filter.
+// Some of these attributes can be hard to find. This list was created by
+// scraping the MDN documentation.
+
+
+['accent-height', 'alignment-baseline', 'arabic-form', 'baseline-shift', 'cap-height', 'clip-path', 'clip-rule', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'dominant-baseline', 'enable-background', 'fill-opacity', 'fill-rule', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'glyph-name', 'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'horiz-adv-x', 'horiz-origin-x', 'image-rendering', 'letter-spacing', 'lighting-color', 'marker-end', 'marker-mid', 'marker-start', 'overline-position', 'overline-thickness', 'paint-order', 'panose-1', 'pointer-events', 'rendering-intent', 'shape-rendering', 'stop-color', 'stop-opacity', 'strikethrough-position', 'strikethrough-thickness', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'text-anchor', 'text-decoration', 'text-rendering', 'underline-position', 'underline-thickness', 'unicode-bidi', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'vector-effect', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'word-spacing', 'writing-mode', 'xmlns:xlink', 'x-height' // NOTE: if you add a camelCased prop to this list,
+// you'll need to set attributeName to name.toLowerCase()
+// instead in the assignment below.
+].forEach(function (attributeName) {
+  var name = attributeName.replace(CAMELIZE, capitalize);
+  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
+  attributeName, null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+}); // String SVG attributes with the xlink namespace.
+
+['xlink:actuate', 'xlink:arcrole', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type' // NOTE: if you add a camelCased prop to this list,
+// you'll need to set attributeName to name.toLowerCase()
+// instead in the assignment below.
+].forEach(function (attributeName) {
+  var name = attributeName.replace(CAMELIZE, capitalize);
+  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
+  attributeName, 'http://www.w3.org/1999/xlink', false, // sanitizeURL
+  false);
+}); // String SVG attributes with the xml namespace.
+
+['xml:base', 'xml:lang', 'xml:space' // NOTE: if you add a camelCased prop to this list,
+// you'll need to set attributeName to name.toLowerCase()
+// instead in the assignment below.
+].forEach(function (attributeName) {
+  var name = attributeName.replace(CAMELIZE, capitalize);
+  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
+  attributeName, 'http://www.w3.org/XML/1998/namespace', false, // sanitizeURL
+  false);
+}); // These attribute exists both in HTML and SVG.
+// The attribute name is case-sensitive in SVG so we can't just use
+// the React name like we do for attributes that exist only in HTML.
+
+['tabIndex', 'crossOrigin'].forEach(function (attributeName) {
+  properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, // mustUseProperty
+  attributeName.toLowerCase(), // attributeName
+  null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+}); // These attributes accept URLs. These must not allow javascript: URLS.
+// These will also need to accept Trusted Types object in the future.
+
+var xlinkHref = 'xlinkHref';
+properties[xlinkHref] = new PropertyInfoRecord('xlinkHref', STRING, false, // mustUseProperty
+'xlink:href', 'http://www.w3.org/1999/xlink', true, // sanitizeURL
+false);
+['src', 'href', 'action', 'formAction'].forEach(function (attributeName) {
+  properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, // mustUseProperty
+  attributeName.toLowerCase(), // attributeName
+  null, // attributeNamespace
+  true, // sanitizeURL
+  true);
+});
+
+/**
+ * CSS properties which accept numbers but are not in units of "px".
+ */
+var isUnitlessNumber = {
+  animationIterationCount: true,
+  aspectRatio: true,
+  borderImageOutset: true,
+  borderImageSlice: true,
+  borderImageWidth: true,
+  boxFlex: true,
+  boxFlexGroup: true,
+  boxOrdinalGroup: true,
+  columnCount: true,
+  columns: true,
+  flex: true,
+  flexGrow: true,
+  flexPositive: true,
+  flexShrink: true,
+  flexNegative: true,
+  flexOrder: true,
+  gridArea: true,
+  gridRow: true,
+  gridRowEnd: true,
+  gridRowSpan: true,
+  gridRowStart: true,
+  gridColumn: true,
+  gridColumnEnd: true,
+  gridColumnSpan: true,
+  gridColumnStart: true,
+  fontWeight: true,
+  lineClamp: true,
+  lineHeight: true,
+  opacity: true,
+  order: true,
+  orphans: true,
+  tabSize: true,
+  widows: true,
+  zIndex: true,
+  zoom: true,
+  // SVG-related properties
+  fillOpacity: true,
+  floodOpacity: true,
+  stopOpacity: true,
+  strokeDasharray: true,
+  strokeDashoffset: true,
+  strokeMiterlimit: true,
+  strokeOpacity: true,
+  strokeWidth: true
+};
+/**
+ * @param {string} prefix vendor-specific prefix, eg: Webkit
+ * @param {string} key style name, eg: transitionDuration
+ * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
+ * WebkitTransitionDuration
+ */
+
+function prefixKey(prefix, key) {
+  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
+}
+/**
+ * Support style names that may come passed in prefixed by adding permutations
+ * of vendor prefixes.
+ */
+
+
+var prefixes = ['Webkit', 'ms', 'Moz', 'O']; // Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
+// infinite loop, because it iterates over the newly added props too.
+
+Object.keys(isUnitlessNumber).forEach(function (prop) {
+  prefixes.forEach(function (prefix) {
+    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
+  });
+});
+
+var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare
+
+function isArray(a) {
+  return isArrayImpl(a);
+}
+
+var startInlineScript = stringToPrecomputedChunk('<script>');
+var endInlineScript = stringToPrecomputedChunk('</script>');
+var startScriptSrc = stringToPrecomputedChunk('<script src="');
+var startModuleSrc = stringToPrecomputedChunk('<script type="module" src="');
+var scriptIntegirty = stringToPrecomputedChunk('" integrity="');
+var endAsyncScript = stringToPrecomputedChunk('" async=""></script>');
+
+var textSeparator = stringToPrecomputedChunk('<!-- -->');
+
+var styleAttributeStart = stringToPrecomputedChunk(' style="');
+var styleAssign = stringToPrecomputedChunk(':');
+var styleSeparator = stringToPrecomputedChunk(';');
+
+var attributeSeparator = stringToPrecomputedChunk(' ');
+var attributeAssign = stringToPrecomputedChunk('="');
+var attributeEnd = stringToPrecomputedChunk('"');
+var attributeEmptyString = stringToPrecomputedChunk('=""');
+
+var endOfStartTag = stringToPrecomputedChunk('>');
+var endOfStartTagSelfClosing = stringToPrecomputedChunk('/>');
+
+var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=""');
+
+var leadingNewline = stringToPrecomputedChunk('\n');
+
+var DOCTYPE = stringToPrecomputedChunk('<!DOCTYPE html>');
+var endTag1 = stringToPrecomputedChunk('</');
+var endTag2 = stringToPrecomputedChunk('>');
+// A placeholder is a node inside a hidden partial tree that can be filled in later, but before
+// display. It's never visible to users. We use the template tag because it can be used in every
+// type of parent. <script> tags also work in every other tag except <colgroup>.
+
+var placeholder1 = stringToPrecomputedChunk('<template id="');
+var placeholder2 = stringToPrecomputedChunk('"></template>');
+
+var startCompletedSuspenseBoundary = stringToPrecomputedChunk('<!--$-->');
+var startPendingSuspenseBoundary1 = stringToPrecomputedChunk('<!--$?--><template id="');
+var startPendingSuspenseBoundary2 = stringToPrecomputedChunk('"></template>');
+var startClientRenderedSuspenseBoundary = stringToPrecomputedChunk('<!--$!-->');
+var endSuspenseBoundary = stringToPrecomputedChunk('<!--/$-->');
+var clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk('<template');
+var clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('"');
+var clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst="');
+var clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg="');
+var clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck="');
+var clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk('></template>');
+var startSegmentHTML = stringToPrecomputedChunk('<div hidden id="');
+var startSegmentHTML2 = stringToPrecomputedChunk('">');
+var endSegmentHTML = stringToPrecomputedChunk('</div>');
+var startSegmentSVG = stringToPrecomputedChunk('<svg aria-hidden="true" style="display:none" id="');
+var startSegmentSVG2 = stringToPrecomputedChunk('">');
+var endSegmentSVG = stringToPrecomputedChunk('</svg>');
+var startSegmentMathML = stringToPrecomputedChunk('<math aria-hidden="true" style="display:none" id="');
+var startSegmentMathML2 = stringToPrecomputedChunk('">');
+var endSegmentMathML = stringToPrecomputedChunk('</math>');
+var startSegmentTable = stringToPrecomputedChunk('<table hidden id="');
+var startSegmentTable2 = stringToPrecomputedChunk('">');
+var endSegmentTable = stringToPrecomputedChunk('</table>');
+var startSegmentTableBody = stringToPrecomputedChunk('<table hidden><tbody id="');
+var startSegmentTableBody2 = stringToPrecomputedChunk('">');
+var endSegmentTableBody = stringToPrecomputedChunk('</tbody></table>');
+var startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id="');
+var startSegmentTableRow2 = stringToPrecomputedChunk('">');
+var endSegmentTableRow = stringToPrecomputedChunk('</tr></table>');
+var startSegmentColGroup = stringToPrecomputedChunk('<table hidden><colgroup id="');
+var startSegmentColGroup2 = stringToPrecomputedChunk('">');
+var endSegmentColGroup = stringToPrecomputedChunk('</colgroup></table>');
+// The following code is the source scripts that we then minify and inline below,
+// with renamed function names that we hope don't collide:
+// const COMMENT_NODE = 8;
+// const SUSPENSE_START_DATA = '$';
+// const SUSPENSE_END_DATA = '/$';
+// const SUSPENSE_PENDING_START_DATA = '$?';
+// const SUSPENSE_FALLBACK_START_DATA = '$!';
+//
+// function clientRenderBoundary(suspenseBoundaryID, errorDigest, errorMsg, errorComponentStack) {
+//   // Find the fallback's first element.
+//   const suspenseIdNode = document.getElementById(suspenseBoundaryID);
+//   if (!suspenseIdNode) {
+//     // The user must have already navigated away from this tree.
+//     // E.g. because the parent was hydrated.
+//     return;
+//   }
+//   // Find the boundary around the fallback. This is always the previous node.
+//   const suspenseNode = suspenseIdNode.previousSibling;
+//   // Tag it to be client rendered.
+//   suspenseNode.data = SUSPENSE_FALLBACK_START_DATA;
+//   // assign error metadata to first sibling
+//   let dataset = suspenseIdNode.dataset;
+//   if (errorDigest) dataset.dgst = errorDigest;
+//   if (errorMsg) dataset.msg = errorMsg;
+//   if (errorComponentStack) dataset.stck = errorComponentStack;
+//   // Tell React to retry it if the parent already hydrated.
+//   if (suspenseNode._reactRetry) {
+//     suspenseNode._reactRetry();
+//   }
+// }
+//
+// function completeBoundary(suspenseBoundaryID, contentID) {
+//   // Find the fallback's first element.
+//   const suspenseIdNode = document.getElementById(suspenseBoundaryID);
+//   const contentNode = document.getElementById(contentID);
+//   // We'll detach the content node so that regardless of what happens next we don't leave in the tree.
+//   // This might also help by not causing recalcing each time we move a child from here to the target.
+//   contentNode.parentNode.removeChild(contentNode);
+//   if (!suspenseIdNode) {
+//     // The user must have already navigated away from this tree.
+//     // E.g. because the parent was hydrated. That's fine there's nothing to do
+//     // but we have to make sure that we already deleted the container node.
+//     return;
+//   }
+//   // Find the boundary around the fallback. This is always the previous node.
+//   const suspenseNode = suspenseIdNode.previousSibling;
+//
+//   // Clear all the existing children. This is complicated because
+//   // there can be embedded Suspense boundaries in the fallback.
+//   // This is similar to clearSuspenseBoundary in ReactDOMHostConfig.
+//   // TODO: We could avoid this if we never emitted suspense boundaries in fallback trees.
+//   // They never hydrate anyway. However, currently we support incrementally loading the fallback.
+//   const parentInstance = suspenseNode.parentNode;
+//   let node = suspenseNode.nextSibling;
+//   let depth = 0;
+//   do {
+//     if (node && node.nodeType === COMMENT_NODE) {
+//       const data = node.data;
+//       if (data === SUSPENSE_END_DATA) {
+//         if (depth === 0) {
+//           break;
+//         } else {
+//           depth--;
+//         }
+//       } else if (
+//         data === SUSPENSE_START_DATA ||
+//         data === SUSPENSE_PENDING_START_DATA ||
+//         data === SUSPENSE_FALLBACK_START_DATA
+//       ) {
+//         depth++;
+//       }
+//     }
+//
+//     const nextNode = node.nextSibling;
+//     parentInstance.removeChild(node);
+//     node = nextNode;
+//   } while (node);
+//
+//   const endOfBoundary = node;
+//
+//   // Insert all the children from the contentNode between the start and end of suspense boundary.
+//   while (contentNode.firstChild) {
+//     parentInstance.insertBefore(contentNode.firstChild, endOfBoundary);
+//   }
+//   suspenseNode.data = SUSPENSE_START_DATA;
+//   if (suspenseNode._reactRetry) {
+//     suspenseNode._reactRetry();
+//   }
+// }
+//
+// function completeSegment(containerID, placeholderID) {
+//   const segmentContainer = document.getElementById(containerID);
+//   const placeholderNode = document.getElementById(placeholderID);
+//   // We always expect both nodes to exist here because, while we might
+//   // have navigated away from the main tree, we still expect the detached
+//   // tree to exist.
+//   segmentContainer.parentNode.removeChild(segmentContainer);
+//   while (segmentContainer.firstChild) {
+//     placeholderNode.parentNode.insertBefore(
+//       segmentContainer.firstChild,
+//       placeholderNode,
+//     );
+//   }
+//   placeholderNode.parentNode.removeChild(placeholderNode);
+// }
+
+var completeSegmentFunction = 'function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}';
+var completeBoundaryFunction = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}';
+var clientRenderFunction = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}';
+var completeSegmentScript1Full = stringToPrecomputedChunk(completeSegmentFunction + ';$RS("');
+var completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("');
+var completeSegmentScript2 = stringToPrecomputedChunk('","');
+var completeSegmentScript3 = stringToPrecomputedChunk('")</script>');
+var completeBoundaryScript1Full = stringToPrecomputedChunk(completeBoundaryFunction + ';$RC("');
+var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("');
+var completeBoundaryScript2 = stringToPrecomputedChunk('","');
+var completeBoundaryScript3 = stringToPrecomputedChunk('")</script>');
+var clientRenderScript1Full = stringToPrecomputedChunk(clientRenderFunction + ';$RX("');
+var clientRenderScript1Partial = stringToPrecomputedChunk('$RX("');
+var clientRenderScript1A = stringToPrecomputedChunk('"');
+var clientRenderScript2 = stringToPrecomputedChunk(')</script>');
+var clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(',');
+
+var rendererSigil;
+
+{
+  // Use this to detect multiple renderers using the same context
+  rendererSigil = {};
+} // Used to store the parent path of all context overrides in a shared linked list.
+// Forming a reverse tree.
+
+
+var rootContextSnapshot = null; // We assume that this runtime owns the "current" field on all ReactContext instances.
+// This global (actually thread local) state represents what state all those "current",
+// fields are currently in.
+
+var currentActiveSnapshot = null;
+
+function popNode(prev) {
+  {
+    prev.context._currentValue = prev.parentValue;
+  }
+}
+
+function pushNode(next) {
+  {
+    next.context._currentValue = next.value;
+  }
+}
+
+function popToNearestCommonAncestor(prev, next) {
+  if (prev === next) ; else {
+    popNode(prev);
+    var parentPrev = prev.parent;
+    var parentNext = next.parent;
+
+    if (parentPrev === null) {
+      if (parentNext !== null) {
+        throw new Error('The stacks must reach the root at the same time. This is a bug in React.');
+      }
+    } else {
+      if (parentNext === null) {
+        throw new Error('The stacks must reach the root at the same time. This is a bug in React.');
+      }
+
+      popToNearestCommonAncestor(parentPrev, parentNext); // On the way back, we push the new ones that weren't common.
+
+      pushNode(next);
+    }
+  }
+}
+
+function popAllPrevious(prev) {
+  popNode(prev);
+  var parentPrev = prev.parent;
+
+  if (parentPrev !== null) {
+    popAllPrevious(parentPrev);
+  }
+}
+
+function pushAllNext(next) {
+  var parentNext = next.parent;
+
+  if (parentNext !== null) {
+    pushAllNext(parentNext);
+  }
+
+  pushNode(next);
+}
+
+function popPreviousToCommonLevel(prev, next) {
+  popNode(prev);
+  var parentPrev = prev.parent;
+
+  if (parentPrev === null) {
+    throw new Error('The depth must equal at least at zero before reaching the root. This is a bug in React.');
+  }
+
+  if (parentPrev.depth === next.depth) {
+    // We found the same level. Now we just need to find a shared ancestor.
+    popToNearestCommonAncestor(parentPrev, next);
+  } else {
+    // We must still be deeper.
+    popPreviousToCommonLevel(parentPrev, next);
+  }
+}
+
+function popNextToCommonLevel(prev, next) {
+  var parentNext = next.parent;
+
+  if (parentNext === null) {
+    throw new Error('The depth must equal at least at zero before reaching the root. This is a bug in React.');
+  }
+
+  if (prev.depth === parentNext.depth) {
+    // We found the same level. Now we just need to find a shared ancestor.
+    popToNearestCommonAncestor(prev, parentNext);
+  } else {
+    // We must still be deeper.
+    popNextToCommonLevel(prev, parentNext);
+  }
+
+  pushNode(next);
+} // Perform context switching to the new snapshot.
+// To make it cheap to read many contexts, while not suspending, we make the switch eagerly by
+// updating all the context's current values. That way reads, always just read the current value.
+// At the cost of updating contexts even if they're never read by this subtree.
+
+
+function switchContext(newSnapshot) {
+  // The basic algorithm we need to do is to pop back any contexts that are no longer on the stack.
+  // We also need to update any new contexts that are now on the stack with the deepest value.
+  // The easiest way to update new contexts is to just reapply them in reverse order from the
+  // perspective of the backpointers. To avoid allocating a lot when switching, we use the stack
+  // for that. Therefore this algorithm is recursive.
+  // 1) First we pop which ever snapshot tree was deepest. Popping old contexts as we go.
+  // 2) Then we find the nearest common ancestor from there. Popping old contexts as we go.
+  // 3) Then we reapply new contexts on the way back up the stack.
+  var prev = currentActiveSnapshot;
+  var next = newSnapshot;
+
+  if (prev !== next) {
+    if (prev === null) {
+      // $FlowFixMe: This has to be non-null since it's not equal to prev.
+      pushAllNext(next);
+    } else if (next === null) {
+      popAllPrevious(prev);
+    } else if (prev.depth === next.depth) {
+      popToNearestCommonAncestor(prev, next);
+    } else if (prev.depth > next.depth) {
+      popPreviousToCommonLevel(prev, next);
+    } else {
+      popNextToCommonLevel(prev, next);
+    }
+
+    currentActiveSnapshot = next;
+  }
+}
+function pushProvider(context, nextValue) {
+  var prevValue;
+
+  {
+    prevValue = context._currentValue;
+    context._currentValue = nextValue;
+
+    {
+      if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
+        error('Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.');
+      }
+
+      context._currentRenderer = rendererSigil;
+    }
+  }
+
+  var prevNode = currentActiveSnapshot;
+  var newNode = {
+    parent: prevNode,
+    depth: prevNode === null ? 0 : prevNode.depth + 1,
+    context: context,
+    parentValue: prevValue,
+    value: nextValue
+  };
+  currentActiveSnapshot = newNode;
+  return newNode;
+}
+function popProvider() {
+  var prevSnapshot = currentActiveSnapshot;
+
+  if (prevSnapshot === null) {
+    throw new Error('Tried to pop a Context at the root of the app. This is a bug in React.');
+  }
+
+  {
+    var value = prevSnapshot.parentValue;
+
+    if (value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
+      prevSnapshot.context._currentValue = prevSnapshot.context._defaultValue;
+    } else {
+      prevSnapshot.context._currentValue = value;
+    }
+  }
+
+  return currentActiveSnapshot = prevSnapshot.parent;
+}
+function getActiveContext() {
+  return currentActiveSnapshot;
+}
+function readContext(context) {
+  var value =  context._currentValue ;
+  return value;
+}
+
+var currentRequest = null;
+function prepareToUseHooksForRequest(request) {
+  currentRequest = request;
+}
+function resetHooksForRequest() {
+  currentRequest = null;
+}
+
+function readContext$1(context) {
+  {
+    if (context.$$typeof !== REACT_SERVER_CONTEXT_TYPE) {
+      error('Only ServerContext is supported in Flight');
+    }
+
+    if (currentCache === null) {
+      error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');
+    }
+  }
+
+  return readContext(context);
+}
+
+var Dispatcher = {
+  useMemo: function (nextCreate) {
+    return nextCreate();
+  },
+  useCallback: function (callback) {
+    return callback;
+  },
+  useDebugValue: function () {},
+  useDeferredValue: unsupportedHook,
+  useTransition: unsupportedHook,
+  getCacheForType: function (resourceType) {
+    if (!currentCache) {
+      throw new Error('Reading the cache is only supported while rendering.');
+    }
+
+    var entry = currentCache.get(resourceType);
+
+    if (entry === undefined) {
+      entry = resourceType(); // TODO: Warn if undefined?
+
+      currentCache.set(resourceType, entry);
+    }
+
+    return entry;
+  },
+  readContext: readContext$1,
+  useContext: readContext$1,
+  useReducer: unsupportedHook,
+  useRef: unsupportedHook,
+  useState: unsupportedHook,
+  useInsertionEffect: unsupportedHook,
+  useLayoutEffect: unsupportedHook,
+  useImperativeHandle: unsupportedHook,
+  useEffect: unsupportedHook,
+  useId: useId,
+  useMutableSource: unsupportedHook,
+  useSyncExternalStore: unsupportedHook,
+  useCacheRefresh: function () {
+    return unsupportedRefresh;
+  }
+};
+
+function unsupportedHook() {
+  throw new Error('This Hook is not supported in Server Components.');
+}
+
+function unsupportedRefresh() {
+  if (!currentCache) {
+    throw new Error('Refreshing the cache is not supported in Server Components.');
+  }
+}
+
+var currentCache = null;
+function setCurrentCache(cache) {
+  currentCache = cache;
+  return currentCache;
+}
+function getCurrentCache() {
+  return currentCache;
+}
+
+function useId() {
+  if (currentRequest === null) {
+    throw new Error('useId can only be used while React is rendering');
+  }
+
+  var id = currentRequest.identifierCount++; // use 'S' for Flight components to distinguish from 'R' and 'r' in Fizz/Client
+
+  return ':' + currentRequest.identifierPrefix + 'S' + id.toString(32) + ':';
+}
+
+var ContextRegistry = ReactSharedInternals.ContextRegistry;
+function getOrCreateServerContext(globalName) {
+  if (!ContextRegistry[globalName]) {
+    ContextRegistry[globalName] = React.createServerContext(globalName, REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED);
+  }
+
+  return ContextRegistry[globalName];
+}
+
+var PENDING = 0;
+var COMPLETED = 1;
+var ABORTED = 3;
+var ERRORED = 4;
+var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
+
+function defaultErrorHandler(error) {
+  console['error'](error); // Don't transform to our wrapper
+}
+
+var OPEN = 0;
+var CLOSING = 1;
+var CLOSED = 2;
+function createRequest(model, bundlerConfig, onError, context, identifierPrefix) {
+  var abortSet = new Set();
+  var pingedTasks = [];
+  var request = {
+    status: OPEN,
+    fatalError: null,
+    destination: null,
+    bundlerConfig: bundlerConfig,
+    cache: new Map(),
+    nextChunkId: 0,
+    pendingChunks: 0,
+    abortableTasks: abortSet,
+    pingedTasks: pingedTasks,
+    completedModuleChunks: [],
+    completedJSONChunks: [],
+    completedErrorChunks: [],
+    writtenSymbols: new Map(),
+    writtenModules: new Map(),
+    writtenProviders: new Map(),
+    identifierPrefix: identifierPrefix || '',
+    identifierCount: 1,
+    onError: onError === undefined ? defaultErrorHandler : onError,
+    toJSON: function (key, value) {
+      return resolveModelToJSON(request, this, key, value);
+    }
+  };
+  request.pendingChunks++;
+  var rootContext = createRootContext(context);
+  var rootTask = createTask(request, model, rootContext, abortSet);
+  pingedTasks.push(rootTask);
+  return request;
+}
+
+function createRootContext(reqContext) {
+  return importServerContexts(reqContext);
+}
+
+var POP = {};
+
+function attemptResolveElement(type, key, ref, props) {
+  if (ref !== null && ref !== undefined) {
+    // When the ref moves to the regular props object this will implicitly
+    // throw for functions. We could probably relax it to a DEV warning for other
+    // cases.
+    throw new Error('Refs cannot be used in server components, nor passed to client components.');
+  }
+
+  if (typeof type === 'function') {
+    if (isModuleReference(type)) {
+      // This is a reference to a client component.
+      return [REACT_ELEMENT_TYPE, type, key, props];
+    } // This is a server-side component.
+
+
+    return type(props);
+  } else if (typeof type === 'string') {
+    // This is a host element. E.g. HTML.
+    return [REACT_ELEMENT_TYPE, type, key, props];
+  } else if (typeof type === 'symbol') {
+    if (type === REACT_FRAGMENT_TYPE) {
+      // For key-less fragments, we add a small optimization to avoid serializing
+      // it as a wrapper.
+      // TODO: If a key is specified, we should propagate its key to any children.
+      // Same as if a server component has a key.
+      return props.children;
+    } // This might be a built-in React component. We'll let the client decide.
+    // Any built-in works as long as its props are serializable.
+
+
+    return [REACT_ELEMENT_TYPE, type, key, props];
+  } else if (type != null && typeof type === 'object') {
+    if (isModuleReference(type)) {
+      // This is a reference to a client component.
+      return [REACT_ELEMENT_TYPE, type, key, props];
+    }
+
+    switch (type.$$typeof) {
+      case REACT_LAZY_TYPE:
+        {
+          var payload = type._payload;
+          var init = type._init;
+          var wrappedType = init(payload);
+          return attemptResolveElement(wrappedType, key, ref, props);
+        }
+
+      case REACT_FORWARD_REF_TYPE:
+        {
+          var render = type.render;
+          return render(props, undefined);
+        }
+
+      case REACT_MEMO_TYPE:
+        {
+          return attemptResolveElement(type.type, key, ref, props);
+        }
+
+      case REACT_PROVIDER_TYPE:
+        {
+          pushProvider(type._context, props.value);
+
+          {
+            var extraKeys = Object.keys(props).filter(function (value) {
+              if (value === 'children' || value === 'value') {
+                return false;
+              }
+
+              return true;
+            });
+
+            if (extraKeys.length !== 0) {
+              error('ServerContext can only have a value prop and children. Found: %s', JSON.stringify(extraKeys));
+            }
+          }
+
+          return [REACT_ELEMENT_TYPE, type, key, // Rely on __popProvider being serialized last to pop the provider.
+          {
+            value: props.value,
+            children: props.children,
+            __pop: POP
+          }];
+        }
+    }
+  }
+
+  throw new Error("Unsupported server component type: " + describeValueForErrorMessage(type));
+}
+
+function pingTask(request, task) {
+  var pingedTasks = request.pingedTasks;
+  pingedTasks.push(task);
+
+  if (pingedTasks.length === 1) {
+    scheduleWork(function () {
+      return performWork(request);
+    });
+  }
+}
+
+function createTask(request, model, context, abortSet) {
+  var id = request.nextChunkId++;
+  var task = {
+    id: id,
+    status: PENDING,
+    model: model,
+    context: context,
+    ping: function () {
+      return pingTask(request, task);
+    }
+  };
+  abortSet.add(task);
+  return task;
+}
+
+function serializeByValueID(id) {
+  return '$' + id.toString(16);
+}
+
+function serializeByRefID(id) {
+  return '@' + id.toString(16);
+}
+
+function escapeStringValue(value) {
+  if (value[0] === '$' || value[0] === '@') {
+    // We need to escape $ or @ prefixed strings since we use those to encode
+    // references to IDs and as special symbol values.
+    return '$' + value;
+  } else {
+    return value;
+  }
+}
+
+function isObjectPrototype(object) {
+  if (!object) {
+    return false;
+  }
+
+  var ObjectPrototype = Object.prototype;
+
+  if (object === ObjectPrototype) {
+    return true;
+  } // It might be an object from a different Realm which is
+  // still just a plain simple object.
+
+
+  if (Object.getPrototypeOf(object)) {
+    return false;
+  }
+
+  var names = Object.getOwnPropertyNames(object);
+
+  for (var i = 0; i < names.length; i++) {
+    if (!(names[i] in ObjectPrototype)) {
+      return false;
+    }
+  }
+
+  return true;
+}
+
+function isSimpleObject(object) {
+  if (!isObjectPrototype(Object.getPrototypeOf(object))) {
+    return false;
+  }
+
+  var names = Object.getOwnPropertyNames(object);
+
+  for (var i = 0; i < names.length; i++) {
+    var descriptor = Object.getOwnPropertyDescriptor(object, names[i]);
+
+    if (!descriptor) {
+      return false;
+    }
+
+    if (!descriptor.enumerable) {
+      if ((names[i] === 'key' || names[i] === 'ref') && typeof descriptor.get === 'function') {
+        // React adds key and ref getters to props objects to issue warnings.
+        // Those getters will not be transferred to the client, but that's ok,
+        // so we'll special case them.
+        continue;
+      }
+
+      return false;
+    }
+  }
+
+  return true;
+}
+
+function objectName(object) {
+  var name = Object.prototype.toString.call(object);
+  return name.replace(/^\[object (.*)\]$/, function (m, p0) {
+    return p0;
+  });
+}
+
+function describeKeyForErrorMessage(key) {
+  var encodedKey = JSON.stringify(key);
+  return '"' + key + '"' === encodedKey ? key : encodedKey;
+}
+
+function describeValueForErrorMessage(value) {
+  switch (typeof value) {
+    case 'string':
+      {
+        return JSON.stringify(value.length <= 10 ? value : value.substr(0, 10) + '...');
+      }
+
+    case 'object':
+      {
+        if (isArray(value)) {
+          return '[...]';
+        }
+
+        var name = objectName(value);
+
+        if (name === 'Object') {
+          return '{...}';
+        }
+
+        return name;
+      }
+
+    case 'function':
+      return 'function';
+
+    default:
+      // eslint-disable-next-line react-internal/safe-string-coercion
+      return String(value);
+  }
+}
+
+function describeObjectForErrorMessage(objectOrArray, expandedName) {
+  if (isArray(objectOrArray)) {
+    var str = '[';
+    var array = objectOrArray;
+
+    for (var i = 0; i < array.length; i++) {
+      if (i > 0) {
+        str += ', ';
+      }
+
+      if (i > 6) {
+        str += '...';
+        break;
+      }
+
+      var _value = array[i];
+
+      if ('' + i === expandedName && typeof _value === 'object' && _value !== null) {
+        str += describeObjectForErrorMessage(_value);
+      } else {
+        str += describeValueForErrorMessage(_value);
+      }
+    }
+
+    str += ']';
+    return str;
+  } else {
+    var _str = '{';
+    var object = objectOrArray;
+    var names = Object.keys(object);
+
+    for (var _i = 0; _i < names.length; _i++) {
+      if (_i > 0) {
+        _str += ', ';
+      }
+
+      if (_i > 6) {
+        _str += '...';
+        break;
+      }
+
+      var name = names[_i];
+      _str += describeKeyForErrorMessage(name) + ': ';
+      var _value2 = object[name];
+
+      if (name === expandedName && typeof _value2 === 'object' && _value2 !== null) {
+        _str += describeObjectForErrorMessage(_value2);
+      } else {
+        _str += describeValueForErrorMessage(_value2);
+      }
+    }
+
+    _str += '}';
+    return _str;
+  }
+}
+
+var insideContextProps = null;
+var isInsideContextValue = false;
+function resolveModelToJSON(request, parent, key, value) {
+  {
+    // $FlowFixMe
+    var originalValue = parent[key];
+
+    if (typeof originalValue === 'object' && originalValue !== value) {
+      error('Only plain objects can be passed to client components from server components. ' + 'Objects with toJSON methods are not supported. Convert it manually ' + 'to a simple value before passing it to props. ' + 'Remove %s from these props: %s', describeKeyForErrorMessage(key), describeObjectForErrorMessage(parent));
+    }
+  } // Special Symbols
+
+
+  switch (value) {
+    case REACT_ELEMENT_TYPE:
+      return '$';
+  }
+
+  {
+    if (parent[0] === REACT_ELEMENT_TYPE && parent[1] && parent[1].$$typeof === REACT_PROVIDER_TYPE && key === '3') {
+      insideContextProps = value;
+    } else if (insideContextProps === parent && key === 'value') {
+      isInsideContextValue = true;
+    } else if (insideContextProps === parent && key === 'children') {
+      isInsideContextValue = false;
+    }
+  } // Resolve server components.
+
+
+  while (typeof value === 'object' && value !== null && (value.$$typeof === REACT_ELEMENT_TYPE || value.$$typeof === REACT_LAZY_TYPE)) {
+    {
+      if (isInsideContextValue) {
+        error('React elements are not allowed in ServerContext');
+      }
+    }
+
+    try {
+      switch (value.$$typeof) {
+        case REACT_ELEMENT_TYPE:
+          {
+            // TODO: Concatenate keys of parents onto children.
+            var element = value; // Attempt to render the server component.
+
+            value = attemptResolveElement(element.type, element.key, element.ref, element.props);
+            break;
+          }
+
+        case REACT_LAZY_TYPE:
+          {
+            var payload = value._payload;
+            var init = value._init;
+            value = init(payload);
+            break;
+          }
+      }
+    } catch (x) {
+      if (typeof x === 'object' && x !== null && typeof x.then === 'function') {
+        // Something suspended, we'll need to create a new task and resolve it later.
+        request.pendingChunks++;
+        var newTask = createTask(request, value, getActiveContext(), request.abortableTasks);
+        var ping = newTask.ping;
+        x.then(ping, ping);
+        return serializeByRefID(newTask.id);
+      } else {
+        logRecoverableError(request, x); // Something errored. We'll still send everything we have up until this point.
+        // We'll replace this element with a lazy reference that throws on the client
+        // once it gets rendered.
+
+        request.pendingChunks++;
+        var errorId = request.nextChunkId++;
+        emitErrorChunk(request, errorId, x);
+        return serializeByRefID(errorId);
+      }
+    }
+  }
+
+  if (value == null) {
+    return value;
+  }
+
+  if (typeof value === 'object' || isModuleReference(value)) {
+    if (isModuleReference(value)) {
+      var moduleReference = value;
+      var moduleKey = getModuleKey(moduleReference);
+      var writtenModules = request.writtenModules;
+      var existingId = writtenModules.get(moduleKey);
+
+      if (existingId !== undefined) {
+        if (parent[0] === REACT_ELEMENT_TYPE && key === '1') {
+          // If we're encoding the "type" of an element, we can refer
+          // to that by a lazy reference instead of directly since React
+          // knows how to deal with lazy values. This lets us suspend
+          // on this component rather than its parent until the code has
+          // loaded.
+          return serializeByRefID(existingId);
+        }
+
+        return serializeByValueID(existingId);
+      }
+
+      try {
+        var moduleMetaData = resolveModuleMetaData(request.bundlerConfig, moduleReference);
+        request.pendingChunks++;
+        var moduleId = request.nextChunkId++;
+        emitModuleChunk(request, moduleId, moduleMetaData);
+        writtenModules.set(moduleKey, moduleId);
+
+        if (parent[0] === REACT_ELEMENT_TYPE && key === '1') {
+          // If we're encoding the "type" of an element, we can refer
+          // to that by a lazy reference instead of directly since React
+          // knows how to deal with lazy values. This lets us suspend
+          // on this component rather than its parent until the code has
+          // loaded.
+          return serializeByRefID(moduleId);
+        }
+
+        return serializeByValueID(moduleId);
+      } catch (x) {
+        request.pendingChunks++;
+
+        var _errorId = request.nextChunkId++;
+
+        emitErrorChunk(request, _errorId, x);
+        return serializeByValueID(_errorId);
+      }
+    } else if (value.$$typeof === REACT_PROVIDER_TYPE) {
+      var providerKey = value._context._globalName;
+      var writtenProviders = request.writtenProviders;
+      var providerId = writtenProviders.get(key);
+
+      if (providerId === undefined) {
+        request.pendingChunks++;
+        providerId = request.nextChunkId++;
+        writtenProviders.set(providerKey, providerId);
+        emitProviderChunk(request, providerId, providerKey);
+      }
+
+      return serializeByValueID(providerId);
+    } else if (value === POP) {
+      popProvider();
+
+      {
+        insideContextProps = null;
+        isInsideContextValue = false;
+      }
+
+      return undefined;
+    }
+
+    {
+      if (value !== null && !isArray(value)) {
+        // Verify that this is a simple plain object.
+        if (objectName(value) !== 'Object') {
+          error('Only plain objects can be passed to client components from server components. ' + 'Built-ins like %s are not supported. ' + 'Remove %s from these props: %s', objectName(value), describeKeyForErrorMessage(key), describeObjectForErrorMessage(parent));
+        } else if (typeof value === 'object' && !isSimpleObject(value)) {
+          error('Only plain objects can be passed to client components from server components. ' + 'Classes or other objects with methods are not supported. ' + 'Remove %s from these props: %s', describeKeyForErrorMessage(key), describeObjectForErrorMessage(parent, key));
+        } else if (Object.getOwnPropertySymbols) {
+          var symbols = Object.getOwnPropertySymbols(value);
+
+          if (symbols.length > 0) {
+            error('Only plain objects can be passed to client components from server components. ' + 'Objects with symbol properties like %s are not supported. ' + 'Remove %s from these props: %s', symbols[0].description, describeKeyForErrorMessage(key), describeObjectForErrorMessage(parent, key));
+          }
+        }
+      }
+    }
+
+    return value;
+  }
+
+  if (typeof value === 'string') {
+    return escapeStringValue(value);
+  }
+
+  if (typeof value === 'boolean' || typeof value === 'number' || typeof value === 'undefined') {
+    return value;
+  }
+
+  if (typeof value === 'function') {
+    if (/^on[A-Z]/.test(key)) {
+      throw new Error('Event handlers cannot be passed to client component props. ' + ("Remove " + describeKeyForErrorMessage(key) + " from these props if possible: " + describeObjectForErrorMessage(parent) + "\n") + 'If you need interactivity, consider converting part of this to a client component.');
+    } else {
+      throw new Error('Functions cannot be passed directly to client components ' + "because they're not serializable. " + ("Remove " + describeKeyForErrorMessage(key) + " (" + (value.displayName || value.name || 'function') + ") from this object, or avoid the entire object: " + describeObjectForErrorMessage(parent)));
+    }
+  }
+
+  if (typeof value === 'symbol') {
+    var writtenSymbols = request.writtenSymbols;
+
+    var _existingId = writtenSymbols.get(value);
+
+    if (_existingId !== undefined) {
+      return serializeByValueID(_existingId);
+    }
+
+    var name = value.description;
+
+    if (Symbol.for(name) !== value) {
+      throw new Error('Only global symbols received from Symbol.for(...) can be passed to client components. ' + ("The symbol Symbol.for(" + value.description + ") cannot be found among global symbols. ") + ("Remove " + describeKeyForErrorMessage(key) + " from this object, or avoid the entire object: " + describeObjectForErrorMessage(parent)));
+    }
+
+    request.pendingChunks++;
+    var symbolId = request.nextChunkId++;
+    emitSymbolChunk(request, symbolId, name);
+    writtenSymbols.set(value, symbolId);
+    return serializeByValueID(symbolId);
+  } // $FlowFixMe: bigint isn't added to Flow yet.
+
+
+  if (typeof value === 'bigint') {
+    throw new Error("BigInt (" + value + ") is not yet supported in client component props. " + ("Remove " + describeKeyForErrorMessage(key) + " from this object or use a plain number instead: " + describeObjectForErrorMessage(parent)));
+  }
+
+  throw new Error("Type " + typeof value + " is not supported in client component props. " + ("Remove " + describeKeyForErrorMessage(key) + " from this object, or avoid the entire object: " + describeObjectForErrorMessage(parent)));
+}
+
+function logRecoverableError(request, error) {
+  var onError = request.onError;
+  onError(error);
+}
+
+function fatalError(request, error) {
+  // This is called outside error handling code such as if an error happens in React internals.
+  if (request.destination !== null) {
+    request.status = CLOSED;
+    closeWithError(request.destination, error);
+  } else {
+    request.status = CLOSING;
+    request.fatalError = error;
+  }
+}
+
+function emitErrorChunk(request, id, error) {
+  // TODO: We should not leak error messages to the client in prod.
+  // Give this an error code instead and log on the server.
+  // We can serialize the error in DEV as a convenience.
+  var message;
+  var stack = '';
+
+  try {
+    if (error instanceof Error) {
+      // eslint-disable-next-line react-internal/safe-string-coercion
+      message = String(error.message); // eslint-disable-next-line react-internal/safe-string-coercion
+
+      stack = String(error.stack);
+    } else {
+      message = 'Error: ' + error;
+    }
+  } catch (x) {
+    message = 'An error occurred but serializing the error message failed.';
+  }
+
+  var processedChunk = processErrorChunk(request, id, message, stack);
+  request.completedErrorChunks.push(processedChunk);
+}
+
+function emitModuleChunk(request, id, moduleMetaData) {
+  var processedChunk = processModuleChunk(request, id, moduleMetaData);
+  request.completedModuleChunks.push(processedChunk);
+}
+
+function emitSymbolChunk(request, id, name) {
+  var processedChunk = processSymbolChunk(request, id, name);
+  request.completedModuleChunks.push(processedChunk);
+}
+
+function emitProviderChunk(request, id, contextName) {
+  var processedChunk = processProviderChunk(request, id, contextName);
+  request.completedJSONChunks.push(processedChunk);
+}
+
+function retryTask(request, task) {
+  if (task.status !== PENDING) {
+    // We completed this by other means before we had a chance to retry it.
+    return;
+  }
+
+  switchContext(task.context);
+
+  try {
+    var _value3 = task.model;
+
+    while (typeof _value3 === 'object' && _value3 !== null && _value3.$$typeof === REACT_ELEMENT_TYPE) {
+      // TODO: Concatenate keys of parents onto children.
+      var element = _value3; // Attempt to render the server component.
+      // Doing this here lets us reuse this same task if the next component
+      // also suspends.
+
+      task.model = _value3;
+      _value3 = attemptResolveElement(element.type, element.key, element.ref, element.props);
+    }
+
+    var processedChunk = processModelChunk(request, task.id, _value3);
+    request.completedJSONChunks.push(processedChunk);
+    request.abortableTasks.delete(task);
+    task.status = COMPLETED;
+  } catch (x) {
+    if (typeof x === 'object' && x !== null && typeof x.then === 'function') {
+      // Something suspended again, let's pick it back up later.
+      var ping = task.ping;
+      x.then(ping, ping);
+      return;
+    } else {
+      request.abortableTasks.delete(task);
+      task.status = ERRORED;
+      logRecoverableError(request, x); // This errored, we need to serialize this error to the
+
+      emitErrorChunk(request, task.id, x);
+    }
+  }
+}
+
+function performWork(request) {
+  var prevDispatcher = ReactCurrentDispatcher.current;
+  var prevCache = getCurrentCache();
+  ReactCurrentDispatcher.current = Dispatcher;
+  setCurrentCache(request.cache);
+  prepareToUseHooksForRequest(request);
+
+  try {
+    var pingedTasks = request.pingedTasks;
+    request.pingedTasks = [];
+
+    for (var i = 0; i < pingedTasks.length; i++) {
+      var task = pingedTasks[i];
+      retryTask(request, task);
+    }
+
+    if (request.destination !== null) {
+      flushCompletedChunks(request, request.destination);
+    }
+  } catch (error) {
+    logRecoverableError(request, error);
+    fatalError(request, error);
+  } finally {
+    ReactCurrentDispatcher.current = prevDispatcher;
+    setCurrentCache(prevCache);
+    resetHooksForRequest();
+  }
+}
+
+function abortTask(task, request, errorId) {
+  task.status = ABORTED; // Instead of emitting an error per task.id, we emit a model that only
+  // has a single value referencing the error.
+
+  var ref = serializeByValueID(errorId);
+  var processedChunk = processReferenceChunk(request, task.id, ref);
+  request.completedJSONChunks.push(processedChunk);
+}
+
+function flushCompletedChunks(request, destination) {
+  beginWriting();
+
+  try {
+    // We emit module chunks first in the stream so that
+    // they can be preloaded as early as possible.
+    var moduleChunks = request.completedModuleChunks;
+    var i = 0;
+
+    for (; i < moduleChunks.length; i++) {
+      request.pendingChunks--;
+      var chunk = moduleChunks[i];
+      var keepWriting = writeChunkAndReturn(destination, chunk);
+
+      if (!keepWriting) {
+        request.destination = null;
+        i++;
+        break;
+      }
+    }
+
+    moduleChunks.splice(0, i); // Next comes model data.
+
+    var jsonChunks = request.completedJSONChunks;
+    i = 0;
+
+    for (; i < jsonChunks.length; i++) {
+      request.pendingChunks--;
+      var _chunk = jsonChunks[i];
+
+      var _keepWriting = writeChunkAndReturn(destination, _chunk);
+
+      if (!_keepWriting) {
+        request.destination = null;
+        i++;
+        break;
+      }
+    }
+
+    jsonChunks.splice(0, i); // Finally, errors are sent. The idea is that it's ok to delay
+    // any error messages and prioritize display of other parts of
+    // the page.
+
+    var errorChunks = request.completedErrorChunks;
+    i = 0;
+
+    for (; i < errorChunks.length; i++) {
+      request.pendingChunks--;
+      var _chunk2 = errorChunks[i];
+
+      var _keepWriting2 = writeChunkAndReturn(destination, _chunk2);
+
+      if (!_keepWriting2) {
+        request.destination = null;
+        i++;
+        break;
+      }
+    }
+
+    errorChunks.splice(0, i);
+  } finally {
+    completeWriting(destination);
+  }
+
+  if (request.pendingChunks === 0) {
+    // We're done.
+    close(destination);
+  }
+}
+
+function startWork(request) {
+  scheduleWork(function () {
+    return performWork(request);
+  });
+}
+function startFlowing(request, destination) {
+  if (request.status === CLOSING) {
+    request.status = CLOSED;
+    closeWithError(destination, request.fatalError);
+    return;
+  }
+
+  if (request.status === CLOSED) {
+    return;
+  }
+
+  if (request.destination !== null) {
+    // We're already flowing.
+    return;
+  }
+
+  request.destination = destination;
+
+  try {
+    flushCompletedChunks(request, destination);
+  } catch (error) {
+    logRecoverableError(request, error);
+    fatalError(request, error);
+  }
+} // This is called to early terminate a request. It creates an error at all pending tasks.
+
+function abort(request, reason) {
+  try {
+    var abortableTasks = request.abortableTasks;
+
+    if (abortableTasks.size > 0) {
+      // We have tasks to abort. We'll emit one error row and then emit a reference
+      // to that row from every row that's still remaining.
+      var _error = reason === undefined ? new Error('The render was aborted by the server without a reason.') : reason;
+
+      logRecoverableError(request, _error);
+      request.pendingChunks++;
+      var errorId = request.nextChunkId++;
+      emitErrorChunk(request, errorId, _error);
+      abortableTasks.forEach(function (task) {
+        return abortTask(task, request, errorId);
+      });
+      abortableTasks.clear();
+    }
+
+    if (request.destination !== null) {
+      flushCompletedChunks(request, request.destination);
+    }
+  } catch (error) {
+    logRecoverableError(request, error);
+    fatalError(request, error);
+  }
+}
+
+function importServerContexts(contexts) {
+  if (contexts) {
+    var prevContext = getActiveContext();
+    switchContext(rootContextSnapshot);
+
+    for (var i = 0; i < contexts.length; i++) {
+      var _contexts$i = contexts[i],
+          name = _contexts$i[0],
+          _value4 = _contexts$i[1];
+      var context = getOrCreateServerContext(name);
+      pushProvider(context, _value4);
+    }
+
+    var importedContext = getActiveContext();
+    switchContext(prevContext);
+    return importedContext;
+  }
+
+  return rootContextSnapshot;
+}
+
+function renderToReadableStream(model, options) {
+  var request = createRequest( // Wrap root in a dummy element that simply adds a flag
+  // to the current dispatcher to check later in the proxies.
+  assign({}, model, {
+    $$typeof: Symbol.for('react.element'),
+    props: {
+      children: model
+    },
+    type: function () {
+      React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher.current.isRsc = true;
+      return model;
+    }
+  }), {}, // Manifest, not used
+  options ? options.onError : undefined, options ? options.context : undefined, options ? options.identifierPrefix : undefined);
+
+  if (options && options.signal) {
+    var signal = options.signal;
+
+    if (signal.aborted) {
+      abort(request, signal.reason);
+    } else {
+      var listener = function () {
+        abort(request, signal.reason);
+        signal.removeEventListener('abort', listener);
+      };
+
+      signal.addEventListener('abort', listener);
+    }
+  }
+
+  var stream = new ReadableStream({
+    type: 'bytes',
+    start: function (controller) {
+      startWork(request);
+    },
+    pull: function (controller) {
+      startFlowing(request, controller);
+    },
+    cancel: function (reason) {}
+  }, // $FlowFixMe size() methods are not allowed on byte streams.
+  {
+    highWaterMark: 0
+  });
+  return stream;
+}
+
+exports.renderToReadableStream = renderToReadableStream;
+  })();
+}
diff --git a/vendor/vendor/react-server-dom-vite/cjs/react-server-dom-vite-writer.browser.production.min.server.js b/vendor/vendor/react-server-dom-vite/cjs/react-server-dom-vite-writer.browser.production.min.server.js
new file mode 100644
index 0000000000000000000000000000000000000000..c43ef9bba56ecbc024d6e34bf1bd40eb4dfb45dc
--- /dev/null
+++ b/vendor/vendor/react-server-dom-vite/cjs/react-server-dom-vite-writer.browser.production.min.server.js
@@ -0,0 +1,48 @@
+/**
+ * @license React
+ * react-server-dom-vite-writer.browser.production.min.server.js
+ *
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+'use strict';var e=require("react"),aa=Object.assign,l=null,n=0;function p(a,b){if(0!==b.length)if(512<b.length)0<n&&(a.enqueue(new Uint8Array(l.buffer,0,n)),l=new Uint8Array(512),n=0),a.enqueue(b);else{var d=l.length-n;d<b.length&&(0===d?a.enqueue(l):(l.set(b.subarray(0,d),n),a.enqueue(l),b=b.subarray(d)),l=new Uint8Array(512),n=0);l.set(b,n);n+=b.length}return!0}var q=new TextEncoder;function r(a){return q.encode(a)}function u(a,b){"function"===typeof a.error?a.error(b):a.close()}
+var w=JSON.stringify,ba=Symbol.for("react.module.reference");function x(a){return"string"===typeof a?!!globalThis.__STRING_REFERENCE_INDEX[a]:a.$$typeof===ba}var y=Symbol.for("react.element"),ca=Symbol.for("react.fragment"),z=Symbol.for("react.provider"),da=Symbol.for("react.forward_ref"),ea=Symbol.for("react.memo"),A=Symbol.for("react.lazy"),B=Symbol.for("react.default_value");
+function C(a,b,d,c,f,g,h){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=c;this.attributeNamespace=f;this.mustUseProperty=d;this.propertyName=a;this.type=b;this.sanitizeURL=g;this.removeEmptyString=h}var D="children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ");D.push("innerText","textContent");D.forEach(function(a){new C(a,0,!1,a,null,!1,!1)});
+[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){new C(a[0],1,!1,a[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){new C(a,2,!1,a.toLowerCase(),null,!1,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){new C(a,2,!1,a,null,!1,!1)});
+"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){new C(a,3,!1,a.toLowerCase(),null,!1,!1)});["checked","multiple","muted","selected"].forEach(function(a){new C(a,3,!0,a,null,!1,!1)});["capture","download"].forEach(function(a){new C(a,4,!1,a,null,!1,!1)});
+["cols","rows","size","span"].forEach(function(a){new C(a,6,!1,a,null,!1,!1)});["rowSpan","start"].forEach(function(a){new C(a,5,!1,a.toLowerCase(),null,!1,!1)});var E=/[\-:]([a-z])/g;function F(a){return a[1].toUpperCase()}
+"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=a.replace(E,
+F);new C(b,1,!1,a,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(E,F);new C(b,1,!1,a,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(E,F);new C(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(a){new C(a,1,!1,a.toLowerCase(),null,!1,!1)});
+new C("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(a){new C(a,1,!1,a.toLowerCase(),null,!0,!0)});
+var G={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,
+fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},fa=["Webkit","ms","Moz","O"];Object.keys(G).forEach(function(a){fa.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);G[b]=G[a]})});var ha=Array.isArray;r("<script>");r("\x3c/script>");r('<script src="');r('<script type="module" src="');r('" integrity="');r('" async="">\x3c/script>');r("\x3c!-- --\x3e");r(' style="');r(":");r(";");r(" ");r('="');r('"');
+r('=""');r(">");r("/>");r(' selected=""');r("\n");r("<!DOCTYPE html>");r("</");r(">");r('<template id="');r('"></template>');r("\x3c!--$--\x3e");r('\x3c!--$?--\x3e<template id="');r('"></template>');r("\x3c!--$!--\x3e");r("\x3c!--/$--\x3e");r("<template");r('"');r(' data-dgst="');r(' data-msg="');r(' data-stck="');r("></template>");r('<div hidden id="');r('">');r("</div>");r('<svg aria-hidden="true" style="display:none" id="');r('">');r("</svg>");r('<math aria-hidden="true" style="display:none" id="');
+r('">');r("</math>");r('<table hidden id="');r('">');r("</table>");r('<table hidden><tbody id="');r('">');r("</tbody></table>");r('<table hidden><tr id="');r('">');r("</tr></table>");r('<table hidden><colgroup id="');r('">');r("</colgroup></table>");r('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("');r('$RS("');r('","');r('")\x3c/script>');r('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("');
+r('$RC("');r('","');r('")\x3c/script>');r('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("');r('$RX("');r('"');r(")\x3c/script>");r(",");var H=null;
+function I(a,b){if(a!==b){a.context._currentValue=a.parentValue;a=a.parent;var d=b.parent;if(null===a){if(null!==d)throw Error("The stacks must reach the root at the same time. This is a bug in React.");}else{if(null===d)throw Error("The stacks must reach the root at the same time. This is a bug in React.");I(a,d);b.context._currentValue=b.value}}}function ia(a){a.context._currentValue=a.parentValue;a=a.parent;null!==a&&ia(a)}
+function ja(a){var b=a.parent;null!==b&&ja(b);a.context._currentValue=a.value}function ka(a,b){a.context._currentValue=a.parentValue;a=a.parent;if(null===a)throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");a.depth===b.depth?I(a,b):ka(a,b)}
+function la(a,b){var d=b.parent;if(null===d)throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");a.depth===d.depth?I(a,d):la(a,d);b.context._currentValue=b.value}function J(a){var b=H;b!==a&&(null===b?ja(a):null===a?ia(b):b.depth===a.depth?I(b,a):b.depth>a.depth?ka(b,a):la(b,a),H=a)}function na(a,b){var d=a._currentValue;a._currentValue=b;var c=H;return H=a={parent:c,depth:null===c?0:c.depth+1,context:a,parentValue:d,value:b}}var K=null;
+function oa(a){return a._currentValue}
+var ra={useMemo:function(a){return a()},useCallback:function(a){return a},useDebugValue:function(){},useDeferredValue:L,useTransition:L,getCacheForType:function(a){if(!M)throw Error("Reading the cache is only supported while rendering.");var b=M.get(a);void 0===b&&(b=a(),M.set(a,b));return b},readContext:oa,useContext:oa,useReducer:L,useRef:L,useState:L,useInsertionEffect:L,useLayoutEffect:L,useImperativeHandle:L,useEffect:L,useId:pa,useMutableSource:L,useSyncExternalStore:L,useCacheRefresh:function(){return qa}};
+function L(){throw Error("This Hook is not supported in Server Components.");}function qa(){if(!M)throw Error("Refreshing the cache is not supported in Server Components.");}var M=null;function pa(){if(null===K)throw Error("useId can only be used while React is rendering");var a=K.identifierCount++;return":"+K.identifierPrefix+"S"+a.toString(32)+":"}var sa=e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,N=sa.ContextRegistry,O=sa.ReactCurrentDispatcher;function ta(a){console.error(a)}
+function ua(a,b,d,c,f){var g=new Set,h=[],k={status:0,fatalError:null,destination:null,bundlerConfig:b,cache:new Map,nextChunkId:0,pendingChunks:0,abortableTasks:g,pingedTasks:h,completedModuleChunks:[],completedJSONChunks:[],completedErrorChunks:[],writtenSymbols:new Map,writtenModules:new Map,writtenProviders:new Map,identifierPrefix:f||"",identifierCount:1,onError:void 0===d?ta:d,toJSON:function(a,b){return va(k,this,a,b)}};k.pendingChunks++;b=wa(c);a=xa(k,a,b,g);h.push(a);return k}var ya={};
+function P(a,b,d,c){if(null!==d&&void 0!==d)throw Error("Refs cannot be used in server components, nor passed to client components.");if("function"===typeof a)return x(a)?[y,a,b,c]:a(c);if("string"===typeof a)return[y,a,b,c];if("symbol"===typeof a)return a===ca?c.children:[y,a,b,c];if(null!=a&&"object"===typeof a){if(x(a))return[y,a,b,c];switch(a.$$typeof){case A:var f=a._init;a=f(a._payload);return P(a,b,d,c);case da:return b=a.render,b(c,void 0);case ea:return P(a.type,b,d,c);case z:return na(a._context,
+c.value),[y,a,b,{value:c.value,children:c.children,__pop:ya}]}}throw Error("Unsupported server component type: "+R(a));}function xa(a,b,d,c){var f={id:a.nextChunkId++,status:0,model:b,context:d,ping:function(){var b=a.pingedTasks;b.push(f);1===b.length&&za(a)}};c.add(f);return f}function Aa(a){return Object.prototype.toString.call(a).replace(/^\[object (.*)\]$/,function(a,d){return d})}function U(a){var b=JSON.stringify(a);return'"'+a+'"'===b?a:b}
+function R(a){switch(typeof a){case "string":return JSON.stringify(10>=a.length?a:a.substr(0,10)+"...");case "object":if(ha(a))return"[...]";a=Aa(a);return"Object"===a?"{...}":a;case "function":return"function";default:return String(a)}}
+function V(a,b){if(ha(a)){for(var d="[",c=0;c<a.length;c++){0<c&&(d+=", ");if(6<c){d+="...";break}var f=a[c];d=""+c===b&&"object"===typeof f&&null!==f?d+V(f):d+R(f)}return d+"]"}d="{";c=Object.keys(a);for(f=0;f<c.length;f++){0<f&&(d+=", ");if(6<f){d+="...";break}var g=c[f];d+=U(g)+": ";var h=a[g];d=g===b&&"object"===typeof h&&null!==h?d+V(h):d+R(h)}return d+"}"}
+function va(a,b,d,c){switch(c){case y:return"$"}for(;"object"===typeof c&&null!==c&&(c.$$typeof===y||c.$$typeof===A);)try{switch(c.$$typeof){case y:var f=c;c=P(f.type,f.key,f.ref,f.props);break;case A:var g=c._init;c=g(c._payload)}}catch(t){if("object"===typeof t&&null!==t&&"function"===typeof t.then)return a.pendingChunks++,a=xa(a,c,H,a.abortableTasks),d=a.ping,t.then(d,d),"@"+a.id.toString(16);W(a,t);a.pendingChunks++;d=a.nextChunkId++;X(a,d,t);return"@"+d.toString(16)}if(null==c)return c;if("object"===
+typeof c||x(c)){if(x(c)){f=c;"string"===typeof f&&(f=globalThis.__STRING_REFERENCE_INDEX[f]);f=f.filepath+"#"+f.name;g=a.writtenModules;var h=g.get(f);if(void 0!==h)return b[0]===y&&"1"===d?"@"+h.toString(16):"$"+h.toString(16);try{"string"===typeof c&&(c=globalThis.__STRING_REFERENCE_INDEX[c]);var k={id:c.filepath,name:c.name};a.pendingChunks++;var m=a.nextChunkId++,Q=w(k),S="M"+m.toString(16)+":"+Q+"\n";var T=q.encode(S);a.completedModuleChunks.push(T);g.set(f,m);return b[0]===y&&"1"===d?"@"+m.toString(16):
+"$"+m.toString(16)}catch(t){return a.pendingChunks++,d=a.nextChunkId++,X(a,d,t),"$"+d.toString(16)}}else{if(c.$$typeof===z)return b=c._context._globalName,c=a.writtenProviders,d=c.get(d),void 0===d&&(a.pendingChunks++,d=a.nextChunkId++,c.set(b,d),b="P"+d.toString(16)+":"+b+"\n",b=q.encode(b),a.completedJSONChunks.push(b)),"$"+d.toString(16);if(c===ya){a=H;if(null===a)throw Error("Tried to pop a Context at the root of the app. This is a bug in React.");d=a.parentValue;a.context._currentValue=d===B?
+a.context._defaultValue:d;H=a.parent;return}}return c}if("string"===typeof c)return a="$"===c[0]||"@"===c[0]?"$"+c:c,a;if("boolean"===typeof c||"number"===typeof c||"undefined"===typeof c)return c;if("function"===typeof c){if(/^on[A-Z]/.test(d))throw Error("Event handlers cannot be passed to client component props. Remove "+(U(d)+" from these props if possible: "+V(b)+"\nIf you need interactivity, consider converting part of this to a client component."));throw Error("Functions cannot be passed directly to client components because they're not serializable. Remove "+
+(U(d)+" ("+(c.displayName||c.name||"function")+") from this object, or avoid the entire object: "+V(b)));}if("symbol"===typeof c){k=a.writtenSymbols;m=k.get(c);if(void 0!==m)return"$"+m.toString(16);m=c.description;if(Symbol.for(m)!==c)throw Error("Only global symbols received from Symbol.for(...) can be passed to client components. The symbol Symbol.for("+(c.description+") cannot be found among global symbols. Remove ")+(U(d)+" from this object, or avoid the entire object: "+V(b)));a.pendingChunks++;
+d=a.nextChunkId++;b=w(m);b="S"+d.toString(16)+":"+b+"\n";b=q.encode(b);a.completedModuleChunks.push(b);k.set(c,d);return"$"+d.toString(16)}if("bigint"===typeof c)throw Error("BigInt ("+c+") is not yet supported in client component props. Remove "+(U(d)+" from this object or use a plain number instead: "+V(b)));throw Error("Type "+typeof c+" is not supported in client component props. Remove "+(U(d)+" from this object, or avoid the entire object: "+V(b)));}function W(a,b){a=a.onError;a(b)}
+function Y(a,b){null!==a.destination?(a.status=2,u(a.destination,b)):(a.status=1,a.fatalError=b)}function X(a,b,d){var c="";try{if(d instanceof Error){var f=String(d.message);c=String(d.stack)}else f="Error: "+d}catch(g){f="An error occurred but serializing the error message failed."}d={message:f,stack:c};b="E"+b.toString(16)+":"+w(d)+"\n";b=q.encode(b);a.completedErrorChunks.push(b)}
+function za(a){var b=O.current,d=M;O.current=ra;M=a.cache;K=a;try{var c=a.pingedTasks;a.pingedTasks=[];for(var f=0;f<c.length;f++){var g=c[f];var h=a;if(0===g.status){J(g.context);try{for(var k=g.model;"object"===typeof k&&null!==k&&k.$$typeof===y;){var m=k;g.model=k;k=P(m.type,m.key,m.ref,m.props)}var Q=g.id,S=w(k,h.toJSON),T="J"+Q.toString(16)+":"+S+"\n";var t=q.encode(T);h.completedJSONChunks.push(t);h.abortableTasks.delete(g);g.status=1}catch(v){if("object"===typeof v&&null!==v&&"function"===
+typeof v.then){var ma=g.ping;v.then(ma,ma)}else h.abortableTasks.delete(g),g.status=4,W(h,v),X(h,g.id,v)}}}null!==a.destination&&Z(a,a.destination)}catch(v){W(a,v),Y(a,v)}finally{O.current=b,M=d,K=null}}
+function Z(a,b){l=new Uint8Array(512);n=0;try{for(var d=a.completedModuleChunks,c=0;c<d.length;c++)if(a.pendingChunks--,!p(b,d[c])){a.destination=null;c++;break}d.splice(0,c);var f=a.completedJSONChunks;for(c=0;c<f.length;c++)if(a.pendingChunks--,!p(b,f[c])){a.destination=null;c++;break}f.splice(0,c);var g=a.completedErrorChunks;for(c=0;c<g.length;c++)if(a.pendingChunks--,!p(b,g[c])){a.destination=null;c++;break}g.splice(0,c)}finally{l&&0<n&&(b.enqueue(new Uint8Array(l.buffer,0,n)),l=null,n=0)}0===
+a.pendingChunks&&b.close()}function Ba(a,b){try{var d=a.abortableTasks;if(0<d.size){var c=void 0===b?Error("The render was aborted by the server without a reason."):b;W(a,c);a.pendingChunks++;var f=a.nextChunkId++;X(a,f,c);d.forEach(function(b){b.status=3;var c="$"+f.toString(16);b=b.id;c=w(c);c="J"+b.toString(16)+":"+c+"\n";c=q.encode(c);a.completedJSONChunks.push(c)});d.clear()}null!==a.destination&&Z(a,a.destination)}catch(g){W(a,g),Y(a,g)}}
+function wa(a){if(a){var b=H;J(null);for(var d=0;d<a.length;d++){var c=a[d],f=c[0];c=c[1];N[f]||(N[f]=e.createServerContext(f,B));na(N[f],c)}a=H;J(b);return a}return null}
+exports.renderToReadableStream=function(a,b){var d=ua(aa({},a,{$$typeof:Symbol.for("react.element"),props:{children:a},type:function(){e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher.current.isRsc=!0;return a}}),{},b?b.onError:void 0,b?b.context:void 0,b?b.identifierPrefix:void 0);if(b&&b.signal){var c=b.signal;if(c.aborted)Ba(d,c.reason);else{var f=function(){Ba(d,c.reason);c.removeEventListener("abort",f)};c.addEventListener("abort",f)}}return new ReadableStream({type:"bytes",
+start:function(){za(d)},pull:function(a){if(1===d.status)d.status=2,u(a,d.fatalError);else if(2!==d.status&&null===d.destination){d.destination=a;try{Z(d,a)}catch(h){W(d,h),Y(d,h)}}},cancel:function(){}},{highWaterMark:0})};
diff --git a/vendor/vendor/react-server-dom-vite/cjs/react-server-dom-vite-writer.node.development.server.js b/vendor/vendor/react-server-dom-vite/cjs/react-server-dom-vite-writer.node.development.server.js
new file mode 100644
index 0000000000000000000000000000000000000000..839ce7cb56736e7c2a8b8d4e37b3b70d0d3dcea5
--- /dev/null
+++ b/vendor/vendor/react-server-dom-vite/cjs/react-server-dom-vite-writer.node.development.server.js
@@ -0,0 +1,1945 @@
+/**
+ * @license React
+ * react-server-dom-vite-writer.node.development.server.js
+ *
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+'use strict';
+
+if (process.env.NODE_ENV !== "production") {
+  (function() {
+'use strict';
+
+var React = require('react');
+var util = require('util');
+
+var assign = Object.assign;
+
+var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
+
+function error(format) {
+  {
+    {
+      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
+        args[_key2 - 1] = arguments[_key2];
+      }
+
+      printWarning('error', format, args);
+    }
+  }
+}
+
+function printWarning(level, format, args) {
+  // When changing this logic, you might want to also
+  // update consoleWithStackDev.www.js as well.
+  {
+    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
+    var stack = ReactDebugCurrentFrame.getStackAddendum();
+
+    if (stack !== '') {
+      format += '%s';
+      args = args.concat([stack]);
+    } // eslint-disable-next-line react-internal/safe-string-coercion
+
+
+    var argsWithFormat = args.map(function (item) {
+      return String(item);
+    }); // Careful: RN currently depends on this prefix
+
+    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
+    // breaks IE9: https://github.com/facebook/react/issues/13610
+    // eslint-disable-next-line react-internal/no-production-logging
+
+    Function.prototype.apply.call(console[level], console, argsWithFormat);
+  }
+}
+
+function scheduleWork(callback) {
+  setImmediate(callback);
+}
+function flushBuffered(destination) {
+  // If we don't have any more data to send right now.
+  // Flush whatever is in the buffer to the wire.
+  if (typeof destination.flush === 'function') {
+    // By convention the Zlib streams provide a flush function for this purpose.
+    // For Express, compression middleware adds this method.
+    destination.flush();
+  }
+}
+var VIEW_SIZE = 2048;
+var currentView = null;
+var writtenBytes = 0;
+var destinationHasCapacity = true;
+function beginWriting(destination) {
+  currentView = new Uint8Array(VIEW_SIZE);
+  writtenBytes = 0;
+  destinationHasCapacity = true;
+}
+
+function writeStringChunk(destination, stringChunk) {
+  if (stringChunk.length === 0) {
+    return;
+  } // maximum possible view needed to encode entire string
+
+
+  if (stringChunk.length * 3 > VIEW_SIZE) {
+    if (writtenBytes > 0) {
+      writeToDestination(destination, currentView.subarray(0, writtenBytes));
+      currentView = new Uint8Array(VIEW_SIZE);
+      writtenBytes = 0;
+    }
+
+    writeToDestination(destination, textEncoder.encode(stringChunk));
+    return;
+  }
+
+  var target = currentView;
+
+  if (writtenBytes > 0) {
+    target = currentView.subarray(writtenBytes);
+  }
+
+  var _textEncoder$encodeIn = textEncoder.encodeInto(stringChunk, target),
+      read = _textEncoder$encodeIn.read,
+      written = _textEncoder$encodeIn.written;
+
+  writtenBytes += written;
+
+  if (read < stringChunk.length) {
+    writeToDestination(destination, currentView);
+    currentView = new Uint8Array(VIEW_SIZE);
+    writtenBytes = textEncoder.encodeInto(stringChunk.slice(read), currentView).written;
+  }
+
+  if (writtenBytes === VIEW_SIZE) {
+    writeToDestination(destination, currentView);
+    currentView = new Uint8Array(VIEW_SIZE);
+    writtenBytes = 0;
+  }
+}
+
+function writeViewChunk(destination, chunk) {
+  if (chunk.byteLength === 0) {
+    return;
+  }
+
+  if (chunk.byteLength > VIEW_SIZE) {
+    // this chunk may overflow a single view which implies it was not
+    // one that is cached by the streaming renderer. We will enqueu
+    // it directly and expect it is not re-used
+    if (writtenBytes > 0) {
+      writeToDestination(destination, currentView.subarray(0, writtenBytes));
+      currentView = new Uint8Array(VIEW_SIZE);
+      writtenBytes = 0;
+    }
+
+    writeToDestination(destination, chunk);
+    return;
+  }
+
+  var bytesToWrite = chunk;
+  var allowableBytes = currentView.length - writtenBytes;
+
+  if (allowableBytes < bytesToWrite.byteLength) {
+    // this chunk would overflow the current view. We enqueue a full view
+    // and start a new view with the remaining chunk
+    if (allowableBytes === 0) {
+      // the current view is already full, send it
+      writeToDestination(destination, currentView);
+    } else {
+      // fill up the current view and apply the remaining chunk bytes
+      // to a new view.
+      currentView.set(bytesToWrite.subarray(0, allowableBytes), writtenBytes);
+      writtenBytes += allowableBytes;
+      writeToDestination(destination, currentView);
+      bytesToWrite = bytesToWrite.subarray(allowableBytes);
+    }
+
+    currentView = new Uint8Array(VIEW_SIZE);
+    writtenBytes = 0;
+  }
+
+  currentView.set(bytesToWrite, writtenBytes);
+  writtenBytes += bytesToWrite.byteLength;
+
+  if (writtenBytes === VIEW_SIZE) {
+    writeToDestination(destination, currentView);
+    currentView = new Uint8Array(VIEW_SIZE);
+    writtenBytes = 0;
+  }
+}
+
+function writeChunk(destination, chunk) {
+  if (typeof chunk === 'string') {
+    writeStringChunk(destination, chunk);
+  } else {
+    writeViewChunk(destination, chunk);
+  }
+}
+
+function writeToDestination(destination, view) {
+  var currentHasCapacity = destination.write(view);
+  destinationHasCapacity = destinationHasCapacity && currentHasCapacity;
+}
+
+function writeChunkAndReturn(destination, chunk) {
+  writeChunk(destination, chunk);
+  return destinationHasCapacity;
+}
+function completeWriting(destination) {
+  if (currentView && writtenBytes > 0) {
+    destination.write(currentView.subarray(0, writtenBytes));
+  }
+
+  currentView = null;
+  writtenBytes = 0;
+  destinationHasCapacity = true;
+}
+function close(destination) {
+  destination.end();
+}
+var textEncoder = new util.TextEncoder();
+function stringToChunk(content) {
+  return content;
+}
+function stringToPrecomputedChunk(content) {
+  return textEncoder.encode(content);
+}
+function closeWithError(destination, error) {
+  // $FlowFixMe: This is an Error object or the destination accepts other types.
+  destination.destroy(error);
+}
+
+// This file is an intermediate layer to translate between Flight
+var stringify = JSON.stringify;
+
+function serializeRowHeader(tag, id) {
+  return tag + id.toString(16) + ':';
+}
+
+function processErrorChunk(request, id, message, stack) {
+  var errorInfo = {
+    message: message,
+    stack: stack
+  };
+  var row = serializeRowHeader('E', id) + stringify(errorInfo) + '\n';
+  return stringToChunk(row);
+}
+function processModelChunk(request, id, model) {
+  var json = stringify(model, request.toJSON);
+  var row = serializeRowHeader('J', id) + json + '\n';
+  return stringToChunk(row);
+}
+function processReferenceChunk(request, id, reference) {
+  var json = stringify(reference);
+  var row = serializeRowHeader('J', id) + json + '\n';
+  return stringToChunk(row);
+}
+function processModuleChunk(request, id, moduleMetaData) {
+  var json = stringify(moduleMetaData);
+  var row = serializeRowHeader('M', id) + json + '\n';
+  return stringToChunk(row);
+}
+function processProviderChunk(request, id, contextName) {
+  var row = serializeRowHeader('P', id) + contextName + '\n';
+  return stringToChunk(row);
+}
+function processSymbolChunk(request, id, name) {
+  var json = stringify(name);
+  var row = serializeRowHeader('S', id) + json + '\n';
+  return stringToChunk(row);
+}
+
+// eslint-disable-next-line no-unused-vars
+var MODULE_TAG = Symbol.for('react.module.reference');
+function getModuleKey(reference) {
+  if (typeof reference === 'string') reference = globalThis.__STRING_REFERENCE_INDEX[reference];
+  return reference.filepath + '#' + reference.name;
+}
+function isModuleReference(reference) {
+  if (typeof reference === 'string') return !!globalThis.__STRING_REFERENCE_INDEX[reference];
+  return reference.$$typeof === MODULE_TAG;
+}
+function resolveModuleMetaData(config, moduleReference) {
+  if (typeof moduleReference === 'string') moduleReference = globalThis.__STRING_REFERENCE_INDEX[moduleReference];
+  return {
+    id: moduleReference.filepath,
+    name: moduleReference.name
+  };
+}
+
+// ATTENTION
+// When adding new symbols to this file,
+// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
+// The Symbol used to tag the ReactElement-like types.
+var REACT_ELEMENT_TYPE = Symbol.for('react.element');
+var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
+var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
+var REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');
+var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
+var REACT_MEMO_TYPE = Symbol.for('react.memo');
+var REACT_LAZY_TYPE = Symbol.for('react.lazy');
+var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for('react.default_value');
+
+// A reserved attribute.
+// It is handled by React separately and shouldn't be written to the DOM.
+var RESERVED = 0; // A simple string attribute.
+// Attributes that aren't in the filter are presumed to have this type.
+
+var STRING = 1; // A string attribute that accepts booleans in React. In HTML, these are called
+// "enumerated" attributes with "true" and "false" as possible values.
+// When true, it should be set to a "true" string.
+// When false, it should be set to a "false" string.
+
+var BOOLEANISH_STRING = 2; // A real boolean attribute.
+// When true, it should be present (set either to an empty string or its name).
+// When false, it should be omitted.
+
+var BOOLEAN = 3; // An attribute that can be used as a flag as well as with a value.
+// When true, it should be present (set either to an empty string or its name).
+// When false, it should be omitted.
+// For any other value, should be present with that value.
+
+var OVERLOADED_BOOLEAN = 4; // An attribute that must be numeric or parse as a numeric.
+// When falsy, it should be removed.
+
+var NUMERIC = 5; // An attribute that must be positive numeric or parse as a positive numeric.
+// When falsy, it should be removed.
+
+var POSITIVE_NUMERIC = 6;
+
+function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL, removeEmptyString) {
+  this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
+  this.attributeName = attributeName;
+  this.attributeNamespace = attributeNamespace;
+  this.mustUseProperty = mustUseProperty;
+  this.propertyName = name;
+  this.type = type;
+  this.sanitizeURL = sanitizeURL;
+  this.removeEmptyString = removeEmptyString;
+} // When adding attributes to this list, be sure to also add them to
+// the `possibleStandardNames` module to ensure casing and incorrect
+// name warnings.
+
+
+var properties = {}; // These props are reserved by React. They shouldn't be written to the DOM.
+
+var reservedProps = ['children', 'dangerouslySetInnerHTML', // TODO: This prevents the assignment of defaultValue to regular
+// elements (not just inputs). Now that ReactDOMInput assigns to the
+// defaultValue property -- do we need this?
+'defaultValue', 'defaultChecked', 'innerHTML', 'suppressContentEditableWarning', 'suppressHydrationWarning', 'style'];
+
+{
+  reservedProps.push('innerText', 'textContent');
+}
+
+reservedProps.forEach(function (name) {
+  properties[name] = new PropertyInfoRecord(name, RESERVED, false, // mustUseProperty
+  name, // attributeName
+  null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+}); // A few React string attributes have a different name.
+// This is a mapping from React prop names to the attribute names.
+
+[['acceptCharset', 'accept-charset'], ['className', 'class'], ['htmlFor', 'for'], ['httpEquiv', 'http-equiv']].forEach(function (_ref) {
+  var name = _ref[0],
+      attributeName = _ref[1];
+  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
+  attributeName, // attributeName
+  null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+}); // These are "enumerated" HTML attributes that accept "true" and "false".
+// In React, we let users pass `true` and `false` even though technically
+// these aren't boolean attributes (they are coerced to strings).
+
+['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(function (name) {
+  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty
+  name.toLowerCase(), // attributeName
+  null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+}); // These are "enumerated" SVG attributes that accept "true" and "false".
+// In React, we let users pass `true` and `false` even though technically
+// these aren't boolean attributes (they are coerced to strings).
+// Since these are SVG attributes, their attribute names are case-sensitive.
+
+['autoReverse', 'externalResourcesRequired', 'focusable', 'preserveAlpha'].forEach(function (name) {
+  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty
+  name, // attributeName
+  null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+}); // These are HTML boolean attributes.
+
+['allowFullScreen', 'async', // Note: there is a special case that prevents it from being written to the DOM
+// on the client side because the browsers are inconsistent. Instead we call focus().
+'autoFocus', 'autoPlay', 'controls', 'default', 'defer', 'disabled', 'disablePictureInPicture', 'disableRemotePlayback', 'formNoValidate', 'hidden', 'loop', 'noModule', 'noValidate', 'open', 'playsInline', 'readOnly', 'required', 'reversed', 'scoped', 'seamless', // Microdata
+'itemScope'].forEach(function (name) {
+  properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, // mustUseProperty
+  name.toLowerCase(), // attributeName
+  null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+}); // These are the few React props that we set as DOM properties
+// rather than attributes. These are all booleans.
+
+['checked', // Note: `option.selected` is not updated if `select.multiple` is
+// disabled with `removeAttribute`. We have special logic for handling this.
+'multiple', 'muted', 'selected' // NOTE: if you add a camelCased prop to this list,
+// you'll need to set attributeName to name.toLowerCase()
+// instead in the assignment below.
+].forEach(function (name) {
+  properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, // mustUseProperty
+  name, // attributeName
+  null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+}); // These are HTML attributes that are "overloaded booleans": they behave like
+// booleans, but can also accept a string value.
+
+['capture', 'download' // NOTE: if you add a camelCased prop to this list,
+// you'll need to set attributeName to name.toLowerCase()
+// instead in the assignment below.
+].forEach(function (name) {
+  properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, // mustUseProperty
+  name, // attributeName
+  null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+}); // These are HTML attributes that must be positive numbers.
+
+['cols', 'rows', 'size', 'span' // NOTE: if you add a camelCased prop to this list,
+// you'll need to set attributeName to name.toLowerCase()
+// instead in the assignment below.
+].forEach(function (name) {
+  properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, // mustUseProperty
+  name, // attributeName
+  null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+}); // These are HTML attributes that must be numbers.
+
+['rowSpan', 'start'].forEach(function (name) {
+  properties[name] = new PropertyInfoRecord(name, NUMERIC, false, // mustUseProperty
+  name.toLowerCase(), // attributeName
+  null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+});
+var CAMELIZE = /[\-\:]([a-z])/g;
+
+var capitalize = function (token) {
+  return token[1].toUpperCase();
+}; // This is a list of all SVG attributes that need special casing, namespacing,
+// or boolean value assignment. Regular attributes that just accept strings
+// and have the same names are omitted, just like in the HTML attribute filter.
+// Some of these attributes can be hard to find. This list was created by
+// scraping the MDN documentation.
+
+
+['accent-height', 'alignment-baseline', 'arabic-form', 'baseline-shift', 'cap-height', 'clip-path', 'clip-rule', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'dominant-baseline', 'enable-background', 'fill-opacity', 'fill-rule', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'glyph-name', 'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'horiz-adv-x', 'horiz-origin-x', 'image-rendering', 'letter-spacing', 'lighting-color', 'marker-end', 'marker-mid', 'marker-start', 'overline-position', 'overline-thickness', 'paint-order', 'panose-1', 'pointer-events', 'rendering-intent', 'shape-rendering', 'stop-color', 'stop-opacity', 'strikethrough-position', 'strikethrough-thickness', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'text-anchor', 'text-decoration', 'text-rendering', 'underline-position', 'underline-thickness', 'unicode-bidi', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'vector-effect', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'word-spacing', 'writing-mode', 'xmlns:xlink', 'x-height' // NOTE: if you add a camelCased prop to this list,
+// you'll need to set attributeName to name.toLowerCase()
+// instead in the assignment below.
+].forEach(function (attributeName) {
+  var name = attributeName.replace(CAMELIZE, capitalize);
+  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
+  attributeName, null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+}); // String SVG attributes with the xlink namespace.
+
+['xlink:actuate', 'xlink:arcrole', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type' // NOTE: if you add a camelCased prop to this list,
+// you'll need to set attributeName to name.toLowerCase()
+// instead in the assignment below.
+].forEach(function (attributeName) {
+  var name = attributeName.replace(CAMELIZE, capitalize);
+  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
+  attributeName, 'http://www.w3.org/1999/xlink', false, // sanitizeURL
+  false);
+}); // String SVG attributes with the xml namespace.
+
+['xml:base', 'xml:lang', 'xml:space' // NOTE: if you add a camelCased prop to this list,
+// you'll need to set attributeName to name.toLowerCase()
+// instead in the assignment below.
+].forEach(function (attributeName) {
+  var name = attributeName.replace(CAMELIZE, capitalize);
+  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
+  attributeName, 'http://www.w3.org/XML/1998/namespace', false, // sanitizeURL
+  false);
+}); // These attribute exists both in HTML and SVG.
+// The attribute name is case-sensitive in SVG so we can't just use
+// the React name like we do for attributes that exist only in HTML.
+
+['tabIndex', 'crossOrigin'].forEach(function (attributeName) {
+  properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, // mustUseProperty
+  attributeName.toLowerCase(), // attributeName
+  null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+}); // These attributes accept URLs. These must not allow javascript: URLS.
+// These will also need to accept Trusted Types object in the future.
+
+var xlinkHref = 'xlinkHref';
+properties[xlinkHref] = new PropertyInfoRecord('xlinkHref', STRING, false, // mustUseProperty
+'xlink:href', 'http://www.w3.org/1999/xlink', true, // sanitizeURL
+false);
+['src', 'href', 'action', 'formAction'].forEach(function (attributeName) {
+  properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, // mustUseProperty
+  attributeName.toLowerCase(), // attributeName
+  null, // attributeNamespace
+  true, // sanitizeURL
+  true);
+});
+
+/**
+ * CSS properties which accept numbers but are not in units of "px".
+ */
+var isUnitlessNumber = {
+  animationIterationCount: true,
+  aspectRatio: true,
+  borderImageOutset: true,
+  borderImageSlice: true,
+  borderImageWidth: true,
+  boxFlex: true,
+  boxFlexGroup: true,
+  boxOrdinalGroup: true,
+  columnCount: true,
+  columns: true,
+  flex: true,
+  flexGrow: true,
+  flexPositive: true,
+  flexShrink: true,
+  flexNegative: true,
+  flexOrder: true,
+  gridArea: true,
+  gridRow: true,
+  gridRowEnd: true,
+  gridRowSpan: true,
+  gridRowStart: true,
+  gridColumn: true,
+  gridColumnEnd: true,
+  gridColumnSpan: true,
+  gridColumnStart: true,
+  fontWeight: true,
+  lineClamp: true,
+  lineHeight: true,
+  opacity: true,
+  order: true,
+  orphans: true,
+  tabSize: true,
+  widows: true,
+  zIndex: true,
+  zoom: true,
+  // SVG-related properties
+  fillOpacity: true,
+  floodOpacity: true,
+  stopOpacity: true,
+  strokeDasharray: true,
+  strokeDashoffset: true,
+  strokeMiterlimit: true,
+  strokeOpacity: true,
+  strokeWidth: true
+};
+/**
+ * @param {string} prefix vendor-specific prefix, eg: Webkit
+ * @param {string} key style name, eg: transitionDuration
+ * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
+ * WebkitTransitionDuration
+ */
+
+function prefixKey(prefix, key) {
+  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
+}
+/**
+ * Support style names that may come passed in prefixed by adding permutations
+ * of vendor prefixes.
+ */
+
+
+var prefixes = ['Webkit', 'ms', 'Moz', 'O']; // Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
+// infinite loop, because it iterates over the newly added props too.
+
+Object.keys(isUnitlessNumber).forEach(function (prop) {
+  prefixes.forEach(function (prefix) {
+    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
+  });
+});
+
+var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare
+
+function isArray(a) {
+  return isArrayImpl(a);
+}
+
+var startInlineScript = stringToPrecomputedChunk('<script>');
+var endInlineScript = stringToPrecomputedChunk('</script>');
+var startScriptSrc = stringToPrecomputedChunk('<script src="');
+var startModuleSrc = stringToPrecomputedChunk('<script type="module" src="');
+var scriptIntegirty = stringToPrecomputedChunk('" integrity="');
+var endAsyncScript = stringToPrecomputedChunk('" async=""></script>');
+
+var textSeparator = stringToPrecomputedChunk('<!-- -->');
+
+var styleAttributeStart = stringToPrecomputedChunk(' style="');
+var styleAssign = stringToPrecomputedChunk(':');
+var styleSeparator = stringToPrecomputedChunk(';');
+
+var attributeSeparator = stringToPrecomputedChunk(' ');
+var attributeAssign = stringToPrecomputedChunk('="');
+var attributeEnd = stringToPrecomputedChunk('"');
+var attributeEmptyString = stringToPrecomputedChunk('=""');
+
+var endOfStartTag = stringToPrecomputedChunk('>');
+var endOfStartTagSelfClosing = stringToPrecomputedChunk('/>');
+
+var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=""');
+
+var leadingNewline = stringToPrecomputedChunk('\n');
+
+var DOCTYPE = stringToPrecomputedChunk('<!DOCTYPE html>');
+var endTag1 = stringToPrecomputedChunk('</');
+var endTag2 = stringToPrecomputedChunk('>');
+// A placeholder is a node inside a hidden partial tree that can be filled in later, but before
+// display. It's never visible to users. We use the template tag because it can be used in every
+// type of parent. <script> tags also work in every other tag except <colgroup>.
+
+var placeholder1 = stringToPrecomputedChunk('<template id="');
+var placeholder2 = stringToPrecomputedChunk('"></template>');
+
+var startCompletedSuspenseBoundary = stringToPrecomputedChunk('<!--$-->');
+var startPendingSuspenseBoundary1 = stringToPrecomputedChunk('<!--$?--><template id="');
+var startPendingSuspenseBoundary2 = stringToPrecomputedChunk('"></template>');
+var startClientRenderedSuspenseBoundary = stringToPrecomputedChunk('<!--$!-->');
+var endSuspenseBoundary = stringToPrecomputedChunk('<!--/$-->');
+var clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk('<template');
+var clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('"');
+var clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst="');
+var clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg="');
+var clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck="');
+var clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk('></template>');
+var startSegmentHTML = stringToPrecomputedChunk('<div hidden id="');
+var startSegmentHTML2 = stringToPrecomputedChunk('">');
+var endSegmentHTML = stringToPrecomputedChunk('</div>');
+var startSegmentSVG = stringToPrecomputedChunk('<svg aria-hidden="true" style="display:none" id="');
+var startSegmentSVG2 = stringToPrecomputedChunk('">');
+var endSegmentSVG = stringToPrecomputedChunk('</svg>');
+var startSegmentMathML = stringToPrecomputedChunk('<math aria-hidden="true" style="display:none" id="');
+var startSegmentMathML2 = stringToPrecomputedChunk('">');
+var endSegmentMathML = stringToPrecomputedChunk('</math>');
+var startSegmentTable = stringToPrecomputedChunk('<table hidden id="');
+var startSegmentTable2 = stringToPrecomputedChunk('">');
+var endSegmentTable = stringToPrecomputedChunk('</table>');
+var startSegmentTableBody = stringToPrecomputedChunk('<table hidden><tbody id="');
+var startSegmentTableBody2 = stringToPrecomputedChunk('">');
+var endSegmentTableBody = stringToPrecomputedChunk('</tbody></table>');
+var startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id="');
+var startSegmentTableRow2 = stringToPrecomputedChunk('">');
+var endSegmentTableRow = stringToPrecomputedChunk('</tr></table>');
+var startSegmentColGroup = stringToPrecomputedChunk('<table hidden><colgroup id="');
+var startSegmentColGroup2 = stringToPrecomputedChunk('">');
+var endSegmentColGroup = stringToPrecomputedChunk('</colgroup></table>');
+// The following code is the source scripts that we then minify and inline below,
+// with renamed function names that we hope don't collide:
+// const COMMENT_NODE = 8;
+// const SUSPENSE_START_DATA = '$';
+// const SUSPENSE_END_DATA = '/$';
+// const SUSPENSE_PENDING_START_DATA = '$?';
+// const SUSPENSE_FALLBACK_START_DATA = '$!';
+//
+// function clientRenderBoundary(suspenseBoundaryID, errorDigest, errorMsg, errorComponentStack) {
+//   // Find the fallback's first element.
+//   const suspenseIdNode = document.getElementById(suspenseBoundaryID);
+//   if (!suspenseIdNode) {
+//     // The user must have already navigated away from this tree.
+//     // E.g. because the parent was hydrated.
+//     return;
+//   }
+//   // Find the boundary around the fallback. This is always the previous node.
+//   const suspenseNode = suspenseIdNode.previousSibling;
+//   // Tag it to be client rendered.
+//   suspenseNode.data = SUSPENSE_FALLBACK_START_DATA;
+//   // assign error metadata to first sibling
+//   let dataset = suspenseIdNode.dataset;
+//   if (errorDigest) dataset.dgst = errorDigest;
+//   if (errorMsg) dataset.msg = errorMsg;
+//   if (errorComponentStack) dataset.stck = errorComponentStack;
+//   // Tell React to retry it if the parent already hydrated.
+//   if (suspenseNode._reactRetry) {
+//     suspenseNode._reactRetry();
+//   }
+// }
+//
+// function completeBoundary(suspenseBoundaryID, contentID) {
+//   // Find the fallback's first element.
+//   const suspenseIdNode = document.getElementById(suspenseBoundaryID);
+//   const contentNode = document.getElementById(contentID);
+//   // We'll detach the content node so that regardless of what happens next we don't leave in the tree.
+//   // This might also help by not causing recalcing each time we move a child from here to the target.
+//   contentNode.parentNode.removeChild(contentNode);
+//   if (!suspenseIdNode) {
+//     // The user must have already navigated away from this tree.
+//     // E.g. because the parent was hydrated. That's fine there's nothing to do
+//     // but we have to make sure that we already deleted the container node.
+//     return;
+//   }
+//   // Find the boundary around the fallback. This is always the previous node.
+//   const suspenseNode = suspenseIdNode.previousSibling;
+//
+//   // Clear all the existing children. This is complicated because
+//   // there can be embedded Suspense boundaries in the fallback.
+//   // This is similar to clearSuspenseBoundary in ReactDOMHostConfig.
+//   // TODO: We could avoid this if we never emitted suspense boundaries in fallback trees.
+//   // They never hydrate anyway. However, currently we support incrementally loading the fallback.
+//   const parentInstance = suspenseNode.parentNode;
+//   let node = suspenseNode.nextSibling;
+//   let depth = 0;
+//   do {
+//     if (node && node.nodeType === COMMENT_NODE) {
+//       const data = node.data;
+//       if (data === SUSPENSE_END_DATA) {
+//         if (depth === 0) {
+//           break;
+//         } else {
+//           depth--;
+//         }
+//       } else if (
+//         data === SUSPENSE_START_DATA ||
+//         data === SUSPENSE_PENDING_START_DATA ||
+//         data === SUSPENSE_FALLBACK_START_DATA
+//       ) {
+//         depth++;
+//       }
+//     }
+//
+//     const nextNode = node.nextSibling;
+//     parentInstance.removeChild(node);
+//     node = nextNode;
+//   } while (node);
+//
+//   const endOfBoundary = node;
+//
+//   // Insert all the children from the contentNode between the start and end of suspense boundary.
+//   while (contentNode.firstChild) {
+//     parentInstance.insertBefore(contentNode.firstChild, endOfBoundary);
+//   }
+//   suspenseNode.data = SUSPENSE_START_DATA;
+//   if (suspenseNode._reactRetry) {
+//     suspenseNode._reactRetry();
+//   }
+// }
+//
+// function completeSegment(containerID, placeholderID) {
+//   const segmentContainer = document.getElementById(containerID);
+//   const placeholderNode = document.getElementById(placeholderID);
+//   // We always expect both nodes to exist here because, while we might
+//   // have navigated away from the main tree, we still expect the detached
+//   // tree to exist.
+//   segmentContainer.parentNode.removeChild(segmentContainer);
+//   while (segmentContainer.firstChild) {
+//     placeholderNode.parentNode.insertBefore(
+//       segmentContainer.firstChild,
+//       placeholderNode,
+//     );
+//   }
+//   placeholderNode.parentNode.removeChild(placeholderNode);
+// }
+
+var completeSegmentFunction = 'function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}';
+var completeBoundaryFunction = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}';
+var clientRenderFunction = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}';
+var completeSegmentScript1Full = stringToPrecomputedChunk(completeSegmentFunction + ';$RS("');
+var completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("');
+var completeSegmentScript2 = stringToPrecomputedChunk('","');
+var completeSegmentScript3 = stringToPrecomputedChunk('")</script>');
+var completeBoundaryScript1Full = stringToPrecomputedChunk(completeBoundaryFunction + ';$RC("');
+var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("');
+var completeBoundaryScript2 = stringToPrecomputedChunk('","');
+var completeBoundaryScript3 = stringToPrecomputedChunk('")</script>');
+var clientRenderScript1Full = stringToPrecomputedChunk(clientRenderFunction + ';$RX("');
+var clientRenderScript1Partial = stringToPrecomputedChunk('$RX("');
+var clientRenderScript1A = stringToPrecomputedChunk('"');
+var clientRenderScript2 = stringToPrecomputedChunk(')</script>');
+var clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(',');
+
+var rendererSigil;
+
+{
+  // Use this to detect multiple renderers using the same context
+  rendererSigil = {};
+} // Used to store the parent path of all context overrides in a shared linked list.
+// Forming a reverse tree.
+
+
+var rootContextSnapshot = null; // We assume that this runtime owns the "current" field on all ReactContext instances.
+// This global (actually thread local) state represents what state all those "current",
+// fields are currently in.
+
+var currentActiveSnapshot = null;
+
+function popNode(prev) {
+  {
+    prev.context._currentValue = prev.parentValue;
+  }
+}
+
+function pushNode(next) {
+  {
+    next.context._currentValue = next.value;
+  }
+}
+
+function popToNearestCommonAncestor(prev, next) {
+  if (prev === next) ; else {
+    popNode(prev);
+    var parentPrev = prev.parent;
+    var parentNext = next.parent;
+
+    if (parentPrev === null) {
+      if (parentNext !== null) {
+        throw new Error('The stacks must reach the root at the same time. This is a bug in React.');
+      }
+    } else {
+      if (parentNext === null) {
+        throw new Error('The stacks must reach the root at the same time. This is a bug in React.');
+      }
+
+      popToNearestCommonAncestor(parentPrev, parentNext); // On the way back, we push the new ones that weren't common.
+
+      pushNode(next);
+    }
+  }
+}
+
+function popAllPrevious(prev) {
+  popNode(prev);
+  var parentPrev = prev.parent;
+
+  if (parentPrev !== null) {
+    popAllPrevious(parentPrev);
+  }
+}
+
+function pushAllNext(next) {
+  var parentNext = next.parent;
+
+  if (parentNext !== null) {
+    pushAllNext(parentNext);
+  }
+
+  pushNode(next);
+}
+
+function popPreviousToCommonLevel(prev, next) {
+  popNode(prev);
+  var parentPrev = prev.parent;
+
+  if (parentPrev === null) {
+    throw new Error('The depth must equal at least at zero before reaching the root. This is a bug in React.');
+  }
+
+  if (parentPrev.depth === next.depth) {
+    // We found the same level. Now we just need to find a shared ancestor.
+    popToNearestCommonAncestor(parentPrev, next);
+  } else {
+    // We must still be deeper.
+    popPreviousToCommonLevel(parentPrev, next);
+  }
+}
+
+function popNextToCommonLevel(prev, next) {
+  var parentNext = next.parent;
+
+  if (parentNext === null) {
+    throw new Error('The depth must equal at least at zero before reaching the root. This is a bug in React.');
+  }
+
+  if (prev.depth === parentNext.depth) {
+    // We found the same level. Now we just need to find a shared ancestor.
+    popToNearestCommonAncestor(prev, parentNext);
+  } else {
+    // We must still be deeper.
+    popNextToCommonLevel(prev, parentNext);
+  }
+
+  pushNode(next);
+} // Perform context switching to the new snapshot.
+// To make it cheap to read many contexts, while not suspending, we make the switch eagerly by
+// updating all the context's current values. That way reads, always just read the current value.
+// At the cost of updating contexts even if they're never read by this subtree.
+
+
+function switchContext(newSnapshot) {
+  // The basic algorithm we need to do is to pop back any contexts that are no longer on the stack.
+  // We also need to update any new contexts that are now on the stack with the deepest value.
+  // The easiest way to update new contexts is to just reapply them in reverse order from the
+  // perspective of the backpointers. To avoid allocating a lot when switching, we use the stack
+  // for that. Therefore this algorithm is recursive.
+  // 1) First we pop which ever snapshot tree was deepest. Popping old contexts as we go.
+  // 2) Then we find the nearest common ancestor from there. Popping old contexts as we go.
+  // 3) Then we reapply new contexts on the way back up the stack.
+  var prev = currentActiveSnapshot;
+  var next = newSnapshot;
+
+  if (prev !== next) {
+    if (prev === null) {
+      // $FlowFixMe: This has to be non-null since it's not equal to prev.
+      pushAllNext(next);
+    } else if (next === null) {
+      popAllPrevious(prev);
+    } else if (prev.depth === next.depth) {
+      popToNearestCommonAncestor(prev, next);
+    } else if (prev.depth > next.depth) {
+      popPreviousToCommonLevel(prev, next);
+    } else {
+      popNextToCommonLevel(prev, next);
+    }
+
+    currentActiveSnapshot = next;
+  }
+}
+function pushProvider(context, nextValue) {
+  var prevValue;
+
+  {
+    prevValue = context._currentValue;
+    context._currentValue = nextValue;
+
+    {
+      if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
+        error('Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.');
+      }
+
+      context._currentRenderer = rendererSigil;
+    }
+  }
+
+  var prevNode = currentActiveSnapshot;
+  var newNode = {
+    parent: prevNode,
+    depth: prevNode === null ? 0 : prevNode.depth + 1,
+    context: context,
+    parentValue: prevValue,
+    value: nextValue
+  };
+  currentActiveSnapshot = newNode;
+  return newNode;
+}
+function popProvider() {
+  var prevSnapshot = currentActiveSnapshot;
+
+  if (prevSnapshot === null) {
+    throw new Error('Tried to pop a Context at the root of the app. This is a bug in React.');
+  }
+
+  {
+    var value = prevSnapshot.parentValue;
+
+    if (value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
+      prevSnapshot.context._currentValue = prevSnapshot.context._defaultValue;
+    } else {
+      prevSnapshot.context._currentValue = value;
+    }
+  }
+
+  return currentActiveSnapshot = prevSnapshot.parent;
+}
+function getActiveContext() {
+  return currentActiveSnapshot;
+}
+function readContext(context) {
+  var value =  context._currentValue ;
+  return value;
+}
+
+var currentRequest = null;
+function prepareToUseHooksForRequest(request) {
+  currentRequest = request;
+}
+function resetHooksForRequest() {
+  currentRequest = null;
+}
+
+function readContext$1(context) {
+  {
+    if (context.$$typeof !== REACT_SERVER_CONTEXT_TYPE) {
+      error('Only ServerContext is supported in Flight');
+    }
+
+    if (currentCache === null) {
+      error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');
+    }
+  }
+
+  return readContext(context);
+}
+
+var Dispatcher = {
+  useMemo: function (nextCreate) {
+    return nextCreate();
+  },
+  useCallback: function (callback) {
+    return callback;
+  },
+  useDebugValue: function () {},
+  useDeferredValue: unsupportedHook,
+  useTransition: unsupportedHook,
+  getCacheForType: function (resourceType) {
+    if (!currentCache) {
+      throw new Error('Reading the cache is only supported while rendering.');
+    }
+
+    var entry = currentCache.get(resourceType);
+
+    if (entry === undefined) {
+      entry = resourceType(); // TODO: Warn if undefined?
+
+      currentCache.set(resourceType, entry);
+    }
+
+    return entry;
+  },
+  readContext: readContext$1,
+  useContext: readContext$1,
+  useReducer: unsupportedHook,
+  useRef: unsupportedHook,
+  useState: unsupportedHook,
+  useInsertionEffect: unsupportedHook,
+  useLayoutEffect: unsupportedHook,
+  useImperativeHandle: unsupportedHook,
+  useEffect: unsupportedHook,
+  useId: useId,
+  useMutableSource: unsupportedHook,
+  useSyncExternalStore: unsupportedHook,
+  useCacheRefresh: function () {
+    return unsupportedRefresh;
+  }
+};
+
+function unsupportedHook() {
+  throw new Error('This Hook is not supported in Server Components.');
+}
+
+function unsupportedRefresh() {
+  if (!currentCache) {
+    throw new Error('Refreshing the cache is not supported in Server Components.');
+  }
+}
+
+var currentCache = null;
+function setCurrentCache(cache) {
+  currentCache = cache;
+  return currentCache;
+}
+function getCurrentCache() {
+  return currentCache;
+}
+
+function useId() {
+  if (currentRequest === null) {
+    throw new Error('useId can only be used while React is rendering');
+  }
+
+  var id = currentRequest.identifierCount++; // use 'S' for Flight components to distinguish from 'R' and 'r' in Fizz/Client
+
+  return ':' + currentRequest.identifierPrefix + 'S' + id.toString(32) + ':';
+}
+
+var ContextRegistry = ReactSharedInternals.ContextRegistry;
+function getOrCreateServerContext(globalName) {
+  if (!ContextRegistry[globalName]) {
+    ContextRegistry[globalName] = React.createServerContext(globalName, REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED);
+  }
+
+  return ContextRegistry[globalName];
+}
+
+var PENDING = 0;
+var COMPLETED = 1;
+var ABORTED = 3;
+var ERRORED = 4;
+var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
+
+function defaultErrorHandler(error) {
+  console['error'](error); // Don't transform to our wrapper
+}
+
+var OPEN = 0;
+var CLOSING = 1;
+var CLOSED = 2;
+function createRequest(model, bundlerConfig, onError, context, identifierPrefix) {
+  var abortSet = new Set();
+  var pingedTasks = [];
+  var request = {
+    status: OPEN,
+    fatalError: null,
+    destination: null,
+    bundlerConfig: bundlerConfig,
+    cache: new Map(),
+    nextChunkId: 0,
+    pendingChunks: 0,
+    abortableTasks: abortSet,
+    pingedTasks: pingedTasks,
+    completedModuleChunks: [],
+    completedJSONChunks: [],
+    completedErrorChunks: [],
+    writtenSymbols: new Map(),
+    writtenModules: new Map(),
+    writtenProviders: new Map(),
+    identifierPrefix: identifierPrefix || '',
+    identifierCount: 1,
+    onError: onError === undefined ? defaultErrorHandler : onError,
+    toJSON: function (key, value) {
+      return resolveModelToJSON(request, this, key, value);
+    }
+  };
+  request.pendingChunks++;
+  var rootContext = createRootContext(context);
+  var rootTask = createTask(request, model, rootContext, abortSet);
+  pingedTasks.push(rootTask);
+  return request;
+}
+
+function createRootContext(reqContext) {
+  return importServerContexts(reqContext);
+}
+
+var POP = {};
+
+function attemptResolveElement(type, key, ref, props) {
+  if (ref !== null && ref !== undefined) {
+    // When the ref moves to the regular props object this will implicitly
+    // throw for functions. We could probably relax it to a DEV warning for other
+    // cases.
+    throw new Error('Refs cannot be used in server components, nor passed to client components.');
+  }
+
+  if (typeof type === 'function') {
+    if (isModuleReference(type)) {
+      // This is a reference to a client component.
+      return [REACT_ELEMENT_TYPE, type, key, props];
+    } // This is a server-side component.
+
+
+    return type(props);
+  } else if (typeof type === 'string') {
+    // This is a host element. E.g. HTML.
+    return [REACT_ELEMENT_TYPE, type, key, props];
+  } else if (typeof type === 'symbol') {
+    if (type === REACT_FRAGMENT_TYPE) {
+      // For key-less fragments, we add a small optimization to avoid serializing
+      // it as a wrapper.
+      // TODO: If a key is specified, we should propagate its key to any children.
+      // Same as if a server component has a key.
+      return props.children;
+    } // This might be a built-in React component. We'll let the client decide.
+    // Any built-in works as long as its props are serializable.
+
+
+    return [REACT_ELEMENT_TYPE, type, key, props];
+  } else if (type != null && typeof type === 'object') {
+    if (isModuleReference(type)) {
+      // This is a reference to a client component.
+      return [REACT_ELEMENT_TYPE, type, key, props];
+    }
+
+    switch (type.$$typeof) {
+      case REACT_LAZY_TYPE:
+        {
+          var payload = type._payload;
+          var init = type._init;
+          var wrappedType = init(payload);
+          return attemptResolveElement(wrappedType, key, ref, props);
+        }
+
+      case REACT_FORWARD_REF_TYPE:
+        {
+          var render = type.render;
+          return render(props, undefined);
+        }
+
+      case REACT_MEMO_TYPE:
+        {
+          return attemptResolveElement(type.type, key, ref, props);
+        }
+
+      case REACT_PROVIDER_TYPE:
+        {
+          pushProvider(type._context, props.value);
+
+          {
+            var extraKeys = Object.keys(props).filter(function (value) {
+              if (value === 'children' || value === 'value') {
+                return false;
+              }
+
+              return true;
+            });
+
+            if (extraKeys.length !== 0) {
+              error('ServerContext can only have a value prop and children. Found: %s', JSON.stringify(extraKeys));
+            }
+          }
+
+          return [REACT_ELEMENT_TYPE, type, key, // Rely on __popProvider being serialized last to pop the provider.
+          {
+            value: props.value,
+            children: props.children,
+            __pop: POP
+          }];
+        }
+    }
+  }
+
+  throw new Error("Unsupported server component type: " + describeValueForErrorMessage(type));
+}
+
+function pingTask(request, task) {
+  var pingedTasks = request.pingedTasks;
+  pingedTasks.push(task);
+
+  if (pingedTasks.length === 1) {
+    scheduleWork(function () {
+      return performWork(request);
+    });
+  }
+}
+
+function createTask(request, model, context, abortSet) {
+  var id = request.nextChunkId++;
+  var task = {
+    id: id,
+    status: PENDING,
+    model: model,
+    context: context,
+    ping: function () {
+      return pingTask(request, task);
+    }
+  };
+  abortSet.add(task);
+  return task;
+}
+
+function serializeByValueID(id) {
+  return '$' + id.toString(16);
+}
+
+function serializeByRefID(id) {
+  return '@' + id.toString(16);
+}
+
+function escapeStringValue(value) {
+  if (value[0] === '$' || value[0] === '@') {
+    // We need to escape $ or @ prefixed strings since we use those to encode
+    // references to IDs and as special symbol values.
+    return '$' + value;
+  } else {
+    return value;
+  }
+}
+
+function isObjectPrototype(object) {
+  if (!object) {
+    return false;
+  }
+
+  var ObjectPrototype = Object.prototype;
+
+  if (object === ObjectPrototype) {
+    return true;
+  } // It might be an object from a different Realm which is
+  // still just a plain simple object.
+
+
+  if (Object.getPrototypeOf(object)) {
+    return false;
+  }
+
+  var names = Object.getOwnPropertyNames(object);
+
+  for (var i = 0; i < names.length; i++) {
+    if (!(names[i] in ObjectPrototype)) {
+      return false;
+    }
+  }
+
+  return true;
+}
+
+function isSimpleObject(object) {
+  if (!isObjectPrototype(Object.getPrototypeOf(object))) {
+    return false;
+  }
+
+  var names = Object.getOwnPropertyNames(object);
+
+  for (var i = 0; i < names.length; i++) {
+    var descriptor = Object.getOwnPropertyDescriptor(object, names[i]);
+
+    if (!descriptor) {
+      return false;
+    }
+
+    if (!descriptor.enumerable) {
+      if ((names[i] === 'key' || names[i] === 'ref') && typeof descriptor.get === 'function') {
+        // React adds key and ref getters to props objects to issue warnings.
+        // Those getters will not be transferred to the client, but that's ok,
+        // so we'll special case them.
+        continue;
+      }
+
+      return false;
+    }
+  }
+
+  return true;
+}
+
+function objectName(object) {
+  var name = Object.prototype.toString.call(object);
+  return name.replace(/^\[object (.*)\]$/, function (m, p0) {
+    return p0;
+  });
+}
+
+function describeKeyForErrorMessage(key) {
+  var encodedKey = JSON.stringify(key);
+  return '"' + key + '"' === encodedKey ? key : encodedKey;
+}
+
+function describeValueForErrorMessage(value) {
+  switch (typeof value) {
+    case 'string':
+      {
+        return JSON.stringify(value.length <= 10 ? value : value.substr(0, 10) + '...');
+      }
+
+    case 'object':
+      {
+        if (isArray(value)) {
+          return '[...]';
+        }
+
+        var name = objectName(value);
+
+        if (name === 'Object') {
+          return '{...}';
+        }
+
+        return name;
+      }
+
+    case 'function':
+      return 'function';
+
+    default:
+      // eslint-disable-next-line react-internal/safe-string-coercion
+      return String(value);
+  }
+}
+
+function describeObjectForErrorMessage(objectOrArray, expandedName) {
+  if (isArray(objectOrArray)) {
+    var str = '[';
+    var array = objectOrArray;
+
+    for (var i = 0; i < array.length; i++) {
+      if (i > 0) {
+        str += ', ';
+      }
+
+      if (i > 6) {
+        str += '...';
+        break;
+      }
+
+      var _value = array[i];
+
+      if ('' + i === expandedName && typeof _value === 'object' && _value !== null) {
+        str += describeObjectForErrorMessage(_value);
+      } else {
+        str += describeValueForErrorMessage(_value);
+      }
+    }
+
+    str += ']';
+    return str;
+  } else {
+    var _str = '{';
+    var object = objectOrArray;
+    var names = Object.keys(object);
+
+    for (var _i = 0; _i < names.length; _i++) {
+      if (_i > 0) {
+        _str += ', ';
+      }
+
+      if (_i > 6) {
+        _str += '...';
+        break;
+      }
+
+      var name = names[_i];
+      _str += describeKeyForErrorMessage(name) + ': ';
+      var _value2 = object[name];
+
+      if (name === expandedName && typeof _value2 === 'object' && _value2 !== null) {
+        _str += describeObjectForErrorMessage(_value2);
+      } else {
+        _str += describeValueForErrorMessage(_value2);
+      }
+    }
+
+    _str += '}';
+    return _str;
+  }
+}
+
+var insideContextProps = null;
+var isInsideContextValue = false;
+function resolveModelToJSON(request, parent, key, value) {
+  {
+    // $FlowFixMe
+    var originalValue = parent[key];
+
+    if (typeof originalValue === 'object' && originalValue !== value) {
+      error('Only plain objects can be passed to client components from server components. ' + 'Objects with toJSON methods are not supported. Convert it manually ' + 'to a simple value before passing it to props. ' + 'Remove %s from these props: %s', describeKeyForErrorMessage(key), describeObjectForErrorMessage(parent));
+    }
+  } // Special Symbols
+
+
+  switch (value) {
+    case REACT_ELEMENT_TYPE:
+      return '$';
+  }
+
+  {
+    if (parent[0] === REACT_ELEMENT_TYPE && parent[1] && parent[1].$$typeof === REACT_PROVIDER_TYPE && key === '3') {
+      insideContextProps = value;
+    } else if (insideContextProps === parent && key === 'value') {
+      isInsideContextValue = true;
+    } else if (insideContextProps === parent && key === 'children') {
+      isInsideContextValue = false;
+    }
+  } // Resolve server components.
+
+
+  while (typeof value === 'object' && value !== null && (value.$$typeof === REACT_ELEMENT_TYPE || value.$$typeof === REACT_LAZY_TYPE)) {
+    {
+      if (isInsideContextValue) {
+        error('React elements are not allowed in ServerContext');
+      }
+    }
+
+    try {
+      switch (value.$$typeof) {
+        case REACT_ELEMENT_TYPE:
+          {
+            // TODO: Concatenate keys of parents onto children.
+            var element = value; // Attempt to render the server component.
+
+            value = attemptResolveElement(element.type, element.key, element.ref, element.props);
+            break;
+          }
+
+        case REACT_LAZY_TYPE:
+          {
+            var payload = value._payload;
+            var init = value._init;
+            value = init(payload);
+            break;
+          }
+      }
+    } catch (x) {
+      if (typeof x === 'object' && x !== null && typeof x.then === 'function') {
+        // Something suspended, we'll need to create a new task and resolve it later.
+        request.pendingChunks++;
+        var newTask = createTask(request, value, getActiveContext(), request.abortableTasks);
+        var ping = newTask.ping;
+        x.then(ping, ping);
+        return serializeByRefID(newTask.id);
+      } else {
+        logRecoverableError(request, x); // Something errored. We'll still send everything we have up until this point.
+        // We'll replace this element with a lazy reference that throws on the client
+        // once it gets rendered.
+
+        request.pendingChunks++;
+        var errorId = request.nextChunkId++;
+        emitErrorChunk(request, errorId, x);
+        return serializeByRefID(errorId);
+      }
+    }
+  }
+
+  if (value == null) {
+    return value;
+  }
+
+  if (typeof value === 'object' || isModuleReference(value)) {
+    if (isModuleReference(value)) {
+      var moduleReference = value;
+      var moduleKey = getModuleKey(moduleReference);
+      var writtenModules = request.writtenModules;
+      var existingId = writtenModules.get(moduleKey);
+
+      if (existingId !== undefined) {
+        if (parent[0] === REACT_ELEMENT_TYPE && key === '1') {
+          // If we're encoding the "type" of an element, we can refer
+          // to that by a lazy reference instead of directly since React
+          // knows how to deal with lazy values. This lets us suspend
+          // on this component rather than its parent until the code has
+          // loaded.
+          return serializeByRefID(existingId);
+        }
+
+        return serializeByValueID(existingId);
+      }
+
+      try {
+        var moduleMetaData = resolveModuleMetaData(request.bundlerConfig, moduleReference);
+        request.pendingChunks++;
+        var moduleId = request.nextChunkId++;
+        emitModuleChunk(request, moduleId, moduleMetaData);
+        writtenModules.set(moduleKey, moduleId);
+
+        if (parent[0] === REACT_ELEMENT_TYPE && key === '1') {
+          // If we're encoding the "type" of an element, we can refer
+          // to that by a lazy reference instead of directly since React
+          // knows how to deal with lazy values. This lets us suspend
+          // on this component rather than its parent until the code has
+          // loaded.
+          return serializeByRefID(moduleId);
+        }
+
+        return serializeByValueID(moduleId);
+      } catch (x) {
+        request.pendingChunks++;
+
+        var _errorId = request.nextChunkId++;
+
+        emitErrorChunk(request, _errorId, x);
+        return serializeByValueID(_errorId);
+      }
+    } else if (value.$$typeof === REACT_PROVIDER_TYPE) {
+      var providerKey = value._context._globalName;
+      var writtenProviders = request.writtenProviders;
+      var providerId = writtenProviders.get(key);
+
+      if (providerId === undefined) {
+        request.pendingChunks++;
+        providerId = request.nextChunkId++;
+        writtenProviders.set(providerKey, providerId);
+        emitProviderChunk(request, providerId, providerKey);
+      }
+
+      return serializeByValueID(providerId);
+    } else if (value === POP) {
+      popProvider();
+
+      {
+        insideContextProps = null;
+        isInsideContextValue = false;
+      }
+
+      return undefined;
+    }
+
+    {
+      if (value !== null && !isArray(value)) {
+        // Verify that this is a simple plain object.
+        if (objectName(value) !== 'Object') {
+          error('Only plain objects can be passed to client components from server components. ' + 'Built-ins like %s are not supported. ' + 'Remove %s from these props: %s', objectName(value), describeKeyForErrorMessage(key), describeObjectForErrorMessage(parent));
+        } else if (typeof value === 'object' && !isSimpleObject(value)) {
+          error('Only plain objects can be passed to client components from server components. ' + 'Classes or other objects with methods are not supported. ' + 'Remove %s from these props: %s', describeKeyForErrorMessage(key), describeObjectForErrorMessage(parent, key));
+        } else if (Object.getOwnPropertySymbols) {
+          var symbols = Object.getOwnPropertySymbols(value);
+
+          if (symbols.length > 0) {
+            error('Only plain objects can be passed to client components from server components. ' + 'Objects with symbol properties like %s are not supported. ' + 'Remove %s from these props: %s', symbols[0].description, describeKeyForErrorMessage(key), describeObjectForErrorMessage(parent, key));
+          }
+        }
+      }
+    }
+
+    return value;
+  }
+
+  if (typeof value === 'string') {
+    return escapeStringValue(value);
+  }
+
+  if (typeof value === 'boolean' || typeof value === 'number' || typeof value === 'undefined') {
+    return value;
+  }
+
+  if (typeof value === 'function') {
+    if (/^on[A-Z]/.test(key)) {
+      throw new Error('Event handlers cannot be passed to client component props. ' + ("Remove " + describeKeyForErrorMessage(key) + " from these props if possible: " + describeObjectForErrorMessage(parent) + "\n") + 'If you need interactivity, consider converting part of this to a client component.');
+    } else {
+      throw new Error('Functions cannot be passed directly to client components ' + "because they're not serializable. " + ("Remove " + describeKeyForErrorMessage(key) + " (" + (value.displayName || value.name || 'function') + ") from this object, or avoid the entire object: " + describeObjectForErrorMessage(parent)));
+    }
+  }
+
+  if (typeof value === 'symbol') {
+    var writtenSymbols = request.writtenSymbols;
+
+    var _existingId = writtenSymbols.get(value);
+
+    if (_existingId !== undefined) {
+      return serializeByValueID(_existingId);
+    }
+
+    var name = value.description;
+
+    if (Symbol.for(name) !== value) {
+      throw new Error('Only global symbols received from Symbol.for(...) can be passed to client components. ' + ("The symbol Symbol.for(" + value.description + ") cannot be found among global symbols. ") + ("Remove " + describeKeyForErrorMessage(key) + " from this object, or avoid the entire object: " + describeObjectForErrorMessage(parent)));
+    }
+
+    request.pendingChunks++;
+    var symbolId = request.nextChunkId++;
+    emitSymbolChunk(request, symbolId, name);
+    writtenSymbols.set(value, symbolId);
+    return serializeByValueID(symbolId);
+  } // $FlowFixMe: bigint isn't added to Flow yet.
+
+
+  if (typeof value === 'bigint') {
+    throw new Error("BigInt (" + value + ") is not yet supported in client component props. " + ("Remove " + describeKeyForErrorMessage(key) + " from this object or use a plain number instead: " + describeObjectForErrorMessage(parent)));
+  }
+
+  throw new Error("Type " + typeof value + " is not supported in client component props. " + ("Remove " + describeKeyForErrorMessage(key) + " from this object, or avoid the entire object: " + describeObjectForErrorMessage(parent)));
+}
+
+function logRecoverableError(request, error) {
+  var onError = request.onError;
+  onError(error);
+}
+
+function fatalError(request, error) {
+  // This is called outside error handling code such as if an error happens in React internals.
+  if (request.destination !== null) {
+    request.status = CLOSED;
+    closeWithError(request.destination, error);
+  } else {
+    request.status = CLOSING;
+    request.fatalError = error;
+  }
+}
+
+function emitErrorChunk(request, id, error) {
+  // TODO: We should not leak error messages to the client in prod.
+  // Give this an error code instead and log on the server.
+  // We can serialize the error in DEV as a convenience.
+  var message;
+  var stack = '';
+
+  try {
+    if (error instanceof Error) {
+      // eslint-disable-next-line react-internal/safe-string-coercion
+      message = String(error.message); // eslint-disable-next-line react-internal/safe-string-coercion
+
+      stack = String(error.stack);
+    } else {
+      message = 'Error: ' + error;
+    }
+  } catch (x) {
+    message = 'An error occurred but serializing the error message failed.';
+  }
+
+  var processedChunk = processErrorChunk(request, id, message, stack);
+  request.completedErrorChunks.push(processedChunk);
+}
+
+function emitModuleChunk(request, id, moduleMetaData) {
+  var processedChunk = processModuleChunk(request, id, moduleMetaData);
+  request.completedModuleChunks.push(processedChunk);
+}
+
+function emitSymbolChunk(request, id, name) {
+  var processedChunk = processSymbolChunk(request, id, name);
+  request.completedModuleChunks.push(processedChunk);
+}
+
+function emitProviderChunk(request, id, contextName) {
+  var processedChunk = processProviderChunk(request, id, contextName);
+  request.completedJSONChunks.push(processedChunk);
+}
+
+function retryTask(request, task) {
+  if (task.status !== PENDING) {
+    // We completed this by other means before we had a chance to retry it.
+    return;
+  }
+
+  switchContext(task.context);
+
+  try {
+    var _value3 = task.model;
+
+    while (typeof _value3 === 'object' && _value3 !== null && _value3.$$typeof === REACT_ELEMENT_TYPE) {
+      // TODO: Concatenate keys of parents onto children.
+      var element = _value3; // Attempt to render the server component.
+      // Doing this here lets us reuse this same task if the next component
+      // also suspends.
+
+      task.model = _value3;
+      _value3 = attemptResolveElement(element.type, element.key, element.ref, element.props);
+    }
+
+    var processedChunk = processModelChunk(request, task.id, _value3);
+    request.completedJSONChunks.push(processedChunk);
+    request.abortableTasks.delete(task);
+    task.status = COMPLETED;
+  } catch (x) {
+    if (typeof x === 'object' && x !== null && typeof x.then === 'function') {
+      // Something suspended again, let's pick it back up later.
+      var ping = task.ping;
+      x.then(ping, ping);
+      return;
+    } else {
+      request.abortableTasks.delete(task);
+      task.status = ERRORED;
+      logRecoverableError(request, x); // This errored, we need to serialize this error to the
+
+      emitErrorChunk(request, task.id, x);
+    }
+  }
+}
+
+function performWork(request) {
+  var prevDispatcher = ReactCurrentDispatcher.current;
+  var prevCache = getCurrentCache();
+  ReactCurrentDispatcher.current = Dispatcher;
+  setCurrentCache(request.cache);
+  prepareToUseHooksForRequest(request);
+
+  try {
+    var pingedTasks = request.pingedTasks;
+    request.pingedTasks = [];
+
+    for (var i = 0; i < pingedTasks.length; i++) {
+      var task = pingedTasks[i];
+      retryTask(request, task);
+    }
+
+    if (request.destination !== null) {
+      flushCompletedChunks(request, request.destination);
+    }
+  } catch (error) {
+    logRecoverableError(request, error);
+    fatalError(request, error);
+  } finally {
+    ReactCurrentDispatcher.current = prevDispatcher;
+    setCurrentCache(prevCache);
+    resetHooksForRequest();
+  }
+}
+
+function abortTask(task, request, errorId) {
+  task.status = ABORTED; // Instead of emitting an error per task.id, we emit a model that only
+  // has a single value referencing the error.
+
+  var ref = serializeByValueID(errorId);
+  var processedChunk = processReferenceChunk(request, task.id, ref);
+  request.completedJSONChunks.push(processedChunk);
+}
+
+function flushCompletedChunks(request, destination) {
+  beginWriting();
+
+  try {
+    // We emit module chunks first in the stream so that
+    // they can be preloaded as early as possible.
+    var moduleChunks = request.completedModuleChunks;
+    var i = 0;
+
+    for (; i < moduleChunks.length; i++) {
+      request.pendingChunks--;
+      var chunk = moduleChunks[i];
+      var keepWriting = writeChunkAndReturn(destination, chunk);
+
+      if (!keepWriting) {
+        request.destination = null;
+        i++;
+        break;
+      }
+    }
+
+    moduleChunks.splice(0, i); // Next comes model data.
+
+    var jsonChunks = request.completedJSONChunks;
+    i = 0;
+
+    for (; i < jsonChunks.length; i++) {
+      request.pendingChunks--;
+      var _chunk = jsonChunks[i];
+
+      var _keepWriting = writeChunkAndReturn(destination, _chunk);
+
+      if (!_keepWriting) {
+        request.destination = null;
+        i++;
+        break;
+      }
+    }
+
+    jsonChunks.splice(0, i); // Finally, errors are sent. The idea is that it's ok to delay
+    // any error messages and prioritize display of other parts of
+    // the page.
+
+    var errorChunks = request.completedErrorChunks;
+    i = 0;
+
+    for (; i < errorChunks.length; i++) {
+      request.pendingChunks--;
+      var _chunk2 = errorChunks[i];
+
+      var _keepWriting2 = writeChunkAndReturn(destination, _chunk2);
+
+      if (!_keepWriting2) {
+        request.destination = null;
+        i++;
+        break;
+      }
+    }
+
+    errorChunks.splice(0, i);
+  } finally {
+    completeWriting(destination);
+  }
+
+  flushBuffered(destination);
+
+  if (request.pendingChunks === 0) {
+    // We're done.
+    close(destination);
+  }
+}
+
+function startWork(request) {
+  scheduleWork(function () {
+    return performWork(request);
+  });
+}
+function startFlowing(request, destination) {
+  if (request.status === CLOSING) {
+    request.status = CLOSED;
+    closeWithError(destination, request.fatalError);
+    return;
+  }
+
+  if (request.status === CLOSED) {
+    return;
+  }
+
+  if (request.destination !== null) {
+    // We're already flowing.
+    return;
+  }
+
+  request.destination = destination;
+
+  try {
+    flushCompletedChunks(request, destination);
+  } catch (error) {
+    logRecoverableError(request, error);
+    fatalError(request, error);
+  }
+} // This is called to early terminate a request. It creates an error at all pending tasks.
+
+function abort(request, reason) {
+  try {
+    var abortableTasks = request.abortableTasks;
+
+    if (abortableTasks.size > 0) {
+      // We have tasks to abort. We'll emit one error row and then emit a reference
+      // to that row from every row that's still remaining.
+      var _error = reason === undefined ? new Error('The render was aborted by the server without a reason.') : reason;
+
+      logRecoverableError(request, _error);
+      request.pendingChunks++;
+      var errorId = request.nextChunkId++;
+      emitErrorChunk(request, errorId, _error);
+      abortableTasks.forEach(function (task) {
+        return abortTask(task, request, errorId);
+      });
+      abortableTasks.clear();
+    }
+
+    if (request.destination !== null) {
+      flushCompletedChunks(request, request.destination);
+    }
+  } catch (error) {
+    logRecoverableError(request, error);
+    fatalError(request, error);
+  }
+}
+
+function importServerContexts(contexts) {
+  if (contexts) {
+    var prevContext = getActiveContext();
+    switchContext(rootContextSnapshot);
+
+    for (var i = 0; i < contexts.length; i++) {
+      var _contexts$i = contexts[i],
+          name = _contexts$i[0],
+          _value4 = _contexts$i[1];
+      var context = getOrCreateServerContext(name);
+      pushProvider(context, _value4);
+    }
+
+    var importedContext = getActiveContext();
+    switchContext(prevContext);
+    return importedContext;
+  }
+
+  return rootContextSnapshot;
+}
+
+function createDrainHandler(destination, request) {
+  return function () {
+    return startFlowing(request, destination);
+  };
+}
+
+function renderToPipeableStream(model, options) {
+  var request = createRequest( // Wrap root in a dummy element that simply adds a flag
+  // to the current dispatcher to check later in the proxies.
+  assign({}, model, {
+    $$typeof: Symbol.for('react.element'),
+    props: {
+      children: model
+    },
+    type: function () {
+      React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher.current.isRsc = true;
+      return model;
+    }
+  }), {}, // Manifest, not used
+  options ? options.onError : undefined, options ? options.context : undefined, options ? options.identifierPrefix : undefined);
+  var hasStartedFlowing = false;
+  startWork(request);
+  return {
+    pipe: function (destination) {
+      if (hasStartedFlowing) {
+        throw new Error('React currently only supports piping to one writable stream.');
+      }
+
+      hasStartedFlowing = true;
+      startFlowing(request, destination);
+      destination.on('drain', createDrainHandler(destination, request));
+      return destination;
+    },
+    abort: function (reason) {
+      abort(request, reason);
+    }
+  };
+}
+
+exports.renderToPipeableStream = renderToPipeableStream;
+  })();
+}
diff --git a/vendor/vendor/react-server-dom-vite/cjs/react-server-dom-vite-writer.node.production.min.server.js b/vendor/vendor/react-server-dom-vite/cjs/react-server-dom-vite-writer.node.production.min.server.js
new file mode 100644
index 0000000000000000000000000000000000000000..dac7e4c645309d40383f80068040a4d82070591d
--- /dev/null
+++ b/vendor/vendor/react-server-dom-vite/cjs/react-server-dom-vite-writer.node.production.min.server.js
@@ -0,0 +1,49 @@
+/**
+ * @license React
+ * react-server-dom-vite-writer.node.production.min.server.js
+ *
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+'use strict';var e=require("react"),aa=require("util"),ba=Object.assign,h=null,k=0,n=!0;function q(a,b){a=a.write(b);n=n&&a}
+function r(a,b){if("string"===typeof b){if(0!==b.length)if(2048<3*b.length)0<k&&(q(a,h.subarray(0,k)),h=new Uint8Array(2048),k=0),q(a,u.encode(b));else{var d=h;0<k&&(d=h.subarray(k));d=u.encodeInto(b,d);var c=d.read;k+=d.written;c<b.length&&(q(a,h),h=new Uint8Array(2048),k=u.encodeInto(b.slice(c),h).written);2048===k&&(q(a,h),h=new Uint8Array(2048),k=0)}}else 0!==b.byteLength&&(2048<b.byteLength?(0<k&&(q(a,h.subarray(0,k)),h=new Uint8Array(2048),k=0),q(a,b)):(d=h.length-k,d<b.byteLength&&(0===d?q(a,
+h):(h.set(b.subarray(0,d),k),k+=d,q(a,h),b=b.subarray(d)),h=new Uint8Array(2048),k=0),h.set(b,k),k+=b.byteLength,2048===k&&(q(a,h),h=new Uint8Array(2048),k=0)));return n}var u=new aa.TextEncoder;function v(a){return u.encode(a)}var x=JSON.stringify,ca=Symbol.for("react.module.reference");function y(a){return"string"===typeof a?!!globalThis.__STRING_REFERENCE_INDEX[a]:a.$$typeof===ca}
+var z=Symbol.for("react.element"),da=Symbol.for("react.fragment"),A=Symbol.for("react.provider"),ea=Symbol.for("react.forward_ref"),fa=Symbol.for("react.memo"),B=Symbol.for("react.lazy"),C=Symbol.for("react.default_value");function D(a,b,d,c,f,g,l){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=c;this.attributeNamespace=f;this.mustUseProperty=d;this.propertyName=a;this.type=b;this.sanitizeURL=g;this.removeEmptyString=l}var E="children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ");
+E.push("innerText","textContent");E.forEach(function(a){new D(a,0,!1,a,null,!1,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){new D(a[0],1,!1,a[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){new D(a,2,!1,a.toLowerCase(),null,!1,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){new D(a,2,!1,a,null,!1,!1)});
+"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){new D(a,3,!1,a.toLowerCase(),null,!1,!1)});["checked","multiple","muted","selected"].forEach(function(a){new D(a,3,!0,a,null,!1,!1)});["capture","download"].forEach(function(a){new D(a,4,!1,a,null,!1,!1)});
+["cols","rows","size","span"].forEach(function(a){new D(a,6,!1,a,null,!1,!1)});["rowSpan","start"].forEach(function(a){new D(a,5,!1,a.toLowerCase(),null,!1,!1)});var F=/[\-:]([a-z])/g;function G(a){return a[1].toUpperCase()}
+"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=a.replace(F,
+G);new D(b,1,!1,a,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(F,G);new D(b,1,!1,a,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(F,G);new D(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(a){new D(a,1,!1,a.toLowerCase(),null,!1,!1)});
+new D("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(a){new D(a,1,!1,a.toLowerCase(),null,!0,!0)});
+var H={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,
+fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},ha=["Webkit","ms","Moz","O"];Object.keys(H).forEach(function(a){ha.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);H[b]=H[a]})});var ia=Array.isArray;v("<script>");v("\x3c/script>");v('<script src="');v('<script type="module" src="');v('" integrity="');v('" async="">\x3c/script>');v("\x3c!-- --\x3e");v(' style="');v(":");v(";");v(" ");v('="');v('"');
+v('=""');v(">");v("/>");v(' selected=""');v("\n");v("<!DOCTYPE html>");v("</");v(">");v('<template id="');v('"></template>');v("\x3c!--$--\x3e");v('\x3c!--$?--\x3e<template id="');v('"></template>');v("\x3c!--$!--\x3e");v("\x3c!--/$--\x3e");v("<template");v('"');v(' data-dgst="');v(' data-msg="');v(' data-stck="');v("></template>");v('<div hidden id="');v('">');v("</div>");v('<svg aria-hidden="true" style="display:none" id="');v('">');v("</svg>");v('<math aria-hidden="true" style="display:none" id="');
+v('">');v("</math>");v('<table hidden id="');v('">');v("</table>");v('<table hidden><tbody id="');v('">');v("</tbody></table>");v('<table hidden><tr id="');v('">');v("</tr></table>");v('<table hidden><colgroup id="');v('">');v("</colgroup></table>");v('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("');v('$RS("');v('","');v('")\x3c/script>');v('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("');
+v('$RC("');v('","');v('")\x3c/script>');v('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("');v('$RX("');v('"');v(")\x3c/script>");v(",");var I=null;
+function J(a,b){if(a!==b){a.context._currentValue=a.parentValue;a=a.parent;var d=b.parent;if(null===a){if(null!==d)throw Error("The stacks must reach the root at the same time. This is a bug in React.");}else{if(null===d)throw Error("The stacks must reach the root at the same time. This is a bug in React.");J(a,d);b.context._currentValue=b.value}}}function ja(a){a.context._currentValue=a.parentValue;a=a.parent;null!==a&&ja(a)}
+function ka(a){var b=a.parent;null!==b&&ka(b);a.context._currentValue=a.value}function la(a,b){a.context._currentValue=a.parentValue;a=a.parent;if(null===a)throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");a.depth===b.depth?J(a,b):la(a,b)}
+function na(a,b){var d=b.parent;if(null===d)throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");a.depth===d.depth?J(a,d):na(a,d);b.context._currentValue=b.value}function K(a){var b=I;b!==a&&(null===b?ka(a):null===a?ja(b):b.depth===a.depth?J(b,a):b.depth>a.depth?la(b,a):na(b,a),I=a)}function oa(a,b){var d=a._currentValue;a._currentValue=b;var c=I;return I=a={parent:c,depth:null===c?0:c.depth+1,context:a,parentValue:d,value:b}}var L=null;
+function pa(a){return a._currentValue}
+var sa={useMemo:function(a){return a()},useCallback:function(a){return a},useDebugValue:function(){},useDeferredValue:M,useTransition:M,getCacheForType:function(a){if(!N)throw Error("Reading the cache is only supported while rendering.");var b=N.get(a);void 0===b&&(b=a(),N.set(a,b));return b},readContext:pa,useContext:pa,useReducer:M,useRef:M,useState:M,useInsertionEffect:M,useLayoutEffect:M,useImperativeHandle:M,useEffect:M,useId:qa,useMutableSource:M,useSyncExternalStore:M,useCacheRefresh:function(){return ra}};
+function M(){throw Error("This Hook is not supported in Server Components.");}function ra(){if(!N)throw Error("Refreshing the cache is not supported in Server Components.");}var N=null;function qa(){if(null===L)throw Error("useId can only be used while React is rendering");var a=L.identifierCount++;return":"+L.identifierPrefix+"S"+a.toString(32)+":"}var ta=e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,O=ta.ContextRegistry,P=ta.ReactCurrentDispatcher;function ua(a){console.error(a)}
+function va(a,b,d,c,f){var g=new Set,l=[],m={status:0,fatalError:null,destination:null,bundlerConfig:b,cache:new Map,nextChunkId:0,pendingChunks:0,abortableTasks:g,pingedTasks:l,completedModuleChunks:[],completedJSONChunks:[],completedErrorChunks:[],writtenSymbols:new Map,writtenModules:new Map,writtenProviders:new Map,identifierPrefix:f||"",identifierCount:1,onError:void 0===d?ua:d,toJSON:function(a,b){return wa(m,this,a,b)}};m.pendingChunks++;b=xa(c);a=ya(m,a,b,g);l.push(a);return m}var za={};
+function Q(a,b,d,c){if(null!==d&&void 0!==d)throw Error("Refs cannot be used in server components, nor passed to client components.");if("function"===typeof a)return y(a)?[z,a,b,c]:a(c);if("string"===typeof a)return[z,a,b,c];if("symbol"===typeof a)return a===da?c.children:[z,a,b,c];if(null!=a&&"object"===typeof a){if(y(a))return[z,a,b,c];switch(a.$$typeof){case B:var f=a._init;a=f(a._payload);return Q(a,b,d,c);case ea:return b=a.render,b(c,void 0);case fa:return Q(a.type,b,d,c);case A:return oa(a._context,
+c.value),[z,a,b,{value:c.value,children:c.children,__pop:za}]}}throw Error("Unsupported server component type: "+R(a));}function Aa(a,b){var d=a.pingedTasks;d.push(b);1===d.length&&setImmediate(function(){return Ba(a)})}function ya(a,b,d,c){var f={id:a.nextChunkId++,status:0,model:b,context:d,ping:function(){return Aa(a,f)}};c.add(f);return f}function Ca(a){return Object.prototype.toString.call(a).replace(/^\[object (.*)\]$/,function(a,d){return d})}
+function T(a){var b=JSON.stringify(a);return'"'+a+'"'===b?a:b}function R(a){switch(typeof a){case "string":return JSON.stringify(10>=a.length?a:a.substr(0,10)+"...");case "object":if(ia(a))return"[...]";a=Ca(a);return"Object"===a?"{...}":a;case "function":return"function";default:return String(a)}}
+function V(a,b){if(ia(a)){for(var d="[",c=0;c<a.length;c++){0<c&&(d+=", ");if(6<c){d+="...";break}var f=a[c];d=""+c===b&&"object"===typeof f&&null!==f?d+V(f):d+R(f)}return d+"]"}d="{";c=Object.keys(a);for(f=0;f<c.length;f++){0<f&&(d+=", ");if(6<f){d+="...";break}var g=c[f];d+=T(g)+": ";var l=a[g];d=g===b&&"object"===typeof l&&null!==l?d+V(l):d+R(l)}return d+"}"}
+function wa(a,b,d,c){switch(c){case z:return"$"}for(;"object"===typeof c&&null!==c&&(c.$$typeof===z||c.$$typeof===B);)try{switch(c.$$typeof){case z:var f=c;c=Q(f.type,f.key,f.ref,f.props);break;case B:var g=c._init;c=g(c._payload)}}catch(t){if("object"===typeof t&&null!==t&&"function"===typeof t.then)return a.pendingChunks++,a=ya(a,c,I,a.abortableTasks),d=a.ping,t.then(d,d),"@"+a.id.toString(16);W(a,t);a.pendingChunks++;d=a.nextChunkId++;X(a,d,t);return"@"+d.toString(16)}if(null==c)return c;if("object"===
+typeof c||y(c)){if(y(c)){f=c;"string"===typeof f&&(f=globalThis.__STRING_REFERENCE_INDEX[f]);f=f.filepath+"#"+f.name;g=a.writtenModules;var l=g.get(f);if(void 0!==l)return b[0]===z&&"1"===d?"@"+l.toString(16):"$"+l.toString(16);try{"string"===typeof c&&(c=globalThis.__STRING_REFERENCE_INDEX[c]);var m={id:c.filepath,name:c.name};a.pendingChunks++;var p=a.nextChunkId++,S=x(m);var U="M"+p.toString(16)+":"+S+"\n";a.completedModuleChunks.push(U);g.set(f,p);return b[0]===z&&"1"===d?"@"+p.toString(16):"$"+
+p.toString(16)}catch(t){return a.pendingChunks++,d=a.nextChunkId++,X(a,d,t),"$"+d.toString(16)}}else{if(c.$$typeof===A)return b=c._context._globalName,c=a.writtenProviders,d=c.get(d),void 0===d&&(a.pendingChunks++,d=a.nextChunkId++,c.set(b,d),b="P"+d.toString(16)+":"+b+"\n",a.completedJSONChunks.push(b)),"$"+d.toString(16);if(c===za){a=I;if(null===a)throw Error("Tried to pop a Context at the root of the app. This is a bug in React.");d=a.parentValue;a.context._currentValue=d===C?a.context._defaultValue:
+d;I=a.parent;return}}return c}if("string"===typeof c)return a="$"===c[0]||"@"===c[0]?"$"+c:c,a;if("boolean"===typeof c||"number"===typeof c||"undefined"===typeof c)return c;if("function"===typeof c){if(/^on[A-Z]/.test(d))throw Error("Event handlers cannot be passed to client component props. Remove "+(T(d)+" from these props if possible: "+V(b)+"\nIf you need interactivity, consider converting part of this to a client component."));throw Error("Functions cannot be passed directly to client components because they're not serializable. Remove "+
+(T(d)+" ("+(c.displayName||c.name||"function")+") from this object, or avoid the entire object: "+V(b)));}if("symbol"===typeof c){m=a.writtenSymbols;p=m.get(c);if(void 0!==p)return"$"+p.toString(16);p=c.description;if(Symbol.for(p)!==c)throw Error("Only global symbols received from Symbol.for(...) can be passed to client components. The symbol Symbol.for("+(c.description+") cannot be found among global symbols. Remove ")+(T(d)+" from this object, or avoid the entire object: "+V(b)));a.pendingChunks++;
+d=a.nextChunkId++;b=x(p);b="S"+d.toString(16)+":"+b+"\n";a.completedModuleChunks.push(b);m.set(c,d);return"$"+d.toString(16)}if("bigint"===typeof c)throw Error("BigInt ("+c+") is not yet supported in client component props. Remove "+(T(d)+" from this object or use a plain number instead: "+V(b)));throw Error("Type "+typeof c+" is not supported in client component props. Remove "+(T(d)+" from this object, or avoid the entire object: "+V(b)));}function W(a,b){a=a.onError;a(b)}
+function Y(a,b){null!==a.destination?(a.status=2,a.destination.destroy(b)):(a.status=1,a.fatalError=b)}function X(a,b,d){var c="";try{if(d instanceof Error){var f=String(d.message);c=String(d.stack)}else f="Error: "+d}catch(g){f="An error occurred but serializing the error message failed."}d={message:f,stack:c};b="E"+b.toString(16)+":"+x(d)+"\n";a.completedErrorChunks.push(b)}
+function Ba(a){var b=P.current,d=N;P.current=sa;N=a.cache;L=a;try{var c=a.pingedTasks;a.pingedTasks=[];for(var f=0;f<c.length;f++){var g=c[f];var l=a;if(0===g.status){K(g.context);try{for(var m=g.model;"object"===typeof m&&null!==m&&m.$$typeof===z;){var p=m;g.model=m;m=Q(p.type,p.key,p.ref,p.props)}var S=g.id,U=x(m,l.toJSON);var t="J"+S.toString(16)+":"+U+"\n";l.completedJSONChunks.push(t);l.abortableTasks.delete(g);g.status=1}catch(w){if("object"===typeof w&&null!==w&&"function"===typeof w.then){var ma=
+g.ping;w.then(ma,ma)}else l.abortableTasks.delete(g),g.status=4,W(l,w),X(l,g.id,w)}}}null!==a.destination&&Z(a,a.destination)}catch(w){W(a,w),Y(a,w)}finally{P.current=b,N=d,L=null}}
+function Z(a,b){h=new Uint8Array(2048);k=0;n=!0;try{for(var d=a.completedModuleChunks,c=0;c<d.length;c++)if(a.pendingChunks--,!r(b,d[c])){a.destination=null;c++;break}d.splice(0,c);var f=a.completedJSONChunks;for(c=0;c<f.length;c++)if(a.pendingChunks--,!r(b,f[c])){a.destination=null;c++;break}f.splice(0,c);var g=a.completedErrorChunks;for(c=0;c<g.length;c++)if(a.pendingChunks--,!r(b,g[c])){a.destination=null;c++;break}g.splice(0,c)}finally{h&&0<k&&b.write(h.subarray(0,k)),h=null,k=0,n=!0}"function"===
+typeof b.flush&&b.flush();0===a.pendingChunks&&b.end()}function Da(a){setImmediate(function(){return Ba(a)})}function Ea(a,b){if(1===a.status)a.status=2,b.destroy(a.fatalError);else if(2!==a.status&&null===a.destination){a.destination=b;try{Z(a,b)}catch(d){W(a,d),Y(a,d)}}}
+function Fa(a,b){try{var d=a.abortableTasks;if(0<d.size){var c=void 0===b?Error("The render was aborted by the server without a reason."):b;W(a,c);a.pendingChunks++;var f=a.nextChunkId++;X(a,f,c);d.forEach(function(b){b.status=3;var c="$"+f.toString(16);b=b.id;c=x(c);c="J"+b.toString(16)+":"+c+"\n";a.completedJSONChunks.push(c)});d.clear()}null!==a.destination&&Z(a,a.destination)}catch(g){W(a,g),Y(a,g)}}
+function xa(a){if(a){var b=I;K(null);for(var d=0;d<a.length;d++){var c=a[d],f=c[0];c=c[1];O[f]||(O[f]=e.createServerContext(f,C));oa(O[f],c)}a=I;K(b);return a}return null}function Ga(a,b){return function(){return Ea(b,a)}}
+exports.renderToPipeableStream=function(a,b){var d=va(ba({},a,{$$typeof:Symbol.for("react.element"),props:{children:a},type:function(){e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher.current.isRsc=!0;return a}}),{},b?b.onError:void 0,b?b.context:void 0,b?b.identifierPrefix:void 0),c=!1;Da(d);return{pipe:function(a){if(c)throw Error("React currently only supports piping to one writable stream.");c=!0;Ea(d,a);a.on("drain",Ga(a,d));return a},abort:function(a){Fa(d,a)}}};
diff --git a/vendor/vendor/react-server-dom-vite/cjs/react-server-dom-vite.development.js b/vendor/vendor/react-server-dom-vite/cjs/react-server-dom-vite.development.js
new file mode 100644
index 0000000000000000000000000000000000000000..dc2717a41e95da71d8de78eea08ff96c996bce4a
--- /dev/null
+++ b/vendor/vendor/react-server-dom-vite/cjs/react-server-dom-vite.development.js
@@ -0,0 +1,629 @@
+/**
+ * @license React
+ * react-server-dom-vite.development.js
+ *
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+'use strict';
+
+if (process.env.NODE_ENV !== "production") {
+  (function() {
+'use strict';
+
+var React = require('react');
+
+function createStringDecoder() {
+  return new TextDecoder();
+}
+var decoderOptions = {
+  stream: true
+};
+function readPartialStringChunk(decoder, buffer) {
+  return decoder.decode(buffer, decoderOptions);
+}
+function readFinalStringChunk(decoder, buffer) {
+  return decoder.decode(buffer);
+}
+
+function parseModel(response, json) {
+  return JSON.parse(json, response._fromJSON);
+}
+
+var META_HOT = undefined;
+var META_ENV_DEV = undefined.DEV;
+
+function resolveModuleReference(bundlerConfig, moduleData) {
+  return moduleData;
+} // Vite import globs will be injected here.
+
+var allClientComponents = {
+  __INJECTED_CLIENT_IMPORTERS__: null
+}; // Mock client component imports during testing
+
+if (META_ENV_DEV && typeof jest !== 'undefined') {
+  global.allClientComponents = allClientComponents;
+}
+
+function importClientComponent(moduleId) {
+  var modImport = allClientComponents[moduleId];
+
+  if (!modImport) {
+    var error = new Error("Could not find client component " + moduleId);
+
+    if (META_HOT) {
+      META_HOT.send('rsc:cc404', {
+        id: moduleId
+      });
+      return new Promise(function (_, reject) {
+        return setTimeout(function () {
+          return reject(error);
+        }, 200);
+      });
+    }
+
+    return Promise.reject(error);
+  }
+
+  return typeof modImport === 'function' ? modImport() : Promise.resolve(modImport);
+} // The module cache contains all the modules we've preloaded so far.
+// If they're still pending they're a thenable.
+
+
+var moduleCache = new Map(); // Start preloading the modules since we might need them soon.
+// This function doesn't suspend.
+
+function preloadModule(_ref) {
+  var id = _ref.id;
+  if (moduleCache.has(id)) return;
+
+  function cacheResult(mod) {
+    moduleCache.set(id, mod);
+    return mod;
+  } // Store the original promise first, then override cache with its result.
+
+
+  var promise = importClientComponent(id);
+  cacheResult(promise);
+  promise.then(cacheResult, cacheResult);
+} // Actually require the module or suspend if it's not yet ready.
+// Increase priority if necessary.
+
+function requireModule(_ref2) {
+  var id = _ref2.id,
+      name = _ref2.name;
+  var mod = moduleCache.get(id);
+
+  if (!mod || mod instanceof Promise || mod instanceof Error) {
+    // This module is still being downloaded or
+    // it has errored out. Pass it to Suspense.
+    throw mod;
+  }
+
+  return mod[name];
+}
+
+// ATTENTION
+// When adding new symbols to this file,
+// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
+// The Symbol used to tag the ReactElement-like types.
+var REACT_ELEMENT_TYPE = Symbol.for('react.element');
+var REACT_LAZY_TYPE = Symbol.for('react.lazy');
+var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for('react.default_value');
+
+var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
+
+var ContextRegistry = ReactSharedInternals.ContextRegistry;
+function getOrCreateServerContext(globalName) {
+  if (!ContextRegistry[globalName]) {
+    ContextRegistry[globalName] = React.createServerContext(globalName, REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED);
+  }
+
+  return ContextRegistry[globalName];
+}
+
+var PENDING = 0;
+var RESOLVED_MODEL = 1;
+var RESOLVED_MODULE = 2;
+var INITIALIZED = 3;
+var ERRORED = 4;
+
+function Chunk(status, value, response) {
+  this._status = status;
+  this._value = value;
+  this._response = response;
+}
+
+Chunk.prototype.then = function (resolve) {
+  var chunk = this;
+
+  if (chunk._status === PENDING) {
+    if (chunk._value === null) {
+      chunk._value = [];
+    }
+
+    chunk._value.push(resolve);
+  } else {
+    resolve();
+  }
+};
+
+function readChunk(chunk) {
+  switch (chunk._status) {
+    case INITIALIZED:
+      return chunk._value;
+
+    case RESOLVED_MODEL:
+      return initializeModelChunk(chunk);
+
+    case RESOLVED_MODULE:
+      return initializeModuleChunk(chunk);
+
+    case PENDING:
+      // eslint-disable-next-line no-throw-literal
+      throw chunk;
+
+    default:
+      throw chunk._value;
+  }
+}
+
+function readRoot() {
+  var response = this;
+  var chunk = getChunk(response, 0);
+  return readChunk(chunk);
+}
+
+function createPendingChunk(response) {
+  return new Chunk(PENDING, null, response);
+}
+
+function createErrorChunk(response, error) {
+  return new Chunk(ERRORED, error, response);
+}
+
+function createInitializedChunk(response, value) {
+  return new Chunk(INITIALIZED, value, response);
+}
+
+function wakeChunk(listeners) {
+  if (listeners !== null) {
+    for (var i = 0; i < listeners.length; i++) {
+      var listener = listeners[i];
+      listener();
+    }
+  }
+}
+
+function triggerErrorOnChunk(chunk, error) {
+  if (chunk._status !== PENDING) {
+    // We already resolved. We didn't expect to see this.
+    return;
+  }
+
+  var listeners = chunk._value;
+  var erroredChunk = chunk;
+  erroredChunk._status = ERRORED;
+  erroredChunk._value = error;
+  wakeChunk(listeners);
+}
+
+function createResolvedModelChunk(response, value) {
+  return new Chunk(RESOLVED_MODEL, value, response);
+}
+
+function createResolvedModuleChunk(response, value) {
+  return new Chunk(RESOLVED_MODULE, value, response);
+}
+
+function resolveModelChunk(chunk, value) {
+  if (chunk._status !== PENDING) {
+    // We already resolved. We didn't expect to see this.
+    return;
+  }
+
+  var listeners = chunk._value;
+  var resolvedChunk = chunk;
+  resolvedChunk._status = RESOLVED_MODEL;
+  resolvedChunk._value = value;
+  wakeChunk(listeners);
+}
+
+function resolveModuleChunk(chunk, value) {
+  if (chunk._status !== PENDING) {
+    // We already resolved. We didn't expect to see this.
+    return;
+  }
+
+  var listeners = chunk._value;
+  var resolvedChunk = chunk;
+  resolvedChunk._status = RESOLVED_MODULE;
+  resolvedChunk._value = value;
+  wakeChunk(listeners);
+}
+
+function initializeModelChunk(chunk) {
+  var value = parseModel(chunk._response, chunk._value);
+  var initializedChunk = chunk;
+  initializedChunk._status = INITIALIZED;
+  initializedChunk._value = value;
+  return value;
+}
+
+function initializeModuleChunk(chunk) {
+  var value = requireModule(chunk._value);
+  var initializedChunk = chunk;
+  initializedChunk._status = INITIALIZED;
+  initializedChunk._value = value;
+  return value;
+} // Report that any missing chunks in the model is now going to throw this
+// error upon read. Also notify any pending promises.
+
+
+function reportGlobalError(response, error) {
+  response._chunks.forEach(function (chunk) {
+    // If this chunk was already resolved or errored, it won't
+    // trigger an error but if it wasn't then we need to
+    // because we won't be getting any new data to resolve it.
+    triggerErrorOnChunk(chunk, error);
+  });
+}
+
+function createElement(type, key, props) {
+  var element = {
+    // This tag allows us to uniquely identify this as a React Element
+    $$typeof: REACT_ELEMENT_TYPE,
+    // Built-in properties that belong on the element
+    type: type,
+    key: key,
+    ref: null,
+    props: props,
+    // Record the component responsible for creating this element.
+    _owner: null
+  };
+
+  {
+    // We don't really need to add any of these but keeping them for good measure.
+    // Unfortunately, _store is enumerable in jest matchers so for equality to
+    // work, I need to keep it or make _store non-enumerable in the other file.
+    element._store = {};
+    Object.defineProperty(element._store, 'validated', {
+      configurable: false,
+      enumerable: false,
+      writable: true,
+      value: true // This element has already been validated on the server.
+
+    });
+    Object.defineProperty(element, '_self', {
+      configurable: false,
+      enumerable: false,
+      writable: false,
+      value: null
+    });
+    Object.defineProperty(element, '_source', {
+      configurable: false,
+      enumerable: false,
+      writable: false,
+      value: null
+    });
+  }
+
+  return element;
+}
+
+function createLazyChunkWrapper(chunk) {
+  var lazyType = {
+    $$typeof: REACT_LAZY_TYPE,
+    _payload: chunk,
+    _init: readChunk
+  };
+  return lazyType;
+}
+
+function getChunk(response, id) {
+  var chunks = response._chunks;
+  var chunk = chunks.get(id);
+
+  if (!chunk) {
+    chunk = createPendingChunk(response);
+    chunks.set(id, chunk);
+  }
+
+  return chunk;
+}
+
+function parseModelString(response, parentObject, value) {
+  switch (value[0]) {
+    case '$':
+      {
+        if (value === '$') {
+          return REACT_ELEMENT_TYPE;
+        } else if (value[1] === '$' || value[1] === '@') {
+          // This was an escaped string value.
+          return value.substring(1);
+        } else {
+          var id = parseInt(value.substring(1), 16);
+          var chunk = getChunk(response, id);
+          return readChunk(chunk);
+        }
+      }
+
+    case '@':
+      {
+        var _id = parseInt(value.substring(1), 16);
+
+        var _chunk = getChunk(response, _id); // We create a React.lazy wrapper around any lazy values.
+        // When passed into React, we'll know how to suspend on this.
+
+
+        return createLazyChunkWrapper(_chunk);
+      }
+  }
+
+  return value;
+}
+function parseModelTuple(response, value) {
+  var tuple = value;
+
+  if (tuple[0] === REACT_ELEMENT_TYPE) {
+    // TODO: Consider having React just directly accept these arrays as elements.
+    // Or even change the ReactElement type to be an array.
+    return createElement(tuple[1], tuple[2], tuple[3]);
+  }
+
+  return value;
+}
+function createResponse(bundlerConfig) {
+  var chunks = new Map();
+  var response = {
+    _bundlerConfig: bundlerConfig,
+    _chunks: chunks,
+    readRoot: readRoot
+  };
+  return response;
+}
+function resolveModel(response, id, model) {
+  var chunks = response._chunks;
+  var chunk = chunks.get(id);
+
+  if (!chunk) {
+    chunks.set(id, createResolvedModelChunk(response, model));
+  } else {
+    resolveModelChunk(chunk, model);
+  }
+}
+function resolveProvider(response, id, contextName) {
+  var chunks = response._chunks;
+  chunks.set(id, createInitializedChunk(response, getOrCreateServerContext(contextName).Provider));
+}
+function resolveModule(response, id, model) {
+  var chunks = response._chunks;
+  var chunk = chunks.get(id);
+  var moduleMetaData = parseModel(response, model);
+  var moduleReference = resolveModuleReference(response._bundlerConfig, moduleMetaData); // TODO: Add an option to encode modules that are lazy loaded.
+  // For now we preload all modules as early as possible since it's likely
+  // that we'll need them.
+
+  preloadModule(moduleReference);
+
+  if (!chunk) {
+    chunks.set(id, createResolvedModuleChunk(response, moduleReference));
+  } else {
+    resolveModuleChunk(chunk, moduleReference);
+  }
+}
+function resolveSymbol(response, id, name) {
+  var chunks = response._chunks; // We assume that we'll always emit the symbol before anything references it
+  // to save a few bytes.
+
+  chunks.set(id, createInitializedChunk(response, Symbol.for(name)));
+}
+function resolveError(response, id, message, stack) {
+  // eslint-disable-next-line react-internal/prod-error-codes
+  var error = new Error(message);
+  error.stack = stack;
+  var chunks = response._chunks;
+  var chunk = chunks.get(id);
+
+  if (!chunk) {
+    chunks.set(id, createErrorChunk(response, error));
+  } else {
+    triggerErrorOnChunk(chunk, error);
+  }
+}
+function close(response) {
+  // In case there are any remaining unresolved chunks, they won't
+  // be resolved now. So we need to issue an error to those.
+  // Ideally we should be able to early bail out if we kept a
+  // ref count of pending chunks.
+  reportGlobalError(response, new Error('Connection closed.'));
+}
+
+function processFullRow(response, row) {
+  if (row === '') {
+    return;
+  }
+
+  var tag = row[0]; // When tags that are not text are added, check them here before
+  // parsing the row as text.
+  // switch (tag) {
+  // }
+
+  var colon = row.indexOf(':', 1);
+  var id = parseInt(row.substring(1, colon), 16);
+  var text = row.substring(colon + 1);
+
+  switch (tag) {
+    case 'J':
+      {
+        resolveModel(response, id, text);
+        return;
+      }
+
+    case 'M':
+      {
+        resolveModule(response, id, text);
+        return;
+      }
+
+    case 'P':
+      {
+        resolveProvider(response, id, text);
+        return;
+      }
+
+    case 'S':
+      {
+        resolveSymbol(response, id, JSON.parse(text));
+        return;
+      }
+
+    case 'E':
+      {
+        var errorInfo = JSON.parse(text);
+        resolveError(response, id, errorInfo.message, errorInfo.stack);
+        return;
+      }
+
+    default:
+      {
+        throw new Error("Error parsing the data. It's probably an error code or network corruption.");
+      }
+  }
+}
+
+function processStringChunk(response, chunk, offset) {
+  var linebreak = chunk.indexOf('\n', offset);
+
+  while (linebreak > -1) {
+    var fullrow = response._partialRow + chunk.substring(offset, linebreak);
+    processFullRow(response, fullrow);
+    response._partialRow = '';
+    offset = linebreak + 1;
+    linebreak = chunk.indexOf('\n', offset);
+  }
+
+  response._partialRow += chunk.substring(offset);
+}
+function processBinaryChunk(response, chunk) {
+
+  var stringDecoder = response._stringDecoder;
+  var linebreak = chunk.indexOf(10); // newline
+
+  while (linebreak > -1) {
+    var fullrow = response._partialRow + readFinalStringChunk(stringDecoder, chunk.subarray(0, linebreak));
+    processFullRow(response, fullrow);
+    response._partialRow = '';
+    chunk = chunk.subarray(linebreak + 1);
+    linebreak = chunk.indexOf(10); // newline
+  }
+
+  response._partialRow += readPartialStringChunk(stringDecoder, chunk);
+}
+
+function createFromJSONCallback(response) {
+  return function (key, value) {
+    if (typeof value === 'string') {
+      // We can't use .bind here because we need the "this" value.
+      return parseModelString(response, this, value);
+    }
+
+    if (typeof value === 'object' && value !== null) {
+      return parseModelTuple(response, value);
+    }
+
+    return value;
+  };
+}
+
+function createResponse$1(bundlerConfig) {
+  // NOTE: CHECK THE COMPILER OUTPUT EACH TIME YOU CHANGE THIS.
+  // It should be inlined to one object literal but minor changes can break it.
+  var stringDecoder =  createStringDecoder() ;
+  var response = createResponse(bundlerConfig);
+  response._partialRow = '';
+
+  {
+    response._stringDecoder = stringDecoder;
+  } // Don't inline this call because it causes closure to outline the call above.
+
+
+  response._fromJSON = createFromJSONCallback(response);
+  return response;
+}
+
+function startReadingFromStream(response, stream) {
+  var reader = stream.getReader();
+
+  function progress(_ref) {
+    var done = _ref.done,
+        value = _ref.value;
+
+    if (done) {
+      close(response);
+      return;
+    }
+
+    var buffer = value;
+    processBinaryChunk(response, buffer);
+    return reader.read().then(progress, error);
+  }
+
+  function error(e) {
+    reportGlobalError(response, e);
+  }
+
+  reader.read().then(progress, error);
+}
+
+function createFromReadableStream(stream) {
+  var response = createResponse$1({});
+  startReadingFromStream(response, stream);
+  return response;
+}
+
+function createFromFetch(promiseForResponse) {
+  var response = createResponse$1({});
+  promiseForResponse.then(function (r) {
+    startReadingFromStream(response, r.body);
+  }, function (e) {
+    reportGlobalError(response, e);
+  });
+  return response;
+}
+
+function createFromXHR(request) {
+  var response = createResponse$1({});
+  var processedLength = 0;
+
+  function progress(e) {
+    var chunk = request.responseText;
+    processStringChunk(response, chunk, processedLength);
+    processedLength = chunk.length;
+  }
+
+  function load(e) {
+    progress();
+    close(response);
+  }
+
+  function error(e) {
+    reportGlobalError(response, new TypeError('Network error'));
+  }
+
+  request.addEventListener('progress', progress);
+  request.addEventListener('load', load);
+  request.addEventListener('error', error);
+  request.addEventListener('abort', error);
+  request.addEventListener('timeout', error);
+  return response;
+}
+
+exports.createFromFetch = createFromFetch;
+exports.createFromReadableStream = createFromReadableStream;
+exports.createFromXHR = createFromXHR;
+  })();
+}
diff --git a/vendor/vendor/react-server-dom-vite/cjs/react-server-dom-vite.production.min.js b/vendor/vendor/react-server-dom-vite/cjs/react-server-dom-vite.production.min.js
new file mode 100644
index 0000000000000000000000000000000000000000..f4e8362d69707b156b5f38f1097498f441df1296
--- /dev/null
+++ b/vendor/vendor/react-server-dom-vite/cjs/react-server-dom-vite.production.min.js
@@ -0,0 +1,19 @@
+/**
+ * @license React
+ * react-server-dom-vite.production.min.js
+ *
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+'use strict';var g=require("react"),h={stream:!0},l={__INJECTED_CLIENT_IMPORTERS__:null};(void 0).DEV&&"undefined"!==typeof jest&&(global.allClientComponents=l);function m(a){var b=l[a];return b?"function"===typeof b?b():Promise.resolve(b):Promise.reject(Error("Could not find client component "+a))}var n=new Map;function p(a){function b(a){n.set(c,a);return a}var c=a.id;n.has(c)||(a=m(c),b(a),a.then(b,b))}
+var q=Symbol.for("react.element"),r=Symbol.for("react.lazy"),t=Symbol.for("react.default_value"),v=g.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ContextRegistry;function w(a){v[a]||(v[a]=g.createServerContext(a,t));return v[a]}function x(a,b,c){this._status=a;this._value=b;this._response=c}x.prototype.then=function(a){0===this._status?(null===this._value&&(this._value=[]),this._value.push(a)):a()};
+function y(a){switch(a._status){case 3:return a._value;case 1:var b=JSON.parse(a._value,a._response._fromJSON);a._status=3;return a._value=b;case 2:var c=a._value;b=c.name;c=n.get(c.id);if(!c||c instanceof Promise||c instanceof Error)throw c;b=c[b];a._status=3;return a._value=b;case 0:throw a;default:throw a._value;}}function z(){var a=A(this,0);return y(a)}function B(a,b){return new x(3,b,a)}function C(a){if(null!==a)for(var b=0;b<a.length;b++)(0,a[b])()}
+function D(a,b){if(0===a._status){var c=a._value;a._status=4;a._value=b;C(c)}}function E(a,b){a._chunks.forEach(function(a){D(a,b)})}function A(a,b){var c=a._chunks,d=c.get(b);d||(d=new x(0,null,a),c.set(b,d));return d}function F(a,b,c){switch(c[0]){case "$":if("$"===c)return q;if("$"===c[1]||"@"===c[1])return c.substring(1);b=parseInt(c.substring(1),16);a=A(a,b);return y(a);case "@":return b=parseInt(c.substring(1),16),a=A(a,b),{$$typeof:r,_payload:a,_init:y}}return c}
+function G(a){E(a,Error("Connection closed."))}
+function H(a,b){if(""!==b){var c=b[0],d=b.indexOf(":",1),e=parseInt(b.substring(1,d),16);b=b.substring(d+1);switch(c){case "J":d=a._chunks;(c=d.get(e))?0===c._status&&(a=c._value,c._status=1,c._value=b,C(a)):d.set(e,new x(1,b,a));break;case "M":d=a._chunks;c=d.get(e);b=JSON.parse(b,a._fromJSON);p(b);c?0===c._status&&(a=c._value,c._status=2,c._value=b,C(a)):d.set(e,new x(2,b,a));break;case "P":a._chunks.set(e,B(a,w(b).Provider));break;case "S":b=JSON.parse(b);a._chunks.set(e,B(a,Symbol.for(b)));break;
+case "E":c=JSON.parse(b);b=Error(c.message);b.stack=c.stack;c=a._chunks;(d=c.get(e))?D(d,b):c.set(e,new x(4,b,a));break;default:throw Error("Error parsing the data. It's probably an error code or network corruption.");}}}function I(a){return function(b,c){return"string"===typeof c?F(a,this,c):"object"===typeof c&&null!==c?(b=c[0]===q?{$$typeof:q,type:c[1],key:c[2],ref:null,props:c[3],_owner:null}:c,b):c}}
+function J(a){var b=new TextDecoder,c=new Map;a={_bundlerConfig:a,_chunks:c,readRoot:z,_partialRow:"",_stringDecoder:b};a._fromJSON=I(a);return a}function K(a,b){function c(b){var k=b.value;if(b.done)G(a);else{b=k;k=a._stringDecoder;for(var f=b.indexOf(10);-1<f;){var L=a._partialRow;var u=b.subarray(0,f);u=k.decode(u);H(a,L+u);a._partialRow="";b=b.subarray(f+1);f=b.indexOf(10)}a._partialRow+=k.decode(b,h);return e.read().then(c,d)}}function d(b){E(a,b)}var e=b.getReader();e.read().then(c,d)}
+exports.createFromFetch=function(a){var b=J({});a.then(function(a){K(b,a.body)},function(a){E(b,a)});return b};exports.createFromReadableStream=function(a){var b=J({});K(b,a);return b};
+exports.createFromXHR=function(a){function b(){for(var b=a.responseText,c=e,f=b.indexOf("\n",c);-1<f;)c=d._partialRow+b.substring(c,f),H(d,c),d._partialRow="",c=f+1,f=b.indexOf("\n",c);d._partialRow+=b.substring(c);e=b.length}function c(){E(d,new TypeError("Network error"))}var d=J({}),e=0;a.addEventListener("progress",b);a.addEventListener("load",function(){b();G(d)});a.addEventListener("error",c);a.addEventListener("abort",c);a.addEventListener("timeout",c);return d};
diff --git a/vendor/vendor/react-server-dom-vite/esm/package.json b/vendor/vendor/react-server-dom-vite/esm/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..3dbc1ca591c0557e35b6004aeba250e6a70b56e3
--- /dev/null
+++ b/vendor/vendor/react-server-dom-vite/esm/package.json
@@ -0,0 +1,3 @@
+{
+  "type": "module"
+}
diff --git a/vendor/vendor/react-server-dom-vite/esm/react-server-dom-vite-client-proxy.js b/vendor/vendor/react-server-dom-vite/esm/react-server-dom-vite-client-proxy.js
new file mode 100644
index 0000000000000000000000000000000000000000..5daa091495c5301421f074249b2fdf48d73f0206
--- /dev/null
+++ b/vendor/vendor/react-server-dom-vite/esm/react-server-dom-vite-client-proxy.js
@@ -0,0 +1,83 @@
+/**
+* @license React
+ * react-server-dom-vite-client-proxy.js
+ *
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+import { __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED } from 'react';
+
+// Store of components discovered during RSC to load
+// them later when consuming the response in SSR.
+globalThis.__COMPONENT_INDEX = {}; // Store to get module references for long strings
+// when rendering in RSC (strings cannot be wrapped Proxy).
+
+globalThis.__STRING_REFERENCE_INDEX = {};
+var MODULE_TAG = Symbol.for('react.module.reference');
+var STRING_SIZE_LIMIT = 64;
+var FN_RSC_ERROR = 'Functions exported from client components cannot be called or used as constructors from a server component.';
+function isRsc() {
+  var currentDispatcher = __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher.current;
+  return !!(currentDispatcher && currentDispatcher.isRsc);
+}
+
+function createModuleReference(id, value, name, isDefault) {
+  var moduleRef = Object.create(null);
+  moduleRef.$$typeof = MODULE_TAG;
+  moduleRef.filepath = id;
+  moduleRef.name = isDefault ? 'default' : name; // Store component in a global index during RSC to use it later in SSR
+
+  globalThis.__COMPONENT_INDEX[id] = Object.defineProperty(globalThis.__COMPONENT_INDEX[id] || Object.create(null), moduleRef.name, {
+    value: value,
+    writable: true
+  });
+  return moduleRef;
+} // A ClientProxy behaves as a module reference for the Flight
+// runtime (RSC) and as a real component for the Fizz runtime (SSR).
+// Note that this is not used in browser environments.
+
+
+function wrapInClientProxy(_ref) {
+  var id = _ref.id,
+      name = _ref.name,
+      isDefault = _ref.isDefault,
+      value = _ref.value;
+  var type = typeof value;
+
+  if (value === null || type !== 'object' && type !== 'function') {
+    if (type === 'string' && value.length >= STRING_SIZE_LIMIT) {
+      var _moduleRef = createModuleReference(id, value, name, isDefault);
+
+      globalThis.__STRING_REFERENCE_INDEX[value] = _moduleRef;
+    }
+
+    return value;
+  }
+
+  var moduleRef = createModuleReference(id, value, name, isDefault);
+
+  var get = function (target, prop, receiver) {
+    if (prop === '$$unwrappedValue') return value;
+    if (prop === '$$moduleReference') return moduleRef;
+    return Reflect.get(isRsc() ? moduleRef : target, prop, receiver);
+  };
+
+  return new Proxy(value, type === 'object' ? {
+    get: get
+  } : {
+    get: get,
+    apply: function () {
+      if (isRsc()) throw new Error(FN_RSC_ERROR + (" Calling \"" + name + "\"."));
+      return Reflect.apply.apply(Reflect, arguments);
+    },
+    construct: function () {
+      if (isRsc()) throw new Error(FN_RSC_ERROR + (" Instantiating \"" + name + "\"."));
+      return Reflect.construct.apply(Reflect, arguments);
+    }
+  });
+}
+
+export { FN_RSC_ERROR, MODULE_TAG, STRING_SIZE_LIMIT, isRsc, wrapInClientProxy };
diff --git a/vendor/vendor/react-server-dom-vite/esm/react-server-dom-vite-plugin.js b/vendor/vendor/react-server-dom-vite/esm/react-server-dom-vite-plugin.js
new file mode 100644
index 0000000000000000000000000000000000000000..86a59df95ec7885df77d4f2520b5c6faf4f40ac6
--- /dev/null
+++ b/vendor/vendor/react-server-dom-vite/esm/react-server-dom-vite-plugin.js
@@ -0,0 +1,628 @@
+/**
+* @license React
+ * react-server-dom-vite-plugin.js
+ *
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+import { init, parse } from 'es-module-lexer';
+import MagicString from 'magic-string';
+import { promises } from 'fs';
+import path from 'path';
+import { version, normalizePath as normalizePath$1, transformWithEsbuild as transformWithEsbuild$1, createServer as createServer$1 } from 'vite';
+
+function _unsupportedIterableToArray(o, minLen) {
+  if (!o) return;
+  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
+  var n = Object.prototype.toString.call(o).slice(8, -1);
+  if (n === "Object" && o.constructor) n = o.constructor.name;
+  if (n === "Map" || n === "Set") return Array.from(o);
+  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
+}
+
+function _arrayLikeToArray(arr, len) {
+  if (len == null || len > arr.length) len = arr.length;
+
+  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
+
+  return arr2;
+}
+
+function _createForOfIteratorHelper(o, allowArrayLike) {
+  var it;
+
+  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
+    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
+      if (it) o = it;
+      var i = 0;
+
+      var F = function () {};
+
+      return {
+        s: F,
+        n: function () {
+          if (i >= o.length) return {
+            done: true
+          };
+          return {
+            done: false,
+            value: o[i++]
+          };
+        },
+        e: function (e) {
+          throw e;
+        },
+        f: F
+      };
+    }
+
+    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
+  }
+
+  var normalCompletion = true,
+      didErr = false,
+      err;
+  return {
+    s: function () {
+      it = o[Symbol.iterator]();
+    },
+    n: function () {
+      var step = it.next();
+      normalCompletion = step.done;
+      return step;
+    },
+    e: function (e) {
+      didErr = true;
+      err = e;
+    },
+    f: function () {
+      try {
+        if (!normalCompletion && it.return != null) it.return();
+      } finally {
+        if (didErr) throw err;
+      }
+    }
+  };
+}
+
+var assign = Object.assign;
+
+var normalizePath = normalizePath$1,
+    transformWithEsbuild = transformWithEsbuild$1,
+    createServer = createServer$1;
+var isVite3 = version && version.startsWith('3.');
+var rscViteFileRE = /\/react-server-dom-vite.js/;
+var noProxyRE = /[&?]no-proxy($|&)/;
+
+var isClientComponent = function (id) {
+  return /\.client\.[jt]sx?($|\?)/.test(id);
+};
+
+function ReactFlightVitePlugin() {
+  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
+      serverBuildEntries = _ref.serverBuildEntries,
+      _ref$optimizeBoundari = _ref.optimizeBoundaries,
+      optimizeBoundaries = _ref$optimizeBoundari === void 0 ? 'build' : _ref$optimizeBoundari,
+      _ref$isServerComponen = _ref.isServerComponentImporterAllowed,
+      isServerComponentImporterAllowed = _ref$isServerComponen === void 0 ? function (importer) {
+    return false;
+  } : _ref$isServerComponen;
+
+  var config;
+  var server;
+  var resolveAlias;
+  var globImporterPath;
+  var allClientBoundaries = new Set();
+
+  function invalidateGlobImporter() {
+    if (globImporterPath && server) {
+      server.watcher.emit('change', globImporterPath);
+    }
+  }
+
+  return {
+    name: 'vite-plugin-react-server-components',
+    enforce: 'pre',
+    buildStart: function () {
+      // Let other plugins differentiate between pure SSR and RSC builds
+      if (config?.build?.ssr) process.env.VITE_RSC_BUILD = 'true';
+    },
+    buildEnd: function () {
+      if (config?.build?.ssr) delete process.env.VITE_RSC_BUILD;
+    },
+    configureServer: function (_server) {
+      server = _server;
+      var seenModules = {};
+      server.ws.on('rsc:cc404', function (data) {
+        if (!seenModules[data.id]) {
+          seenModules[data.id] = true;
+          invalidateGlobImporter();
+        }
+      });
+    },
+    configResolved: async function (_config) {
+      await init;
+      config = _config;
+      var aliasPlugin = config.plugins.find(function (plugin) {
+        return plugin.name === 'alias';
+      });
+
+      if (aliasPlugin) {
+        resolveAlias = aliasPlugin.resolveId.bind({
+          // Mock Rollup instance
+          resolve: function (id) {
+            return {
+              then: function () {
+                return id ? {
+                  id: id
+                } : null;
+              }
+            };
+          }
+        });
+      } // By pushing this plugin at the end of the existing array,
+      // we enforce running it *after* Vite resolves import.meta.glob.
+
+
+      config.plugins.push(hashImportsPlugin);
+    },
+    resolveId: function (source, importer) {
+      if (!importer) return null;
+
+      if (noProxyRE.test(source)) {
+        var _source$split = source.split('?'),
+            id = _source$split[0],
+            query = _source$split[1];
+
+        return this.resolve(id, importer, {
+          skipSelf: true
+        }).then(function (result) {
+          if (!result) return null;
+          return assign({}, result, {
+            id: result.id + (query ? "?" + query : ''),
+            moduleSideEffects: false
+          });
+        });
+      }
+      /**
+       * Throw errors when non-Server Components try to load Server Components.
+       */
+
+
+      if (/\.server(\.[jt]sx?)?$/.test(source) && !(/(\.server\.[jt]sx?|index\.html)$/.test(importer) || isServerComponentImporterAllowed(importer, source))) {
+        throw new Error("Cannot import " + source + " from \"" + importer + "\". " + 'By react-server convention, .server.js files can only be imported from other .server.js files. ' + 'That way nobody accidentally sends these to the client by indirectly importing it.');
+      }
+    },
+    load: function (id) {
+      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
+      if (!options.ssr || !isClientComponent(id) || noProxyRE.test(id)) return;
+
+      if (server) {
+        var mod = server.moduleGraph.idToModuleMap.get(id.replace('/@fs', ''));
+
+        if (mod && mod.importers) {
+          if (Array.from(mod.importers).every(function (impMod) {
+            return noProxyRE.test(impMod.id);
+          })) {
+            // This module is only imported from client components
+            // so we don't need to create a module reference
+            return;
+          }
+        } // Mark module as a client component.
+
+
+        var moduleNode = server.moduleGraph.getModuleById(id);
+        if (!moduleNode.meta) moduleNode.meta = {};
+
+        if (!moduleNode.meta.isClientComponent) {
+          moduleNode.meta.isClientComponent = true; // Invalidate glob importer file to account for the
+          // newly discovered client component.
+
+          invalidateGlobImporter();
+        }
+      }
+
+      return proxyClientComponent(id.split('?')[0]);
+    },
+    transform: function (code, id) {
+      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
+
+      // Add more information for this module in the graph.
+      // It will be used later to discover client boundaries.
+      if (server && options.ssr && /\.[jt]sx?($|\?)/.test(id)) {
+        augmentModuleGraph(server.moduleGraph, id, code, config.root, resolveAlias);
+      }
+      /**
+       * In order to allow dynamic component imports from RSC, we use Vite's import.meta.glob.
+       * This hook replaces the glob placeholders with resolved paths to all client components.
+       *
+       * NOTE: Glob import paths MUST be relative to the importer file in
+       * order to get the `?v=xxx` querystring from Vite added to the import URL.
+       * If the paths are relative to the root instead, Vite won't add the querystring
+       * and we will have duplicated files in the browser (with duplicated contexts, etc).
+       */
+
+
+      if (rscViteFileRE.test(id)) {
+        var INJECTING_RE = /\{\s*__INJECTED_CLIENT_IMPORTERS__[:\s]*null[,\s]*\}\s*;/;
+        var s = new MagicString(code);
+        id = id.split('?')[0];
+
+        if (options && options.ssr) {
+          // In SSR, directly use components already discovered by RSC
+          // instead of globs to avoid bundling unused components.
+          s.replace(INJECTING_RE, 'globalThis.__COMPONENT_INDEX');
+          return {
+            code: s.toString(),
+            map: s.generateMap({
+              file: id,
+              source: id
+            })
+          };
+        }
+
+        var injectGlobs = function (clientComponents) {
+          var importerPath = path.dirname(id);
+          var importers = clientComponents.map(function (absolutePath) {
+            return normalizePath(path.relative(importerPath, absolutePath));
+          });
+          var injectedGlobs = "Object.assign(Object.create(null), " + importers.map(function (glob) {
+            return (// Mark the globs to modify the result after Vite resolves them.
+              "\n/* HASH_BEGIN */ " + ("import.meta.glob('" + normalizePath(glob) + "') /* HASH_END */")
+            );
+          }).join(', ') + ");";
+          s.replace(INJECTING_RE, injectedGlobs);
+          return {
+            code: s.toString(),
+            map: s.generateMap({
+              file: id,
+              source: id
+            })
+          };
+        };
+
+        if (config.command === 'serve') {
+          globImporterPath = id; // When mixing client and server components from the same
+          // facade file, the module graph can break and miss certain
+          // import connections (bug in Vite?) due to HMR. Instead of
+          // creating a new list of discovered components from scratch,
+          // reuse the already discovered ones and simply add new ones
+          // to the list without removing anything.
+
+          findClientBoundaries(server.moduleGraph, optimizeBoundaries === true).forEach(function (boundary) {
+            return allClientBoundaries.add(boundary);
+          });
+          return injectGlobs(Array.from(allClientBoundaries));
+        }
+
+        if (!serverBuildEntries) {
+          throw new Error('[react-server-dom-vite] Parameter serverBuildEntries is required for client build');
+        }
+
+        return findClientBoundariesForClientBuild(serverBuildEntries, optimizeBoundaries !== false, config.root).then(injectGlobs);
+      }
+    },
+    handleHotUpdate: function (_ref2) {
+      var modules = _ref2.modules;
+
+      if (modules.some(function (mod) {
+        return mod.meta && mod.meta.isClientComponent;
+      })) {
+        return modules.filter(function (mod) {
+          return !mod.meta || !mod.meta.ssr;
+        });
+      }
+
+      return modules;
+    }
+  };
+}
+
+var btoa = function (hash) {
+  return (// eslint-disable-next-line react-internal/safe-string-coercion
+    Buffer.from(String(hash), 'binary').toString('base64')
+  );
+}; // Quick, lossy hash function: https://stackoverflow.com/a/8831937/4468962
+// Prevents leaking path information in the browser, and minifies RSC responses.
+
+
+function hashCode(value) {
+  var hash = 0;
+
+  for (var i = 0; i < value.length; i++) {
+    var char = value.charCodeAt(i);
+    hash = (hash << 5) - hash + char;
+    hash &= hash;
+  }
+
+  return btoa(hash).replace(/=+/, '');
+}
+
+var getComponentFilename = function (filepath) {
+  return filepath.split('/').pop().split('.').shift();
+};
+
+var getComponentId = function (filepath) {
+  return getComponentFilename(filepath) + "-" + hashCode(filepath);
+};
+async function proxyClientComponent(filepath, src) {
+  var DEFAULT_EXPORT = 'default'; // Modify the import ID to avoid infinite wraps
+
+  var importFrom = filepath + "?no-proxy";
+  await init;
+
+  if (!src) {
+    src = await promises.readFile(filepath, 'utf-8');
+  }
+
+  var _await$transformWithE = await transformWithEsbuild(src, filepath),
+      code = _await$transformWithE.code;
+
+  var _parse = parse(code),
+      exportStatements = _parse[1];
+
+  var proxyCode = "import {wrapInClientProxy} from 'react-server-dom-vite/client-proxy';\n" + ("import * as allImports from '" + importFrom + "';\n\n"); // Wrap components in Client Proxy
+
+  exportStatements.forEach(function (key) {
+    var isDefault = key === DEFAULT_EXPORT;
+    var componentName = isDefault ? getComponentFilename(filepath) : key;
+    proxyCode += "export " + (isDefault ? DEFAULT_EXPORT : "const " + componentName + " =") + " /* @__PURE__ */wrapInClientProxy({ name: '" + componentName + "', id: '" + getComponentId(filepath) + "', value: allImports['" + key + "'], isDefault: " + // eslint-disable-next-line react-internal/safe-string-coercion
+    String(isDefault) + " });\n";
+  });
+  return {
+    code: proxyCode,
+    moduleSideEffects: false
+  };
+}
+
+function findClientBoundaries(moduleGraph) {
+  var optimizeBoundaries = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
+  var clientBoundaries = []; // eslint-disable-next-line no-for-of-loops/no-for-of-loops
+
+  var _iterator = _createForOfIteratorHelper(moduleGraph.fileToModulesMap.values()),
+      _step;
+
+  try {
+    for (_iterator.s(); !(_step = _iterator.n()).done;) {
+      var set = _step.value;
+      var clientModule = Array.from(set).find(function (moduleNode) {
+        return moduleNode.meta && moduleNode.meta.isClientComponent;
+      });
+
+      if (clientModule && (!optimizeBoundaries || isDirectImportInServer(clientModule))) {
+        clientBoundaries.push(clientModule.file);
+      }
+    }
+  } catch (err) {
+    _iterator.e(err);
+  } finally {
+    _iterator.f();
+  }
+
+  return clientBoundaries;
+}
+
+async function findClientBoundariesForClientBuild(serverEntries, optimizeBoundaries, root) {
+  // Viteception
+  var server = await createServer({
+    root: root,
+    clearScreen: false,
+    server: {
+      middlewareMode: isVite3 ? true : 'ssr',
+      hmr: false
+    },
+    appType: 'custom'
+  });
+
+  try {
+    // Load server entries to discover client components
+    await Promise.all(serverEntries.map(server.ssrLoadModule));
+  } catch (error) {
+    error.message = 'Could not load server build entries: ' + error.message;
+    throw error;
+  }
+
+  await server.close();
+  return findClientBoundaries(server.moduleGraph, optimizeBoundaries);
+}
+
+var hashImportsPlugin = {
+  name: 'vite-plugin-react-server-components-hash-imports',
+  enforce: 'post',
+  transform: function (code, id) {
+    // Turn relative import paths to lossy hashes
+    if (rscViteFileRE.test(id)) {
+      var s = new MagicString(code);
+      s.replace(/\/\*\s*HASH_BEGIN\s*\*\/\s*([^]+?)\/\*\s*HASH_END\s*\*\//gm, function (_, imports) {
+        return imports.trim().replace(/"([^"]+?)":/gm, function (all, relativePath) {
+          if (relativePath === '__VITE_PRELOAD__') return all;
+          var absolutePath = path.resolve(path.dirname(id.split('?')[0]), relativePath);
+          return "\"" + getComponentId(normalizePath(absolutePath)) + "\":";
+        });
+      });
+      return {
+        code: s.toString(),
+        map: s.generateMap({
+          file: id,
+          source: id
+        })
+      };
+    }
+  }
+};
+
+/**
+ * A client module should behave as a client boundary
+ * if it is imported by the server before encountering
+ * another boundary in the process.
+ * This traverses the module graph upwards to find non client
+ * components that import the `originalMod`.
+ *
+ * The `accModInfo` represents the exported members from the
+ * `originalMod` but renamed accordingly to all the intermediate/facade
+ * files in the import chain from the `originalMod` to every parent importer.
+ */
+function isDirectImportInServer(originalMod, currentMod, accModInfo) {
+  // TODO: this should use recursion in any module that exports
+  // the original one, not only in full facade files.
+  if (!currentMod || (currentMod.meta || {}).isFacade) {
+    if (!accModInfo && originalMod.meta && originalMod.meta.namedExports) {
+      // First iteration in the recursion, initialize the
+      // acumulator with data from the original module.
+      accModInfo = {
+        file: originalMod.file,
+        exports: originalMod.meta.namedExports
+      };
+    }
+
+    if (currentMod && accModInfo) {
+      // Update accumulator in subsequent iterations with
+      // whatever the current module is re-exporting.
+      var lastModExports = accModInfo.exports;
+      var lastModImports = currentMod.meta.imports.filter(function (importMeta) {
+        return importMeta.action === 'export' && importMeta.from === accModInfo.file;
+      });
+      accModInfo = {
+        file: currentMod.file,
+        exports: []
+      };
+      lastModImports.forEach(function (mod) {
+        mod.variables.forEach(function (_ref3) {
+          var name = _ref3[0],
+              alias = _ref3[1];
+
+          if (name === '*' && !alias) {
+            var _accModInfo$exports;
+
+            (_accModInfo$exports = accModInfo.exports).push.apply(_accModInfo$exports, lastModExports);
+          } else {
+            accModInfo.exports.push(alias || name);
+          }
+        });
+      });
+    }
+
+    return Array.from((currentMod || originalMod).importers || []).some(function (importer) {
+      return (// eslint-disable-next-line no-unused-vars
+        isDirectImportInServer(originalMod, importer, accModInfo)
+      );
+    });
+  } // Not enough information: safer to assume it is
+  // imported in server to create a new boundary.
+
+
+  if (!currentMod.meta || !originalMod.meta) return true; // If current module is a client component, stop checking
+  // parents since this can be the actual boundary.
+
+  if (isClientComponent(currentMod.file)) return false; // If current module is not a client component, assume
+  // it is a server component on a shared component
+  // that will be imported in the server to be safe.
+  // However, due to the lack of tree-shaking in the dev module graph,
+  // we need to manually make sure this module is importing something from
+  // the original module before marking it as client boundary.
+
+  return currentMod.meta.imports.some(function (imp) {
+    return imp.from === accModInfo.file && (imp.variables || []).some(function (_ref4) {
+      var name = _ref4[0];
+      return accModInfo.exports.includes(name);
+    });
+  });
+}
+
+var RESOLVE_EXTENSIONS = ['', '.js', '.ts', '.jsx', '.tsx', '/index', '/index.js', '/index.ts', '/index.jsx', '/index.tsx']; // Resolve relative paths  and aliases. Examples:
+// - import {XYZ} from '~/components' => import {XYZ} from '<absolute>/src/components/index.ts'
+// - import {XYZ} from '/src/component.client' => import {XYZ} from '<absolute>/src/component.client.jsx'`
+
+function resolveModPath(modPath, dirname) {
+  var extensions = /\.[jt]sx?$/.test(modPath) ? [''] : RESOLVE_EXTENSIONS;
+
+  for (var i = 0; i < extensions.length; i++) {
+    var extension = extensions[i];
+
+    try {
+      var absolutePath = modPath.startsWith('.') ? normalizePath(path.resolve(dirname, modPath)) : modPath;
+      return normalizePath(require.resolve(absolutePath + extension));
+    } catch (error) {// Do not throw, this is likely a virtual module or another exception
+    }
+  }
+}
+
+function augmentModuleGraph(moduleGraph, id, code, root, resolveAlias) {
+  var currentModule = moduleGraph.getModuleById(id);
+  if (!currentModule) return;
+
+  var _id$split = id.split('?'),
+      source = _id$split[0];
+
+  var dirname = normalizePath(path.dirname(source));
+
+  var _parse2 = parse(code),
+      rawImports = _parse2[0],
+      namedExports = _parse2[1],
+      isFacade = _parse2[2]; // This is currently not used but it should be considered
+  // to improve the crawling in `isDirectImportInServer`.
+
+
+  var imports = [];
+  rawImports.forEach(function (_ref5) {
+    var startMod = _ref5.s,
+        endMod = _ref5.e,
+        dynamicImportIndex = _ref5.d,
+        startStatement = _ref5.ss,
+        endStatement = _ref5.se;
+    if (dynamicImportIndex !== -1) return; // Skip dynamic imports for now
+
+    var rawModPath = code.slice(startMod, endMod);
+    var modPath = rawModPath.split('?')[0];
+
+    if (resolveAlias) {
+      var resolvedAliasPath = resolveAlias(modPath, 'rsc_importer', {});
+
+      if (resolvedAliasPath && resolvedAliasPath.id) {
+        modPath = resolvedAliasPath.id;
+      }
+    }
+
+    if (modPath && modPath.startsWith('/src/')) {
+      // Vite default alias
+      modPath = normalizePath(path.join(root, modPath));
+    }
+
+    var resolvedPath = resolveModPath(modPath, dirname);
+    if (!resolvedPath) return; // Virtual modules or other exceptions
+
+    var _code$slice$split$0$s = code.slice(startStatement, endStatement).split(/\s+(from\s+)?['"]/m)[0].split(/\s+(.+)/m),
+        action = _code$slice$split$0$s[0],
+        _code$slice$split$0$s2 = _code$slice$split$0$s[1],
+        variables = _code$slice$split$0$s2 === void 0 ? '' : _code$slice$split$0$s2;
+
+    imports.push({
+      action: action,
+      // 'import' or 'export'
+      variables: variables // [['originalName', 'alias']]
+      .trim().replace(/^[^{*]/, 'default as $&').replace(/[{}]/gm, '').trim().split(/\s*,\s*/m).filter(Boolean).map(function (s) {
+        return s.split(/\s+as\s+/m);
+      }),
+      from: resolvedPath,
+      // '/absolute/path'
+      originalFrom: rawModPath // './path' or '3plib/subpath'
+
+    });
+  });
+
+  if (!currentModule.meta) {
+    currentModule.meta = {};
+  }
+
+  assign(currentModule.meta, {
+    isFacade: isFacade,
+    namedExports: namedExports,
+    imports: imports,
+    ssr: true
+  });
+}
+
+export default ReactFlightVitePlugin;
diff --git a/vendor/vendor/react-server-dom-vite/esm/react-server-dom-vite-writer.browser.server.js b/vendor/vendor/react-server-dom-vite/esm/react-server-dom-vite-writer.browser.server.js
new file mode 100644
index 0000000000000000000000000000000000000000..b9ff949f57cbff7de274a081bac7149f247b054d
--- /dev/null
+++ b/vendor/vendor/react-server-dom-vite/esm/react-server-dom-vite-writer.browser.server.js
@@ -0,0 +1,1876 @@
+/**
+* @license React
+ * react-server-dom-vite-writer.browser.server.js
+ *
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+import { __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, createServerContext } from 'react';
+
+var assign = Object.assign;
+
+var ReactSharedInternals = __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
+
+function error(format) {
+  {
+    {
+      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
+        args[_key2 - 1] = arguments[_key2];
+      }
+
+      printWarning('error', format, args);
+    }
+  }
+}
+
+function printWarning(level, format, args) {
+  // When changing this logic, you might want to also
+  // update consoleWithStackDev.www.js as well.
+  {
+    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
+    var stack = ReactDebugCurrentFrame.getStackAddendum();
+
+    if (stack !== '') {
+      format += '%s';
+      args = args.concat([stack]);
+    } // eslint-disable-next-line react-internal/safe-string-coercion
+
+
+    var argsWithFormat = args.map(function (item) {
+      return String(item);
+    }); // Careful: RN currently depends on this prefix
+
+    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
+    // breaks IE9: https://github.com/facebook/react/issues/13610
+    // eslint-disable-next-line react-internal/no-production-logging
+
+    Function.prototype.apply.call(console[level], console, argsWithFormat);
+  }
+}
+
+function scheduleWork(callback) {
+  callback();
+}
+var VIEW_SIZE = 512;
+var currentView = null;
+var writtenBytes = 0;
+function beginWriting(destination) {
+  currentView = new Uint8Array(VIEW_SIZE);
+  writtenBytes = 0;
+}
+function writeChunk(destination, chunk) {
+  if (chunk.length === 0) {
+    return;
+  }
+
+  if (chunk.length > VIEW_SIZE) {
+    // this chunk may overflow a single view which implies it was not
+    // one that is cached by the streaming renderer. We will enqueu
+    // it directly and expect it is not re-used
+    if (writtenBytes > 0) {
+      destination.enqueue(new Uint8Array(currentView.buffer, 0, writtenBytes));
+      currentView = new Uint8Array(VIEW_SIZE);
+      writtenBytes = 0;
+    }
+
+    destination.enqueue(chunk);
+    return;
+  }
+
+  var bytesToWrite = chunk;
+  var allowableBytes = currentView.length - writtenBytes;
+
+  if (allowableBytes < bytesToWrite.length) {
+    // this chunk would overflow the current view. We enqueue a full view
+    // and start a new view with the remaining chunk
+    if (allowableBytes === 0) {
+      // the current view is already full, send it
+      destination.enqueue(currentView);
+    } else {
+      // fill up the current view and apply the remaining chunk bytes
+      // to a new view.
+      currentView.set(bytesToWrite.subarray(0, allowableBytes), writtenBytes); // writtenBytes += allowableBytes; // this can be skipped because we are going to immediately reset the view
+
+      destination.enqueue(currentView);
+      bytesToWrite = bytesToWrite.subarray(allowableBytes);
+    }
+
+    currentView = new Uint8Array(VIEW_SIZE);
+    writtenBytes = 0;
+  }
+
+  currentView.set(bytesToWrite, writtenBytes);
+  writtenBytes += bytesToWrite.length;
+}
+function writeChunkAndReturn(destination, chunk) {
+  writeChunk(destination, chunk); // in web streams there is no backpressure so we can alwas write more
+
+  return true;
+}
+function completeWriting(destination) {
+  if (currentView && writtenBytes > 0) {
+    destination.enqueue(new Uint8Array(currentView.buffer, 0, writtenBytes));
+    currentView = null;
+    writtenBytes = 0;
+  }
+}
+function close(destination) {
+  destination.close();
+}
+var textEncoder = new TextEncoder();
+function stringToChunk(content) {
+  return textEncoder.encode(content);
+}
+function stringToPrecomputedChunk(content) {
+  return textEncoder.encode(content);
+}
+function closeWithError(destination, error) {
+  if (typeof destination.error === 'function') {
+    // $FlowFixMe: This is an Error object or the destination accepts other types.
+    destination.error(error);
+  } else {
+    // Earlier implementations doesn't support this method. In that environment you're
+    // supposed to throw from a promise returned but we don't return a promise in our
+    // approach. We could fork this implementation but this is environment is an edge
+    // case to begin with. It's even less common to run this in an older environment.
+    // Even then, this is not where errors are supposed to happen and they get reported
+    // to a global callback in addition to this anyway. So it's fine just to close this.
+    destination.close();
+  }
+}
+
+// This file is an intermediate layer to translate between Flight
+var stringify = JSON.stringify;
+
+function serializeRowHeader(tag, id) {
+  return tag + id.toString(16) + ':';
+}
+
+function processErrorChunk(request, id, message, stack) {
+  var errorInfo = {
+    message: message,
+    stack: stack
+  };
+  var row = serializeRowHeader('E', id) + stringify(errorInfo) + '\n';
+  return stringToChunk(row);
+}
+function processModelChunk(request, id, model) {
+  var json = stringify(model, request.toJSON);
+  var row = serializeRowHeader('J', id) + json + '\n';
+  return stringToChunk(row);
+}
+function processReferenceChunk(request, id, reference) {
+  var json = stringify(reference);
+  var row = serializeRowHeader('J', id) + json + '\n';
+  return stringToChunk(row);
+}
+function processModuleChunk(request, id, moduleMetaData) {
+  var json = stringify(moduleMetaData);
+  var row = serializeRowHeader('M', id) + json + '\n';
+  return stringToChunk(row);
+}
+function processProviderChunk(request, id, contextName) {
+  var row = serializeRowHeader('P', id) + contextName + '\n';
+  return stringToChunk(row);
+}
+function processSymbolChunk(request, id, name) {
+  var json = stringify(name);
+  var row = serializeRowHeader('S', id) + json + '\n';
+  return stringToChunk(row);
+}
+
+// eslint-disable-next-line no-unused-vars
+var MODULE_TAG = Symbol.for('react.module.reference');
+function getModuleKey(reference) {
+  if (typeof reference === 'string') reference = globalThis.__STRING_REFERENCE_INDEX[reference];
+  return reference.filepath + '#' + reference.name;
+}
+function isModuleReference(reference) {
+  if (typeof reference === 'string') return !!globalThis.__STRING_REFERENCE_INDEX[reference];
+  return reference.$$typeof === MODULE_TAG;
+}
+function resolveModuleMetaData(config, moduleReference) {
+  if (typeof moduleReference === 'string') moduleReference = globalThis.__STRING_REFERENCE_INDEX[moduleReference];
+  return {
+    id: moduleReference.filepath,
+    name: moduleReference.name
+  };
+}
+
+// ATTENTION
+// When adding new symbols to this file,
+// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
+// The Symbol used to tag the ReactElement-like types.
+var REACT_ELEMENT_TYPE = Symbol.for('react.element');
+var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
+var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
+var REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');
+var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
+var REACT_MEMO_TYPE = Symbol.for('react.memo');
+var REACT_LAZY_TYPE = Symbol.for('react.lazy');
+var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for('react.default_value');
+
+// A reserved attribute.
+// It is handled by React separately and shouldn't be written to the DOM.
+var RESERVED = 0; // A simple string attribute.
+// Attributes that aren't in the filter are presumed to have this type.
+
+var STRING = 1; // A string attribute that accepts booleans in React. In HTML, these are called
+// "enumerated" attributes with "true" and "false" as possible values.
+// When true, it should be set to a "true" string.
+// When false, it should be set to a "false" string.
+
+var BOOLEANISH_STRING = 2; // A real boolean attribute.
+// When true, it should be present (set either to an empty string or its name).
+// When false, it should be omitted.
+
+var BOOLEAN = 3; // An attribute that can be used as a flag as well as with a value.
+// When true, it should be present (set either to an empty string or its name).
+// When false, it should be omitted.
+// For any other value, should be present with that value.
+
+var OVERLOADED_BOOLEAN = 4; // An attribute that must be numeric or parse as a numeric.
+// When falsy, it should be removed.
+
+var NUMERIC = 5; // An attribute that must be positive numeric or parse as a positive numeric.
+// When falsy, it should be removed.
+
+var POSITIVE_NUMERIC = 6;
+
+function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL, removeEmptyString) {
+  this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
+  this.attributeName = attributeName;
+  this.attributeNamespace = attributeNamespace;
+  this.mustUseProperty = mustUseProperty;
+  this.propertyName = name;
+  this.type = type;
+  this.sanitizeURL = sanitizeURL;
+  this.removeEmptyString = removeEmptyString;
+} // When adding attributes to this list, be sure to also add them to
+// the `possibleStandardNames` module to ensure casing and incorrect
+// name warnings.
+
+
+var properties = {}; // These props are reserved by React. They shouldn't be written to the DOM.
+
+var reservedProps = ['children', 'dangerouslySetInnerHTML', // TODO: This prevents the assignment of defaultValue to regular
+// elements (not just inputs). Now that ReactDOMInput assigns to the
+// defaultValue property -- do we need this?
+'defaultValue', 'defaultChecked', 'innerHTML', 'suppressContentEditableWarning', 'suppressHydrationWarning', 'style'];
+
+{
+  reservedProps.push('innerText', 'textContent');
+}
+
+reservedProps.forEach(function (name) {
+  properties[name] = new PropertyInfoRecord(name, RESERVED, false, // mustUseProperty
+  name, // attributeName
+  null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+}); // A few React string attributes have a different name.
+// This is a mapping from React prop names to the attribute names.
+
+[['acceptCharset', 'accept-charset'], ['className', 'class'], ['htmlFor', 'for'], ['httpEquiv', 'http-equiv']].forEach(function (_ref) {
+  var name = _ref[0],
+      attributeName = _ref[1];
+  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
+  attributeName, // attributeName
+  null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+}); // These are "enumerated" HTML attributes that accept "true" and "false".
+// In React, we let users pass `true` and `false` even though technically
+// these aren't boolean attributes (they are coerced to strings).
+
+['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(function (name) {
+  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty
+  name.toLowerCase(), // attributeName
+  null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+}); // These are "enumerated" SVG attributes that accept "true" and "false".
+// In React, we let users pass `true` and `false` even though technically
+// these aren't boolean attributes (they are coerced to strings).
+// Since these are SVG attributes, their attribute names are case-sensitive.
+
+['autoReverse', 'externalResourcesRequired', 'focusable', 'preserveAlpha'].forEach(function (name) {
+  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty
+  name, // attributeName
+  null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+}); // These are HTML boolean attributes.
+
+['allowFullScreen', 'async', // Note: there is a special case that prevents it from being written to the DOM
+// on the client side because the browsers are inconsistent. Instead we call focus().
+'autoFocus', 'autoPlay', 'controls', 'default', 'defer', 'disabled', 'disablePictureInPicture', 'disableRemotePlayback', 'formNoValidate', 'hidden', 'loop', 'noModule', 'noValidate', 'open', 'playsInline', 'readOnly', 'required', 'reversed', 'scoped', 'seamless', // Microdata
+'itemScope'].forEach(function (name) {
+  properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, // mustUseProperty
+  name.toLowerCase(), // attributeName
+  null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+}); // These are the few React props that we set as DOM properties
+// rather than attributes. These are all booleans.
+
+['checked', // Note: `option.selected` is not updated if `select.multiple` is
+// disabled with `removeAttribute`. We have special logic for handling this.
+'multiple', 'muted', 'selected' // NOTE: if you add a camelCased prop to this list,
+// you'll need to set attributeName to name.toLowerCase()
+// instead in the assignment below.
+].forEach(function (name) {
+  properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, // mustUseProperty
+  name, // attributeName
+  null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+}); // These are HTML attributes that are "overloaded booleans": they behave like
+// booleans, but can also accept a string value.
+
+['capture', 'download' // NOTE: if you add a camelCased prop to this list,
+// you'll need to set attributeName to name.toLowerCase()
+// instead in the assignment below.
+].forEach(function (name) {
+  properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, // mustUseProperty
+  name, // attributeName
+  null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+}); // These are HTML attributes that must be positive numbers.
+
+['cols', 'rows', 'size', 'span' // NOTE: if you add a camelCased prop to this list,
+// you'll need to set attributeName to name.toLowerCase()
+// instead in the assignment below.
+].forEach(function (name) {
+  properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, // mustUseProperty
+  name, // attributeName
+  null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+}); // These are HTML attributes that must be numbers.
+
+['rowSpan', 'start'].forEach(function (name) {
+  properties[name] = new PropertyInfoRecord(name, NUMERIC, false, // mustUseProperty
+  name.toLowerCase(), // attributeName
+  null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+});
+var CAMELIZE = /[\-\:]([a-z])/g;
+
+var capitalize = function (token) {
+  return token[1].toUpperCase();
+}; // This is a list of all SVG attributes that need special casing, namespacing,
+// or boolean value assignment. Regular attributes that just accept strings
+// and have the same names are omitted, just like in the HTML attribute filter.
+// Some of these attributes can be hard to find. This list was created by
+// scraping the MDN documentation.
+
+
+['accent-height', 'alignment-baseline', 'arabic-form', 'baseline-shift', 'cap-height', 'clip-path', 'clip-rule', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'dominant-baseline', 'enable-background', 'fill-opacity', 'fill-rule', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'glyph-name', 'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'horiz-adv-x', 'horiz-origin-x', 'image-rendering', 'letter-spacing', 'lighting-color', 'marker-end', 'marker-mid', 'marker-start', 'overline-position', 'overline-thickness', 'paint-order', 'panose-1', 'pointer-events', 'rendering-intent', 'shape-rendering', 'stop-color', 'stop-opacity', 'strikethrough-position', 'strikethrough-thickness', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'text-anchor', 'text-decoration', 'text-rendering', 'underline-position', 'underline-thickness', 'unicode-bidi', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'vector-effect', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'word-spacing', 'writing-mode', 'xmlns:xlink', 'x-height' // NOTE: if you add a camelCased prop to this list,
+// you'll need to set attributeName to name.toLowerCase()
+// instead in the assignment below.
+].forEach(function (attributeName) {
+  var name = attributeName.replace(CAMELIZE, capitalize);
+  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
+  attributeName, null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+}); // String SVG attributes with the xlink namespace.
+
+['xlink:actuate', 'xlink:arcrole', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type' // NOTE: if you add a camelCased prop to this list,
+// you'll need to set attributeName to name.toLowerCase()
+// instead in the assignment below.
+].forEach(function (attributeName) {
+  var name = attributeName.replace(CAMELIZE, capitalize);
+  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
+  attributeName, 'http://www.w3.org/1999/xlink', false, // sanitizeURL
+  false);
+}); // String SVG attributes with the xml namespace.
+
+['xml:base', 'xml:lang', 'xml:space' // NOTE: if you add a camelCased prop to this list,
+// you'll need to set attributeName to name.toLowerCase()
+// instead in the assignment below.
+].forEach(function (attributeName) {
+  var name = attributeName.replace(CAMELIZE, capitalize);
+  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
+  attributeName, 'http://www.w3.org/XML/1998/namespace', false, // sanitizeURL
+  false);
+}); // These attribute exists both in HTML and SVG.
+// The attribute name is case-sensitive in SVG so we can't just use
+// the React name like we do for attributes that exist only in HTML.
+
+['tabIndex', 'crossOrigin'].forEach(function (attributeName) {
+  properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, // mustUseProperty
+  attributeName.toLowerCase(), // attributeName
+  null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+}); // These attributes accept URLs. These must not allow javascript: URLS.
+// These will also need to accept Trusted Types object in the future.
+
+var xlinkHref = 'xlinkHref';
+properties[xlinkHref] = new PropertyInfoRecord('xlinkHref', STRING, false, // mustUseProperty
+'xlink:href', 'http://www.w3.org/1999/xlink', true, // sanitizeURL
+false);
+['src', 'href', 'action', 'formAction'].forEach(function (attributeName) {
+  properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, // mustUseProperty
+  attributeName.toLowerCase(), // attributeName
+  null, // attributeNamespace
+  true, // sanitizeURL
+  true);
+});
+
+/**
+ * CSS properties which accept numbers but are not in units of "px".
+ */
+var isUnitlessNumber = {
+  animationIterationCount: true,
+  aspectRatio: true,
+  borderImageOutset: true,
+  borderImageSlice: true,
+  borderImageWidth: true,
+  boxFlex: true,
+  boxFlexGroup: true,
+  boxOrdinalGroup: true,
+  columnCount: true,
+  columns: true,
+  flex: true,
+  flexGrow: true,
+  flexPositive: true,
+  flexShrink: true,
+  flexNegative: true,
+  flexOrder: true,
+  gridArea: true,
+  gridRow: true,
+  gridRowEnd: true,
+  gridRowSpan: true,
+  gridRowStart: true,
+  gridColumn: true,
+  gridColumnEnd: true,
+  gridColumnSpan: true,
+  gridColumnStart: true,
+  fontWeight: true,
+  lineClamp: true,
+  lineHeight: true,
+  opacity: true,
+  order: true,
+  orphans: true,
+  tabSize: true,
+  widows: true,
+  zIndex: true,
+  zoom: true,
+  // SVG-related properties
+  fillOpacity: true,
+  floodOpacity: true,
+  stopOpacity: true,
+  strokeDasharray: true,
+  strokeDashoffset: true,
+  strokeMiterlimit: true,
+  strokeOpacity: true,
+  strokeWidth: true
+};
+/**
+ * @param {string} prefix vendor-specific prefix, eg: Webkit
+ * @param {string} key style name, eg: transitionDuration
+ * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
+ * WebkitTransitionDuration
+ */
+
+function prefixKey(prefix, key) {
+  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
+}
+/**
+ * Support style names that may come passed in prefixed by adding permutations
+ * of vendor prefixes.
+ */
+
+
+var prefixes = ['Webkit', 'ms', 'Moz', 'O']; // Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
+// infinite loop, because it iterates over the newly added props too.
+
+Object.keys(isUnitlessNumber).forEach(function (prop) {
+  prefixes.forEach(function (prefix) {
+    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
+  });
+});
+
+var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare
+
+function isArray(a) {
+  return isArrayImpl(a);
+}
+
+var startInlineScript = stringToPrecomputedChunk('<script>');
+var endInlineScript = stringToPrecomputedChunk('</script>');
+var startScriptSrc = stringToPrecomputedChunk('<script src="');
+var startModuleSrc = stringToPrecomputedChunk('<script type="module" src="');
+var scriptIntegirty = stringToPrecomputedChunk('" integrity="');
+var endAsyncScript = stringToPrecomputedChunk('" async=""></script>');
+
+var textSeparator = stringToPrecomputedChunk('<!-- -->');
+
+var styleAttributeStart = stringToPrecomputedChunk(' style="');
+var styleAssign = stringToPrecomputedChunk(':');
+var styleSeparator = stringToPrecomputedChunk(';');
+
+var attributeSeparator = stringToPrecomputedChunk(' ');
+var attributeAssign = stringToPrecomputedChunk('="');
+var attributeEnd = stringToPrecomputedChunk('"');
+var attributeEmptyString = stringToPrecomputedChunk('=""');
+
+var endOfStartTag = stringToPrecomputedChunk('>');
+var endOfStartTagSelfClosing = stringToPrecomputedChunk('/>');
+
+var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=""');
+
+var leadingNewline = stringToPrecomputedChunk('\n');
+
+var DOCTYPE = stringToPrecomputedChunk('<!DOCTYPE html>');
+var endTag1 = stringToPrecomputedChunk('</');
+var endTag2 = stringToPrecomputedChunk('>');
+// A placeholder is a node inside a hidden partial tree that can be filled in later, but before
+// display. It's never visible to users. We use the template tag because it can be used in every
+// type of parent. <script> tags also work in every other tag except <colgroup>.
+
+var placeholder1 = stringToPrecomputedChunk('<template id="');
+var placeholder2 = stringToPrecomputedChunk('"></template>');
+
+var startCompletedSuspenseBoundary = stringToPrecomputedChunk('<!--$-->');
+var startPendingSuspenseBoundary1 = stringToPrecomputedChunk('<!--$?--><template id="');
+var startPendingSuspenseBoundary2 = stringToPrecomputedChunk('"></template>');
+var startClientRenderedSuspenseBoundary = stringToPrecomputedChunk('<!--$!-->');
+var endSuspenseBoundary = stringToPrecomputedChunk('<!--/$-->');
+var clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk('<template');
+var clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('"');
+var clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst="');
+var clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg="');
+var clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck="');
+var clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk('></template>');
+var startSegmentHTML = stringToPrecomputedChunk('<div hidden id="');
+var startSegmentHTML2 = stringToPrecomputedChunk('">');
+var endSegmentHTML = stringToPrecomputedChunk('</div>');
+var startSegmentSVG = stringToPrecomputedChunk('<svg aria-hidden="true" style="display:none" id="');
+var startSegmentSVG2 = stringToPrecomputedChunk('">');
+var endSegmentSVG = stringToPrecomputedChunk('</svg>');
+var startSegmentMathML = stringToPrecomputedChunk('<math aria-hidden="true" style="display:none" id="');
+var startSegmentMathML2 = stringToPrecomputedChunk('">');
+var endSegmentMathML = stringToPrecomputedChunk('</math>');
+var startSegmentTable = stringToPrecomputedChunk('<table hidden id="');
+var startSegmentTable2 = stringToPrecomputedChunk('">');
+var endSegmentTable = stringToPrecomputedChunk('</table>');
+var startSegmentTableBody = stringToPrecomputedChunk('<table hidden><tbody id="');
+var startSegmentTableBody2 = stringToPrecomputedChunk('">');
+var endSegmentTableBody = stringToPrecomputedChunk('</tbody></table>');
+var startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id="');
+var startSegmentTableRow2 = stringToPrecomputedChunk('">');
+var endSegmentTableRow = stringToPrecomputedChunk('</tr></table>');
+var startSegmentColGroup = stringToPrecomputedChunk('<table hidden><colgroup id="');
+var startSegmentColGroup2 = stringToPrecomputedChunk('">');
+var endSegmentColGroup = stringToPrecomputedChunk('</colgroup></table>');
+// The following code is the source scripts that we then minify and inline below,
+// with renamed function names that we hope don't collide:
+// const COMMENT_NODE = 8;
+// const SUSPENSE_START_DATA = '$';
+// const SUSPENSE_END_DATA = '/$';
+// const SUSPENSE_PENDING_START_DATA = '$?';
+// const SUSPENSE_FALLBACK_START_DATA = '$!';
+//
+// function clientRenderBoundary(suspenseBoundaryID, errorDigest, errorMsg, errorComponentStack) {
+//   // Find the fallback's first element.
+//   const suspenseIdNode = document.getElementById(suspenseBoundaryID);
+//   if (!suspenseIdNode) {
+//     // The user must have already navigated away from this tree.
+//     // E.g. because the parent was hydrated.
+//     return;
+//   }
+//   // Find the boundary around the fallback. This is always the previous node.
+//   const suspenseNode = suspenseIdNode.previousSibling;
+//   // Tag it to be client rendered.
+//   suspenseNode.data = SUSPENSE_FALLBACK_START_DATA;
+//   // assign error metadata to first sibling
+//   let dataset = suspenseIdNode.dataset;
+//   if (errorDigest) dataset.dgst = errorDigest;
+//   if (errorMsg) dataset.msg = errorMsg;
+//   if (errorComponentStack) dataset.stck = errorComponentStack;
+//   // Tell React to retry it if the parent already hydrated.
+//   if (suspenseNode._reactRetry) {
+//     suspenseNode._reactRetry();
+//   }
+// }
+//
+// function completeBoundary(suspenseBoundaryID, contentID) {
+//   // Find the fallback's first element.
+//   const suspenseIdNode = document.getElementById(suspenseBoundaryID);
+//   const contentNode = document.getElementById(contentID);
+//   // We'll detach the content node so that regardless of what happens next we don't leave in the tree.
+//   // This might also help by not causing recalcing each time we move a child from here to the target.
+//   contentNode.parentNode.removeChild(contentNode);
+//   if (!suspenseIdNode) {
+//     // The user must have already navigated away from this tree.
+//     // E.g. because the parent was hydrated. That's fine there's nothing to do
+//     // but we have to make sure that we already deleted the container node.
+//     return;
+//   }
+//   // Find the boundary around the fallback. This is always the previous node.
+//   const suspenseNode = suspenseIdNode.previousSibling;
+//
+//   // Clear all the existing children. This is complicated because
+//   // there can be embedded Suspense boundaries in the fallback.
+//   // This is similar to clearSuspenseBoundary in ReactDOMHostConfig.
+//   // TODO: We could avoid this if we never emitted suspense boundaries in fallback trees.
+//   // They never hydrate anyway. However, currently we support incrementally loading the fallback.
+//   const parentInstance = suspenseNode.parentNode;
+//   let node = suspenseNode.nextSibling;
+//   let depth = 0;
+//   do {
+//     if (node && node.nodeType === COMMENT_NODE) {
+//       const data = node.data;
+//       if (data === SUSPENSE_END_DATA) {
+//         if (depth === 0) {
+//           break;
+//         } else {
+//           depth--;
+//         }
+//       } else if (
+//         data === SUSPENSE_START_DATA ||
+//         data === SUSPENSE_PENDING_START_DATA ||
+//         data === SUSPENSE_FALLBACK_START_DATA
+//       ) {
+//         depth++;
+//       }
+//     }
+//
+//     const nextNode = node.nextSibling;
+//     parentInstance.removeChild(node);
+//     node = nextNode;
+//   } while (node);
+//
+//   const endOfBoundary = node;
+//
+//   // Insert all the children from the contentNode between the start and end of suspense boundary.
+//   while (contentNode.firstChild) {
+//     parentInstance.insertBefore(contentNode.firstChild, endOfBoundary);
+//   }
+//   suspenseNode.data = SUSPENSE_START_DATA;
+//   if (suspenseNode._reactRetry) {
+//     suspenseNode._reactRetry();
+//   }
+// }
+//
+// function completeSegment(containerID, placeholderID) {
+//   const segmentContainer = document.getElementById(containerID);
+//   const placeholderNode = document.getElementById(placeholderID);
+//   // We always expect both nodes to exist here because, while we might
+//   // have navigated away from the main tree, we still expect the detached
+//   // tree to exist.
+//   segmentContainer.parentNode.removeChild(segmentContainer);
+//   while (segmentContainer.firstChild) {
+//     placeholderNode.parentNode.insertBefore(
+//       segmentContainer.firstChild,
+//       placeholderNode,
+//     );
+//   }
+//   placeholderNode.parentNode.removeChild(placeholderNode);
+// }
+
+var completeSegmentFunction = 'function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}';
+var completeBoundaryFunction = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}';
+var clientRenderFunction = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}';
+var completeSegmentScript1Full = stringToPrecomputedChunk(completeSegmentFunction + ';$RS("');
+var completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("');
+var completeSegmentScript2 = stringToPrecomputedChunk('","');
+var completeSegmentScript3 = stringToPrecomputedChunk('")</script>');
+var completeBoundaryScript1Full = stringToPrecomputedChunk(completeBoundaryFunction + ';$RC("');
+var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("');
+var completeBoundaryScript2 = stringToPrecomputedChunk('","');
+var completeBoundaryScript3 = stringToPrecomputedChunk('")</script>');
+var clientRenderScript1Full = stringToPrecomputedChunk(clientRenderFunction + ';$RX("');
+var clientRenderScript1Partial = stringToPrecomputedChunk('$RX("');
+var clientRenderScript1A = stringToPrecomputedChunk('"');
+var clientRenderScript2 = stringToPrecomputedChunk(')</script>');
+var clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(',');
+
+var rendererSigil;
+
+{
+  // Use this to detect multiple renderers using the same context
+  rendererSigil = {};
+} // Used to store the parent path of all context overrides in a shared linked list.
+// Forming a reverse tree.
+
+
+var rootContextSnapshot = null; // We assume that this runtime owns the "current" field on all ReactContext instances.
+// This global (actually thread local) state represents what state all those "current",
+// fields are currently in.
+
+var currentActiveSnapshot = null;
+
+function popNode(prev) {
+  {
+    prev.context._currentValue = prev.parentValue;
+  }
+}
+
+function pushNode(next) {
+  {
+    next.context._currentValue = next.value;
+  }
+}
+
+function popToNearestCommonAncestor(prev, next) {
+  if (prev === next) ; else {
+    popNode(prev);
+    var parentPrev = prev.parent;
+    var parentNext = next.parent;
+
+    if (parentPrev === null) {
+      if (parentNext !== null) {
+        throw new Error('The stacks must reach the root at the same time. This is a bug in React.');
+      }
+    } else {
+      if (parentNext === null) {
+        throw new Error('The stacks must reach the root at the same time. This is a bug in React.');
+      }
+
+      popToNearestCommonAncestor(parentPrev, parentNext); // On the way back, we push the new ones that weren't common.
+
+      pushNode(next);
+    }
+  }
+}
+
+function popAllPrevious(prev) {
+  popNode(prev);
+  var parentPrev = prev.parent;
+
+  if (parentPrev !== null) {
+    popAllPrevious(parentPrev);
+  }
+}
+
+function pushAllNext(next) {
+  var parentNext = next.parent;
+
+  if (parentNext !== null) {
+    pushAllNext(parentNext);
+  }
+
+  pushNode(next);
+}
+
+function popPreviousToCommonLevel(prev, next) {
+  popNode(prev);
+  var parentPrev = prev.parent;
+
+  if (parentPrev === null) {
+    throw new Error('The depth must equal at least at zero before reaching the root. This is a bug in React.');
+  }
+
+  if (parentPrev.depth === next.depth) {
+    // We found the same level. Now we just need to find a shared ancestor.
+    popToNearestCommonAncestor(parentPrev, next);
+  } else {
+    // We must still be deeper.
+    popPreviousToCommonLevel(parentPrev, next);
+  }
+}
+
+function popNextToCommonLevel(prev, next) {
+  var parentNext = next.parent;
+
+  if (parentNext === null) {
+    throw new Error('The depth must equal at least at zero before reaching the root. This is a bug in React.');
+  }
+
+  if (prev.depth === parentNext.depth) {
+    // We found the same level. Now we just need to find a shared ancestor.
+    popToNearestCommonAncestor(prev, parentNext);
+  } else {
+    // We must still be deeper.
+    popNextToCommonLevel(prev, parentNext);
+  }
+
+  pushNode(next);
+} // Perform context switching to the new snapshot.
+// To make it cheap to read many contexts, while not suspending, we make the switch eagerly by
+// updating all the context's current values. That way reads, always just read the current value.
+// At the cost of updating contexts even if they're never read by this subtree.
+
+
+function switchContext(newSnapshot) {
+  // The basic algorithm we need to do is to pop back any contexts that are no longer on the stack.
+  // We also need to update any new contexts that are now on the stack with the deepest value.
+  // The easiest way to update new contexts is to just reapply them in reverse order from the
+  // perspective of the backpointers. To avoid allocating a lot when switching, we use the stack
+  // for that. Therefore this algorithm is recursive.
+  // 1) First we pop which ever snapshot tree was deepest. Popping old contexts as we go.
+  // 2) Then we find the nearest common ancestor from there. Popping old contexts as we go.
+  // 3) Then we reapply new contexts on the way back up the stack.
+  var prev = currentActiveSnapshot;
+  var next = newSnapshot;
+
+  if (prev !== next) {
+    if (prev === null) {
+      // $FlowFixMe: This has to be non-null since it's not equal to prev.
+      pushAllNext(next);
+    } else if (next === null) {
+      popAllPrevious(prev);
+    } else if (prev.depth === next.depth) {
+      popToNearestCommonAncestor(prev, next);
+    } else if (prev.depth > next.depth) {
+      popPreviousToCommonLevel(prev, next);
+    } else {
+      popNextToCommonLevel(prev, next);
+    }
+
+    currentActiveSnapshot = next;
+  }
+}
+function pushProvider(context, nextValue) {
+  var prevValue;
+
+  {
+    prevValue = context._currentValue;
+    context._currentValue = nextValue;
+
+    {
+      if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
+        error('Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.');
+      }
+
+      context._currentRenderer = rendererSigil;
+    }
+  }
+
+  var prevNode = currentActiveSnapshot;
+  var newNode = {
+    parent: prevNode,
+    depth: prevNode === null ? 0 : prevNode.depth + 1,
+    context: context,
+    parentValue: prevValue,
+    value: nextValue
+  };
+  currentActiveSnapshot = newNode;
+  return newNode;
+}
+function popProvider() {
+  var prevSnapshot = currentActiveSnapshot;
+
+  if (prevSnapshot === null) {
+    throw new Error('Tried to pop a Context at the root of the app. This is a bug in React.');
+  }
+
+  {
+    var value = prevSnapshot.parentValue;
+
+    if (value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
+      prevSnapshot.context._currentValue = prevSnapshot.context._defaultValue;
+    } else {
+      prevSnapshot.context._currentValue = value;
+    }
+  }
+
+  return currentActiveSnapshot = prevSnapshot.parent;
+}
+function getActiveContext() {
+  return currentActiveSnapshot;
+}
+function readContext(context) {
+  var value =  context._currentValue ;
+  return value;
+}
+
+var currentRequest = null;
+function prepareToUseHooksForRequest(request) {
+  currentRequest = request;
+}
+function resetHooksForRequest() {
+  currentRequest = null;
+}
+
+function readContext$1(context) {
+  {
+    if (context.$$typeof !== REACT_SERVER_CONTEXT_TYPE) {
+      error('Only ServerContext is supported in Flight');
+    }
+
+    if (currentCache === null) {
+      error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');
+    }
+  }
+
+  return readContext(context);
+}
+
+var Dispatcher = {
+  useMemo: function (nextCreate) {
+    return nextCreate();
+  },
+  useCallback: function (callback) {
+    return callback;
+  },
+  useDebugValue: function () {},
+  useDeferredValue: unsupportedHook,
+  useTransition: unsupportedHook,
+  getCacheForType: function (resourceType) {
+    if (!currentCache) {
+      throw new Error('Reading the cache is only supported while rendering.');
+    }
+
+    var entry = currentCache.get(resourceType);
+
+    if (entry === undefined) {
+      entry = resourceType(); // TODO: Warn if undefined?
+
+      currentCache.set(resourceType, entry);
+    }
+
+    return entry;
+  },
+  readContext: readContext$1,
+  useContext: readContext$1,
+  useReducer: unsupportedHook,
+  useRef: unsupportedHook,
+  useState: unsupportedHook,
+  useInsertionEffect: unsupportedHook,
+  useLayoutEffect: unsupportedHook,
+  useImperativeHandle: unsupportedHook,
+  useEffect: unsupportedHook,
+  useId: useId,
+  useMutableSource: unsupportedHook,
+  useSyncExternalStore: unsupportedHook,
+  useCacheRefresh: function () {
+    return unsupportedRefresh;
+  }
+};
+
+function unsupportedHook() {
+  throw new Error('This Hook is not supported in Server Components.');
+}
+
+function unsupportedRefresh() {
+  if (!currentCache) {
+    throw new Error('Refreshing the cache is not supported in Server Components.');
+  }
+}
+
+var currentCache = null;
+function setCurrentCache(cache) {
+  currentCache = cache;
+  return currentCache;
+}
+function getCurrentCache() {
+  return currentCache;
+}
+
+function useId() {
+  if (currentRequest === null) {
+    throw new Error('useId can only be used while React is rendering');
+  }
+
+  var id = currentRequest.identifierCount++; // use 'S' for Flight components to distinguish from 'R' and 'r' in Fizz/Client
+
+  return ':' + currentRequest.identifierPrefix + 'S' + id.toString(32) + ':';
+}
+
+var ContextRegistry = ReactSharedInternals.ContextRegistry;
+function getOrCreateServerContext(globalName) {
+  if (!ContextRegistry[globalName]) {
+    ContextRegistry[globalName] = createServerContext(globalName, REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED);
+  }
+
+  return ContextRegistry[globalName];
+}
+
+var PENDING = 0;
+var COMPLETED = 1;
+var ABORTED = 3;
+var ERRORED = 4;
+var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
+
+function defaultErrorHandler(error) {
+  console['error'](error); // Don't transform to our wrapper
+}
+
+var OPEN = 0;
+var CLOSING = 1;
+var CLOSED = 2;
+function createRequest(model, bundlerConfig, onError, context, identifierPrefix) {
+  var abortSet = new Set();
+  var pingedTasks = [];
+  var request = {
+    status: OPEN,
+    fatalError: null,
+    destination: null,
+    bundlerConfig: bundlerConfig,
+    cache: new Map(),
+    nextChunkId: 0,
+    pendingChunks: 0,
+    abortableTasks: abortSet,
+    pingedTasks: pingedTasks,
+    completedModuleChunks: [],
+    completedJSONChunks: [],
+    completedErrorChunks: [],
+    writtenSymbols: new Map(),
+    writtenModules: new Map(),
+    writtenProviders: new Map(),
+    identifierPrefix: identifierPrefix || '',
+    identifierCount: 1,
+    onError: onError === undefined ? defaultErrorHandler : onError,
+    toJSON: function (key, value) {
+      return resolveModelToJSON(request, this, key, value);
+    }
+  };
+  request.pendingChunks++;
+  var rootContext = createRootContext(context);
+  var rootTask = createTask(request, model, rootContext, abortSet);
+  pingedTasks.push(rootTask);
+  return request;
+}
+
+function createRootContext(reqContext) {
+  return importServerContexts(reqContext);
+}
+
+var POP = {};
+
+function attemptResolveElement(type, key, ref, props) {
+  if (ref !== null && ref !== undefined) {
+    // When the ref moves to the regular props object this will implicitly
+    // throw for functions. We could probably relax it to a DEV warning for other
+    // cases.
+    throw new Error('Refs cannot be used in server components, nor passed to client components.');
+  }
+
+  if (typeof type === 'function') {
+    if (isModuleReference(type)) {
+      // This is a reference to a client component.
+      return [REACT_ELEMENT_TYPE, type, key, props];
+    } // This is a server-side component.
+
+
+    return type(props);
+  } else if (typeof type === 'string') {
+    // This is a host element. E.g. HTML.
+    return [REACT_ELEMENT_TYPE, type, key, props];
+  } else if (typeof type === 'symbol') {
+    if (type === REACT_FRAGMENT_TYPE) {
+      // For key-less fragments, we add a small optimization to avoid serializing
+      // it as a wrapper.
+      // TODO: If a key is specified, we should propagate its key to any children.
+      // Same as if a server component has a key.
+      return props.children;
+    } // This might be a built-in React component. We'll let the client decide.
+    // Any built-in works as long as its props are serializable.
+
+
+    return [REACT_ELEMENT_TYPE, type, key, props];
+  } else if (type != null && typeof type === 'object') {
+    if (isModuleReference(type)) {
+      // This is a reference to a client component.
+      return [REACT_ELEMENT_TYPE, type, key, props];
+    }
+
+    switch (type.$$typeof) {
+      case REACT_LAZY_TYPE:
+        {
+          var payload = type._payload;
+          var init = type._init;
+          var wrappedType = init(payload);
+          return attemptResolveElement(wrappedType, key, ref, props);
+        }
+
+      case REACT_FORWARD_REF_TYPE:
+        {
+          var render = type.render;
+          return render(props, undefined);
+        }
+
+      case REACT_MEMO_TYPE:
+        {
+          return attemptResolveElement(type.type, key, ref, props);
+        }
+
+      case REACT_PROVIDER_TYPE:
+        {
+          pushProvider(type._context, props.value);
+
+          {
+            var extraKeys = Object.keys(props).filter(function (value) {
+              if (value === 'children' || value === 'value') {
+                return false;
+              }
+
+              return true;
+            });
+
+            if (extraKeys.length !== 0) {
+              error('ServerContext can only have a value prop and children. Found: %s', JSON.stringify(extraKeys));
+            }
+          }
+
+          return [REACT_ELEMENT_TYPE, type, key, // Rely on __popProvider being serialized last to pop the provider.
+          {
+            value: props.value,
+            children: props.children,
+            __pop: POP
+          }];
+        }
+    }
+  }
+
+  throw new Error("Unsupported server component type: " + describeValueForErrorMessage(type));
+}
+
+function pingTask(request, task) {
+  var pingedTasks = request.pingedTasks;
+  pingedTasks.push(task);
+
+  if (pingedTasks.length === 1) {
+    scheduleWork(function () {
+      return performWork(request);
+    });
+  }
+}
+
+function createTask(request, model, context, abortSet) {
+  var id = request.nextChunkId++;
+  var task = {
+    id: id,
+    status: PENDING,
+    model: model,
+    context: context,
+    ping: function () {
+      return pingTask(request, task);
+    }
+  };
+  abortSet.add(task);
+  return task;
+}
+
+function serializeByValueID(id) {
+  return '$' + id.toString(16);
+}
+
+function serializeByRefID(id) {
+  return '@' + id.toString(16);
+}
+
+function escapeStringValue(value) {
+  if (value[0] === '$' || value[0] === '@') {
+    // We need to escape $ or @ prefixed strings since we use those to encode
+    // references to IDs and as special symbol values.
+    return '$' + value;
+  } else {
+    return value;
+  }
+}
+
+function isObjectPrototype(object) {
+  if (!object) {
+    return false;
+  }
+
+  var ObjectPrototype = Object.prototype;
+
+  if (object === ObjectPrototype) {
+    return true;
+  } // It might be an object from a different Realm which is
+  // still just a plain simple object.
+
+
+  if (Object.getPrototypeOf(object)) {
+    return false;
+  }
+
+  var names = Object.getOwnPropertyNames(object);
+
+  for (var i = 0; i < names.length; i++) {
+    if (!(names[i] in ObjectPrototype)) {
+      return false;
+    }
+  }
+
+  return true;
+}
+
+function isSimpleObject(object) {
+  if (!isObjectPrototype(Object.getPrototypeOf(object))) {
+    return false;
+  }
+
+  var names = Object.getOwnPropertyNames(object);
+
+  for (var i = 0; i < names.length; i++) {
+    var descriptor = Object.getOwnPropertyDescriptor(object, names[i]);
+
+    if (!descriptor) {
+      return false;
+    }
+
+    if (!descriptor.enumerable) {
+      if ((names[i] === 'key' || names[i] === 'ref') && typeof descriptor.get === 'function') {
+        // React adds key and ref getters to props objects to issue warnings.
+        // Those getters will not be transferred to the client, but that's ok,
+        // so we'll special case them.
+        continue;
+      }
+
+      return false;
+    }
+  }
+
+  return true;
+}
+
+function objectName(object) {
+  var name = Object.prototype.toString.call(object);
+  return name.replace(/^\[object (.*)\]$/, function (m, p0) {
+    return p0;
+  });
+}
+
+function describeKeyForErrorMessage(key) {
+  var encodedKey = JSON.stringify(key);
+  return '"' + key + '"' === encodedKey ? key : encodedKey;
+}
+
+function describeValueForErrorMessage(value) {
+  switch (typeof value) {
+    case 'string':
+      {
+        return JSON.stringify(value.length <= 10 ? value : value.substr(0, 10) + '...');
+      }
+
+    case 'object':
+      {
+        if (isArray(value)) {
+          return '[...]';
+        }
+
+        var name = objectName(value);
+
+        if (name === 'Object') {
+          return '{...}';
+        }
+
+        return name;
+      }
+
+    case 'function':
+      return 'function';
+
+    default:
+      // eslint-disable-next-line react-internal/safe-string-coercion
+      return String(value);
+  }
+}
+
+function describeObjectForErrorMessage(objectOrArray, expandedName) {
+  if (isArray(objectOrArray)) {
+    var str = '[';
+    var array = objectOrArray;
+
+    for (var i = 0; i < array.length; i++) {
+      if (i > 0) {
+        str += ', ';
+      }
+
+      if (i > 6) {
+        str += '...';
+        break;
+      }
+
+      var _value = array[i];
+
+      if ('' + i === expandedName && typeof _value === 'object' && _value !== null) {
+        str += describeObjectForErrorMessage(_value);
+      } else {
+        str += describeValueForErrorMessage(_value);
+      }
+    }
+
+    str += ']';
+    return str;
+  } else {
+    var _str = '{';
+    var object = objectOrArray;
+    var names = Object.keys(object);
+
+    for (var _i = 0; _i < names.length; _i++) {
+      if (_i > 0) {
+        _str += ', ';
+      }
+
+      if (_i > 6) {
+        _str += '...';
+        break;
+      }
+
+      var name = names[_i];
+      _str += describeKeyForErrorMessage(name) + ': ';
+      var _value2 = object[name];
+
+      if (name === expandedName && typeof _value2 === 'object' && _value2 !== null) {
+        _str += describeObjectForErrorMessage(_value2);
+      } else {
+        _str += describeValueForErrorMessage(_value2);
+      }
+    }
+
+    _str += '}';
+    return _str;
+  }
+}
+
+var insideContextProps = null;
+var isInsideContextValue = false;
+function resolveModelToJSON(request, parent, key, value) {
+  {
+    // $FlowFixMe
+    var originalValue = parent[key];
+
+    if (typeof originalValue === 'object' && originalValue !== value) {
+      error('Only plain objects can be passed to client components from server components. ' + 'Objects with toJSON methods are not supported. Convert it manually ' + 'to a simple value before passing it to props. ' + 'Remove %s from these props: %s', describeKeyForErrorMessage(key), describeObjectForErrorMessage(parent));
+    }
+  } // Special Symbols
+
+
+  switch (value) {
+    case REACT_ELEMENT_TYPE:
+      return '$';
+  }
+
+  {
+    if (parent[0] === REACT_ELEMENT_TYPE && parent[1] && parent[1].$$typeof === REACT_PROVIDER_TYPE && key === '3') {
+      insideContextProps = value;
+    } else if (insideContextProps === parent && key === 'value') {
+      isInsideContextValue = true;
+    } else if (insideContextProps === parent && key === 'children') {
+      isInsideContextValue = false;
+    }
+  } // Resolve server components.
+
+
+  while (typeof value === 'object' && value !== null && (value.$$typeof === REACT_ELEMENT_TYPE || value.$$typeof === REACT_LAZY_TYPE)) {
+    {
+      if (isInsideContextValue) {
+        error('React elements are not allowed in ServerContext');
+      }
+    }
+
+    try {
+      switch (value.$$typeof) {
+        case REACT_ELEMENT_TYPE:
+          {
+            // TODO: Concatenate keys of parents onto children.
+            var element = value; // Attempt to render the server component.
+
+            value = attemptResolveElement(element.type, element.key, element.ref, element.props);
+            break;
+          }
+
+        case REACT_LAZY_TYPE:
+          {
+            var payload = value._payload;
+            var init = value._init;
+            value = init(payload);
+            break;
+          }
+      }
+    } catch (x) {
+      if (typeof x === 'object' && x !== null && typeof x.then === 'function') {
+        // Something suspended, we'll need to create a new task and resolve it later.
+        request.pendingChunks++;
+        var newTask = createTask(request, value, getActiveContext(), request.abortableTasks);
+        var ping = newTask.ping;
+        x.then(ping, ping);
+        return serializeByRefID(newTask.id);
+      } else {
+        logRecoverableError(request, x); // Something errored. We'll still send everything we have up until this point.
+        // We'll replace this element with a lazy reference that throws on the client
+        // once it gets rendered.
+
+        request.pendingChunks++;
+        var errorId = request.nextChunkId++;
+        emitErrorChunk(request, errorId, x);
+        return serializeByRefID(errorId);
+      }
+    }
+  }
+
+  if (value == null) {
+    return value;
+  }
+
+  if (typeof value === 'object' || isModuleReference(value)) {
+    if (isModuleReference(value)) {
+      var moduleReference = value;
+      var moduleKey = getModuleKey(moduleReference);
+      var writtenModules = request.writtenModules;
+      var existingId = writtenModules.get(moduleKey);
+
+      if (existingId !== undefined) {
+        if (parent[0] === REACT_ELEMENT_TYPE && key === '1') {
+          // If we're encoding the "type" of an element, we can refer
+          // to that by a lazy reference instead of directly since React
+          // knows how to deal with lazy values. This lets us suspend
+          // on this component rather than its parent until the code has
+          // loaded.
+          return serializeByRefID(existingId);
+        }
+
+        return serializeByValueID(existingId);
+      }
+
+      try {
+        var moduleMetaData = resolveModuleMetaData(request.bundlerConfig, moduleReference);
+        request.pendingChunks++;
+        var moduleId = request.nextChunkId++;
+        emitModuleChunk(request, moduleId, moduleMetaData);
+        writtenModules.set(moduleKey, moduleId);
+
+        if (parent[0] === REACT_ELEMENT_TYPE && key === '1') {
+          // If we're encoding the "type" of an element, we can refer
+          // to that by a lazy reference instead of directly since React
+          // knows how to deal with lazy values. This lets us suspend
+          // on this component rather than its parent until the code has
+          // loaded.
+          return serializeByRefID(moduleId);
+        }
+
+        return serializeByValueID(moduleId);
+      } catch (x) {
+        request.pendingChunks++;
+
+        var _errorId = request.nextChunkId++;
+
+        emitErrorChunk(request, _errorId, x);
+        return serializeByValueID(_errorId);
+      }
+    } else if (value.$$typeof === REACT_PROVIDER_TYPE) {
+      var providerKey = value._context._globalName;
+      var writtenProviders = request.writtenProviders;
+      var providerId = writtenProviders.get(key);
+
+      if (providerId === undefined) {
+        request.pendingChunks++;
+        providerId = request.nextChunkId++;
+        writtenProviders.set(providerKey, providerId);
+        emitProviderChunk(request, providerId, providerKey);
+      }
+
+      return serializeByValueID(providerId);
+    } else if (value === POP) {
+      popProvider();
+
+      {
+        insideContextProps = null;
+        isInsideContextValue = false;
+      }
+
+      return undefined;
+    }
+
+    {
+      if (value !== null && !isArray(value)) {
+        // Verify that this is a simple plain object.
+        if (objectName(value) !== 'Object') {
+          error('Only plain objects can be passed to client components from server components. ' + 'Built-ins like %s are not supported. ' + 'Remove %s from these props: %s', objectName(value), describeKeyForErrorMessage(key), describeObjectForErrorMessage(parent));
+        } else if (typeof value === 'object' && !isSimpleObject(value)) {
+          error('Only plain objects can be passed to client components from server components. ' + 'Classes or other objects with methods are not supported. ' + 'Remove %s from these props: %s', describeKeyForErrorMessage(key), describeObjectForErrorMessage(parent, key));
+        } else if (Object.getOwnPropertySymbols) {
+          var symbols = Object.getOwnPropertySymbols(value);
+
+          if (symbols.length > 0) {
+            error('Only plain objects can be passed to client components from server components. ' + 'Objects with symbol properties like %s are not supported. ' + 'Remove %s from these props: %s', symbols[0].description, describeKeyForErrorMessage(key), describeObjectForErrorMessage(parent, key));
+          }
+        }
+      }
+    }
+
+    return value;
+  }
+
+  if (typeof value === 'string') {
+    return escapeStringValue(value);
+  }
+
+  if (typeof value === 'boolean' || typeof value === 'number' || typeof value === 'undefined') {
+    return value;
+  }
+
+  if (typeof value === 'function') {
+    if (/^on[A-Z]/.test(key)) {
+      throw new Error('Event handlers cannot be passed to client component props. ' + ("Remove " + describeKeyForErrorMessage(key) + " from these props if possible: " + describeObjectForErrorMessage(parent) + "\n") + 'If you need interactivity, consider converting part of this to a client component.');
+    } else {
+      throw new Error('Functions cannot be passed directly to client components ' + "because they're not serializable. " + ("Remove " + describeKeyForErrorMessage(key) + " (" + (value.displayName || value.name || 'function') + ") from this object, or avoid the entire object: " + describeObjectForErrorMessage(parent)));
+    }
+  }
+
+  if (typeof value === 'symbol') {
+    var writtenSymbols = request.writtenSymbols;
+
+    var _existingId = writtenSymbols.get(value);
+
+    if (_existingId !== undefined) {
+      return serializeByValueID(_existingId);
+    }
+
+    var name = value.description;
+
+    if (Symbol.for(name) !== value) {
+      throw new Error('Only global symbols received from Symbol.for(...) can be passed to client components. ' + ("The symbol Symbol.for(" + value.description + ") cannot be found among global symbols. ") + ("Remove " + describeKeyForErrorMessage(key) + " from this object, or avoid the entire object: " + describeObjectForErrorMessage(parent)));
+    }
+
+    request.pendingChunks++;
+    var symbolId = request.nextChunkId++;
+    emitSymbolChunk(request, symbolId, name);
+    writtenSymbols.set(value, symbolId);
+    return serializeByValueID(symbolId);
+  } // $FlowFixMe: bigint isn't added to Flow yet.
+
+
+  if (typeof value === 'bigint') {
+    throw new Error("BigInt (" + value + ") is not yet supported in client component props. " + ("Remove " + describeKeyForErrorMessage(key) + " from this object or use a plain number instead: " + describeObjectForErrorMessage(parent)));
+  }
+
+  throw new Error("Type " + typeof value + " is not supported in client component props. " + ("Remove " + describeKeyForErrorMessage(key) + " from this object, or avoid the entire object: " + describeObjectForErrorMessage(parent)));
+}
+
+function logRecoverableError(request, error) {
+  var onError = request.onError;
+  onError(error);
+}
+
+function fatalError(request, error) {
+  // This is called outside error handling code such as if an error happens in React internals.
+  if (request.destination !== null) {
+    request.status = CLOSED;
+    closeWithError(request.destination, error);
+  } else {
+    request.status = CLOSING;
+    request.fatalError = error;
+  }
+}
+
+function emitErrorChunk(request, id, error) {
+  // TODO: We should not leak error messages to the client in prod.
+  // Give this an error code instead and log on the server.
+  // We can serialize the error in DEV as a convenience.
+  var message;
+  var stack = '';
+
+  try {
+    if (error instanceof Error) {
+      // eslint-disable-next-line react-internal/safe-string-coercion
+      message = String(error.message); // eslint-disable-next-line react-internal/safe-string-coercion
+
+      stack = String(error.stack);
+    } else {
+      message = 'Error: ' + error;
+    }
+  } catch (x) {
+    message = 'An error occurred but serializing the error message failed.';
+  }
+
+  var processedChunk = processErrorChunk(request, id, message, stack);
+  request.completedErrorChunks.push(processedChunk);
+}
+
+function emitModuleChunk(request, id, moduleMetaData) {
+  var processedChunk = processModuleChunk(request, id, moduleMetaData);
+  request.completedModuleChunks.push(processedChunk);
+}
+
+function emitSymbolChunk(request, id, name) {
+  var processedChunk = processSymbolChunk(request, id, name);
+  request.completedModuleChunks.push(processedChunk);
+}
+
+function emitProviderChunk(request, id, contextName) {
+  var processedChunk = processProviderChunk(request, id, contextName);
+  request.completedJSONChunks.push(processedChunk);
+}
+
+function retryTask(request, task) {
+  if (task.status !== PENDING) {
+    // We completed this by other means before we had a chance to retry it.
+    return;
+  }
+
+  switchContext(task.context);
+
+  try {
+    var _value3 = task.model;
+
+    while (typeof _value3 === 'object' && _value3 !== null && _value3.$$typeof === REACT_ELEMENT_TYPE) {
+      // TODO: Concatenate keys of parents onto children.
+      var element = _value3; // Attempt to render the server component.
+      // Doing this here lets us reuse this same task if the next component
+      // also suspends.
+
+      task.model = _value3;
+      _value3 = attemptResolveElement(element.type, element.key, element.ref, element.props);
+    }
+
+    var processedChunk = processModelChunk(request, task.id, _value3);
+    request.completedJSONChunks.push(processedChunk);
+    request.abortableTasks.delete(task);
+    task.status = COMPLETED;
+  } catch (x) {
+    if (typeof x === 'object' && x !== null && typeof x.then === 'function') {
+      // Something suspended again, let's pick it back up later.
+      var ping = task.ping;
+      x.then(ping, ping);
+      return;
+    } else {
+      request.abortableTasks.delete(task);
+      task.status = ERRORED;
+      logRecoverableError(request, x); // This errored, we need to serialize this error to the
+
+      emitErrorChunk(request, task.id, x);
+    }
+  }
+}
+
+function performWork(request) {
+  var prevDispatcher = ReactCurrentDispatcher.current;
+  var prevCache = getCurrentCache();
+  ReactCurrentDispatcher.current = Dispatcher;
+  setCurrentCache(request.cache);
+  prepareToUseHooksForRequest(request);
+
+  try {
+    var pingedTasks = request.pingedTasks;
+    request.pingedTasks = [];
+
+    for (var i = 0; i < pingedTasks.length; i++) {
+      var task = pingedTasks[i];
+      retryTask(request, task);
+    }
+
+    if (request.destination !== null) {
+      flushCompletedChunks(request, request.destination);
+    }
+  } catch (error) {
+    logRecoverableError(request, error);
+    fatalError(request, error);
+  } finally {
+    ReactCurrentDispatcher.current = prevDispatcher;
+    setCurrentCache(prevCache);
+    resetHooksForRequest();
+  }
+}
+
+function abortTask(task, request, errorId) {
+  task.status = ABORTED; // Instead of emitting an error per task.id, we emit a model that only
+  // has a single value referencing the error.
+
+  var ref = serializeByValueID(errorId);
+  var processedChunk = processReferenceChunk(request, task.id, ref);
+  request.completedJSONChunks.push(processedChunk);
+}
+
+function flushCompletedChunks(request, destination) {
+  beginWriting();
+
+  try {
+    // We emit module chunks first in the stream so that
+    // they can be preloaded as early as possible.
+    var moduleChunks = request.completedModuleChunks;
+    var i = 0;
+
+    for (; i < moduleChunks.length; i++) {
+      request.pendingChunks--;
+      var chunk = moduleChunks[i];
+      var keepWriting = writeChunkAndReturn(destination, chunk);
+
+      if (!keepWriting) {
+        request.destination = null;
+        i++;
+        break;
+      }
+    }
+
+    moduleChunks.splice(0, i); // Next comes model data.
+
+    var jsonChunks = request.completedJSONChunks;
+    i = 0;
+
+    for (; i < jsonChunks.length; i++) {
+      request.pendingChunks--;
+      var _chunk = jsonChunks[i];
+
+      var _keepWriting = writeChunkAndReturn(destination, _chunk);
+
+      if (!_keepWriting) {
+        request.destination = null;
+        i++;
+        break;
+      }
+    }
+
+    jsonChunks.splice(0, i); // Finally, errors are sent. The idea is that it's ok to delay
+    // any error messages and prioritize display of other parts of
+    // the page.
+
+    var errorChunks = request.completedErrorChunks;
+    i = 0;
+
+    for (; i < errorChunks.length; i++) {
+      request.pendingChunks--;
+      var _chunk2 = errorChunks[i];
+
+      var _keepWriting2 = writeChunkAndReturn(destination, _chunk2);
+
+      if (!_keepWriting2) {
+        request.destination = null;
+        i++;
+        break;
+      }
+    }
+
+    errorChunks.splice(0, i);
+  } finally {
+    completeWriting(destination);
+  }
+
+  if (request.pendingChunks === 0) {
+    // We're done.
+    close(destination);
+  }
+}
+
+function startWork(request) {
+  scheduleWork(function () {
+    return performWork(request);
+  });
+}
+function startFlowing(request, destination) {
+  if (request.status === CLOSING) {
+    request.status = CLOSED;
+    closeWithError(destination, request.fatalError);
+    return;
+  }
+
+  if (request.status === CLOSED) {
+    return;
+  }
+
+  if (request.destination !== null) {
+    // We're already flowing.
+    return;
+  }
+
+  request.destination = destination;
+
+  try {
+    flushCompletedChunks(request, destination);
+  } catch (error) {
+    logRecoverableError(request, error);
+    fatalError(request, error);
+  }
+} // This is called to early terminate a request. It creates an error at all pending tasks.
+
+function abort(request, reason) {
+  try {
+    var abortableTasks = request.abortableTasks;
+
+    if (abortableTasks.size > 0) {
+      // We have tasks to abort. We'll emit one error row and then emit a reference
+      // to that row from every row that's still remaining.
+      var _error = reason === undefined ? new Error('The render was aborted by the server without a reason.') : reason;
+
+      logRecoverableError(request, _error);
+      request.pendingChunks++;
+      var errorId = request.nextChunkId++;
+      emitErrorChunk(request, errorId, _error);
+      abortableTasks.forEach(function (task) {
+        return abortTask(task, request, errorId);
+      });
+      abortableTasks.clear();
+    }
+
+    if (request.destination !== null) {
+      flushCompletedChunks(request, request.destination);
+    }
+  } catch (error) {
+    logRecoverableError(request, error);
+    fatalError(request, error);
+  }
+}
+
+function importServerContexts(contexts) {
+  if (contexts) {
+    var prevContext = getActiveContext();
+    switchContext(rootContextSnapshot);
+
+    for (var i = 0; i < contexts.length; i++) {
+      var _contexts$i = contexts[i],
+          name = _contexts$i[0],
+          _value4 = _contexts$i[1];
+      var context = getOrCreateServerContext(name);
+      pushProvider(context, _value4);
+    }
+
+    var importedContext = getActiveContext();
+    switchContext(prevContext);
+    return importedContext;
+  }
+
+  return rootContextSnapshot;
+}
+
+function renderToReadableStream(model, options) {
+  var request = createRequest( // Wrap root in a dummy element that simply adds a flag
+  // to the current dispatcher to check later in the proxies.
+  assign({}, model, {
+    $$typeof: Symbol.for('react.element'),
+    props: {
+      children: model
+    },
+    type: function () {
+      __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher.current.isRsc = true;
+      return model;
+    }
+  }), {}, // Manifest, not used
+  options ? options.onError : undefined, options ? options.context : undefined, options ? options.identifierPrefix : undefined);
+
+  if (options && options.signal) {
+    var signal = options.signal;
+
+    if (signal.aborted) {
+      abort(request, signal.reason);
+    } else {
+      var listener = function () {
+        abort(request, signal.reason);
+        signal.removeEventListener('abort', listener);
+      };
+
+      signal.addEventListener('abort', listener);
+    }
+  }
+
+  var stream = new ReadableStream({
+    type: 'bytes',
+    start: function (controller) {
+      startWork(request);
+    },
+    pull: function (controller) {
+      startFlowing(request, controller);
+    },
+    cancel: function (reason) {}
+  }, // $FlowFixMe size() methods are not allowed on byte streams.
+  {
+    highWaterMark: 0
+  });
+  return stream;
+}
+
+export { renderToReadableStream };
diff --git a/vendor/vendor/react-server-dom-vite/esm/react-server-dom-vite-writer.node.server.js b/vendor/vendor/react-server-dom-vite/esm/react-server-dom-vite-writer.node.server.js
new file mode 100644
index 0000000000000000000000000000000000000000..2898b55932c703c4b2b49c68f18b9219a967d3c6
--- /dev/null
+++ b/vendor/vendor/react-server-dom-vite/esm/react-server-dom-vite-writer.node.server.js
@@ -0,0 +1,1937 @@
+/**
+* @license React
+ * react-server-dom-vite-writer.node.server.js
+ *
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+import { __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, createServerContext } from 'react';
+import { TextEncoder } from 'util';
+
+var assign = Object.assign;
+
+var ReactSharedInternals = __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
+
+function error(format) {
+  {
+    {
+      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
+        args[_key2 - 1] = arguments[_key2];
+      }
+
+      printWarning('error', format, args);
+    }
+  }
+}
+
+function printWarning(level, format, args) {
+  // When changing this logic, you might want to also
+  // update consoleWithStackDev.www.js as well.
+  {
+    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
+    var stack = ReactDebugCurrentFrame.getStackAddendum();
+
+    if (stack !== '') {
+      format += '%s';
+      args = args.concat([stack]);
+    } // eslint-disable-next-line react-internal/safe-string-coercion
+
+
+    var argsWithFormat = args.map(function (item) {
+      return String(item);
+    }); // Careful: RN currently depends on this prefix
+
+    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
+    // breaks IE9: https://github.com/facebook/react/issues/13610
+    // eslint-disable-next-line react-internal/no-production-logging
+
+    Function.prototype.apply.call(console[level], console, argsWithFormat);
+  }
+}
+
+function scheduleWork(callback) {
+  setImmediate(callback);
+}
+function flushBuffered(destination) {
+  // If we don't have any more data to send right now.
+  // Flush whatever is in the buffer to the wire.
+  if (typeof destination.flush === 'function') {
+    // By convention the Zlib streams provide a flush function for this purpose.
+    // For Express, compression middleware adds this method.
+    destination.flush();
+  }
+}
+var VIEW_SIZE = 2048;
+var currentView = null;
+var writtenBytes = 0;
+var destinationHasCapacity = true;
+function beginWriting(destination) {
+  currentView = new Uint8Array(VIEW_SIZE);
+  writtenBytes = 0;
+  destinationHasCapacity = true;
+}
+
+function writeStringChunk(destination, stringChunk) {
+  if (stringChunk.length === 0) {
+    return;
+  } // maximum possible view needed to encode entire string
+
+
+  if (stringChunk.length * 3 > VIEW_SIZE) {
+    if (writtenBytes > 0) {
+      writeToDestination(destination, currentView.subarray(0, writtenBytes));
+      currentView = new Uint8Array(VIEW_SIZE);
+      writtenBytes = 0;
+    }
+
+    writeToDestination(destination, textEncoder.encode(stringChunk));
+    return;
+  }
+
+  var target = currentView;
+
+  if (writtenBytes > 0) {
+    target = currentView.subarray(writtenBytes);
+  }
+
+  var _textEncoder$encodeIn = textEncoder.encodeInto(stringChunk, target),
+      read = _textEncoder$encodeIn.read,
+      written = _textEncoder$encodeIn.written;
+
+  writtenBytes += written;
+
+  if (read < stringChunk.length) {
+    writeToDestination(destination, currentView);
+    currentView = new Uint8Array(VIEW_SIZE);
+    writtenBytes = textEncoder.encodeInto(stringChunk.slice(read), currentView).written;
+  }
+
+  if (writtenBytes === VIEW_SIZE) {
+    writeToDestination(destination, currentView);
+    currentView = new Uint8Array(VIEW_SIZE);
+    writtenBytes = 0;
+  }
+}
+
+function writeViewChunk(destination, chunk) {
+  if (chunk.byteLength === 0) {
+    return;
+  }
+
+  if (chunk.byteLength > VIEW_SIZE) {
+    // this chunk may overflow a single view which implies it was not
+    // one that is cached by the streaming renderer. We will enqueu
+    // it directly and expect it is not re-used
+    if (writtenBytes > 0) {
+      writeToDestination(destination, currentView.subarray(0, writtenBytes));
+      currentView = new Uint8Array(VIEW_SIZE);
+      writtenBytes = 0;
+    }
+
+    writeToDestination(destination, chunk);
+    return;
+  }
+
+  var bytesToWrite = chunk;
+  var allowableBytes = currentView.length - writtenBytes;
+
+  if (allowableBytes < bytesToWrite.byteLength) {
+    // this chunk would overflow the current view. We enqueue a full view
+    // and start a new view with the remaining chunk
+    if (allowableBytes === 0) {
+      // the current view is already full, send it
+      writeToDestination(destination, currentView);
+    } else {
+      // fill up the current view and apply the remaining chunk bytes
+      // to a new view.
+      currentView.set(bytesToWrite.subarray(0, allowableBytes), writtenBytes);
+      writtenBytes += allowableBytes;
+      writeToDestination(destination, currentView);
+      bytesToWrite = bytesToWrite.subarray(allowableBytes);
+    }
+
+    currentView = new Uint8Array(VIEW_SIZE);
+    writtenBytes = 0;
+  }
+
+  currentView.set(bytesToWrite, writtenBytes);
+  writtenBytes += bytesToWrite.byteLength;
+
+  if (writtenBytes === VIEW_SIZE) {
+    writeToDestination(destination, currentView);
+    currentView = new Uint8Array(VIEW_SIZE);
+    writtenBytes = 0;
+  }
+}
+
+function writeChunk(destination, chunk) {
+  if (typeof chunk === 'string') {
+    writeStringChunk(destination, chunk);
+  } else {
+    writeViewChunk(destination, chunk);
+  }
+}
+
+function writeToDestination(destination, view) {
+  var currentHasCapacity = destination.write(view);
+  destinationHasCapacity = destinationHasCapacity && currentHasCapacity;
+}
+
+function writeChunkAndReturn(destination, chunk) {
+  writeChunk(destination, chunk);
+  return destinationHasCapacity;
+}
+function completeWriting(destination) {
+  if (currentView && writtenBytes > 0) {
+    destination.write(currentView.subarray(0, writtenBytes));
+  }
+
+  currentView = null;
+  writtenBytes = 0;
+  destinationHasCapacity = true;
+}
+function close(destination) {
+  destination.end();
+}
+var textEncoder = new TextEncoder();
+function stringToChunk(content) {
+  return content;
+}
+function stringToPrecomputedChunk(content) {
+  return textEncoder.encode(content);
+}
+function closeWithError(destination, error) {
+  // $FlowFixMe: This is an Error object or the destination accepts other types.
+  destination.destroy(error);
+}
+
+// This file is an intermediate layer to translate between Flight
+var stringify = JSON.stringify;
+
+function serializeRowHeader(tag, id) {
+  return tag + id.toString(16) + ':';
+}
+
+function processErrorChunk(request, id, message, stack) {
+  var errorInfo = {
+    message: message,
+    stack: stack
+  };
+  var row = serializeRowHeader('E', id) + stringify(errorInfo) + '\n';
+  return stringToChunk(row);
+}
+function processModelChunk(request, id, model) {
+  var json = stringify(model, request.toJSON);
+  var row = serializeRowHeader('J', id) + json + '\n';
+  return stringToChunk(row);
+}
+function processReferenceChunk(request, id, reference) {
+  var json = stringify(reference);
+  var row = serializeRowHeader('J', id) + json + '\n';
+  return stringToChunk(row);
+}
+function processModuleChunk(request, id, moduleMetaData) {
+  var json = stringify(moduleMetaData);
+  var row = serializeRowHeader('M', id) + json + '\n';
+  return stringToChunk(row);
+}
+function processProviderChunk(request, id, contextName) {
+  var row = serializeRowHeader('P', id) + contextName + '\n';
+  return stringToChunk(row);
+}
+function processSymbolChunk(request, id, name) {
+  var json = stringify(name);
+  var row = serializeRowHeader('S', id) + json + '\n';
+  return stringToChunk(row);
+}
+
+// eslint-disable-next-line no-unused-vars
+var MODULE_TAG = Symbol.for('react.module.reference');
+function getModuleKey(reference) {
+  if (typeof reference === 'string') reference = globalThis.__STRING_REFERENCE_INDEX[reference];
+  return reference.filepath + '#' + reference.name;
+}
+function isModuleReference(reference) {
+  if (typeof reference === 'string') return !!globalThis.__STRING_REFERENCE_INDEX[reference];
+  return reference.$$typeof === MODULE_TAG;
+}
+function resolveModuleMetaData(config, moduleReference) {
+  if (typeof moduleReference === 'string') moduleReference = globalThis.__STRING_REFERENCE_INDEX[moduleReference];
+  return {
+    id: moduleReference.filepath,
+    name: moduleReference.name
+  };
+}
+
+// ATTENTION
+// When adding new symbols to this file,
+// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
+// The Symbol used to tag the ReactElement-like types.
+var REACT_ELEMENT_TYPE = Symbol.for('react.element');
+var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
+var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
+var REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');
+var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
+var REACT_MEMO_TYPE = Symbol.for('react.memo');
+var REACT_LAZY_TYPE = Symbol.for('react.lazy');
+var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for('react.default_value');
+
+// A reserved attribute.
+// It is handled by React separately and shouldn't be written to the DOM.
+var RESERVED = 0; // A simple string attribute.
+// Attributes that aren't in the filter are presumed to have this type.
+
+var STRING = 1; // A string attribute that accepts booleans in React. In HTML, these are called
+// "enumerated" attributes with "true" and "false" as possible values.
+// When true, it should be set to a "true" string.
+// When false, it should be set to a "false" string.
+
+var BOOLEANISH_STRING = 2; // A real boolean attribute.
+// When true, it should be present (set either to an empty string or its name).
+// When false, it should be omitted.
+
+var BOOLEAN = 3; // An attribute that can be used as a flag as well as with a value.
+// When true, it should be present (set either to an empty string or its name).
+// When false, it should be omitted.
+// For any other value, should be present with that value.
+
+var OVERLOADED_BOOLEAN = 4; // An attribute that must be numeric or parse as a numeric.
+// When falsy, it should be removed.
+
+var NUMERIC = 5; // An attribute that must be positive numeric or parse as a positive numeric.
+// When falsy, it should be removed.
+
+var POSITIVE_NUMERIC = 6;
+
+function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL, removeEmptyString) {
+  this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
+  this.attributeName = attributeName;
+  this.attributeNamespace = attributeNamespace;
+  this.mustUseProperty = mustUseProperty;
+  this.propertyName = name;
+  this.type = type;
+  this.sanitizeURL = sanitizeURL;
+  this.removeEmptyString = removeEmptyString;
+} // When adding attributes to this list, be sure to also add them to
+// the `possibleStandardNames` module to ensure casing and incorrect
+// name warnings.
+
+
+var properties = {}; // These props are reserved by React. They shouldn't be written to the DOM.
+
+var reservedProps = ['children', 'dangerouslySetInnerHTML', // TODO: This prevents the assignment of defaultValue to regular
+// elements (not just inputs). Now that ReactDOMInput assigns to the
+// defaultValue property -- do we need this?
+'defaultValue', 'defaultChecked', 'innerHTML', 'suppressContentEditableWarning', 'suppressHydrationWarning', 'style'];
+
+{
+  reservedProps.push('innerText', 'textContent');
+}
+
+reservedProps.forEach(function (name) {
+  properties[name] = new PropertyInfoRecord(name, RESERVED, false, // mustUseProperty
+  name, // attributeName
+  null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+}); // A few React string attributes have a different name.
+// This is a mapping from React prop names to the attribute names.
+
+[['acceptCharset', 'accept-charset'], ['className', 'class'], ['htmlFor', 'for'], ['httpEquiv', 'http-equiv']].forEach(function (_ref) {
+  var name = _ref[0],
+      attributeName = _ref[1];
+  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
+  attributeName, // attributeName
+  null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+}); // These are "enumerated" HTML attributes that accept "true" and "false".
+// In React, we let users pass `true` and `false` even though technically
+// these aren't boolean attributes (they are coerced to strings).
+
+['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(function (name) {
+  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty
+  name.toLowerCase(), // attributeName
+  null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+}); // These are "enumerated" SVG attributes that accept "true" and "false".
+// In React, we let users pass `true` and `false` even though technically
+// these aren't boolean attributes (they are coerced to strings).
+// Since these are SVG attributes, their attribute names are case-sensitive.
+
+['autoReverse', 'externalResourcesRequired', 'focusable', 'preserveAlpha'].forEach(function (name) {
+  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty
+  name, // attributeName
+  null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+}); // These are HTML boolean attributes.
+
+['allowFullScreen', 'async', // Note: there is a special case that prevents it from being written to the DOM
+// on the client side because the browsers are inconsistent. Instead we call focus().
+'autoFocus', 'autoPlay', 'controls', 'default', 'defer', 'disabled', 'disablePictureInPicture', 'disableRemotePlayback', 'formNoValidate', 'hidden', 'loop', 'noModule', 'noValidate', 'open', 'playsInline', 'readOnly', 'required', 'reversed', 'scoped', 'seamless', // Microdata
+'itemScope'].forEach(function (name) {
+  properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, // mustUseProperty
+  name.toLowerCase(), // attributeName
+  null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+}); // These are the few React props that we set as DOM properties
+// rather than attributes. These are all booleans.
+
+['checked', // Note: `option.selected` is not updated if `select.multiple` is
+// disabled with `removeAttribute`. We have special logic for handling this.
+'multiple', 'muted', 'selected' // NOTE: if you add a camelCased prop to this list,
+// you'll need to set attributeName to name.toLowerCase()
+// instead in the assignment below.
+].forEach(function (name) {
+  properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, // mustUseProperty
+  name, // attributeName
+  null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+}); // These are HTML attributes that are "overloaded booleans": they behave like
+// booleans, but can also accept a string value.
+
+['capture', 'download' // NOTE: if you add a camelCased prop to this list,
+// you'll need to set attributeName to name.toLowerCase()
+// instead in the assignment below.
+].forEach(function (name) {
+  properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, // mustUseProperty
+  name, // attributeName
+  null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+}); // These are HTML attributes that must be positive numbers.
+
+['cols', 'rows', 'size', 'span' // NOTE: if you add a camelCased prop to this list,
+// you'll need to set attributeName to name.toLowerCase()
+// instead in the assignment below.
+].forEach(function (name) {
+  properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, // mustUseProperty
+  name, // attributeName
+  null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+}); // These are HTML attributes that must be numbers.
+
+['rowSpan', 'start'].forEach(function (name) {
+  properties[name] = new PropertyInfoRecord(name, NUMERIC, false, // mustUseProperty
+  name.toLowerCase(), // attributeName
+  null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+});
+var CAMELIZE = /[\-\:]([a-z])/g;
+
+var capitalize = function (token) {
+  return token[1].toUpperCase();
+}; // This is a list of all SVG attributes that need special casing, namespacing,
+// or boolean value assignment. Regular attributes that just accept strings
+// and have the same names are omitted, just like in the HTML attribute filter.
+// Some of these attributes can be hard to find. This list was created by
+// scraping the MDN documentation.
+
+
+['accent-height', 'alignment-baseline', 'arabic-form', 'baseline-shift', 'cap-height', 'clip-path', 'clip-rule', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'dominant-baseline', 'enable-background', 'fill-opacity', 'fill-rule', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'glyph-name', 'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'horiz-adv-x', 'horiz-origin-x', 'image-rendering', 'letter-spacing', 'lighting-color', 'marker-end', 'marker-mid', 'marker-start', 'overline-position', 'overline-thickness', 'paint-order', 'panose-1', 'pointer-events', 'rendering-intent', 'shape-rendering', 'stop-color', 'stop-opacity', 'strikethrough-position', 'strikethrough-thickness', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'text-anchor', 'text-decoration', 'text-rendering', 'underline-position', 'underline-thickness', 'unicode-bidi', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'vector-effect', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'word-spacing', 'writing-mode', 'xmlns:xlink', 'x-height' // NOTE: if you add a camelCased prop to this list,
+// you'll need to set attributeName to name.toLowerCase()
+// instead in the assignment below.
+].forEach(function (attributeName) {
+  var name = attributeName.replace(CAMELIZE, capitalize);
+  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
+  attributeName, null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+}); // String SVG attributes with the xlink namespace.
+
+['xlink:actuate', 'xlink:arcrole', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type' // NOTE: if you add a camelCased prop to this list,
+// you'll need to set attributeName to name.toLowerCase()
+// instead in the assignment below.
+].forEach(function (attributeName) {
+  var name = attributeName.replace(CAMELIZE, capitalize);
+  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
+  attributeName, 'http://www.w3.org/1999/xlink', false, // sanitizeURL
+  false);
+}); // String SVG attributes with the xml namespace.
+
+['xml:base', 'xml:lang', 'xml:space' // NOTE: if you add a camelCased prop to this list,
+// you'll need to set attributeName to name.toLowerCase()
+// instead in the assignment below.
+].forEach(function (attributeName) {
+  var name = attributeName.replace(CAMELIZE, capitalize);
+  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
+  attributeName, 'http://www.w3.org/XML/1998/namespace', false, // sanitizeURL
+  false);
+}); // These attribute exists both in HTML and SVG.
+// The attribute name is case-sensitive in SVG so we can't just use
+// the React name like we do for attributes that exist only in HTML.
+
+['tabIndex', 'crossOrigin'].forEach(function (attributeName) {
+  properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, // mustUseProperty
+  attributeName.toLowerCase(), // attributeName
+  null, // attributeNamespace
+  false, // sanitizeURL
+  false);
+}); // These attributes accept URLs. These must not allow javascript: URLS.
+// These will also need to accept Trusted Types object in the future.
+
+var xlinkHref = 'xlinkHref';
+properties[xlinkHref] = new PropertyInfoRecord('xlinkHref', STRING, false, // mustUseProperty
+'xlink:href', 'http://www.w3.org/1999/xlink', true, // sanitizeURL
+false);
+['src', 'href', 'action', 'formAction'].forEach(function (attributeName) {
+  properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, // mustUseProperty
+  attributeName.toLowerCase(), // attributeName
+  null, // attributeNamespace
+  true, // sanitizeURL
+  true);
+});
+
+/**
+ * CSS properties which accept numbers but are not in units of "px".
+ */
+var isUnitlessNumber = {
+  animationIterationCount: true,
+  aspectRatio: true,
+  borderImageOutset: true,
+  borderImageSlice: true,
+  borderImageWidth: true,
+  boxFlex: true,
+  boxFlexGroup: true,
+  boxOrdinalGroup: true,
+  columnCount: true,
+  columns: true,
+  flex: true,
+  flexGrow: true,
+  flexPositive: true,
+  flexShrink: true,
+  flexNegative: true,
+  flexOrder: true,
+  gridArea: true,
+  gridRow: true,
+  gridRowEnd: true,
+  gridRowSpan: true,
+  gridRowStart: true,
+  gridColumn: true,
+  gridColumnEnd: true,
+  gridColumnSpan: true,
+  gridColumnStart: true,
+  fontWeight: true,
+  lineClamp: true,
+  lineHeight: true,
+  opacity: true,
+  order: true,
+  orphans: true,
+  tabSize: true,
+  widows: true,
+  zIndex: true,
+  zoom: true,
+  // SVG-related properties
+  fillOpacity: true,
+  floodOpacity: true,
+  stopOpacity: true,
+  strokeDasharray: true,
+  strokeDashoffset: true,
+  strokeMiterlimit: true,
+  strokeOpacity: true,
+  strokeWidth: true
+};
+/**
+ * @param {string} prefix vendor-specific prefix, eg: Webkit
+ * @param {string} key style name, eg: transitionDuration
+ * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
+ * WebkitTransitionDuration
+ */
+
+function prefixKey(prefix, key) {
+  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
+}
+/**
+ * Support style names that may come passed in prefixed by adding permutations
+ * of vendor prefixes.
+ */
+
+
+var prefixes = ['Webkit', 'ms', 'Moz', 'O']; // Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
+// infinite loop, because it iterates over the newly added props too.
+
+Object.keys(isUnitlessNumber).forEach(function (prop) {
+  prefixes.forEach(function (prefix) {
+    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
+  });
+});
+
+var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare
+
+function isArray(a) {
+  return isArrayImpl(a);
+}
+
+var startInlineScript = stringToPrecomputedChunk('<script>');
+var endInlineScript = stringToPrecomputedChunk('</script>');
+var startScriptSrc = stringToPrecomputedChunk('<script src="');
+var startModuleSrc = stringToPrecomputedChunk('<script type="module" src="');
+var scriptIntegirty = stringToPrecomputedChunk('" integrity="');
+var endAsyncScript = stringToPrecomputedChunk('" async=""></script>');
+
+var textSeparator = stringToPrecomputedChunk('<!-- -->');
+
+var styleAttributeStart = stringToPrecomputedChunk(' style="');
+var styleAssign = stringToPrecomputedChunk(':');
+var styleSeparator = stringToPrecomputedChunk(';');
+
+var attributeSeparator = stringToPrecomputedChunk(' ');
+var attributeAssign = stringToPrecomputedChunk('="');
+var attributeEnd = stringToPrecomputedChunk('"');
+var attributeEmptyString = stringToPrecomputedChunk('=""');
+
+var endOfStartTag = stringToPrecomputedChunk('>');
+var endOfStartTagSelfClosing = stringToPrecomputedChunk('/>');
+
+var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=""');
+
+var leadingNewline = stringToPrecomputedChunk('\n');
+
+var DOCTYPE = stringToPrecomputedChunk('<!DOCTYPE html>');
+var endTag1 = stringToPrecomputedChunk('</');
+var endTag2 = stringToPrecomputedChunk('>');
+// A placeholder is a node inside a hidden partial tree that can be filled in later, but before
+// display. It's never visible to users. We use the template tag because it can be used in every
+// type of parent. <script> tags also work in every other tag except <colgroup>.
+
+var placeholder1 = stringToPrecomputedChunk('<template id="');
+var placeholder2 = stringToPrecomputedChunk('"></template>');
+
+var startCompletedSuspenseBoundary = stringToPrecomputedChunk('<!--$-->');
+var startPendingSuspenseBoundary1 = stringToPrecomputedChunk('<!--$?--><template id="');
+var startPendingSuspenseBoundary2 = stringToPrecomputedChunk('"></template>');
+var startClientRenderedSuspenseBoundary = stringToPrecomputedChunk('<!--$!-->');
+var endSuspenseBoundary = stringToPrecomputedChunk('<!--/$-->');
+var clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk('<template');
+var clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('"');
+var clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst="');
+var clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg="');
+var clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck="');
+var clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk('></template>');
+var startSegmentHTML = stringToPrecomputedChunk('<div hidden id="');
+var startSegmentHTML2 = stringToPrecomputedChunk('">');
+var endSegmentHTML = stringToPrecomputedChunk('</div>');
+var startSegmentSVG = stringToPrecomputedChunk('<svg aria-hidden="true" style="display:none" id="');
+var startSegmentSVG2 = stringToPrecomputedChunk('">');
+var endSegmentSVG = stringToPrecomputedChunk('</svg>');
+var startSegmentMathML = stringToPrecomputedChunk('<math aria-hidden="true" style="display:none" id="');
+var startSegmentMathML2 = stringToPrecomputedChunk('">');
+var endSegmentMathML = stringToPrecomputedChunk('</math>');
+var startSegmentTable = stringToPrecomputedChunk('<table hidden id="');
+var startSegmentTable2 = stringToPrecomputedChunk('">');
+var endSegmentTable = stringToPrecomputedChunk('</table>');
+var startSegmentTableBody = stringToPrecomputedChunk('<table hidden><tbody id="');
+var startSegmentTableBody2 = stringToPrecomputedChunk('">');
+var endSegmentTableBody = stringToPrecomputedChunk('</tbody></table>');
+var startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id="');
+var startSegmentTableRow2 = stringToPrecomputedChunk('">');
+var endSegmentTableRow = stringToPrecomputedChunk('</tr></table>');
+var startSegmentColGroup = stringToPrecomputedChunk('<table hidden><colgroup id="');
+var startSegmentColGroup2 = stringToPrecomputedChunk('">');
+var endSegmentColGroup = stringToPrecomputedChunk('</colgroup></table>');
+// The following code is the source scripts that we then minify and inline below,
+// with renamed function names that we hope don't collide:
+// const COMMENT_NODE = 8;
+// const SUSPENSE_START_DATA = '$';
+// const SUSPENSE_END_DATA = '/$';
+// const SUSPENSE_PENDING_START_DATA = '$?';
+// const SUSPENSE_FALLBACK_START_DATA = '$!';
+//
+// function clientRenderBoundary(suspenseBoundaryID, errorDigest, errorMsg, errorComponentStack) {
+//   // Find the fallback's first element.
+//   const suspenseIdNode = document.getElementById(suspenseBoundaryID);
+//   if (!suspenseIdNode) {
+//     // The user must have already navigated away from this tree.
+//     // E.g. because the parent was hydrated.
+//     return;
+//   }
+//   // Find the boundary around the fallback. This is always the previous node.
+//   const suspenseNode = suspenseIdNode.previousSibling;
+//   // Tag it to be client rendered.
+//   suspenseNode.data = SUSPENSE_FALLBACK_START_DATA;
+//   // assign error metadata to first sibling
+//   let dataset = suspenseIdNode.dataset;
+//   if (errorDigest) dataset.dgst = errorDigest;
+//   if (errorMsg) dataset.msg = errorMsg;
+//   if (errorComponentStack) dataset.stck = errorComponentStack;
+//   // Tell React to retry it if the parent already hydrated.
+//   if (suspenseNode._reactRetry) {
+//     suspenseNode._reactRetry();
+//   }
+// }
+//
+// function completeBoundary(suspenseBoundaryID, contentID) {
+//   // Find the fallback's first element.
+//   const suspenseIdNode = document.getElementById(suspenseBoundaryID);
+//   const contentNode = document.getElementById(contentID);
+//   // We'll detach the content node so that regardless of what happens next we don't leave in the tree.
+//   // This might also help by not causing recalcing each time we move a child from here to the target.
+//   contentNode.parentNode.removeChild(contentNode);
+//   if (!suspenseIdNode) {
+//     // The user must have already navigated away from this tree.
+//     // E.g. because the parent was hydrated. That's fine there's nothing to do
+//     // but we have to make sure that we already deleted the container node.
+//     return;
+//   }
+//   // Find the boundary around the fallback. This is always the previous node.
+//   const suspenseNode = suspenseIdNode.previousSibling;
+//
+//   // Clear all the existing children. This is complicated because
+//   // there can be embedded Suspense boundaries in the fallback.
+//   // This is similar to clearSuspenseBoundary in ReactDOMHostConfig.
+//   // TODO: We could avoid this if we never emitted suspense boundaries in fallback trees.
+//   // They never hydrate anyway. However, currently we support incrementally loading the fallback.
+//   const parentInstance = suspenseNode.parentNode;
+//   let node = suspenseNode.nextSibling;
+//   let depth = 0;
+//   do {
+//     if (node && node.nodeType === COMMENT_NODE) {
+//       const data = node.data;
+//       if (data === SUSPENSE_END_DATA) {
+//         if (depth === 0) {
+//           break;
+//         } else {
+//           depth--;
+//         }
+//       } else if (
+//         data === SUSPENSE_START_DATA ||
+//         data === SUSPENSE_PENDING_START_DATA ||
+//         data === SUSPENSE_FALLBACK_START_DATA
+//       ) {
+//         depth++;
+//       }
+//     }
+//
+//     const nextNode = node.nextSibling;
+//     parentInstance.removeChild(node);
+//     node = nextNode;
+//   } while (node);
+//
+//   const endOfBoundary = node;
+//
+//   // Insert all the children from the contentNode between the start and end of suspense boundary.
+//   while (contentNode.firstChild) {
+//     parentInstance.insertBefore(contentNode.firstChild, endOfBoundary);
+//   }
+//   suspenseNode.data = SUSPENSE_START_DATA;
+//   if (suspenseNode._reactRetry) {
+//     suspenseNode._reactRetry();
+//   }
+// }
+//
+// function completeSegment(containerID, placeholderID) {
+//   const segmentContainer = document.getElementById(containerID);
+//   const placeholderNode = document.getElementById(placeholderID);
+//   // We always expect both nodes to exist here because, while we might
+//   // have navigated away from the main tree, we still expect the detached
+//   // tree to exist.
+//   segmentContainer.parentNode.removeChild(segmentContainer);
+//   while (segmentContainer.firstChild) {
+//     placeholderNode.parentNode.insertBefore(
+//       segmentContainer.firstChild,
+//       placeholderNode,
+//     );
+//   }
+//   placeholderNode.parentNode.removeChild(placeholderNode);
+// }
+
+var completeSegmentFunction = 'function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}';
+var completeBoundaryFunction = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}';
+var clientRenderFunction = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}';
+var completeSegmentScript1Full = stringToPrecomputedChunk(completeSegmentFunction + ';$RS("');
+var completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("');
+var completeSegmentScript2 = stringToPrecomputedChunk('","');
+var completeSegmentScript3 = stringToPrecomputedChunk('")</script>');
+var completeBoundaryScript1Full = stringToPrecomputedChunk(completeBoundaryFunction + ';$RC("');
+var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("');
+var completeBoundaryScript2 = stringToPrecomputedChunk('","');
+var completeBoundaryScript3 = stringToPrecomputedChunk('")</script>');
+var clientRenderScript1Full = stringToPrecomputedChunk(clientRenderFunction + ';$RX("');
+var clientRenderScript1Partial = stringToPrecomputedChunk('$RX("');
+var clientRenderScript1A = stringToPrecomputedChunk('"');
+var clientRenderScript2 = stringToPrecomputedChunk(')</script>');
+var clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(',');
+
+var rendererSigil;
+
+{
+  // Use this to detect multiple renderers using the same context
+  rendererSigil = {};
+} // Used to store the parent path of all context overrides in a shared linked list.
+// Forming a reverse tree.
+
+
+var rootContextSnapshot = null; // We assume that this runtime owns the "current" field on all ReactContext instances.
+// This global (actually thread local) state represents what state all those "current",
+// fields are currently in.
+
+var currentActiveSnapshot = null;
+
+function popNode(prev) {
+  {
+    prev.context._currentValue = prev.parentValue;
+  }
+}
+
+function pushNode(next) {
+  {
+    next.context._currentValue = next.value;
+  }
+}
+
+function popToNearestCommonAncestor(prev, next) {
+  if (prev === next) ; else {
+    popNode(prev);
+    var parentPrev = prev.parent;
+    var parentNext = next.parent;
+
+    if (parentPrev === null) {
+      if (parentNext !== null) {
+        throw new Error('The stacks must reach the root at the same time. This is a bug in React.');
+      }
+    } else {
+      if (parentNext === null) {
+        throw new Error('The stacks must reach the root at the same time. This is a bug in React.');
+      }
+
+      popToNearestCommonAncestor(parentPrev, parentNext); // On the way back, we push the new ones that weren't common.
+
+      pushNode(next);
+    }
+  }
+}
+
+function popAllPrevious(prev) {
+  popNode(prev);
+  var parentPrev = prev.parent;
+
+  if (parentPrev !== null) {
+    popAllPrevious(parentPrev);
+  }
+}
+
+function pushAllNext(next) {
+  var parentNext = next.parent;
+
+  if (parentNext !== null) {
+    pushAllNext(parentNext);
+  }
+
+  pushNode(next);
+}
+
+function popPreviousToCommonLevel(prev, next) {
+  popNode(prev);
+  var parentPrev = prev.parent;
+
+  if (parentPrev === null) {
+    throw new Error('The depth must equal at least at zero before reaching the root. This is a bug in React.');
+  }
+
+  if (parentPrev.depth === next.depth) {
+    // We found the same level. Now we just need to find a shared ancestor.
+    popToNearestCommonAncestor(parentPrev, next);
+  } else {
+    // We must still be deeper.
+    popPreviousToCommonLevel(parentPrev, next);
+  }
+}
+
+function popNextToCommonLevel(prev, next) {
+  var parentNext = next.parent;
+
+  if (parentNext === null) {
+    throw new Error('The depth must equal at least at zero before reaching the root. This is a bug in React.');
+  }
+
+  if (prev.depth === parentNext.depth) {
+    // We found the same level. Now we just need to find a shared ancestor.
+    popToNearestCommonAncestor(prev, parentNext);
+  } else {
+    // We must still be deeper.
+    popNextToCommonLevel(prev, parentNext);
+  }
+
+  pushNode(next);
+} // Perform context switching to the new snapshot.
+// To make it cheap to read many contexts, while not suspending, we make the switch eagerly by
+// updating all the context's current values. That way reads, always just read the current value.
+// At the cost of updating contexts even if they're never read by this subtree.
+
+
+function switchContext(newSnapshot) {
+  // The basic algorithm we need to do is to pop back any contexts that are no longer on the stack.
+  // We also need to update any new contexts that are now on the stack with the deepest value.
+  // The easiest way to update new contexts is to just reapply them in reverse order from the
+  // perspective of the backpointers. To avoid allocating a lot when switching, we use the stack
+  // for that. Therefore this algorithm is recursive.
+  // 1) First we pop which ever snapshot tree was deepest. Popping old contexts as we go.
+  // 2) Then we find the nearest common ancestor from there. Popping old contexts as we go.
+  // 3) Then we reapply new contexts on the way back up the stack.
+  var prev = currentActiveSnapshot;
+  var next = newSnapshot;
+
+  if (prev !== next) {
+    if (prev === null) {
+      // $FlowFixMe: This has to be non-null since it's not equal to prev.
+      pushAllNext(next);
+    } else if (next === null) {
+      popAllPrevious(prev);
+    } else if (prev.depth === next.depth) {
+      popToNearestCommonAncestor(prev, next);
+    } else if (prev.depth > next.depth) {
+      popPreviousToCommonLevel(prev, next);
+    } else {
+      popNextToCommonLevel(prev, next);
+    }
+
+    currentActiveSnapshot = next;
+  }
+}
+function pushProvider(context, nextValue) {
+  var prevValue;
+
+  {
+    prevValue = context._currentValue;
+    context._currentValue = nextValue;
+
+    {
+      if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
+        error('Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.');
+      }
+
+      context._currentRenderer = rendererSigil;
+    }
+  }
+
+  var prevNode = currentActiveSnapshot;
+  var newNode = {
+    parent: prevNode,
+    depth: prevNode === null ? 0 : prevNode.depth + 1,
+    context: context,
+    parentValue: prevValue,
+    value: nextValue
+  };
+  currentActiveSnapshot = newNode;
+  return newNode;
+}
+function popProvider() {
+  var prevSnapshot = currentActiveSnapshot;
+
+  if (prevSnapshot === null) {
+    throw new Error('Tried to pop a Context at the root of the app. This is a bug in React.');
+  }
+
+  {
+    var value = prevSnapshot.parentValue;
+
+    if (value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
+      prevSnapshot.context._currentValue = prevSnapshot.context._defaultValue;
+    } else {
+      prevSnapshot.context._currentValue = value;
+    }
+  }
+
+  return currentActiveSnapshot = prevSnapshot.parent;
+}
+function getActiveContext() {
+  return currentActiveSnapshot;
+}
+function readContext(context) {
+  var value =  context._currentValue ;
+  return value;
+}
+
+var currentRequest = null;
+function prepareToUseHooksForRequest(request) {
+  currentRequest = request;
+}
+function resetHooksForRequest() {
+  currentRequest = null;
+}
+
+function readContext$1(context) {
+  {
+    if (context.$$typeof !== REACT_SERVER_CONTEXT_TYPE) {
+      error('Only ServerContext is supported in Flight');
+    }
+
+    if (currentCache === null) {
+      error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');
+    }
+  }
+
+  return readContext(context);
+}
+
+var Dispatcher = {
+  useMemo: function (nextCreate) {
+    return nextCreate();
+  },
+  useCallback: function (callback) {
+    return callback;
+  },
+  useDebugValue: function () {},
+  useDeferredValue: unsupportedHook,
+  useTransition: unsupportedHook,
+  getCacheForType: function (resourceType) {
+    if (!currentCache) {
+      throw new Error('Reading the cache is only supported while rendering.');
+    }
+
+    var entry = currentCache.get(resourceType);
+
+    if (entry === undefined) {
+      entry = resourceType(); // TODO: Warn if undefined?
+
+      currentCache.set(resourceType, entry);
+    }
+
+    return entry;
+  },
+  readContext: readContext$1,
+  useContext: readContext$1,
+  useReducer: unsupportedHook,
+  useRef: unsupportedHook,
+  useState: unsupportedHook,
+  useInsertionEffect: unsupportedHook,
+  useLayoutEffect: unsupportedHook,
+  useImperativeHandle: unsupportedHook,
+  useEffect: unsupportedHook,
+  useId: useId,
+  useMutableSource: unsupportedHook,
+  useSyncExternalStore: unsupportedHook,
+  useCacheRefresh: function () {
+    return unsupportedRefresh;
+  }
+};
+
+function unsupportedHook() {
+  throw new Error('This Hook is not supported in Server Components.');
+}
+
+function unsupportedRefresh() {
+  if (!currentCache) {
+    throw new Error('Refreshing the cache is not supported in Server Components.');
+  }
+}
+
+var currentCache = null;
+function setCurrentCache(cache) {
+  currentCache = cache;
+  return currentCache;
+}
+function getCurrentCache() {
+  return currentCache;
+}
+
+function useId() {
+  if (currentRequest === null) {
+    throw new Error('useId can only be used while React is rendering');
+  }
+
+  var id = currentRequest.identifierCount++; // use 'S' for Flight components to distinguish from 'R' and 'r' in Fizz/Client
+
+  return ':' + currentRequest.identifierPrefix + 'S' + id.toString(32) + ':';
+}
+
+var ContextRegistry = ReactSharedInternals.ContextRegistry;
+function getOrCreateServerContext(globalName) {
+  if (!ContextRegistry[globalName]) {
+    ContextRegistry[globalName] = createServerContext(globalName, REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED);
+  }
+
+  return ContextRegistry[globalName];
+}
+
+var PENDING = 0;
+var COMPLETED = 1;
+var ABORTED = 3;
+var ERRORED = 4;
+var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
+
+function defaultErrorHandler(error) {
+  console['error'](error); // Don't transform to our wrapper
+}
+
+var OPEN = 0;
+var CLOSING = 1;
+var CLOSED = 2;
+function createRequest(model, bundlerConfig, onError, context, identifierPrefix) {
+  var abortSet = new Set();
+  var pingedTasks = [];
+  var request = {
+    status: OPEN,
+    fatalError: null,
+    destination: null,
+    bundlerConfig: bundlerConfig,
+    cache: new Map(),
+    nextChunkId: 0,
+    pendingChunks: 0,
+    abortableTasks: abortSet,
+    pingedTasks: pingedTasks,
+    completedModuleChunks: [],
+    completedJSONChunks: [],
+    completedErrorChunks: [],
+    writtenSymbols: new Map(),
+    writtenModules: new Map(),
+    writtenProviders: new Map(),
+    identifierPrefix: identifierPrefix || '',
+    identifierCount: 1,
+    onError: onError === undefined ? defaultErrorHandler : onError,
+    toJSON: function (key, value) {
+      return resolveModelToJSON(request, this, key, value);
+    }
+  };
+  request.pendingChunks++;
+  var rootContext = createRootContext(context);
+  var rootTask = createTask(request, model, rootContext, abortSet);
+  pingedTasks.push(rootTask);
+  return request;
+}
+
+function createRootContext(reqContext) {
+  return importServerContexts(reqContext);
+}
+
+var POP = {};
+
+function attemptResolveElement(type, key, ref, props) {
+  if (ref !== null && ref !== undefined) {
+    // When the ref moves to the regular props object this will implicitly
+    // throw for functions. We could probably relax it to a DEV warning for other
+    // cases.
+    throw new Error('Refs cannot be used in server components, nor passed to client components.');
+  }
+
+  if (typeof type === 'function') {
+    if (isModuleReference(type)) {
+      // This is a reference to a client component.
+      return [REACT_ELEMENT_TYPE, type, key, props];
+    } // This is a server-side component.
+
+
+    return type(props);
+  } else if (typeof type === 'string') {
+    // This is a host element. E.g. HTML.
+    return [REACT_ELEMENT_TYPE, type, key, props];
+  } else if (typeof type === 'symbol') {
+    if (type === REACT_FRAGMENT_TYPE) {
+      // For key-less fragments, we add a small optimization to avoid serializing
+      // it as a wrapper.
+      // TODO: If a key is specified, we should propagate its key to any children.
+      // Same as if a server component has a key.
+      return props.children;
+    } // This might be a built-in React component. We'll let the client decide.
+    // Any built-in works as long as its props are serializable.
+
+
+    return [REACT_ELEMENT_TYPE, type, key, props];
+  } else if (type != null && typeof type === 'object') {
+    if (isModuleReference(type)) {
+      // This is a reference to a client component.
+      return [REACT_ELEMENT_TYPE, type, key, props];
+    }
+
+    switch (type.$$typeof) {
+      case REACT_LAZY_TYPE:
+        {
+          var payload = type._payload;
+          var init = type._init;
+          var wrappedType = init(payload);
+          return attemptResolveElement(wrappedType, key, ref, props);
+        }
+
+      case REACT_FORWARD_REF_TYPE:
+        {
+          var render = type.render;
+          return render(props, undefined);
+        }
+
+      case REACT_MEMO_TYPE:
+        {
+          return attemptResolveElement(type.type, key, ref, props);
+        }
+
+      case REACT_PROVIDER_TYPE:
+        {
+          pushProvider(type._context, props.value);
+
+          {
+            var extraKeys = Object.keys(props).filter(function (value) {
+              if (value === 'children' || value === 'value') {
+                return false;
+              }
+
+              return true;
+            });
+
+            if (extraKeys.length !== 0) {
+              error('ServerContext can only have a value prop and children. Found: %s', JSON.stringify(extraKeys));
+            }
+          }
+
+          return [REACT_ELEMENT_TYPE, type, key, // Rely on __popProvider being serialized last to pop the provider.
+          {
+            value: props.value,
+            children: props.children,
+            __pop: POP
+          }];
+        }
+    }
+  }
+
+  throw new Error("Unsupported server component type: " + describeValueForErrorMessage(type));
+}
+
+function pingTask(request, task) {
+  var pingedTasks = request.pingedTasks;
+  pingedTasks.push(task);
+
+  if (pingedTasks.length === 1) {
+    scheduleWork(function () {
+      return performWork(request);
+    });
+  }
+}
+
+function createTask(request, model, context, abortSet) {
+  var id = request.nextChunkId++;
+  var task = {
+    id: id,
+    status: PENDING,
+    model: model,
+    context: context,
+    ping: function () {
+      return pingTask(request, task);
+    }
+  };
+  abortSet.add(task);
+  return task;
+}
+
+function serializeByValueID(id) {
+  return '$' + id.toString(16);
+}
+
+function serializeByRefID(id) {
+  return '@' + id.toString(16);
+}
+
+function escapeStringValue(value) {
+  if (value[0] === '$' || value[0] === '@') {
+    // We need to escape $ or @ prefixed strings since we use those to encode
+    // references to IDs and as special symbol values.
+    return '$' + value;
+  } else {
+    return value;
+  }
+}
+
+function isObjectPrototype(object) {
+  if (!object) {
+    return false;
+  }
+
+  var ObjectPrototype = Object.prototype;
+
+  if (object === ObjectPrototype) {
+    return true;
+  } // It might be an object from a different Realm which is
+  // still just a plain simple object.
+
+
+  if (Object.getPrototypeOf(object)) {
+    return false;
+  }
+
+  var names = Object.getOwnPropertyNames(object);
+
+  for (var i = 0; i < names.length; i++) {
+    if (!(names[i] in ObjectPrototype)) {
+      return false;
+    }
+  }
+
+  return true;
+}
+
+function isSimpleObject(object) {
+  if (!isObjectPrototype(Object.getPrototypeOf(object))) {
+    return false;
+  }
+
+  var names = Object.getOwnPropertyNames(object);
+
+  for (var i = 0; i < names.length; i++) {
+    var descriptor = Object.getOwnPropertyDescriptor(object, names[i]);
+
+    if (!descriptor) {
+      return false;
+    }
+
+    if (!descriptor.enumerable) {
+      if ((names[i] === 'key' || names[i] === 'ref') && typeof descriptor.get === 'function') {
+        // React adds key and ref getters to props objects to issue warnings.
+        // Those getters will not be transferred to the client, but that's ok,
+        // so we'll special case them.
+        continue;
+      }
+
+      return false;
+    }
+  }
+
+  return true;
+}
+
+function objectName(object) {
+  var name = Object.prototype.toString.call(object);
+  return name.replace(/^\[object (.*)\]$/, function (m, p0) {
+    return p0;
+  });
+}
+
+function describeKeyForErrorMessage(key) {
+  var encodedKey = JSON.stringify(key);
+  return '"' + key + '"' === encodedKey ? key : encodedKey;
+}
+
+function describeValueForErrorMessage(value) {
+  switch (typeof value) {
+    case 'string':
+      {
+        return JSON.stringify(value.length <= 10 ? value : value.substr(0, 10) + '...');
+      }
+
+    case 'object':
+      {
+        if (isArray(value)) {
+          return '[...]';
+        }
+
+        var name = objectName(value);
+
+        if (name === 'Object') {
+          return '{...}';
+        }
+
+        return name;
+      }
+
+    case 'function':
+      return 'function';
+
+    default:
+      // eslint-disable-next-line react-internal/safe-string-coercion
+      return String(value);
+  }
+}
+
+function describeObjectForErrorMessage(objectOrArray, expandedName) {
+  if (isArray(objectOrArray)) {
+    var str = '[';
+    var array = objectOrArray;
+
+    for (var i = 0; i < array.length; i++) {
+      if (i > 0) {
+        str += ', ';
+      }
+
+      if (i > 6) {
+        str += '...';
+        break;
+      }
+
+      var _value = array[i];
+
+      if ('' + i === expandedName && typeof _value === 'object' && _value !== null) {
+        str += describeObjectForErrorMessage(_value);
+      } else {
+        str += describeValueForErrorMessage(_value);
+      }
+    }
+
+    str += ']';
+    return str;
+  } else {
+    var _str = '{';
+    var object = objectOrArray;
+    var names = Object.keys(object);
+
+    for (var _i = 0; _i < names.length; _i++) {
+      if (_i > 0) {
+        _str += ', ';
+      }
+
+      if (_i > 6) {
+        _str += '...';
+        break;
+      }
+
+      var name = names[_i];
+      _str += describeKeyForErrorMessage(name) + ': ';
+      var _value2 = object[name];
+
+      if (name === expandedName && typeof _value2 === 'object' && _value2 !== null) {
+        _str += describeObjectForErrorMessage(_value2);
+      } else {
+        _str += describeValueForErrorMessage(_value2);
+      }
+    }
+
+    _str += '}';
+    return _str;
+  }
+}
+
+var insideContextProps = null;
+var isInsideContextValue = false;
+function resolveModelToJSON(request, parent, key, value) {
+  {
+    // $FlowFixMe
+    var originalValue = parent[key];
+
+    if (typeof originalValue === 'object' && originalValue !== value) {
+      error('Only plain objects can be passed to client components from server components. ' + 'Objects with toJSON methods are not supported. Convert it manually ' + 'to a simple value before passing it to props. ' + 'Remove %s from these props: %s', describeKeyForErrorMessage(key), describeObjectForErrorMessage(parent));
+    }
+  } // Special Symbols
+
+
+  switch (value) {
+    case REACT_ELEMENT_TYPE:
+      return '$';
+  }
+
+  {
+    if (parent[0] === REACT_ELEMENT_TYPE && parent[1] && parent[1].$$typeof === REACT_PROVIDER_TYPE && key === '3') {
+      insideContextProps = value;
+    } else if (insideContextProps === parent && key === 'value') {
+      isInsideContextValue = true;
+    } else if (insideContextProps === parent && key === 'children') {
+      isInsideContextValue = false;
+    }
+  } // Resolve server components.
+
+
+  while (typeof value === 'object' && value !== null && (value.$$typeof === REACT_ELEMENT_TYPE || value.$$typeof === REACT_LAZY_TYPE)) {
+    {
+      if (isInsideContextValue) {
+        error('React elements are not allowed in ServerContext');
+      }
+    }
+
+    try {
+      switch (value.$$typeof) {
+        case REACT_ELEMENT_TYPE:
+          {
+            // TODO: Concatenate keys of parents onto children.
+            var element = value; // Attempt to render the server component.
+
+            value = attemptResolveElement(element.type, element.key, element.ref, element.props);
+            break;
+          }
+
+        case REACT_LAZY_TYPE:
+          {
+            var payload = value._payload;
+            var init = value._init;
+            value = init(payload);
+            break;
+          }
+      }
+    } catch (x) {
+      if (typeof x === 'object' && x !== null && typeof x.then === 'function') {
+        // Something suspended, we'll need to create a new task and resolve it later.
+        request.pendingChunks++;
+        var newTask = createTask(request, value, getActiveContext(), request.abortableTasks);
+        var ping = newTask.ping;
+        x.then(ping, ping);
+        return serializeByRefID(newTask.id);
+      } else {
+        logRecoverableError(request, x); // Something errored. We'll still send everything we have up until this point.
+        // We'll replace this element with a lazy reference that throws on the client
+        // once it gets rendered.
+
+        request.pendingChunks++;
+        var errorId = request.nextChunkId++;
+        emitErrorChunk(request, errorId, x);
+        return serializeByRefID(errorId);
+      }
+    }
+  }
+
+  if (value == null) {
+    return value;
+  }
+
+  if (typeof value === 'object' || isModuleReference(value)) {
+    if (isModuleReference(value)) {
+      var moduleReference = value;
+      var moduleKey = getModuleKey(moduleReference);
+      var writtenModules = request.writtenModules;
+      var existingId = writtenModules.get(moduleKey);
+
+      if (existingId !== undefined) {
+        if (parent[0] === REACT_ELEMENT_TYPE && key === '1') {
+          // If we're encoding the "type" of an element, we can refer
+          // to that by a lazy reference instead of directly since React
+          // knows how to deal with lazy values. This lets us suspend
+          // on this component rather than its parent until the code has
+          // loaded.
+          return serializeByRefID(existingId);
+        }
+
+        return serializeByValueID(existingId);
+      }
+
+      try {
+        var moduleMetaData = resolveModuleMetaData(request.bundlerConfig, moduleReference);
+        request.pendingChunks++;
+        var moduleId = request.nextChunkId++;
+        emitModuleChunk(request, moduleId, moduleMetaData);
+        writtenModules.set(moduleKey, moduleId);
+
+        if (parent[0] === REACT_ELEMENT_TYPE && key === '1') {
+          // If we're encoding the "type" of an element, we can refer
+          // to that by a lazy reference instead of directly since React
+          // knows how to deal with lazy values. This lets us suspend
+          // on this component rather than its parent until the code has
+          // loaded.
+          return serializeByRefID(moduleId);
+        }
+
+        return serializeByValueID(moduleId);
+      } catch (x) {
+        request.pendingChunks++;
+
+        var _errorId = request.nextChunkId++;
+
+        emitErrorChunk(request, _errorId, x);
+        return serializeByValueID(_errorId);
+      }
+    } else if (value.$$typeof === REACT_PROVIDER_TYPE) {
+      var providerKey = value._context._globalName;
+      var writtenProviders = request.writtenProviders;
+      var providerId = writtenProviders.get(key);
+
+      if (providerId === undefined) {
+        request.pendingChunks++;
+        providerId = request.nextChunkId++;
+        writtenProviders.set(providerKey, providerId);
+        emitProviderChunk(request, providerId, providerKey);
+      }
+
+      return serializeByValueID(providerId);
+    } else if (value === POP) {
+      popProvider();
+
+      {
+        insideContextProps = null;
+        isInsideContextValue = false;
+      }
+
+      return undefined;
+    }
+
+    {
+      if (value !== null && !isArray(value)) {
+        // Verify that this is a simple plain object.
+        if (objectName(value) !== 'Object') {
+          error('Only plain objects can be passed to client components from server components. ' + 'Built-ins like %s are not supported. ' + 'Remove %s from these props: %s', objectName(value), describeKeyForErrorMessage(key), describeObjectForErrorMessage(parent));
+        } else if (typeof value === 'object' && !isSimpleObject(value)) {
+          error('Only plain objects can be passed to client components from server components. ' + 'Classes or other objects with methods are not supported. ' + 'Remove %s from these props: %s', describeKeyForErrorMessage(key), describeObjectForErrorMessage(parent, key));
+        } else if (Object.getOwnPropertySymbols) {
+          var symbols = Object.getOwnPropertySymbols(value);
+
+          if (symbols.length > 0) {
+            error('Only plain objects can be passed to client components from server components. ' + 'Objects with symbol properties like %s are not supported. ' + 'Remove %s from these props: %s', symbols[0].description, describeKeyForErrorMessage(key), describeObjectForErrorMessage(parent, key));
+          }
+        }
+      }
+    }
+
+    return value;
+  }
+
+  if (typeof value === 'string') {
+    return escapeStringValue(value);
+  }
+
+  if (typeof value === 'boolean' || typeof value === 'number' || typeof value === 'undefined') {
+    return value;
+  }
+
+  if (typeof value === 'function') {
+    if (/^on[A-Z]/.test(key)) {
+      throw new Error('Event handlers cannot be passed to client component props. ' + ("Remove " + describeKeyForErrorMessage(key) + " from these props if possible: " + describeObjectForErrorMessage(parent) + "\n") + 'If you need interactivity, consider converting part of this to a client component.');
+    } else {
+      throw new Error('Functions cannot be passed directly to client components ' + "because they're not serializable. " + ("Remove " + describeKeyForErrorMessage(key) + " (" + (value.displayName || value.name || 'function') + ") from this object, or avoid the entire object: " + describeObjectForErrorMessage(parent)));
+    }
+  }
+
+  if (typeof value === 'symbol') {
+    var writtenSymbols = request.writtenSymbols;
+
+    var _existingId = writtenSymbols.get(value);
+
+    if (_existingId !== undefined) {
+      return serializeByValueID(_existingId);
+    }
+
+    var name = value.description;
+
+    if (Symbol.for(name) !== value) {
+      throw new Error('Only global symbols received from Symbol.for(...) can be passed to client components. ' + ("The symbol Symbol.for(" + value.description + ") cannot be found among global symbols. ") + ("Remove " + describeKeyForErrorMessage(key) + " from this object, or avoid the entire object: " + describeObjectForErrorMessage(parent)));
+    }
+
+    request.pendingChunks++;
+    var symbolId = request.nextChunkId++;
+    emitSymbolChunk(request, symbolId, name);
+    writtenSymbols.set(value, symbolId);
+    return serializeByValueID(symbolId);
+  } // $FlowFixMe: bigint isn't added to Flow yet.
+
+
+  if (typeof value === 'bigint') {
+    throw new Error("BigInt (" + value + ") is not yet supported in client component props. " + ("Remove " + describeKeyForErrorMessage(key) + " from this object or use a plain number instead: " + describeObjectForErrorMessage(parent)));
+  }
+
+  throw new Error("Type " + typeof value + " is not supported in client component props. " + ("Remove " + describeKeyForErrorMessage(key) + " from this object, or avoid the entire object: " + describeObjectForErrorMessage(parent)));
+}
+
+function logRecoverableError(request, error) {
+  var onError = request.onError;
+  onError(error);
+}
+
+function fatalError(request, error) {
+  // This is called outside error handling code such as if an error happens in React internals.
+  if (request.destination !== null) {
+    request.status = CLOSED;
+    closeWithError(request.destination, error);
+  } else {
+    request.status = CLOSING;
+    request.fatalError = error;
+  }
+}
+
+function emitErrorChunk(request, id, error) {
+  // TODO: We should not leak error messages to the client in prod.
+  // Give this an error code instead and log on the server.
+  // We can serialize the error in DEV as a convenience.
+  var message;
+  var stack = '';
+
+  try {
+    if (error instanceof Error) {
+      // eslint-disable-next-line react-internal/safe-string-coercion
+      message = String(error.message); // eslint-disable-next-line react-internal/safe-string-coercion
+
+      stack = String(error.stack);
+    } else {
+      message = 'Error: ' + error;
+    }
+  } catch (x) {
+    message = 'An error occurred but serializing the error message failed.';
+  }
+
+  var processedChunk = processErrorChunk(request, id, message, stack);
+  request.completedErrorChunks.push(processedChunk);
+}
+
+function emitModuleChunk(request, id, moduleMetaData) {
+  var processedChunk = processModuleChunk(request, id, moduleMetaData);
+  request.completedModuleChunks.push(processedChunk);
+}
+
+function emitSymbolChunk(request, id, name) {
+  var processedChunk = processSymbolChunk(request, id, name);
+  request.completedModuleChunks.push(processedChunk);
+}
+
+function emitProviderChunk(request, id, contextName) {
+  var processedChunk = processProviderChunk(request, id, contextName);
+  request.completedJSONChunks.push(processedChunk);
+}
+
+function retryTask(request, task) {
+  if (task.status !== PENDING) {
+    // We completed this by other means before we had a chance to retry it.
+    return;
+  }
+
+  switchContext(task.context);
+
+  try {
+    var _value3 = task.model;
+
+    while (typeof _value3 === 'object' && _value3 !== null && _value3.$$typeof === REACT_ELEMENT_TYPE) {
+      // TODO: Concatenate keys of parents onto children.
+      var element = _value3; // Attempt to render the server component.
+      // Doing this here lets us reuse this same task if the next component
+      // also suspends.
+
+      task.model = _value3;
+      _value3 = attemptResolveElement(element.type, element.key, element.ref, element.props);
+    }
+
+    var processedChunk = processModelChunk(request, task.id, _value3);
+    request.completedJSONChunks.push(processedChunk);
+    request.abortableTasks.delete(task);
+    task.status = COMPLETED;
+  } catch (x) {
+    if (typeof x === 'object' && x !== null && typeof x.then === 'function') {
+      // Something suspended again, let's pick it back up later.
+      var ping = task.ping;
+      x.then(ping, ping);
+      return;
+    } else {
+      request.abortableTasks.delete(task);
+      task.status = ERRORED;
+      logRecoverableError(request, x); // This errored, we need to serialize this error to the
+
+      emitErrorChunk(request, task.id, x);
+    }
+  }
+}
+
+function performWork(request) {
+  var prevDispatcher = ReactCurrentDispatcher.current;
+  var prevCache = getCurrentCache();
+  ReactCurrentDispatcher.current = Dispatcher;
+  setCurrentCache(request.cache);
+  prepareToUseHooksForRequest(request);
+
+  try {
+    var pingedTasks = request.pingedTasks;
+    request.pingedTasks = [];
+
+    for (var i = 0; i < pingedTasks.length; i++) {
+      var task = pingedTasks[i];
+      retryTask(request, task);
+    }
+
+    if (request.destination !== null) {
+      flushCompletedChunks(request, request.destination);
+    }
+  } catch (error) {
+    logRecoverableError(request, error);
+    fatalError(request, error);
+  } finally {
+    ReactCurrentDispatcher.current = prevDispatcher;
+    setCurrentCache(prevCache);
+    resetHooksForRequest();
+  }
+}
+
+function abortTask(task, request, errorId) {
+  task.status = ABORTED; // Instead of emitting an error per task.id, we emit a model that only
+  // has a single value referencing the error.
+
+  var ref = serializeByValueID(errorId);
+  var processedChunk = processReferenceChunk(request, task.id, ref);
+  request.completedJSONChunks.push(processedChunk);
+}
+
+function flushCompletedChunks(request, destination) {
+  beginWriting();
+
+  try {
+    // We emit module chunks first in the stream so that
+    // they can be preloaded as early as possible.
+    var moduleChunks = request.completedModuleChunks;
+    var i = 0;
+
+    for (; i < moduleChunks.length; i++) {
+      request.pendingChunks--;
+      var chunk = moduleChunks[i];
+      var keepWriting = writeChunkAndReturn(destination, chunk);
+
+      if (!keepWriting) {
+        request.destination = null;
+        i++;
+        break;
+      }
+    }
+
+    moduleChunks.splice(0, i); // Next comes model data.
+
+    var jsonChunks = request.completedJSONChunks;
+    i = 0;
+
+    for (; i < jsonChunks.length; i++) {
+      request.pendingChunks--;
+      var _chunk = jsonChunks[i];
+
+      var _keepWriting = writeChunkAndReturn(destination, _chunk);
+
+      if (!_keepWriting) {
+        request.destination = null;
+        i++;
+        break;
+      }
+    }
+
+    jsonChunks.splice(0, i); // Finally, errors are sent. The idea is that it's ok to delay
+    // any error messages and prioritize display of other parts of
+    // the page.
+
+    var errorChunks = request.completedErrorChunks;
+    i = 0;
+
+    for (; i < errorChunks.length; i++) {
+      request.pendingChunks--;
+      var _chunk2 = errorChunks[i];
+
+      var _keepWriting2 = writeChunkAndReturn(destination, _chunk2);
+
+      if (!_keepWriting2) {
+        request.destination = null;
+        i++;
+        break;
+      }
+    }
+
+    errorChunks.splice(0, i);
+  } finally {
+    completeWriting(destination);
+  }
+
+  flushBuffered(destination);
+
+  if (request.pendingChunks === 0) {
+    // We're done.
+    close(destination);
+  }
+}
+
+function startWork(request) {
+  scheduleWork(function () {
+    return performWork(request);
+  });
+}
+function startFlowing(request, destination) {
+  if (request.status === CLOSING) {
+    request.status = CLOSED;
+    closeWithError(destination, request.fatalError);
+    return;
+  }
+
+  if (request.status === CLOSED) {
+    return;
+  }
+
+  if (request.destination !== null) {
+    // We're already flowing.
+    return;
+  }
+
+  request.destination = destination;
+
+  try {
+    flushCompletedChunks(request, destination);
+  } catch (error) {
+    logRecoverableError(request, error);
+    fatalError(request, error);
+  }
+} // This is called to early terminate a request. It creates an error at all pending tasks.
+
+function abort(request, reason) {
+  try {
+    var abortableTasks = request.abortableTasks;
+
+    if (abortableTasks.size > 0) {
+      // We have tasks to abort. We'll emit one error row and then emit a reference
+      // to that row from every row that's still remaining.
+      var _error = reason === undefined ? new Error('The render was aborted by the server without a reason.') : reason;
+
+      logRecoverableError(request, _error);
+      request.pendingChunks++;
+      var errorId = request.nextChunkId++;
+      emitErrorChunk(request, errorId, _error);
+      abortableTasks.forEach(function (task) {
+        return abortTask(task, request, errorId);
+      });
+      abortableTasks.clear();
+    }
+
+    if (request.destination !== null) {
+      flushCompletedChunks(request, request.destination);
+    }
+  } catch (error) {
+    logRecoverableError(request, error);
+    fatalError(request, error);
+  }
+}
+
+function importServerContexts(contexts) {
+  if (contexts) {
+    var prevContext = getActiveContext();
+    switchContext(rootContextSnapshot);
+
+    for (var i = 0; i < contexts.length; i++) {
+      var _contexts$i = contexts[i],
+          name = _contexts$i[0],
+          _value4 = _contexts$i[1];
+      var context = getOrCreateServerContext(name);
+      pushProvider(context, _value4);
+    }
+
+    var importedContext = getActiveContext();
+    switchContext(prevContext);
+    return importedContext;
+  }
+
+  return rootContextSnapshot;
+}
+
+function createDrainHandler(destination, request) {
+  return function () {
+    return startFlowing(request, destination);
+  };
+}
+
+function renderToPipeableStream(model, options) {
+  var request = createRequest( // Wrap root in a dummy element that simply adds a flag
+  // to the current dispatcher to check later in the proxies.
+  assign({}, model, {
+    $$typeof: Symbol.for('react.element'),
+    props: {
+      children: model
+    },
+    type: function () {
+      __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher.current.isRsc = true;
+      return model;
+    }
+  }), {}, // Manifest, not used
+  options ? options.onError : undefined, options ? options.context : undefined, options ? options.identifierPrefix : undefined);
+  var hasStartedFlowing = false;
+  startWork(request);
+  return {
+    pipe: function (destination) {
+      if (hasStartedFlowing) {
+        throw new Error('React currently only supports piping to one writable stream.');
+      }
+
+      hasStartedFlowing = true;
+      startFlowing(request, destination);
+      destination.on('drain', createDrainHandler(destination, request));
+      return destination;
+    },
+    abort: function (reason) {
+      abort(request, reason);
+    }
+  };
+}
+
+export { renderToPipeableStream };
diff --git a/vendor/vendor/react-server-dom-vite/esm/react-server-dom-vite.js b/vendor/vendor/react-server-dom-vite/esm/react-server-dom-vite.js
new file mode 100644
index 0000000000000000000000000000000000000000..33108f3b82c421c1aa804954648e776b9846cda4
--- /dev/null
+++ b/vendor/vendor/react-server-dom-vite/esm/react-server-dom-vite.js
@@ -0,0 +1,619 @@
+/**
+* @license React
+ * react-server-dom-vite.js
+ *
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+import { __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, createServerContext } from 'react';
+
+function createStringDecoder() {
+  return new TextDecoder();
+}
+var decoderOptions = {
+  stream: true
+};
+function readPartialStringChunk(decoder, buffer) {
+  return decoder.decode(buffer, decoderOptions);
+}
+function readFinalStringChunk(decoder, buffer) {
+  return decoder.decode(buffer);
+}
+
+function parseModel(response, json) {
+  return JSON.parse(json, response._fromJSON);
+}
+
+var META_HOT = import.meta.hot;
+var META_ENV_DEV = import.meta.env.DEV;
+
+function resolveModuleReference(bundlerConfig, moduleData) {
+  return moduleData;
+} // Vite import globs will be injected here.
+
+var allClientComponents = {
+  __INJECTED_CLIENT_IMPORTERS__: null
+}; // Mock client component imports during testing
+
+if (META_ENV_DEV && typeof jest !== 'undefined') {
+  global.allClientComponents = allClientComponents;
+}
+
+function importClientComponent(moduleId) {
+  var modImport = allClientComponents[moduleId];
+
+  if (!modImport) {
+    var error = new Error("Could not find client component " + moduleId);
+
+    if (META_HOT) {
+      META_HOT.send('rsc:cc404', {
+        id: moduleId
+      });
+      return new Promise(function (_, reject) {
+        return setTimeout(function () {
+          return reject(error);
+        }, 200);
+      });
+    }
+
+    return Promise.reject(error);
+  }
+
+  return typeof modImport === 'function' ? modImport() : Promise.resolve(modImport);
+} // The module cache contains all the modules we've preloaded so far.
+// If they're still pending they're a thenable.
+
+
+var moduleCache = new Map(); // Start preloading the modules since we might need them soon.
+// This function doesn't suspend.
+
+function preloadModule(_ref) {
+  var id = _ref.id;
+  if (moduleCache.has(id)) return;
+
+  function cacheResult(mod) {
+    moduleCache.set(id, mod);
+    return mod;
+  } // Store the original promise first, then override cache with its result.
+
+
+  var promise = importClientComponent(id);
+  cacheResult(promise);
+  promise.then(cacheResult, cacheResult);
+} // Actually require the module or suspend if it's not yet ready.
+// Increase priority if necessary.
+
+function requireModule(_ref2) {
+  var id = _ref2.id,
+      name = _ref2.name;
+  var mod = moduleCache.get(id);
+
+  if (!mod || mod instanceof Promise || mod instanceof Error) {
+    // This module is still being downloaded or
+    // it has errored out. Pass it to Suspense.
+    throw mod;
+  }
+
+  return mod[name];
+}
+
+// ATTENTION
+// When adding new symbols to this file,
+// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
+// The Symbol used to tag the ReactElement-like types.
+var REACT_ELEMENT_TYPE = Symbol.for('react.element');
+var REACT_LAZY_TYPE = Symbol.for('react.lazy');
+var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for('react.default_value');
+
+var ReactSharedInternals = __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
+
+var ContextRegistry = ReactSharedInternals.ContextRegistry;
+function getOrCreateServerContext(globalName) {
+  if (!ContextRegistry[globalName]) {
+    ContextRegistry[globalName] = createServerContext(globalName, REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED);
+  }
+
+  return ContextRegistry[globalName];
+}
+
+var PENDING = 0;
+var RESOLVED_MODEL = 1;
+var RESOLVED_MODULE = 2;
+var INITIALIZED = 3;
+var ERRORED = 4;
+
+function Chunk(status, value, response) {
+  this._status = status;
+  this._value = value;
+  this._response = response;
+}
+
+Chunk.prototype.then = function (resolve) {
+  var chunk = this;
+
+  if (chunk._status === PENDING) {
+    if (chunk._value === null) {
+      chunk._value = [];
+    }
+
+    chunk._value.push(resolve);
+  } else {
+    resolve();
+  }
+};
+
+function readChunk(chunk) {
+  switch (chunk._status) {
+    case INITIALIZED:
+      return chunk._value;
+
+    case RESOLVED_MODEL:
+      return initializeModelChunk(chunk);
+
+    case RESOLVED_MODULE:
+      return initializeModuleChunk(chunk);
+
+    case PENDING:
+      // eslint-disable-next-line no-throw-literal
+      throw chunk;
+
+    default:
+      throw chunk._value;
+  }
+}
+
+function readRoot() {
+  var response = this;
+  var chunk = getChunk(response, 0);
+  return readChunk(chunk);
+}
+
+function createPendingChunk(response) {
+  return new Chunk(PENDING, null, response);
+}
+
+function createErrorChunk(response, error) {
+  return new Chunk(ERRORED, error, response);
+}
+
+function createInitializedChunk(response, value) {
+  return new Chunk(INITIALIZED, value, response);
+}
+
+function wakeChunk(listeners) {
+  if (listeners !== null) {
+    for (var i = 0; i < listeners.length; i++) {
+      var listener = listeners[i];
+      listener();
+    }
+  }
+}
+
+function triggerErrorOnChunk(chunk, error) {
+  if (chunk._status !== PENDING) {
+    // We already resolved. We didn't expect to see this.
+    return;
+  }
+
+  var listeners = chunk._value;
+  var erroredChunk = chunk;
+  erroredChunk._status = ERRORED;
+  erroredChunk._value = error;
+  wakeChunk(listeners);
+}
+
+function createResolvedModelChunk(response, value) {
+  return new Chunk(RESOLVED_MODEL, value, response);
+}
+
+function createResolvedModuleChunk(response, value) {
+  return new Chunk(RESOLVED_MODULE, value, response);
+}
+
+function resolveModelChunk(chunk, value) {
+  if (chunk._status !== PENDING) {
+    // We already resolved. We didn't expect to see this.
+    return;
+  }
+
+  var listeners = chunk._value;
+  var resolvedChunk = chunk;
+  resolvedChunk._status = RESOLVED_MODEL;
+  resolvedChunk._value = value;
+  wakeChunk(listeners);
+}
+
+function resolveModuleChunk(chunk, value) {
+  if (chunk._status !== PENDING) {
+    // We already resolved. We didn't expect to see this.
+    return;
+  }
+
+  var listeners = chunk._value;
+  var resolvedChunk = chunk;
+  resolvedChunk._status = RESOLVED_MODULE;
+  resolvedChunk._value = value;
+  wakeChunk(listeners);
+}
+
+function initializeModelChunk(chunk) {
+  var value = parseModel(chunk._response, chunk._value);
+  var initializedChunk = chunk;
+  initializedChunk._status = INITIALIZED;
+  initializedChunk._value = value;
+  return value;
+}
+
+function initializeModuleChunk(chunk) {
+  var value = requireModule(chunk._value);
+  var initializedChunk = chunk;
+  initializedChunk._status = INITIALIZED;
+  initializedChunk._value = value;
+  return value;
+} // Report that any missing chunks in the model is now going to throw this
+// error upon read. Also notify any pending promises.
+
+
+function reportGlobalError(response, error) {
+  response._chunks.forEach(function (chunk) {
+    // If this chunk was already resolved or errored, it won't
+    // trigger an error but if it wasn't then we need to
+    // because we won't be getting any new data to resolve it.
+    triggerErrorOnChunk(chunk, error);
+  });
+}
+
+function createElement(type, key, props) {
+  var element = {
+    // This tag allows us to uniquely identify this as a React Element
+    $$typeof: REACT_ELEMENT_TYPE,
+    // Built-in properties that belong on the element
+    type: type,
+    key: key,
+    ref: null,
+    props: props,
+    // Record the component responsible for creating this element.
+    _owner: null
+  };
+
+  {
+    // We don't really need to add any of these but keeping them for good measure.
+    // Unfortunately, _store is enumerable in jest matchers so for equality to
+    // work, I need to keep it or make _store non-enumerable in the other file.
+    element._store = {};
+    Object.defineProperty(element._store, 'validated', {
+      configurable: false,
+      enumerable: false,
+      writable: true,
+      value: true // This element has already been validated on the server.
+
+    });
+    Object.defineProperty(element, '_self', {
+      configurable: false,
+      enumerable: false,
+      writable: false,
+      value: null
+    });
+    Object.defineProperty(element, '_source', {
+      configurable: false,
+      enumerable: false,
+      writable: false,
+      value: null
+    });
+  }
+
+  return element;
+}
+
+function createLazyChunkWrapper(chunk) {
+  var lazyType = {
+    $$typeof: REACT_LAZY_TYPE,
+    _payload: chunk,
+    _init: readChunk
+  };
+  return lazyType;
+}
+
+function getChunk(response, id) {
+  var chunks = response._chunks;
+  var chunk = chunks.get(id);
+
+  if (!chunk) {
+    chunk = createPendingChunk(response);
+    chunks.set(id, chunk);
+  }
+
+  return chunk;
+}
+
+function parseModelString(response, parentObject, value) {
+  switch (value[0]) {
+    case '$':
+      {
+        if (value === '$') {
+          return REACT_ELEMENT_TYPE;
+        } else if (value[1] === '$' || value[1] === '@') {
+          // This was an escaped string value.
+          return value.substring(1);
+        } else {
+          var id = parseInt(value.substring(1), 16);
+          var chunk = getChunk(response, id);
+          return readChunk(chunk);
+        }
+      }
+
+    case '@':
+      {
+        var _id = parseInt(value.substring(1), 16);
+
+        var _chunk = getChunk(response, _id); // We create a React.lazy wrapper around any lazy values.
+        // When passed into React, we'll know how to suspend on this.
+
+
+        return createLazyChunkWrapper(_chunk);
+      }
+  }
+
+  return value;
+}
+function parseModelTuple(response, value) {
+  var tuple = value;
+
+  if (tuple[0] === REACT_ELEMENT_TYPE) {
+    // TODO: Consider having React just directly accept these arrays as elements.
+    // Or even change the ReactElement type to be an array.
+    return createElement(tuple[1], tuple[2], tuple[3]);
+  }
+
+  return value;
+}
+function createResponse(bundlerConfig) {
+  var chunks = new Map();
+  var response = {
+    _bundlerConfig: bundlerConfig,
+    _chunks: chunks,
+    readRoot: readRoot
+  };
+  return response;
+}
+function resolveModel(response, id, model) {
+  var chunks = response._chunks;
+  var chunk = chunks.get(id);
+
+  if (!chunk) {
+    chunks.set(id, createResolvedModelChunk(response, model));
+  } else {
+    resolveModelChunk(chunk, model);
+  }
+}
+function resolveProvider(response, id, contextName) {
+  var chunks = response._chunks;
+  chunks.set(id, createInitializedChunk(response, getOrCreateServerContext(contextName).Provider));
+}
+function resolveModule(response, id, model) {
+  var chunks = response._chunks;
+  var chunk = chunks.get(id);
+  var moduleMetaData = parseModel(response, model);
+  var moduleReference = resolveModuleReference(response._bundlerConfig, moduleMetaData); // TODO: Add an option to encode modules that are lazy loaded.
+  // For now we preload all modules as early as possible since it's likely
+  // that we'll need them.
+
+  preloadModule(moduleReference);
+
+  if (!chunk) {
+    chunks.set(id, createResolvedModuleChunk(response, moduleReference));
+  } else {
+    resolveModuleChunk(chunk, moduleReference);
+  }
+}
+function resolveSymbol(response, id, name) {
+  var chunks = response._chunks; // We assume that we'll always emit the symbol before anything references it
+  // to save a few bytes.
+
+  chunks.set(id, createInitializedChunk(response, Symbol.for(name)));
+}
+function resolveError(response, id, message, stack) {
+  // eslint-disable-next-line react-internal/prod-error-codes
+  var error = new Error(message);
+  error.stack = stack;
+  var chunks = response._chunks;
+  var chunk = chunks.get(id);
+
+  if (!chunk) {
+    chunks.set(id, createErrorChunk(response, error));
+  } else {
+    triggerErrorOnChunk(chunk, error);
+  }
+}
+function close(response) {
+  // In case there are any remaining unresolved chunks, they won't
+  // be resolved now. So we need to issue an error to those.
+  // Ideally we should be able to early bail out if we kept a
+  // ref count of pending chunks.
+  reportGlobalError(response, new Error('Connection closed.'));
+}
+
+function processFullRow(response, row) {
+  if (row === '') {
+    return;
+  }
+
+  var tag = row[0]; // When tags that are not text are added, check them here before
+  // parsing the row as text.
+  // switch (tag) {
+  // }
+
+  var colon = row.indexOf(':', 1);
+  var id = parseInt(row.substring(1, colon), 16);
+  var text = row.substring(colon + 1);
+
+  switch (tag) {
+    case 'J':
+      {
+        resolveModel(response, id, text);
+        return;
+      }
+
+    case 'M':
+      {
+        resolveModule(response, id, text);
+        return;
+      }
+
+    case 'P':
+      {
+        resolveProvider(response, id, text);
+        return;
+      }
+
+    case 'S':
+      {
+        resolveSymbol(response, id, JSON.parse(text));
+        return;
+      }
+
+    case 'E':
+      {
+        var errorInfo = JSON.parse(text);
+        resolveError(response, id, errorInfo.message, errorInfo.stack);
+        return;
+      }
+
+    default:
+      {
+        throw new Error("Error parsing the data. It's probably an error code or network corruption.");
+      }
+  }
+}
+
+function processStringChunk(response, chunk, offset) {
+  var linebreak = chunk.indexOf('\n', offset);
+
+  while (linebreak > -1) {
+    var fullrow = response._partialRow + chunk.substring(offset, linebreak);
+    processFullRow(response, fullrow);
+    response._partialRow = '';
+    offset = linebreak + 1;
+    linebreak = chunk.indexOf('\n', offset);
+  }
+
+  response._partialRow += chunk.substring(offset);
+}
+function processBinaryChunk(response, chunk) {
+
+  var stringDecoder = response._stringDecoder;
+  var linebreak = chunk.indexOf(10); // newline
+
+  while (linebreak > -1) {
+    var fullrow = response._partialRow + readFinalStringChunk(stringDecoder, chunk.subarray(0, linebreak));
+    processFullRow(response, fullrow);
+    response._partialRow = '';
+    chunk = chunk.subarray(linebreak + 1);
+    linebreak = chunk.indexOf(10); // newline
+  }
+
+  response._partialRow += readPartialStringChunk(stringDecoder, chunk);
+}
+
+function createFromJSONCallback(response) {
+  return function (key, value) {
+    if (typeof value === 'string') {
+      // We can't use .bind here because we need the "this" value.
+      return parseModelString(response, this, value);
+    }
+
+    if (typeof value === 'object' && value !== null) {
+      return parseModelTuple(response, value);
+    }
+
+    return value;
+  };
+}
+
+function createResponse$1(bundlerConfig) {
+  // NOTE: CHECK THE COMPILER OUTPUT EACH TIME YOU CHANGE THIS.
+  // It should be inlined to one object literal but minor changes can break it.
+  var stringDecoder =  createStringDecoder() ;
+  var response = createResponse(bundlerConfig);
+  response._partialRow = '';
+
+  {
+    response._stringDecoder = stringDecoder;
+  } // Don't inline this call because it causes closure to outline the call above.
+
+
+  response._fromJSON = createFromJSONCallback(response);
+  return response;
+}
+
+function startReadingFromStream(response, stream) {
+  var reader = stream.getReader();
+
+  function progress(_ref) {
+    var done = _ref.done,
+        value = _ref.value;
+
+    if (done) {
+      close(response);
+      return;
+    }
+
+    var buffer = value;
+    processBinaryChunk(response, buffer);
+    return reader.read().then(progress, error);
+  }
+
+  function error(e) {
+    reportGlobalError(response, e);
+  }
+
+  reader.read().then(progress, error);
+}
+
+function createFromReadableStream(stream) {
+  var response = createResponse$1({});
+  startReadingFromStream(response, stream);
+  return response;
+}
+
+function createFromFetch(promiseForResponse) {
+  var response = createResponse$1({});
+  promiseForResponse.then(function (r) {
+    startReadingFromStream(response, r.body);
+  }, function (e) {
+    reportGlobalError(response, e);
+  });
+  return response;
+}
+
+function createFromXHR(request) {
+  var response = createResponse$1({});
+  var processedLength = 0;
+
+  function progress(e) {
+    var chunk = request.responseText;
+    processStringChunk(response, chunk, processedLength);
+    processedLength = chunk.length;
+  }
+
+  function load(e) {
+    progress();
+    close(response);
+  }
+
+  function error(e) {
+    reportGlobalError(response, new TypeError('Network error'));
+  }
+
+  request.addEventListener('progress', progress);
+  request.addEventListener('load', load);
+  request.addEventListener('error', error);
+  request.addEventListener('abort', error);
+  request.addEventListener('timeout', error);
+  return response;
+}
+
+export { createFromFetch, createFromReadableStream, createFromXHR };
diff --git a/vendor/vendor/react-server-dom-vite/index.js b/vendor/vendor/react-server-dom-vite/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..8000702be9ee8b30c5ae64da359bfcafb027afd3
--- /dev/null
+++ b/vendor/vendor/react-server-dom-vite/index.js
@@ -0,0 +1,7 @@
+'use strict';
+
+if (process.env.NODE_ENV === 'production') {
+  module.exports = require('./cjs/react-server-dom-vite.production.min.js');
+} else {
+  module.exports = require('./cjs/react-server-dom-vite.development.js');
+}
diff --git a/vendor/vendor/react-server-dom-vite/package.json b/vendor/vendor/react-server-dom-vite/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..5e68be1320f8b4f3be60f2153f22ca5a8fdbd525
--- /dev/null
+++ b/vendor/vendor/react-server-dom-vite/package.json
@@ -0,0 +1,67 @@
+{
+  "name": "react-server-dom-vite",
+  "description": "React Server Components bindings for DOM using Vite. This is intended to be integrated into meta-frameworks. It is not intended to be imported directly.",
+  "version": "0.1.0",
+  "keywords": [
+    "react"
+  ],
+  "homepage": "https://reactjs.org/",
+  "bugs": "https://github.com/facebook/react/issues",
+  "license": "MIT",
+  "files": [
+    "LICENSE",
+    "README.md",
+    "index.js",
+    "plugin.js",
+    "writer.browser.server.js",
+    "writer.node.server.js",
+    "cjs/",
+    "umd/",
+    "esm/"
+  ],
+  "exports": {
+    ".": {
+      "require": "./index.js",
+      "import": "./esm/react-server-dom-vite.js"
+    },
+    "./plugin": {
+      "require": "./plugin.js",
+      "import": "./esm/react-server-dom-vite-plugin.js"
+    },
+    "./writer": {
+      "require": "./writer.node.server.js",
+      "node": "./esm/react-server-dom-vite-writer.node.server.js",
+      "default": "./esm/react-server-dom-vite-writer.browser.server.js"
+    },
+    "./writer.node.server": {
+      "require": "./writer.node.server.js",
+      "import": "./esm/react-server-dom-vite-writer.node.server.js"
+    },
+    "./writer.browser.server":  {
+      "require": "./writer.browser.server.js",
+      "import": "./esm/react-server-dom-vite-writer.browser.server.js"
+    },
+    "./client-proxy": "./esm/react-server-dom-vite-client-proxy.js",
+    "./package.json": "./package.json"
+  },
+  "main": "index.js",
+  "repository": {
+    "type" : "git",
+    "url" : "https://github.com/facebook/react.git",
+    "directory": "packages/react-server-dom-vite"
+  },
+  "engines": {
+    "node": ">=0.10.0"
+  },
+  "peerDependencies": {
+    "react": "^18.0.0",
+    "vite": "^2.7.1 || ^3.0.7"
+  },
+  "dependencies": {
+    "es-module-lexer": "^0.9.3",
+    "magic-string": "^0.26.2"
+  },
+  "devDependencies": {
+    "vite": "^2.7.1"
+  }
+}
diff --git a/vendor/vendor/react-server-dom-vite/plugin.js b/vendor/vendor/react-server-dom-vite/plugin.js
new file mode 100644
index 0000000000000000000000000000000000000000..ffb0bbe2988e8d9cdec22846c0b24f2d8398ef72
--- /dev/null
+++ b/vendor/vendor/react-server-dom-vite/plugin.js
@@ -0,0 +1,3 @@
+'use strict';
+
+module.exports = require('./cjs/react-server-dom-vite-plugin.js');
diff --git a/vendor/vendor/react-server-dom-vite/writer.browser.server.js b/vendor/vendor/react-server-dom-vite/writer.browser.server.js
new file mode 100644
index 0000000000000000000000000000000000000000..65ab3bb72bab0d4ecce62b4c0bc1c92e94ef49c2
--- /dev/null
+++ b/vendor/vendor/react-server-dom-vite/writer.browser.server.js
@@ -0,0 +1,7 @@
+'use strict';
+
+if (process.env.NODE_ENV === 'production') {
+  module.exports = require('./cjs/react-server-dom-vite-writer.browser.production.min.server.js');
+} else {
+  module.exports = require('./cjs/react-server-dom-vite-writer.browser.development.server.js');
+}
diff --git a/vendor/vendor/react-server-dom-vite/writer.node.server.js b/vendor/vendor/react-server-dom-vite/writer.node.server.js
new file mode 100644
index 0000000000000000000000000000000000000000..ee69b99c15b428645a2cf17bc7d2e7a297f93f1a
--- /dev/null
+++ b/vendor/vendor/react-server-dom-vite/writer.node.server.js
@@ -0,0 +1,7 @@
+'use strict';
+
+if (process.env.NODE_ENV === 'production') {
+  module.exports = require('./cjs/react-server-dom-vite-writer.node.production.min.server.js');
+} else {
+  module.exports = require('./cjs/react-server-dom-vite-writer.node.development.server.js');
+}
